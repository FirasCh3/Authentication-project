{"ast":null,"code":"import { createRequire as __cjsCompatRequire } from 'module';\nconst require = __cjsCompatRequire(import.meta.url);\nimport { ClassMemberKind, filterToMembersWithDecorator, isNamedClassDeclaration, reflectObjectLiteral, reflectTypeEntityToDeclaration, typeNodeToValueExpr } from \"./chunk-OIJPCKRW.js\";\nimport { ImportManager, translateExpression, translateStatement, translateType } from \"./chunk-AAX4HKH5.js\";\nimport { ErrorCode, FatalDiagnosticError, ImportFlags, Reference, assertSuccessfulReferenceEmit, attachDefaultImportDeclaration, getDefaultImportDeclaration, getSourceFile, identifierOfNode, isDeclaration, isFromDtsFile, makeDiagnostic, makeRelatedInformation, nodeDebugInfo, nodeNameForError } from \"./chunk-KPIJL3UY.js\";\nimport { PerfEvent, PerfPhase } from \"./chunk-HJOPJLIM.js\";\nimport { absoluteFrom, absoluteFromSourceFile, relative } from \"./chunk-EC5K6QPP.js\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/util.mjs\nimport { ExternalExpr, ParseLocation, ParseSourceFile, ParseSourceSpan, ReadPropExpr, WrappedNodeExpr } from \"@angular/compiler\";\nimport ts from \"typescript\";\nfunction valueReferenceToExpression(valueRef) {\n  if (valueRef.kind === 2) {\n    return null;\n  } else if (valueRef.kind === 0) {\n    const expr = new WrappedNodeExpr(valueRef.expression);\n    if (valueRef.defaultImportStatement !== null) {\n      attachDefaultImportDeclaration(expr, valueRef.defaultImportStatement);\n    }\n    return expr;\n  } else {\n    let importExpr = new ExternalExpr({\n      moduleName: valueRef.moduleName,\n      name: valueRef.importedName\n    });\n    if (valueRef.nestedPath !== null) {\n      for (const property of valueRef.nestedPath) {\n        importExpr = new ReadPropExpr(importExpr, property);\n      }\n    }\n    return importExpr;\n  }\n}\nfunction toR3Reference(origin, ref, context, refEmitter) {\n  const emittedValueRef = refEmitter.emit(ref, context);\n  assertSuccessfulReferenceEmit(emittedValueRef, origin, \"class\");\n  const emittedTypeRef = refEmitter.emit(ref, context, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports);\n  assertSuccessfulReferenceEmit(emittedTypeRef, origin, \"class\");\n  return {\n    value: emittedValueRef.expression,\n    type: emittedTypeRef.expression\n  };\n}\nfunction isAngularCore(decorator) {\n  return decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\nfunction isAngularCoreReference(reference, symbolName) {\n  return reference.ownedByModuleGuess === \"@angular/core\" && reference.debugName === symbolName;\n}\nfunction findAngularDecorator(decorators, name, isCore) {\n  return decorators.find(decorator => isAngularDecorator(decorator, name, isCore));\n}\nfunction isAngularDecorator(decorator, name, isCore) {\n  if (isCore) {\n    return decorator.name === name;\n  } else if (isAngularCore(decorator)) {\n    return decorator.import.name === name;\n  }\n  return false;\n}\nfunction unwrapExpression(node) {\n  while (ts.isAsExpression(node) || ts.isParenthesizedExpression(node)) {\n    node = node.expression;\n  }\n  return node;\n}\nfunction expandForwardRef(arg) {\n  arg = unwrapExpression(arg);\n  if (!ts.isArrowFunction(arg) && !ts.isFunctionExpression(arg)) {\n    return null;\n  }\n  const body = arg.body;\n  if (ts.isBlock(body)) {\n    if (body.statements.length !== 1) {\n      return null;\n    }\n    const stmt = body.statements[0];\n    if (!ts.isReturnStatement(stmt) || stmt.expression === void 0) {\n      return null;\n    }\n    return stmt.expression;\n  } else {\n    return body;\n  }\n}\nfunction tryUnwrapForwardRef(node, reflector) {\n  node = unwrapExpression(node);\n  if (!ts.isCallExpression(node) || node.arguments.length !== 1) {\n    return null;\n  }\n  const fn = ts.isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression;\n  if (!ts.isIdentifier(fn)) {\n    return null;\n  }\n  const expr = expandForwardRef(node.arguments[0]);\n  if (expr === null) {\n    return null;\n  }\n  const imp = reflector.getImportOfIdentifier(fn);\n  if (imp === null || imp.from !== \"@angular/core\" || imp.name !== \"forwardRef\") {\n    return null;\n  }\n  return expr;\n}\nvar forwardRefResolver = (fn, callExpr, resolve, unresolvable) => {\n  if (!isAngularCoreReference(fn, \"forwardRef\") || callExpr.arguments.length !== 1) {\n    return unresolvable;\n  }\n  const expanded = expandForwardRef(callExpr.arguments[0]);\n  if (expanded !== null) {\n    return resolve(expanded);\n  } else {\n    return unresolvable;\n  }\n};\nfunction combineResolvers(resolvers) {\n  return (fn, callExpr, resolve, unresolvable) => {\n    for (const resolver of resolvers) {\n      const resolved = resolver(fn, callExpr, resolve, unresolvable);\n      if (resolved !== unresolvable) {\n        return resolved;\n      }\n    }\n    return unresolvable;\n  };\n}\nfunction isExpressionForwardReference(expr, context, contextSource) {\n  if (isWrappedTsNodeExpr(expr)) {\n    const node = ts.getOriginalNode(expr.node);\n    return node.getSourceFile() === contextSource && context.pos < node.pos;\n  } else {\n    return false;\n  }\n}\nfunction isWrappedTsNodeExpr(expr) {\n  return expr instanceof WrappedNodeExpr;\n}\nfunction readBaseClass(node, reflector, evaluator) {\n  const baseExpression = reflector.getBaseClassExpression(node);\n  if (baseExpression !== null) {\n    const baseClass = evaluator.evaluate(baseExpression);\n    if (baseClass instanceof Reference && reflector.isClass(baseClass.node)) {\n      return baseClass;\n    } else {\n      return \"dynamic\";\n    }\n  }\n  return null;\n}\nvar parensWrapperTransformerFactory = context => {\n  const visitor = node => {\n    const visited = ts.visitEachChild(node, visitor, context);\n    if (ts.isArrowFunction(visited) || ts.isFunctionExpression(visited)) {\n      return ts.factory.createParenthesizedExpression(visited);\n    }\n    return visited;\n  };\n  return node => ts.visitEachChild(node, visitor, context);\n};\nfunction wrapFunctionExpressionsInParens(expression) {\n  return ts.transform(expression, [parensWrapperTransformerFactory]).transformed[0];\n}\nfunction resolveProvidersRequiringFactory(rawProviders, reflector, evaluator) {\n  const providers = /* @__PURE__ */new Set();\n  const resolvedProviders = evaluator.evaluate(rawProviders);\n  if (!Array.isArray(resolvedProviders)) {\n    return providers;\n  }\n  resolvedProviders.forEach(function processProviders(provider) {\n    let tokenClass = null;\n    if (Array.isArray(provider)) {\n      provider.forEach(processProviders);\n    } else if (provider instanceof Reference) {\n      tokenClass = provider;\n    } else if (provider instanceof Map && provider.has(\"useClass\") && !provider.has(\"deps\")) {\n      const useExisting = provider.get(\"useClass\");\n      if (useExisting instanceof Reference) {\n        tokenClass = useExisting;\n      }\n    }\n    if (tokenClass !== null && !tokenClass.node.getSourceFile().isDeclarationFile && reflector.isClass(tokenClass.node)) {\n      const constructorParameters = reflector.getConstructorParameters(tokenClass.node);\n      if (constructorParameters !== null && constructorParameters.length > 0) {\n        providers.add(tokenClass);\n      }\n    }\n  });\n  return providers;\n}\nfunction wrapTypeReference(reflector, clazz) {\n  const value = new WrappedNodeExpr(clazz.name);\n  const type = value;\n  return {\n    value,\n    type\n  };\n}\nfunction createSourceSpan(node) {\n  const sf = node.getSourceFile();\n  const [startOffset, endOffset] = [node.getStart(), node.getEnd()];\n  const {\n    line: startLine,\n    character: startCol\n  } = sf.getLineAndCharacterOfPosition(startOffset);\n  const {\n    line: endLine,\n    character: endCol\n  } = sf.getLineAndCharacterOfPosition(endOffset);\n  const parseSf = new ParseSourceFile(sf.getFullText(), sf.fileName);\n  return new ParseSourceSpan(new ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1), new ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));\n}\nfunction compileResults(fac, def, metadataStmt, propName, additionalFields) {\n  const statements = def.statements;\n  if (metadataStmt !== null) {\n    statements.push(metadataStmt);\n  }\n  const results = [fac, {\n    name: propName,\n    initializer: def.expression,\n    statements: def.statements,\n    type: def.type\n  }];\n  if (additionalFields !== null) {\n    results.push(...additionalFields);\n  }\n  return results;\n}\nfunction toFactoryMetadata(meta, target) {\n  return {\n    name: meta.name,\n    type: meta.type,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: meta.deps,\n    target\n  };\n}\nfunction resolveImportedFile(moduleResolver, importedFile, expr, origin) {\n  if (importedFile !== \"unknown\") {\n    return importedFile;\n  }\n  if (!(expr instanceof ExternalExpr)) {\n    return null;\n  }\n  return moduleResolver.resolveModule(expr.value.moduleName, origin.fileName);\n}\nfunction getOriginNodeForDiagnostics(expr, container) {\n  const nodeSf = expr.getSourceFile();\n  const exprSf = container.getSourceFile();\n  if (nodeSf === exprSf && expr.pos >= container.pos && expr.end <= container.end) {\n    return expr;\n  } else {\n    return container;\n  }\n}\nfunction isAbstractClassDeclaration(clazz) {\n  return ts.canHaveModifiers(clazz) && clazz.modifiers !== void 0 ? clazz.modifiers.some(mod => mod.kind === ts.SyntaxKind.AbstractKeyword) : false;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic.mjs\nvar DynamicValue = class {\n  constructor(node, reason, code) {\n    this.node = node;\n    this.reason = reason;\n    this.code = code;\n  }\n  static fromDynamicInput(node, input) {\n    return new DynamicValue(node, input, 0);\n  }\n  static fromDynamicString(node) {\n    return new DynamicValue(node, void 0, 1);\n  }\n  static fromExternalReference(node, ref) {\n    return new DynamicValue(node, ref, 2);\n  }\n  static fromUnsupportedSyntax(node) {\n    return new DynamicValue(node, void 0, 3);\n  }\n  static fromUnknownIdentifier(node) {\n    return new DynamicValue(node, void 0, 4);\n  }\n  static fromInvalidExpressionType(node, value) {\n    return new DynamicValue(node, value, 5);\n  }\n  static fromComplexFunctionCall(node, fn) {\n    return new DynamicValue(node, fn, 6);\n  }\n  static fromDynamicType(node) {\n    return new DynamicValue(node, void 0, 7);\n  }\n  static fromSyntheticInput(node, value) {\n    return new DynamicValue(node, value, 8);\n  }\n  static fromUnknown(node) {\n    return new DynamicValue(node, void 0, 9);\n  }\n  isFromDynamicInput() {\n    return this.code === 0;\n  }\n  isFromDynamicString() {\n    return this.code === 1;\n  }\n  isFromExternalReference() {\n    return this.code === 2;\n  }\n  isFromUnsupportedSyntax() {\n    return this.code === 3;\n  }\n  isFromUnknownIdentifier() {\n    return this.code === 4;\n  }\n  isFromInvalidExpressionType() {\n    return this.code === 5;\n  }\n  isFromComplexFunctionCall() {\n    return this.code === 6;\n  }\n  isFromDynamicType() {\n    return this.code === 7;\n  }\n  isFromUnknown() {\n    return this.code === 9;\n  }\n  accept(visitor) {\n    switch (this.code) {\n      case 0:\n        return visitor.visitDynamicInput(this);\n      case 1:\n        return visitor.visitDynamicString(this);\n      case 2:\n        return visitor.visitExternalReference(this);\n      case 3:\n        return visitor.visitUnsupportedSyntax(this);\n      case 4:\n        return visitor.visitUnknownIdentifier(this);\n      case 5:\n        return visitor.visitInvalidExpressionType(this);\n      case 6:\n        return visitor.visitComplexFunctionCall(this);\n      case 7:\n        return visitor.visitDynamicType(this);\n      case 8:\n        return visitor.visitSyntheticInput(this);\n      case 9:\n        return visitor.visitUnknown(this);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.mjs\nimport ts2 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/result.mjs\nvar ResolvedModule = class {\n  constructor(exports, evaluate) {\n    this.exports = exports;\n    this.evaluate = evaluate;\n  }\n  getExport(name) {\n    if (!this.exports.has(name)) {\n      return void 0;\n    }\n    return this.evaluate(this.exports.get(name));\n  }\n  getExports() {\n    const map = /* @__PURE__ */new Map();\n    this.exports.forEach((decl, name) => {\n      map.set(name, this.evaluate(decl));\n    });\n    return map;\n  }\n};\nvar EnumValue = class {\n  constructor(enumRef, name, resolved) {\n    this.enumRef = enumRef;\n    this.name = name;\n    this.resolved = resolved;\n  }\n};\nvar KnownFn = class {};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/builtin.mjs\nvar ArraySliceBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n  evaluate(node, args) {\n    if (args.length === 0) {\n      return this.lhs;\n    } else {\n      return DynamicValue.fromUnknown(node);\n    }\n  }\n};\nvar ArrayConcatBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n  evaluate(node, args) {\n    const result = [...this.lhs];\n    for (const arg of args) {\n      if (arg instanceof DynamicValue) {\n        result.push(DynamicValue.fromDynamicInput(node, arg));\n      } else if (Array.isArray(arg)) {\n        result.push(...arg);\n      } else {\n        result.push(arg);\n      }\n    }\n    return result;\n  }\n};\nvar StringConcatBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n  evaluate(node, args) {\n    let result = this.lhs;\n    for (const arg of args) {\n      const resolved = arg instanceof EnumValue ? arg.resolved : arg;\n      if (typeof resolved === \"string\" || typeof resolved === \"number\" || typeof resolved === \"boolean\" || resolved == null) {\n        result = result.concat(resolved);\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n    return result;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/synthetic.mjs\nvar SyntheticValue = class {\n  constructor(value) {\n    this.value = value;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.mjs\nfunction literalBinaryOp(op) {\n  return {\n    op,\n    literal: true\n  };\n}\nfunction referenceBinaryOp(op) {\n  return {\n    op,\n    literal: false\n  };\n}\nvar BINARY_OPERATORS = /* @__PURE__ */new Map([[ts2.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)], [ts2.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)], [ts2.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)], [ts2.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)], [ts2.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)], [ts2.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)], [ts2.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)], [ts2.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)], [ts2.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)], [ts2.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)], [ts2.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)], [ts2.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)], [ts2.SyntaxKind.EqualsEqualsToken, literalBinaryOp((a, b) => a == b)], [ts2.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp((a, b) => a === b)], [ts2.SyntaxKind.ExclamationEqualsToken, literalBinaryOp((a, b) => a != b)], [ts2.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp((a, b) => a !== b)], [ts2.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)], [ts2.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)], [ts2.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)], [ts2.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))], [ts2.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)], [ts2.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]]);\nvar UNARY_OPERATORS = /* @__PURE__ */new Map([[ts2.SyntaxKind.TildeToken, a => ~a], [ts2.SyntaxKind.MinusToken, a => -a], [ts2.SyntaxKind.PlusToken, a => +a], [ts2.SyntaxKind.ExclamationToken, a => !a]]);\nvar StaticInterpreter = class {\n  constructor(host, checker, dependencyTracker) {\n    this.host = host;\n    this.checker = checker;\n    this.dependencyTracker = dependencyTracker;\n  }\n  visit(node, context) {\n    return this.visitExpression(node, context);\n  }\n  visitExpression(node, context) {\n    let result;\n    if (node.kind === ts2.SyntaxKind.TrueKeyword) {\n      return true;\n    } else if (node.kind === ts2.SyntaxKind.FalseKeyword) {\n      return false;\n    } else if (node.kind === ts2.SyntaxKind.NullKeyword) {\n      return null;\n    } else if (ts2.isStringLiteral(node)) {\n      return node.text;\n    } else if (ts2.isNoSubstitutionTemplateLiteral(node)) {\n      return node.text;\n    } else if (ts2.isTemplateExpression(node)) {\n      result = this.visitTemplateExpression(node, context);\n    } else if (ts2.isNumericLiteral(node)) {\n      return parseFloat(node.text);\n    } else if (ts2.isObjectLiteralExpression(node)) {\n      result = this.visitObjectLiteralExpression(node, context);\n    } else if (ts2.isIdentifier(node)) {\n      result = this.visitIdentifier(node, context);\n    } else if (ts2.isPropertyAccessExpression(node)) {\n      result = this.visitPropertyAccessExpression(node, context);\n    } else if (ts2.isCallExpression(node)) {\n      result = this.visitCallExpression(node, context);\n    } else if (ts2.isConditionalExpression(node)) {\n      result = this.visitConditionalExpression(node, context);\n    } else if (ts2.isPrefixUnaryExpression(node)) {\n      result = this.visitPrefixUnaryExpression(node, context);\n    } else if (ts2.isBinaryExpression(node)) {\n      result = this.visitBinaryExpression(node, context);\n    } else if (ts2.isArrayLiteralExpression(node)) {\n      result = this.visitArrayLiteralExpression(node, context);\n    } else if (ts2.isParenthesizedExpression(node)) {\n      result = this.visitParenthesizedExpression(node, context);\n    } else if (ts2.isElementAccessExpression(node)) {\n      result = this.visitElementAccessExpression(node, context);\n    } else if (ts2.isAsExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (ts2.isNonNullExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (this.host.isClass(node)) {\n      result = this.visitDeclaration(node, context);\n    } else {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    if (result instanceof DynamicValue && result.node !== node) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n  visitArrayLiteralExpression(node, context) {\n    const array = [];\n    for (let i = 0; i < node.elements.length; i++) {\n      const element = node.elements[i];\n      if (ts2.isSpreadElement(element)) {\n        array.push(...this.visitSpreadElement(element, context));\n      } else {\n        array.push(this.visitExpression(element, context));\n      }\n    }\n    return array;\n  }\n  visitObjectLiteralExpression(node, context) {\n    const map = /* @__PURE__ */new Map();\n    for (let i = 0; i < node.properties.length; i++) {\n      const property = node.properties[i];\n      if (ts2.isPropertyAssignment(property)) {\n        const name = this.stringNameFromPropertyName(property.name, context);\n        if (name === void 0) {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromDynamicString(property.name));\n        }\n        map.set(name, this.visitExpression(property.initializer, context));\n      } else if (ts2.isShorthandPropertyAssignment(property)) {\n        const symbol = this.checker.getShorthandAssignmentValueSymbol(property);\n        if (symbol === void 0 || symbol.valueDeclaration === void 0) {\n          map.set(property.name.text, DynamicValue.fromUnknown(property));\n        } else {\n          map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));\n        }\n      } else if (ts2.isSpreadAssignment(property)) {\n        const spread = this.visitExpression(property.expression, context);\n        if (spread instanceof DynamicValue) {\n          return DynamicValue.fromDynamicInput(node, spread);\n        } else if (spread instanceof Map) {\n          spread.forEach((value, key) => map.set(key, value));\n        } else if (spread instanceof ResolvedModule) {\n          spread.getExports().forEach((value, key) => map.set(key, value));\n        } else {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromInvalidExpressionType(property, spread));\n        }\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n    return map;\n  }\n  visitTemplateExpression(node, context) {\n    const pieces = [node.head.text];\n    for (let i = 0; i < node.templateSpans.length; i++) {\n      const span = node.templateSpans[i];\n      const value = literal(this.visit(span.expression, context), () => DynamicValue.fromDynamicString(span.expression));\n      if (value instanceof DynamicValue) {\n        return DynamicValue.fromDynamicInput(node, value);\n      }\n      pieces.push(`${value}`, span.literal.text);\n    }\n    return pieces.join(\"\");\n  }\n  visitIdentifier(node, context) {\n    const decl = this.host.getDeclarationOfIdentifier(node);\n    if (decl === null) {\n      if (getOriginalKeywordKind(node) === ts2.SyntaxKind.UndefinedKeyword) {\n        return void 0;\n      } else {\n        if (this.dependencyTracker !== null && this.host.getImportOfIdentifier(node) !== null) {\n          this.dependencyTracker.recordDependencyAnalysisFailure(context.originatingFile);\n        }\n        return DynamicValue.fromUnknownIdentifier(node);\n      }\n    }\n    const declContext = {\n      ...context,\n      ...joinModuleContext(context, node, decl)\n    };\n    const result = this.visitDeclaration(decl.node, declContext);\n    if (result instanceof Reference) {\n      if (!result.synthetic) {\n        result.addIdentifier(node);\n      }\n    } else if (result instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n  visitDeclaration(node, context) {\n    if (this.dependencyTracker !== null) {\n      this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());\n    }\n    if (this.host.isClass(node)) {\n      return this.getReference(node, context);\n    } else if (ts2.isVariableDeclaration(node)) {\n      return this.visitVariableDeclaration(node, context);\n    } else if (ts2.isParameter(node) && context.scope.has(node)) {\n      return context.scope.get(node);\n    } else if (ts2.isExportAssignment(node)) {\n      return this.visitExpression(node.expression, context);\n    } else if (ts2.isEnumDeclaration(node)) {\n      return this.visitEnumDeclaration(node, context);\n    } else if (ts2.isSourceFile(node)) {\n      return this.visitSourceFile(node, context);\n    } else if (ts2.isBindingElement(node)) {\n      return this.visitBindingElement(node, context);\n    } else {\n      return this.getReference(node, context);\n    }\n  }\n  visitVariableDeclaration(node, context) {\n    const value = this.host.getVariableValue(node);\n    if (value !== null) {\n      return this.visitExpression(value, context);\n    } else if (isVariableDeclarationDeclared(node)) {\n      if (node.type !== void 0) {\n        const evaluatedType = this.visitType(node.type, context);\n        if (!(evaluatedType instanceof DynamicValue)) {\n          return evaluatedType;\n        }\n      }\n      return this.getReference(node, context);\n    } else {\n      return void 0;\n    }\n  }\n  visitEnumDeclaration(node, context) {\n    const enumRef = this.getReference(node, context);\n    const map = /* @__PURE__ */new Map();\n    node.members.forEach(member => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n      if (name !== void 0) {\n        const resolved = member.initializer && this.visit(member.initializer, context);\n        map.set(name, new EnumValue(enumRef, name, resolved));\n      }\n    });\n    return map;\n  }\n  visitElementAccessExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    const rhs = this.visitExpression(node.argumentExpression, context);\n    if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    }\n    if (typeof rhs !== \"string\" && typeof rhs !== \"number\") {\n      return DynamicValue.fromInvalidExpressionType(node, rhs);\n    }\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n  visitPropertyAccessExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    const rhs = node.name.text;\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n  visitSourceFile(node, context) {\n    const declarations = this.host.getExportsOfModule(node);\n    if (declarations === null) {\n      return DynamicValue.fromUnknown(node);\n    }\n    return new ResolvedModule(declarations, decl => {\n      const declContext = {\n        ...context,\n        ...joinModuleContext(context, node, decl)\n      };\n      return this.visitDeclaration(decl.node, declContext);\n    });\n  }\n  accessHelper(node, lhs, rhs, context) {\n    const strIndex = `${rhs}`;\n    if (lhs instanceof Map) {\n      if (lhs.has(strIndex)) {\n        return lhs.get(strIndex);\n      } else {\n        return void 0;\n      }\n    } else if (lhs instanceof ResolvedModule) {\n      return lhs.getExport(strIndex);\n    } else if (Array.isArray(lhs)) {\n      if (rhs === \"length\") {\n        return lhs.length;\n      } else if (rhs === \"slice\") {\n        return new ArraySliceBuiltinFn(lhs);\n      } else if (rhs === \"concat\") {\n        return new ArrayConcatBuiltinFn(lhs);\n      }\n      if (typeof rhs !== \"number\" || !Number.isInteger(rhs)) {\n        return DynamicValue.fromInvalidExpressionType(node, rhs);\n      }\n      return lhs[rhs];\n    } else if (typeof lhs === \"string\" && rhs === \"concat\") {\n      return new StringConcatBuiltinFn(lhs);\n    } else if (lhs instanceof Reference) {\n      const ref = lhs.node;\n      if (this.host.isClass(ref)) {\n        const module = owningModule(context, lhs.bestGuessOwningModule);\n        let value = void 0;\n        const member = this.host.getMembersOfClass(ref).find(member2 => member2.isStatic && member2.name === strIndex);\n        if (member !== void 0) {\n          if (member.value !== null) {\n            value = this.visitExpression(member.value, context);\n          } else if (member.implementation !== null) {\n            value = new Reference(member.implementation, module);\n          } else if (member.node) {\n            value = new Reference(member.node, module);\n          }\n        }\n        return value;\n      } else if (isDeclaration(ref)) {\n        return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(ref, lhs));\n      }\n    } else if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    } else if (lhs instanceof SyntheticValue) {\n      return DynamicValue.fromSyntheticInput(node, lhs);\n    }\n    return DynamicValue.fromUnknown(node);\n  }\n  visitCallExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    if (lhs instanceof KnownFn) {\n      return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));\n    }\n    if (!(lhs instanceof Reference)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n    const fn = this.host.getDefinitionOfFunction(lhs.node);\n    if (fn === null) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n    if (!isFunctionOrMethodReference(lhs)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n    const resolveFfrExpr = expr => {\n      let contextExtension = {};\n      if (fn.body === null && expr.getSourceFile() !== node.expression.getSourceFile() && lhs.bestGuessOwningModule !== null) {\n        contextExtension = {\n          absoluteModuleName: lhs.bestGuessOwningModule.specifier,\n          resolutionContext: lhs.bestGuessOwningModule.resolutionContext\n        };\n      }\n      return this.visitFfrExpression(expr, {\n        ...context,\n        ...contextExtension\n      });\n    };\n    if (fn.body === null && context.foreignFunctionResolver !== void 0) {\n      const unresolvable = DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(node.expression, lhs));\n      return context.foreignFunctionResolver(lhs, node, resolveFfrExpr, unresolvable);\n    }\n    const res = this.visitFunctionBody(node, fn, context);\n    if (res instanceof DynamicValue && context.foreignFunctionResolver !== void 0) {\n      const unresolvable = DynamicValue.fromComplexFunctionCall(node, fn);\n      return context.foreignFunctionResolver(lhs, node, resolveFfrExpr, unresolvable);\n    }\n    return res;\n  }\n  visitFfrExpression(expr, context) {\n    const res = this.visitExpression(expr, context);\n    if (res instanceof Reference) {\n      res.synthetic = true;\n    }\n    return res;\n  }\n  visitFunctionBody(node, fn, context) {\n    if (fn.body === null) {\n      return DynamicValue.fromUnknown(node);\n    } else if (fn.body.length !== 1 || !ts2.isReturnStatement(fn.body[0])) {\n      return DynamicValue.fromComplexFunctionCall(node, fn);\n    }\n    const ret = fn.body[0];\n    const args = this.evaluateFunctionArguments(node, context);\n    const newScope = /* @__PURE__ */new Map();\n    const calleeContext = {\n      ...context,\n      scope: newScope\n    };\n    fn.parameters.forEach((param, index) => {\n      let arg = args[index];\n      if (param.node.dotDotDotToken !== void 0) {\n        arg = args.slice(index);\n      }\n      if (arg === void 0 && param.initializer !== null) {\n        arg = this.visitExpression(param.initializer, calleeContext);\n      }\n      newScope.set(param.node, arg);\n    });\n    return ret.expression !== void 0 ? this.visitExpression(ret.expression, calleeContext) : void 0;\n  }\n  visitConditionalExpression(node, context) {\n    const condition = this.visitExpression(node.condition, context);\n    if (condition instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, condition);\n    }\n    if (condition) {\n      return this.visitExpression(node.whenTrue, context);\n    } else {\n      return this.visitExpression(node.whenFalse, context);\n    }\n  }\n  visitPrefixUnaryExpression(node, context) {\n    const operatorKind = node.operator;\n    if (!UNARY_OPERATORS.has(operatorKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    const op = UNARY_OPERATORS.get(operatorKind);\n    const value = this.visitExpression(node.operand, context);\n    if (value instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, value);\n    } else {\n      return op(value);\n    }\n  }\n  visitBinaryExpression(node, context) {\n    const tokenKind = node.operatorToken.kind;\n    if (!BINARY_OPERATORS.has(tokenKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    const opRecord = BINARY_OPERATORS.get(tokenKind);\n    let lhs, rhs;\n    if (opRecord.literal) {\n      lhs = literal(this.visitExpression(node.left, context), value => DynamicValue.fromInvalidExpressionType(node.left, value));\n      rhs = literal(this.visitExpression(node.right, context), value => DynamicValue.fromInvalidExpressionType(node.right, value));\n    } else {\n      lhs = this.visitExpression(node.left, context);\n      rhs = this.visitExpression(node.right, context);\n    }\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    } else if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    } else {\n      return opRecord.op(lhs, rhs);\n    }\n  }\n  visitParenthesizedExpression(node, context) {\n    return this.visitExpression(node.expression, context);\n  }\n  evaluateFunctionArguments(node, context) {\n    const args = [];\n    for (const arg of node.arguments) {\n      if (ts2.isSpreadElement(arg)) {\n        args.push(...this.visitSpreadElement(arg, context));\n      } else {\n        args.push(this.visitExpression(arg, context));\n      }\n    }\n    return args;\n  }\n  visitSpreadElement(node, context) {\n    const spread = this.visitExpression(node.expression, context);\n    if (spread instanceof DynamicValue) {\n      return [DynamicValue.fromDynamicInput(node, spread)];\n    } else if (!Array.isArray(spread)) {\n      return [DynamicValue.fromInvalidExpressionType(node, spread)];\n    } else {\n      return spread;\n    }\n  }\n  visitBindingElement(node, context) {\n    const path = [];\n    let closestDeclaration = node;\n    while (ts2.isBindingElement(closestDeclaration) || ts2.isArrayBindingPattern(closestDeclaration) || ts2.isObjectBindingPattern(closestDeclaration)) {\n      if (ts2.isBindingElement(closestDeclaration)) {\n        path.unshift(closestDeclaration);\n      }\n      closestDeclaration = closestDeclaration.parent;\n    }\n    if (!ts2.isVariableDeclaration(closestDeclaration) || closestDeclaration.initializer === void 0) {\n      return DynamicValue.fromUnknown(node);\n    }\n    let value = this.visit(closestDeclaration.initializer, context);\n    for (const element of path) {\n      let key;\n      if (ts2.isArrayBindingPattern(element.parent)) {\n        key = element.parent.elements.indexOf(element);\n      } else {\n        const name = element.propertyName || element.name;\n        if (ts2.isIdentifier(name)) {\n          key = name.text;\n        } else {\n          return DynamicValue.fromUnknown(element);\n        }\n      }\n      value = this.accessHelper(element, value, key, context);\n      if (value instanceof DynamicValue) {\n        return value;\n      }\n    }\n    return value;\n  }\n  stringNameFromPropertyName(node, context) {\n    if (ts2.isIdentifier(node) || ts2.isStringLiteral(node) || ts2.isNumericLiteral(node)) {\n      return node.text;\n    } else if (ts2.isComputedPropertyName(node)) {\n      const literal2 = this.visitExpression(node.expression, context);\n      return typeof literal2 === \"string\" ? literal2 : void 0;\n    } else {\n      return void 0;\n    }\n  }\n  getReference(node, context) {\n    return new Reference(node, owningModule(context));\n  }\n  visitType(node, context) {\n    if (ts2.isLiteralTypeNode(node)) {\n      return this.visitExpression(node.literal, context);\n    } else if (ts2.isTupleTypeNode(node)) {\n      return this.visitTupleType(node, context);\n    } else if (ts2.isNamedTupleMember(node)) {\n      return this.visitType(node.type, context);\n    } else if (ts2.isTypeOperatorNode(node) && node.operator === ts2.SyntaxKind.ReadonlyKeyword) {\n      return this.visitType(node.type, context);\n    } else if (ts2.isTypeQueryNode(node)) {\n      return this.visitTypeQuery(node, context);\n    }\n    return DynamicValue.fromDynamicType(node);\n  }\n  visitTupleType(node, context) {\n    const res = [];\n    for (const elem of node.elements) {\n      res.push(this.visitType(elem, context));\n    }\n    return res;\n  }\n  visitTypeQuery(node, context) {\n    if (!ts2.isIdentifier(node.exprName)) {\n      return DynamicValue.fromUnknown(node);\n    }\n    const decl = this.host.getDeclarationOfIdentifier(node.exprName);\n    if (decl === null) {\n      return DynamicValue.fromUnknownIdentifier(node.exprName);\n    }\n    const declContext = {\n      ...context,\n      ...joinModuleContext(context, node, decl)\n    };\n    return this.visitDeclaration(decl.node, declContext);\n  }\n};\nfunction isFunctionOrMethodReference(ref) {\n  return ts2.isFunctionDeclaration(ref.node) || ts2.isMethodDeclaration(ref.node) || ts2.isFunctionExpression(ref.node);\n}\nfunction literal(value, reject) {\n  if (value instanceof EnumValue) {\n    value = value.resolved;\n  }\n  if (value instanceof DynamicValue || value === null || value === void 0 || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n  return reject(value);\n}\nfunction isVariableDeclarationDeclared(node) {\n  if (node.parent === void 0 || !ts2.isVariableDeclarationList(node.parent)) {\n    return false;\n  }\n  const declList = node.parent;\n  if (declList.parent === void 0 || !ts2.isVariableStatement(declList.parent)) {\n    return false;\n  }\n  const varStmt = declList.parent;\n  const modifiers = ts2.getModifiers(varStmt);\n  return modifiers !== void 0 && modifiers.some(mod => mod.kind === ts2.SyntaxKind.DeclareKeyword);\n}\nvar EMPTY = {};\nfunction joinModuleContext(existing, node, decl) {\n  if (decl.viaModule !== null && decl.viaModule !== existing.absoluteModuleName) {\n    return {\n      absoluteModuleName: decl.viaModule,\n      resolutionContext: node.getSourceFile().fileName\n    };\n  } else {\n    return EMPTY;\n  }\n}\nfunction owningModule(context, override = null) {\n  let specifier = context.absoluteModuleName;\n  if (override !== null) {\n    specifier = override.specifier;\n  }\n  if (specifier !== null) {\n    return {\n      specifier,\n      resolutionContext: context.resolutionContext\n    };\n  } else {\n    return null;\n  }\n}\nfunction getOriginalKeywordKind(identifier) {\n  return typeof ts2.identifierToKeywordKind === \"function\" ? ts2.identifierToKeywordKind(identifier) : identifier.originalKeywordKind;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interface.mjs\nvar PartialEvaluator = class {\n  constructor(host, checker, dependencyTracker) {\n    this.host = host;\n    this.checker = checker;\n    this.dependencyTracker = dependencyTracker;\n  }\n  evaluate(expr, foreignFunctionResolver) {\n    const interpreter = new StaticInterpreter(this.host, this.checker, this.dependencyTracker);\n    const sourceFile = expr.getSourceFile();\n    return interpreter.visit(expr, {\n      originatingFile: sourceFile,\n      absoluteModuleName: null,\n      resolutionContext: sourceFile.fileName,\n      scope: /* @__PURE__ */new Map(),\n      foreignFunctionResolver\n    });\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.mjs\nimport ts3 from \"typescript\";\nfunction describeResolvedType(value, maxDepth = 1) {\n  var _a, _b;\n  if (value === null) {\n    return \"null\";\n  } else if (value === void 0) {\n    return \"undefined\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"string\") {\n    return typeof value;\n  } else if (value instanceof Map) {\n    if (maxDepth === 0) {\n      return \"object\";\n    }\n    const entries = Array.from(value.entries()).map(([key, v]) => {\n      return `${quoteKey(key)}: ${describeResolvedType(v, maxDepth - 1)}`;\n    });\n    return entries.length > 0 ? `{ ${entries.join(\"; \")} }` : \"{}\";\n  } else if (value instanceof ResolvedModule) {\n    return \"(module)\";\n  } else if (value instanceof EnumValue) {\n    return (_a = value.enumRef.debugName) != null ? _a : \"(anonymous)\";\n  } else if (value instanceof Reference) {\n    return (_b = value.debugName) != null ? _b : \"(anonymous)\";\n  } else if (Array.isArray(value)) {\n    if (maxDepth === 0) {\n      return \"Array\";\n    }\n    return `[${value.map(v => describeResolvedType(v, maxDepth - 1)).join(\", \")}]`;\n  } else if (value instanceof DynamicValue) {\n    return \"(not statically analyzable)\";\n  } else if (value instanceof KnownFn) {\n    return \"Function\";\n  } else {\n    return \"unknown\";\n  }\n}\nfunction quoteKey(key) {\n  if (/^[a-z0-9_]+$/i.test(key)) {\n    return key;\n  } else {\n    return `'${key.replace(/'/g, \"\\\\'\")}'`;\n  }\n}\nfunction traceDynamicValue(node, value) {\n  return value.accept(new TraceDynamicValueVisitor(node));\n}\nvar TraceDynamicValueVisitor = class {\n  constructor(node) {\n    this.node = node;\n    this.currentContainerNode = null;\n  }\n  visitDynamicInput(value) {\n    const trace = value.reason.accept(this);\n    if (this.shouldTrace(value.node)) {\n      const info = makeRelatedInformation(value.node, \"Unable to evaluate this expression statically.\");\n      trace.unshift(info);\n    }\n    return trace;\n  }\n  visitSyntheticInput(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate this expression further.\")];\n  }\n  visitDynamicString(value) {\n    return [makeRelatedInformation(value.node, \"A string value could not be determined statically.\")];\n  }\n  visitExternalReference(value) {\n    const name = value.reason.debugName;\n    const description = name !== null ? `'${name}'` : \"an anonymous declaration\";\n    return [makeRelatedInformation(value.node, `A value for ${description} cannot be determined statically, as it is an external declaration.`)];\n  }\n  visitComplexFunctionCall(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate function call of complex function. A function must have exactly one return statement.\"), makeRelatedInformation(value.reason.node, \"Function is declared here.\")];\n  }\n  visitInvalidExpressionType(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate an invalid expression.\")];\n  }\n  visitUnknown(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate statically.\")];\n  }\n  visitUnknownIdentifier(value) {\n    return [makeRelatedInformation(value.node, \"Unknown reference.\")];\n  }\n  visitDynamicType(value) {\n    return [makeRelatedInformation(value.node, \"Dynamic type.\")];\n  }\n  visitUnsupportedSyntax(value) {\n    return [makeRelatedInformation(value.node, \"This syntax is not supported.\")];\n  }\n  shouldTrace(node) {\n    if (node === this.node) {\n      return false;\n    }\n    const container = getContainerNode(node);\n    if (container === this.currentContainerNode) {\n      return false;\n    }\n    this.currentContainerNode = container;\n    return true;\n  }\n};\nfunction getContainerNode(node) {\n  let currentNode = node;\n  while (currentNode !== void 0) {\n    switch (currentNode.kind) {\n      case ts3.SyntaxKind.ExpressionStatement:\n      case ts3.SyntaxKind.VariableStatement:\n      case ts3.SyntaxKind.ReturnStatement:\n      case ts3.SyntaxKind.IfStatement:\n      case ts3.SyntaxKind.SwitchStatement:\n      case ts3.SyntaxKind.DoStatement:\n      case ts3.SyntaxKind.WhileStatement:\n      case ts3.SyntaxKind.ForStatement:\n      case ts3.SyntaxKind.ForInStatement:\n      case ts3.SyntaxKind.ForOfStatement:\n      case ts3.SyntaxKind.ContinueStatement:\n      case ts3.SyntaxKind.BreakStatement:\n      case ts3.SyntaxKind.ThrowStatement:\n      case ts3.SyntaxKind.ObjectBindingPattern:\n      case ts3.SyntaxKind.ArrayBindingPattern:\n        return currentNode;\n    }\n    currentNode = currentNode.parent;\n  }\n  return node.getSourceFile();\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/di.mjs\nimport { LiteralExpr, WrappedNodeExpr as WrappedNodeExpr2 } from \"@angular/compiler\";\nimport ts4 from \"typescript\";\nfunction getConstructorDependencies(clazz, reflector, isCore) {\n  const deps = [];\n  const errors = [];\n  let ctorParams = reflector.getConstructorParameters(clazz);\n  if (ctorParams === null) {\n    if (reflector.hasBaseClass(clazz)) {\n      return null;\n    } else {\n      ctorParams = [];\n    }\n  }\n  ctorParams.forEach((param, idx) => {\n    let token = valueReferenceToExpression(param.typeValueReference);\n    let attributeNameType = null;\n    let optional = false,\n      self = false,\n      skipSelf = false,\n      host = false;\n    (param.decorators || []).filter(dec => isCore || isAngularCore(dec)).forEach(dec => {\n      const name = isCore || dec.import === null ? dec.name : dec.import.name;\n      if (name === \"Inject\") {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, dec.node, `Unexpected number of arguments to @Inject().`);\n        }\n        token = new WrappedNodeExpr2(dec.args[0]);\n      } else if (name === \"Optional\") {\n        optional = true;\n      } else if (name === \"SkipSelf\") {\n        skipSelf = true;\n      } else if (name === \"Self\") {\n        self = true;\n      } else if (name === \"Host\") {\n        host = true;\n      } else if (name === \"Attribute\") {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, dec.node, `Unexpected number of arguments to @Attribute().`);\n        }\n        const attributeName = dec.args[0];\n        token = new WrappedNodeExpr2(attributeName);\n        if (ts4.isStringLiteralLike(attributeName)) {\n          attributeNameType = new LiteralExpr(attributeName.text);\n        } else {\n          attributeNameType = new WrappedNodeExpr2(ts4.factory.createKeywordTypeNode(ts4.SyntaxKind.UnknownKeyword));\n        }\n      } else {\n        throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, dec.node, `Unexpected decorator ${name} on parameter.`);\n      }\n    });\n    if (token === null) {\n      if (param.typeValueReference.kind !== 2) {\n        throw new Error(\"Illegal state: expected value reference to be unavailable if no token is present\");\n      }\n      errors.push({\n        index: idx,\n        param,\n        reason: param.typeValueReference.reason\n      });\n    } else {\n      deps.push({\n        token,\n        attributeNameType,\n        optional,\n        self,\n        skipSelf,\n        host\n      });\n    }\n  });\n  if (errors.length === 0) {\n    return {\n      deps\n    };\n  } else {\n    return {\n      deps: null,\n      errors\n    };\n  }\n}\nfunction unwrapConstructorDependencies(deps) {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    return \"invalid\";\n  }\n}\nfunction getValidConstructorDependencies(clazz, reflector, isCore) {\n  return validateConstructorDependencies(clazz, getConstructorDependencies(clazz, reflector, isCore));\n}\nfunction validateConstructorDependencies(clazz, deps) {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    const error = deps.errors[0];\n    throw createUnsuitableInjectionTokenError(clazz, error);\n  }\n}\nfunction createUnsuitableInjectionTokenError(clazz, error) {\n  const {\n    param,\n    index,\n    reason\n  } = error;\n  let chainMessage = void 0;\n  let hints = void 0;\n  switch (reason.kind) {\n    case 5:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type is not supported as injection token.\")];\n      break;\n    case 1:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type does not have a value, so it cannot be used as injection token.\")];\n      if (reason.decl !== null) {\n        hints.push(makeRelatedInformation(reason.decl, \"The type is declared here.\"));\n      }\n      break;\n    case 2:\n      chainMessage = \"Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type is imported using a type-only import, which prevents it from being usable as an injection token.\"), makeRelatedInformation(reason.node, \"The type-only import occurs here.\")];\n      break;\n    case 4:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type corresponds with a namespace, which cannot be used as injection token.\"), makeRelatedInformation(reason.importClause, \"The namespace import occurs here.\")];\n      break;\n    case 3:\n      chainMessage = \"The type should reference a known declaration.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type could not be resolved.\")];\n      break;\n    case 0:\n      chainMessage = \"Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.\";\n      break;\n  }\n  const chain = {\n    messageText: `No suitable injection token for parameter '${param.name || index}' of class '${clazz.name.text}'.`,\n    category: ts4.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainMessage,\n      category: ts4.DiagnosticCategory.Message,\n      code: 0\n    }]\n  };\n  return new FatalDiagnosticError(ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/diagnostics.mjs\nimport ts7 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/api.mjs\nvar MetaKind;\n(function (MetaKind2) {\n  MetaKind2[MetaKind2[\"Directive\"] = 0] = \"Directive\";\n  MetaKind2[MetaKind2[\"Pipe\"] = 1] = \"Pipe\";\n  MetaKind2[MetaKind2[\"NgModule\"] = 2] = \"NgModule\";\n})(MetaKind || (MetaKind = {}));\nvar MatchSource;\n(function (MatchSource2) {\n  MatchSource2[MatchSource2[\"Selector\"] = 0] = \"Selector\";\n  MatchSource2[MatchSource2[\"HostDirective\"] = 1] = \"HostDirective\";\n})(MatchSource || (MatchSource = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/dts.mjs\nimport ts6 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/property_mapping.mjs\nvar ClassPropertyMapping = class {\n  constructor(forwardMap) {\n    this.forwardMap = forwardMap;\n    this.reverseMap = reverseMapFromForwardMap(forwardMap);\n  }\n  static empty() {\n    return new ClassPropertyMapping( /* @__PURE__ */new Map());\n  }\n  static fromMappedObject(obj) {\n    const forwardMap = /* @__PURE__ */new Map();\n    for (const classPropertyName of Object.keys(obj)) {\n      const value = obj[classPropertyName];\n      let inputOrOutput;\n      if (typeof value === \"string\") {\n        inputOrOutput = {\n          classPropertyName,\n          bindingPropertyName: value\n        };\n      } else if (Array.isArray(value)) {\n        inputOrOutput = {\n          classPropertyName,\n          bindingPropertyName: value[0]\n        };\n      } else {\n        inputOrOutput = value;\n      }\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n    return new ClassPropertyMapping(forwardMap);\n  }\n  static merge(a, b) {\n    const forwardMap = new Map(a.forwardMap.entries());\n    for (const [classPropertyName, inputOrOutput] of b.forwardMap) {\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n    return new ClassPropertyMapping(forwardMap);\n  }\n  get classPropertyNames() {\n    return Array.from(this.forwardMap.keys());\n  }\n  get propertyNames() {\n    return Array.from(this.reverseMap.keys());\n  }\n  hasBindingPropertyName(propertyName) {\n    return this.reverseMap.has(propertyName);\n  }\n  getByBindingPropertyName(propertyName) {\n    return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName) : null;\n  }\n  getByClassPropertyName(classPropertyName) {\n    return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName) : null;\n  }\n  toDirectMappedObject() {\n    const obj = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n    }\n    return obj;\n  }\n  toJointMappedObject(transform) {\n    const obj = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      obj[classPropertyName] = transform(inputOrOutput);\n    }\n    return obj;\n  }\n  *[Symbol.iterator]() {\n    for (const inputOrOutput of this.forwardMap.values()) {\n      yield inputOrOutput;\n    }\n  }\n};\nfunction reverseMapFromForwardMap(forwardMap) {\n  const reverseMap = /* @__PURE__ */new Map();\n  for (const [_, inputOrOutput] of forwardMap) {\n    if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {\n      reverseMap.set(inputOrOutput.bindingPropertyName, []);\n    }\n    reverseMap.get(inputOrOutput.bindingPropertyName).push(inputOrOutput);\n  }\n  return reverseMap;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/util.mjs\nimport ts5 from \"typescript\";\nfunction extractReferencesFromType(checker, def, bestGuessOwningModule) {\n  if (!ts5.isTupleTypeNode(def)) {\n    return [];\n  }\n  return def.elements.map(element => {\n    if (!ts5.isTypeQueryNode(element)) {\n      throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(element)}`);\n    }\n    return extraReferenceFromTypeQuery(checker, element, def, bestGuessOwningModule);\n  });\n}\nfunction extraReferenceFromTypeQuery(checker, typeNode, origin, bestGuessOwningModule) {\n  const type = typeNode.exprName;\n  const {\n    node,\n    from\n  } = reflectTypeEntityToDeclaration(type, checker);\n  if (!isNamedClassDeclaration(node)) {\n    throw new Error(`Expected named ClassDeclaration: ${nodeDebugInfo(node)}`);\n  }\n  if (from !== null && !from.startsWith(\".\")) {\n    return new Reference(node, {\n      specifier: from,\n      resolutionContext: origin.getSourceFile().fileName\n    });\n  }\n  return new Reference(node, bestGuessOwningModule);\n}\nfunction readBooleanType(type) {\n  if (!ts5.isLiteralTypeNode(type)) {\n    return null;\n  }\n  switch (type.literal.kind) {\n    case ts5.SyntaxKind.TrueKeyword:\n      return true;\n    case ts5.SyntaxKind.FalseKeyword:\n      return false;\n    default:\n      return null;\n  }\n}\nfunction readStringType(type) {\n  if (!ts5.isLiteralTypeNode(type) || !ts5.isStringLiteral(type.literal)) {\n    return null;\n  }\n  return type.literal.text;\n}\nfunction readMapType(type, valueTransform) {\n  if (!ts5.isTypeLiteralNode(type)) {\n    return {};\n  }\n  const obj = {};\n  type.members.forEach(member => {\n    if (!ts5.isPropertySignature(member) || member.type === void 0 || member.name === void 0 || !ts5.isStringLiteral(member.name) && !ts5.isIdentifier(member.name)) {\n      return;\n    }\n    const value = valueTransform(member.type);\n    if (value === null) {\n      return null;\n    }\n    obj[member.name.text] = value;\n  });\n  return obj;\n}\nfunction readStringArrayType(type) {\n  if (!ts5.isTupleTypeNode(type)) {\n    return [];\n  }\n  const res = [];\n  type.elements.forEach(el => {\n    if (!ts5.isLiteralTypeNode(el) || !ts5.isStringLiteral(el.literal)) {\n      return;\n    }\n    res.push(el.literal.text);\n  });\n  return res;\n}\nfunction extractDirectiveTypeCheckMeta(node, inputs, reflector) {\n  const members = reflector.getMembersOfClass(node);\n  const staticMembers = members.filter(member => member.isStatic);\n  const ngTemplateGuards = staticMembers.map(extractTemplateGuard).filter(guard => guard !== null);\n  const hasNgTemplateContextGuard = staticMembers.some(member => member.kind === ClassMemberKind.Method && member.name === \"ngTemplateContextGuard\");\n  const coercedInputFields = new Set(staticMembers.map(extractCoercedInput).filter(inputName => inputName !== null));\n  const restrictedInputFields = /* @__PURE__ */new Set();\n  const stringLiteralInputFields = /* @__PURE__ */new Set();\n  const undeclaredInputFields = /* @__PURE__ */new Set();\n  for (const {\n    classPropertyName,\n    transform\n  } of inputs) {\n    const field = members.find(member => member.name === classPropertyName);\n    if (field === void 0 || field.node === null) {\n      undeclaredInputFields.add(classPropertyName);\n      continue;\n    }\n    if (isRestricted(field.node)) {\n      restrictedInputFields.add(classPropertyName);\n    }\n    if (field.nameNode !== null && ts5.isStringLiteral(field.nameNode)) {\n      stringLiteralInputFields.add(classPropertyName);\n    }\n    if (transform !== null) {\n      coercedInputFields.add(classPropertyName);\n    }\n  }\n  const arity = reflector.getGenericArityOfClass(node);\n  return {\n    hasNgTemplateContextGuard,\n    ngTemplateGuards,\n    coercedInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    undeclaredInputFields,\n    isGeneric: arity !== null && arity > 0\n  };\n}\nfunction isRestricted(node) {\n  const modifiers = ts5.canHaveModifiers(node) ? ts5.getModifiers(node) : void 0;\n  return modifiers !== void 0 && modifiers.some(({\n    kind\n  }) => {\n    return kind === ts5.SyntaxKind.PrivateKeyword || kind === ts5.SyntaxKind.ProtectedKeyword || kind === ts5.SyntaxKind.ReadonlyKeyword;\n  });\n}\nfunction extractTemplateGuard(member) {\n  if (!member.name.startsWith(\"ngTemplateGuard_\")) {\n    return null;\n  }\n  const inputName = afterUnderscore(member.name);\n  if (member.kind === ClassMemberKind.Property) {\n    let type = null;\n    if (member.type !== null && ts5.isLiteralTypeNode(member.type) && ts5.isStringLiteral(member.type.literal)) {\n      type = member.type.literal.text;\n    }\n    if (type !== \"binding\") {\n      return null;\n    }\n    return {\n      inputName,\n      type\n    };\n  } else if (member.kind === ClassMemberKind.Method) {\n    return {\n      inputName,\n      type: \"invocation\"\n    };\n  } else {\n    return null;\n  }\n}\nfunction extractCoercedInput(member) {\n  if (member.kind !== ClassMemberKind.Property || !member.name.startsWith(\"ngAcceptInputType_\")) {\n    return null;\n  }\n  return afterUnderscore(member.name);\n}\nvar CompoundMetadataReader = class {\n  constructor(readers) {\n    this.readers = readers;\n  }\n  getDirectiveMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getDirectiveMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getNgModuleMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getNgModuleMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getPipeMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getPipeMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n};\nfunction afterUnderscore(str) {\n  const pos = str.indexOf(\"_\");\n  if (pos === -1) {\n    throw new Error(`Expected '${str}' to contain '_'`);\n  }\n  return str.slice(pos + 1);\n}\nfunction hasInjectableFields(clazz, host) {\n  const members = host.getMembersOfClass(clazz);\n  return members.some(({\n    isStatic,\n    name\n  }) => isStatic && (name === \"\\u0275prov\" || name === \"\\u0275fac\"));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/dts.mjs\nvar DtsMetadataReader = class {\n  constructor(checker, reflector) {\n    this.checker = checker;\n    this.reflector = reflector;\n  }\n  getNgModuleMetadata(ref) {\n    const clazz = ref.node;\n    const ngModuleDef = this.reflector.getMembersOfClass(clazz).find(member => member.name === \"\\u0275mod\" && member.isStatic);\n    if (ngModuleDef === void 0) {\n      return null;\n    } else if (ngModuleDef.type === null || !ts6.isTypeReferenceNode(ngModuleDef.type) || ngModuleDef.type.typeArguments === void 0 || ngModuleDef.type.typeArguments.length !== 4) {\n      return null;\n    }\n    const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;\n    return {\n      kind: MetaKind.NgModule,\n      ref,\n      declarations: extractReferencesFromType(this.checker, declarationMetadata, ref.bestGuessOwningModule),\n      exports: extractReferencesFromType(this.checker, exportMetadata, ref.bestGuessOwningModule),\n      imports: extractReferencesFromType(this.checker, importMetadata, ref.bestGuessOwningModule),\n      schemas: [],\n      rawDeclarations: null,\n      rawImports: null,\n      rawExports: null,\n      decorator: null,\n      mayDeclareProviders: true\n    };\n  }\n  getDirectiveMetadata(ref) {\n    var _a, _b;\n    const clazz = ref.node;\n    const def = this.reflector.getMembersOfClass(clazz).find(field => field.isStatic && (field.name === \"\\u0275cmp\" || field.name === \"\\u0275dir\"));\n    if (def === void 0) {\n      return null;\n    } else if (def.type === null || !ts6.isTypeReferenceNode(def.type) || def.type.typeArguments === void 0 || def.type.typeArguments.length < 2) {\n      return null;\n    }\n    const isComponent = def.name === \"\\u0275cmp\";\n    const ctorParams = this.reflector.getConstructorParameters(clazz);\n    const isStructural = !isComponent && ctorParams !== null && ctorParams.some(param => {\n      return param.typeValueReference.kind === 1 && param.typeValueReference.moduleName === \"@angular/core\" && param.typeValueReference.importedName === \"TemplateRef\";\n    });\n    const isStandalone = def.type.typeArguments.length > 7 && ((_a = readBooleanType(def.type.typeArguments[7])) != null ? _a : false);\n    const inputs = ClassPropertyMapping.fromMappedObject(readInputsType(def.type.typeArguments[3]));\n    const outputs = ClassPropertyMapping.fromMappedObject(readMapType(def.type.typeArguments[4], readStringType));\n    const hostDirectives = def.type.typeArguments.length > 8 ? readHostDirectivesType(this.checker, def.type.typeArguments[8], ref.bestGuessOwningModule) : null;\n    const isSignal = def.type.typeArguments.length > 9 && ((_b = readBooleanType(def.type.typeArguments[9])) != null ? _b : false);\n    return {\n      kind: MetaKind.Directive,\n      matchSource: MatchSource.Selector,\n      ref,\n      name: clazz.name.text,\n      isComponent,\n      selector: readStringType(def.type.typeArguments[1]),\n      exportAs: readStringArrayType(def.type.typeArguments[2]),\n      inputs,\n      outputs,\n      hostDirectives,\n      queries: readStringArrayType(def.type.typeArguments[5]),\n      ...extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector),\n      baseClass: readBaseClass2(clazz, this.checker, this.reflector),\n      isPoisoned: false,\n      isStructural,\n      animationTriggerNames: null,\n      isStandalone,\n      isSignal,\n      imports: null,\n      schemas: null,\n      decorator: null,\n      assumedToExportProviders: isComponent && isStandalone\n    };\n  }\n  getPipeMetadata(ref) {\n    var _a;\n    const def = this.reflector.getMembersOfClass(ref.node).find(field => field.isStatic && field.name === \"\\u0275pipe\");\n    if (def === void 0) {\n      return null;\n    } else if (def.type === null || !ts6.isTypeReferenceNode(def.type) || def.type.typeArguments === void 0 || def.type.typeArguments.length < 2) {\n      return null;\n    }\n    const type = def.type.typeArguments[1];\n    if (!ts6.isLiteralTypeNode(type) || !ts6.isStringLiteral(type.literal)) {\n      return null;\n    }\n    const name = type.literal.text;\n    const isStandalone = def.type.typeArguments.length > 2 && ((_a = readBooleanType(def.type.typeArguments[2])) != null ? _a : false);\n    return {\n      kind: MetaKind.Pipe,\n      ref,\n      name,\n      nameExpr: null,\n      isStandalone,\n      decorator: null\n    };\n  }\n};\nfunction readInputsType(type) {\n  const inputsMap = {};\n  if (ts6.isTypeLiteralNode(type)) {\n    for (const member of type.members) {\n      if (!ts6.isPropertySignature(member) || member.type === void 0 || member.name === void 0 || !ts6.isStringLiteral(member.name) && !ts6.isIdentifier(member.name)) {\n        continue;\n      }\n      const stringValue = readStringType(member.type);\n      const classPropertyName = member.name.text;\n      if (stringValue != null) {\n        inputsMap[classPropertyName] = {\n          bindingPropertyName: stringValue,\n          classPropertyName,\n          required: false,\n          transform: null\n        };\n      } else {\n        const config = readMapType(member.type, innerValue => {\n          var _a;\n          return (_a = readStringType(innerValue)) != null ? _a : readBooleanType(innerValue);\n        });\n        inputsMap[classPropertyName] = {\n          classPropertyName,\n          bindingPropertyName: config.alias,\n          required: config.required,\n          transform: null\n        };\n      }\n    }\n  }\n  return inputsMap;\n}\nfunction readBaseClass2(clazz, checker, reflector) {\n  if (!isNamedClassDeclaration(clazz)) {\n    return reflector.hasBaseClass(clazz) ? \"dynamic\" : null;\n  }\n  if (clazz.heritageClauses !== void 0) {\n    for (const clause of clazz.heritageClauses) {\n      if (clause.token === ts6.SyntaxKind.ExtendsKeyword) {\n        const baseExpr = clause.types[0].expression;\n        let symbol = checker.getSymbolAtLocation(baseExpr);\n        if (symbol === void 0) {\n          return \"dynamic\";\n        } else if (symbol.flags & ts6.SymbolFlags.Alias) {\n          symbol = checker.getAliasedSymbol(symbol);\n        }\n        if (symbol.valueDeclaration !== void 0 && isNamedClassDeclaration(symbol.valueDeclaration)) {\n          return new Reference(symbol.valueDeclaration);\n        } else {\n          return \"dynamic\";\n        }\n      }\n    }\n  }\n  return null;\n}\nfunction readHostDirectivesType(checker, type, bestGuessOwningModule) {\n  if (!ts6.isTupleTypeNode(type) || type.elements.length === 0) {\n    return null;\n  }\n  const result = [];\n  for (const hostDirectiveType of type.elements) {\n    const {\n      directive,\n      inputs,\n      outputs\n    } = readMapType(hostDirectiveType, type2 => type2);\n    if (directive) {\n      if (!ts6.isTypeQueryNode(directive)) {\n        throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(directive)}`);\n      }\n      result.push({\n        directive: extraReferenceFromTypeQuery(checker, directive, type, bestGuessOwningModule),\n        isForwardReference: false,\n        inputs: readMapType(inputs, readStringType),\n        outputs: readMapType(outputs, readStringType)\n      });\n    }\n  }\n  return result.length > 0 ? result : null;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/inheritance.mjs\nfunction flattenInheritedDirectiveMetadata(reader, dir) {\n  const topMeta = reader.getDirectiveMetadata(dir);\n  if (topMeta === null) {\n    return null;\n  }\n  if (topMeta.baseClass === null) {\n    return topMeta;\n  }\n  const coercedInputFields = /* @__PURE__ */new Set();\n  const undeclaredInputFields = /* @__PURE__ */new Set();\n  const restrictedInputFields = /* @__PURE__ */new Set();\n  const stringLiteralInputFields = /* @__PURE__ */new Set();\n  let isDynamic = false;\n  let inputs = ClassPropertyMapping.empty();\n  let outputs = ClassPropertyMapping.empty();\n  let isStructural = false;\n  const addMetadata = meta => {\n    if (meta.baseClass === \"dynamic\") {\n      isDynamic = true;\n    } else if (meta.baseClass !== null) {\n      const baseMeta = reader.getDirectiveMetadata(meta.baseClass);\n      if (baseMeta !== null) {\n        addMetadata(baseMeta);\n      } else {\n        isDynamic = true;\n      }\n    }\n    isStructural = isStructural || meta.isStructural;\n    inputs = ClassPropertyMapping.merge(inputs, meta.inputs);\n    outputs = ClassPropertyMapping.merge(outputs, meta.outputs);\n    for (const coercedInputField of meta.coercedInputFields) {\n      coercedInputFields.add(coercedInputField);\n    }\n    for (const undeclaredInputField of meta.undeclaredInputFields) {\n      undeclaredInputFields.add(undeclaredInputField);\n    }\n    for (const restrictedInputField of meta.restrictedInputFields) {\n      restrictedInputFields.add(restrictedInputField);\n    }\n    for (const field of meta.stringLiteralInputFields) {\n      stringLiteralInputFields.add(field);\n    }\n  };\n  addMetadata(topMeta);\n  return {\n    ...topMeta,\n    inputs,\n    outputs,\n    coercedInputFields,\n    undeclaredInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    baseClass: isDynamic ? \"dynamic\" : null,\n    isStructural\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/registry.mjs\nvar LocalMetadataRegistry = class {\n  constructor() {\n    this.directives = /* @__PURE__ */new Map();\n    this.ngModules = /* @__PURE__ */new Map();\n    this.pipes = /* @__PURE__ */new Map();\n  }\n  getDirectiveMetadata(ref) {\n    return this.directives.has(ref.node) ? this.directives.get(ref.node) : null;\n  }\n  getNgModuleMetadata(ref) {\n    return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node) : null;\n  }\n  getPipeMetadata(ref) {\n    return this.pipes.has(ref.node) ? this.pipes.get(ref.node) : null;\n  }\n  registerDirectiveMetadata(meta) {\n    this.directives.set(meta.ref.node, meta);\n  }\n  registerNgModuleMetadata(meta) {\n    this.ngModules.set(meta.ref.node, meta);\n  }\n  registerPipeMetadata(meta) {\n    this.pipes.set(meta.ref.node, meta);\n  }\n  getKnown(kind) {\n    switch (kind) {\n      case MetaKind.Directive:\n        return Array.from(this.directives.values()).map(v => v.ref.node);\n      case MetaKind.Pipe:\n        return Array.from(this.pipes.values()).map(v => v.ref.node);\n      case MetaKind.NgModule:\n        return Array.from(this.ngModules.values()).map(v => v.ref.node);\n    }\n  }\n};\nvar CompoundMetadataRegistry = class {\n  constructor(registries) {\n    this.registries = registries;\n  }\n  registerDirectiveMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerDirectiveMetadata(meta);\n    }\n  }\n  registerNgModuleMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerNgModuleMetadata(meta);\n    }\n  }\n  registerPipeMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerPipeMetadata(meta);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/resource_registry.mjs\nvar ResourceRegistry = class {\n  constructor() {\n    this.externalTemplateToComponentsMap = /* @__PURE__ */new Map();\n    this.componentToTemplateMap = /* @__PURE__ */new Map();\n    this.componentToStylesMap = /* @__PURE__ */new Map();\n    this.externalStyleToComponentsMap = /* @__PURE__ */new Map();\n  }\n  getComponentsWithTemplate(template) {\n    if (!this.externalTemplateToComponentsMap.has(template)) {\n      return /* @__PURE__ */new Set();\n    }\n    return this.externalTemplateToComponentsMap.get(template);\n  }\n  registerResources(resources, component) {\n    if (resources.template !== null) {\n      this.registerTemplate(resources.template, component);\n    }\n    for (const style of resources.styles) {\n      this.registerStyle(style, component);\n    }\n  }\n  registerTemplate(templateResource, component) {\n    const {\n      path\n    } = templateResource;\n    if (path !== null) {\n      if (!this.externalTemplateToComponentsMap.has(path)) {\n        this.externalTemplateToComponentsMap.set(path, /* @__PURE__ */new Set());\n      }\n      this.externalTemplateToComponentsMap.get(path).add(component);\n    }\n    this.componentToTemplateMap.set(component, templateResource);\n  }\n  getTemplate(component) {\n    if (!this.componentToTemplateMap.has(component)) {\n      return null;\n    }\n    return this.componentToTemplateMap.get(component);\n  }\n  registerStyle(styleResource, component) {\n    const {\n      path\n    } = styleResource;\n    if (!this.componentToStylesMap.has(component)) {\n      this.componentToStylesMap.set(component, /* @__PURE__ */new Set());\n    }\n    if (path !== null) {\n      if (!this.externalStyleToComponentsMap.has(path)) {\n        this.externalStyleToComponentsMap.set(path, /* @__PURE__ */new Set());\n      }\n      this.externalStyleToComponentsMap.get(path).add(component);\n    }\n    this.componentToStylesMap.get(component).add(styleResource);\n  }\n  getStyles(component) {\n    if (!this.componentToStylesMap.has(component)) {\n      return /* @__PURE__ */new Set();\n    }\n    return this.componentToStylesMap.get(component);\n  }\n  getComponentsWithStyle(styleUrl) {\n    if (!this.externalStyleToComponentsMap.has(styleUrl)) {\n      return /* @__PURE__ */new Set();\n    }\n    return this.externalStyleToComponentsMap.get(styleUrl);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/providers.mjs\nvar ExportedProviderStatusResolver = class {\n  constructor(metaReader) {\n    this.metaReader = metaReader;\n    this.calculating = /* @__PURE__ */new Set();\n  }\n  mayExportProviders(ref, dependencyCallback) {\n    var _a;\n    if (this.calculating.has(ref.node)) {\n      return false;\n    }\n    this.calculating.add(ref.node);\n    if (dependencyCallback !== void 0) {\n      dependencyCallback(ref);\n    }\n    try {\n      const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n      if (dirMeta !== null) {\n        if (!dirMeta.isComponent || !dirMeta.isStandalone) {\n          return false;\n        }\n        if (dirMeta.assumedToExportProviders) {\n          return true;\n        }\n        return ((_a = dirMeta.imports) != null ? _a : []).some(importRef => this.mayExportProviders(importRef, dependencyCallback));\n      }\n      const pipeMeta = this.metaReader.getPipeMetadata(ref);\n      if (pipeMeta !== null) {\n        return false;\n      }\n      const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);\n      if (ngModuleMeta !== null) {\n        if (ngModuleMeta.mayDeclareProviders) {\n          return true;\n        }\n        return ngModuleMeta.imports.some(importRef => this.mayExportProviders(importRef, dependencyCallback));\n      }\n      return false;\n    } finally {\n      this.calculating.delete(ref.node);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/host_directives_resolver.mjs\nvar EMPTY_ARRAY = [];\nvar HostDirectivesResolver = class {\n  constructor(metaReader) {\n    this.metaReader = metaReader;\n    this.cache = /* @__PURE__ */new Map();\n  }\n  resolve(metadata) {\n    if (this.cache.has(metadata.ref.node)) {\n      return this.cache.get(metadata.ref.node);\n    }\n    const results = metadata.hostDirectives && metadata.hostDirectives.length > 0 ? this.walkHostDirectives(metadata.hostDirectives, []) : EMPTY_ARRAY;\n    this.cache.set(metadata.ref.node, results);\n    return results;\n  }\n  walkHostDirectives(directives, results) {\n    for (const current of directives) {\n      const hostMeta = flattenInheritedDirectiveMetadata(this.metaReader, current.directive);\n      if (hostMeta === null) {\n        continue;\n      }\n      if (hostMeta.hostDirectives) {\n        this.walkHostDirectives(hostMeta.hostDirectives, results);\n      }\n      results.push({\n        ...hostMeta,\n        matchSource: MatchSource.HostDirective,\n        inputs: ClassPropertyMapping.fromMappedObject(this.filterMappings(hostMeta.inputs, current.inputs, resolveInput)),\n        outputs: ClassPropertyMapping.fromMappedObject(this.filterMappings(hostMeta.outputs, current.outputs, resolveOutput))\n      });\n    }\n    return results;\n  }\n  filterMappings(source, allowedProperties, valueResolver) {\n    const result = {};\n    if (allowedProperties !== null) {\n      for (const publicName in allowedProperties) {\n        if (allowedProperties.hasOwnProperty(publicName)) {\n          const bindings = source.getByBindingPropertyName(publicName);\n          if (bindings !== null) {\n            for (const binding of bindings) {\n              result[binding.classPropertyName] = valueResolver(allowedProperties[publicName], binding);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n};\nfunction resolveInput(bindingName, binding) {\n  return {\n    bindingPropertyName: bindingName,\n    classPropertyName: binding.classPropertyName,\n    required: binding.required,\n    transform: binding.transform\n  };\n}\nfunction resolveOutput(bindingName) {\n  return bindingName;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/diagnostics.mjs\nfunction makeDuplicateDeclarationError(node, data, kind) {\n  const context = [];\n  for (const decl of data) {\n    if (decl.rawDeclarations === null) {\n      continue;\n    }\n    const contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);\n    context.push(makeRelatedInformation(contextNode, `'${node.name.text}' is listed in the declarations of the NgModule '${decl.ngModule.name.text}'.`));\n  }\n  return makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name, `The ${kind} '${node.name.text}' is declared by more than one NgModule.`, context);\n}\nfunction createValueHasWrongTypeError(node, value, messageText) {\n  var _a;\n  let chainedMessage;\n  let relatedInformation;\n  if (value instanceof DynamicValue) {\n    chainedMessage = \"Value could not be determined statically.\";\n    relatedInformation = traceDynamicValue(node, value);\n  } else if (value instanceof Reference) {\n    const target = value.debugName !== null ? `'${value.debugName}'` : \"an anonymous declaration\";\n    chainedMessage = `Value is a reference to ${target}.`;\n    const referenceNode = (_a = identifierOfNode(value.node)) != null ? _a : value.node;\n    relatedInformation = [makeRelatedInformation(referenceNode, \"Reference is declared here.\")];\n  } else {\n    chainedMessage = `Value is of type '${describeResolvedType(value)}'.`;\n  }\n  const chain = {\n    messageText,\n    category: ts7.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainedMessage,\n      category: ts7.DiagnosticCategory.Message,\n      code: 0\n    }]\n  };\n  return new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);\n}\nfunction getProviderDiagnostics(providerClasses, providersDeclaration, registry) {\n  const diagnostics = [];\n  for (const provider of providerClasses) {\n    const injectableMeta = registry.getInjectableMeta(provider.node);\n    if (injectableMeta !== null) {\n      continue;\n    }\n    const contextNode = provider.getOriginForDiagnostics(providersDeclaration);\n    diagnostics.push(makeDiagnostic(ErrorCode.UNDECORATED_PROVIDER, contextNode, `The class '${provider.node.name.text}' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.\n\nEither add the @Injectable() decorator to '${provider.node.name.text}', or configure a different provider (such as a provider with 'useFactory').\n`, [makeRelatedInformation(provider.node, `'${provider.node.name.text}' is declared here.`)]));\n  }\n  return diagnostics;\n}\nfunction getDirectiveDiagnostics(node, injectableRegistry, evaluator, reflector, scopeRegistry, strictInjectionParameters, kind) {\n  let diagnostics = [];\n  const addDiagnostics = more => {\n    if (more === null) {\n      return;\n    } else if (diagnostics === null) {\n      diagnostics = Array.isArray(more) ? more : [more];\n    } else if (Array.isArray(more)) {\n      diagnostics.push(...more);\n    } else {\n      diagnostics.push(more);\n    }\n  };\n  const duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);\n  if (duplicateDeclarations !== null) {\n    addDiagnostics(makeDuplicateDeclarationError(node, duplicateDeclarations, kind));\n  }\n  addDiagnostics(checkInheritanceOfInjectable(node, injectableRegistry, reflector, evaluator, strictInjectionParameters, kind));\n  return diagnostics;\n}\nfunction validateHostDirectives(origin, hostDirectives, metaReader) {\n  const diagnostics = [];\n  for (const current of hostDirectives) {\n    const hostMeta = flattenInheritedDirectiveMetadata(metaReader, current.directive);\n    if (hostMeta === null) {\n      diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_INVALID, current.directive.getOriginForDiagnostics(origin), `${current.directive.debugName} must be a standalone directive to be used as a host directive`));\n      continue;\n    }\n    if (!hostMeta.isStandalone) {\n      diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_NOT_STANDALONE, current.directive.getOriginForDiagnostics(origin), `Host directive ${hostMeta.name} must be standalone`));\n    }\n    if (hostMeta.isComponent) {\n      diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_COMPONENT, current.directive.getOriginForDiagnostics(origin), `Host directive ${hostMeta.name} cannot be a component`));\n    }\n    const requiredInputNames = Array.from(hostMeta.inputs).filter(input => input.required).map(input => input.classPropertyName);\n    validateHostDirectiveMappings(\"input\", current, hostMeta, origin, diagnostics, requiredInputNames.length > 0 ? new Set(requiredInputNames) : null);\n    validateHostDirectiveMappings(\"output\", current, hostMeta, origin, diagnostics, null);\n  }\n  return diagnostics;\n}\nfunction validateHostDirectiveMappings(bindingType, hostDirectiveMeta, meta, origin, diagnostics, requiredBindings) {\n  const className = meta.name;\n  const hostDirectiveMappings = bindingType === \"input\" ? hostDirectiveMeta.inputs : hostDirectiveMeta.outputs;\n  const existingBindings = bindingType === \"input\" ? meta.inputs : meta.outputs;\n  const exposedRequiredBindings = /* @__PURE__ */new Set();\n  for (const publicName in hostDirectiveMappings) {\n    if (hostDirectiveMappings.hasOwnProperty(publicName)) {\n      const bindings = existingBindings.getByBindingPropertyName(publicName);\n      if (bindings === null) {\n        diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING, hostDirectiveMeta.directive.getOriginForDiagnostics(origin), `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`));\n      } else if (requiredBindings !== null) {\n        for (const field of bindings) {\n          if (requiredBindings.has(field.classPropertyName)) {\n            exposedRequiredBindings.add(field.classPropertyName);\n          }\n        }\n      }\n      const remappedPublicName = hostDirectiveMappings[publicName];\n      const bindingsForPublicName = existingBindings.getByBindingPropertyName(remappedPublicName);\n      if (bindingsForPublicName !== null) {\n        for (const binding of bindingsForPublicName) {\n          if (binding.bindingPropertyName !== publicName) {\n            diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS, hostDirectiveMeta.directive.getOriginForDiagnostics(origin), `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`));\n          }\n        }\n      }\n    }\n  }\n  if (requiredBindings !== null && requiredBindings.size !== exposedRequiredBindings.size) {\n    const missingBindings = [];\n    for (const publicName of requiredBindings) {\n      if (!exposedRequiredBindings.has(publicName)) {\n        const name = existingBindings.getByClassPropertyName(publicName);\n        if (name) {\n          missingBindings.push(`'${name.bindingPropertyName}'`);\n        }\n      }\n    }\n    diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_MISSING_REQUIRED_BINDING, hostDirectiveMeta.directive.getOriginForDiagnostics(origin), `Required ${bindingType}${missingBindings.length === 1 ? \"\" : \"s\"} ${missingBindings.join(\", \")} from host directive ${className} must be exposed.`));\n  }\n}\nfunction getUndecoratedClassWithAngularFeaturesDiagnostic(node) {\n  return makeDiagnostic(ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name, `Class is using Angular features but is not decorated. Please add an explicit Angular decorator.`);\n}\nfunction checkInheritanceOfInjectable(node, injectableRegistry, reflector, evaluator, strictInjectionParameters, kind) {\n  const classWithCtor = findInheritedCtor(node, injectableRegistry, reflector, evaluator);\n  if (classWithCtor === null || classWithCtor.isCtorValid) {\n    return null;\n  }\n  if (!classWithCtor.isDecorated) {\n    return getInheritedUndecoratedCtorDiagnostic(node, classWithCtor.ref, kind);\n  }\n  if (isFromDtsFile(classWithCtor.ref.node)) {\n    return null;\n  }\n  if (!strictInjectionParameters || isAbstractClassDeclaration(node)) {\n    return null;\n  }\n  return getInheritedInvalidCtorDiagnostic(node, classWithCtor.ref, kind);\n}\nfunction findInheritedCtor(node, injectableRegistry, reflector, evaluator) {\n  if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {\n    return null;\n  }\n  let baseClass = readBaseClass(node, reflector, evaluator);\n  while (baseClass !== null) {\n    if (baseClass === \"dynamic\") {\n      return null;\n    }\n    const injectableMeta = injectableRegistry.getInjectableMeta(baseClass.node);\n    if (injectableMeta !== null) {\n      if (injectableMeta.ctorDeps !== null) {\n        return {\n          ref: baseClass,\n          isCtorValid: injectableMeta.ctorDeps !== \"invalid\",\n          isDecorated: true\n        };\n      }\n    } else {\n      const baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);\n      if (baseClassConstructorParams !== null) {\n        return {\n          ref: baseClass,\n          isCtorValid: baseClassConstructorParams.length === 0,\n          isDecorated: false\n        };\n      }\n    }\n    baseClass = readBaseClass(baseClass.node, reflector, evaluator);\n  }\n  return null;\n}\nfunction getInheritedInvalidCtorDiagnostic(node, baseClass, kind) {\n  const baseClassName = baseClass.debugName;\n  return makeDiagnostic(ErrorCode.INJECTABLE_INHERITS_INVALID_CONSTRUCTOR, node.name, `The ${kind.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, but the latter has a constructor parameter that is not compatible with dependency injection. Either add an explicit constructor to ${node.name.text} or change ${baseClassName}'s constructor to use parameters that are valid for DI.`);\n}\nfunction getInheritedUndecoratedCtorDiagnostic(node, baseClass, kind) {\n  const baseClassName = baseClass.debugName;\n  const baseNeedsDecorator = kind === \"Component\" || kind === \"Directive\" ? \"Directive\" : \"Injectable\";\n  return makeDiagnostic(ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name, `The ${kind.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, but the latter does not have an Angular decorator of its own. Dependency injection will not be able to resolve the parameters of ${baseClassName}'s constructor. Either add a @${baseNeedsDecorator} decorator to ${baseClassName}, or add an explicit constructor to ${node.name.text}.`);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/evaluation.mjs\nimport ts8 from \"typescript\";\nfunction resolveEnumValue(evaluator, metadata, field, enumSymbolName) {\n  let resolved = null;\n  if (metadata.has(field)) {\n    const expr = metadata.get(field);\n    const value = evaluator.evaluate(expr);\n    if (value instanceof EnumValue && isAngularCoreReference(value.enumRef, enumSymbolName)) {\n      resolved = value.resolved;\n    } else {\n      throw createValueHasWrongTypeError(expr, value, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);\n    }\n  }\n  return resolved;\n}\nfunction isStringArray(resolvedValue) {\n  return Array.isArray(resolvedValue) && resolvedValue.every(elem => typeof elem === \"string\");\n}\nfunction resolveLiteral(decorator, literalCache) {\n  if (literalCache.has(decorator)) {\n    return literalCache.get(decorator);\n  }\n  if (decorator.args === null || decorator.args.length !== 1) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @${decorator.name} decorator`);\n  }\n  const meta = unwrapExpression(decorator.args[0]);\n  if (!ts8.isObjectLiteralExpression(meta)) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `Decorator argument must be literal.`);\n  }\n  literalCache.set(decorator, meta);\n  return meta;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/factory.mjs\nimport { compileDeclareFactoryFunction, compileFactoryFunction } from \"@angular/compiler\";\nfunction compileNgFactoryDefField(metadata) {\n  const res = compileFactoryFunction(metadata);\n  return {\n    name: \"\\u0275fac\",\n    initializer: res.expression,\n    statements: res.statements,\n    type: res.type\n  };\n}\nfunction compileDeclareFactory(metadata) {\n  const res = compileDeclareFactoryFunction(metadata);\n  return {\n    name: \"\\u0275fac\",\n    initializer: res.expression,\n    statements: res.statements,\n    type: res.type\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/injectable_registry.mjs\nvar InjectableClassRegistry = class {\n  constructor(host, isCore) {\n    this.host = host;\n    this.isCore = isCore;\n    this.classes = /* @__PURE__ */new Map();\n  }\n  registerInjectable(declaration, meta) {\n    this.classes.set(declaration, meta);\n  }\n  getInjectableMeta(declaration) {\n    if (this.classes.has(declaration)) {\n      return this.classes.get(declaration);\n    }\n    if (!hasInjectableFields(declaration, this.host)) {\n      return null;\n    }\n    const ctorDeps = getConstructorDependencies(declaration, this.host, this.isCore);\n    const meta = {\n      ctorDeps: unwrapConstructorDependencies(ctorDeps)\n    };\n    this.classes.set(declaration, meta);\n    return meta;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/metadata.mjs\nimport { FunctionExpr, LiteralArrayExpr, LiteralExpr as LiteralExpr2, literalMap, ReturnStatement, WrappedNodeExpr as WrappedNodeExpr3 } from \"@angular/compiler\";\nimport ts9 from \"typescript\";\nfunction extractClassMetadata(clazz, reflection, isCore, annotateForClosureCompiler, angularDecoratorTransform = dec => dec) {\n  if (!reflection.isClass(clazz)) {\n    return null;\n  }\n  const id = clazz.name;\n  const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);\n  if (classDecorators === null) {\n    return null;\n  }\n  const ngClassDecorators = classDecorators.filter(dec => isAngularDecorator2(dec, isCore)).map(decorator => decoratorToMetadata(angularDecoratorTransform(decorator), annotateForClosureCompiler)).map(decorator => removeIdentifierReferences(decorator, id.text));\n  if (ngClassDecorators.length === 0) {\n    return null;\n  }\n  const metaDecorators = new WrappedNodeExpr3(ts9.factory.createArrayLiteralExpression(ngClassDecorators));\n  let metaCtorParameters = null;\n  const classCtorParameters = reflection.getConstructorParameters(clazz);\n  if (classCtorParameters !== null) {\n    const ctorParameters = classCtorParameters.map(param => ctorParameterToMetadata(param, isCore));\n    metaCtorParameters = new FunctionExpr([], [new ReturnStatement(new LiteralArrayExpr(ctorParameters))]);\n  }\n  let metaPropDecorators = null;\n  const classMembers = reflection.getMembersOfClass(clazz).filter(member => !member.isStatic && member.decorators !== null && member.decorators.length > 0);\n  const duplicateDecoratedMemberNames = classMembers.map(member => member.name).filter((name, i, arr) => arr.indexOf(name) < i);\n  if (duplicateDecoratedMemberNames.length > 0) {\n    throw new Error(`Duplicate decorated properties found on class '${clazz.name.text}': ` + duplicateDecoratedMemberNames.join(\", \"));\n  }\n  const decoratedMembers = classMembers.map(member => {\n    var _a;\n    return classMemberToMetadata((_a = member.nameNode) != null ? _a : member.name, member.decorators, isCore);\n  });\n  if (decoratedMembers.length > 0) {\n    metaPropDecorators = new WrappedNodeExpr3(ts9.factory.createObjectLiteralExpression(decoratedMembers));\n  }\n  return {\n    type: new WrappedNodeExpr3(id),\n    decorators: metaDecorators,\n    ctorParameters: metaCtorParameters,\n    propDecorators: metaPropDecorators\n  };\n}\nfunction ctorParameterToMetadata(param, isCore) {\n  const type = param.typeValueReference.kind !== 2 ? valueReferenceToExpression(param.typeValueReference) : new LiteralExpr2(void 0);\n  const mapEntries = [{\n    key: \"type\",\n    value: type,\n    quoted: false\n  }];\n  if (param.decorators !== null) {\n    const ngDecorators = param.decorators.filter(dec => isAngularDecorator2(dec, isCore)).map(decorator => decoratorToMetadata(decorator));\n    const value = new WrappedNodeExpr3(ts9.factory.createArrayLiteralExpression(ngDecorators));\n    mapEntries.push({\n      key: \"decorators\",\n      value,\n      quoted: false\n    });\n  }\n  return literalMap(mapEntries);\n}\nfunction classMemberToMetadata(name, decorators, isCore) {\n  const ngDecorators = decorators.filter(dec => isAngularDecorator2(dec, isCore)).map(decorator => decoratorToMetadata(decorator));\n  const decoratorMeta = ts9.factory.createArrayLiteralExpression(ngDecorators);\n  return ts9.factory.createPropertyAssignment(name, decoratorMeta);\n}\nfunction decoratorToMetadata(decorator, wrapFunctionsInParens) {\n  if (decorator.identifier === null) {\n    throw new Error(\"Illegal state: synthesized decorator cannot be emitted in class metadata.\");\n  }\n  const properties = [ts9.factory.createPropertyAssignment(\"type\", decorator.identifier)];\n  if (decorator.args !== null && decorator.args.length > 0) {\n    const args = decorator.args.map(arg => {\n      return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(arg) : arg;\n    });\n    properties.push(ts9.factory.createPropertyAssignment(\"args\", ts9.factory.createArrayLiteralExpression(args)));\n  }\n  return ts9.factory.createObjectLiteralExpression(properties, true);\n}\nfunction isAngularDecorator2(decorator, isCore) {\n  return isCore || decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\nfunction removeIdentifierReferences(node, name) {\n  const result = ts9.transform(node, [context => root => ts9.visitNode(root, function walk(current) {\n    return ts9.isIdentifier(current) && current.text === name ? ts9.factory.createIdentifier(current.text) : ts9.visitEachChild(current, walk, context);\n  })]);\n  return result.transformed[0];\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/references_registry.mjs\nvar NoopReferencesRegistry = class {\n  add(source, ...references) {}\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/schema.mjs\nimport { CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA } from \"@angular/compiler\";\nfunction extractSchemas(rawExpr, evaluator, context) {\n  const schemas = [];\n  const result = evaluator.evaluate(rawExpr);\n  if (!Array.isArray(result)) {\n    throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array`);\n  }\n  for (const schemaRef of result) {\n    if (!(schemaRef instanceof Reference)) {\n      throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array of schemas`);\n    }\n    const id = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());\n    if (id === null || schemaRef.ownedByModuleGuess !== \"@angular/core\") {\n      throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array of schemas`);\n    }\n    switch (id.text) {\n      case \"CUSTOM_ELEMENTS_SCHEMA\":\n        schemas.push(CUSTOM_ELEMENTS_SCHEMA);\n        break;\n      case \"NO_ERRORS_SCHEMA\":\n        schemas.push(NO_ERRORS_SCHEMA);\n        break;\n      default:\n        throw createValueHasWrongTypeError(rawExpr, schemaRef, `'${schemaRef.debugName}' is not a valid ${context} schema`);\n    }\n  }\n  return schemas;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/input_transforms.mjs\nimport { outputAst } from \"@angular/compiler\";\nfunction compileInputTransformFields(inputs) {\n  const extraFields = [];\n  for (const input of inputs) {\n    if (input.transform) {\n      extraFields.push({\n        name: `ngAcceptInputType_${input.classPropertyName}`,\n        type: outputAst.transplantedType(input.transform.type),\n        statements: [],\n        initializer: null\n      });\n    }\n  }\n  return extraFields;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/handler.mjs\nimport { compileClassMetadata as compileClassMetadata3, compileComponentFromMetadata, compileDeclareClassMetadata as compileDeclareClassMetadata3, compileDeclareComponentFromMetadata, CssSelector as CssSelector2, DEFAULT_INTERPOLATION_CONFIG as DEFAULT_INTERPOLATION_CONFIG2, DomElementSchemaRegistry, FactoryTarget as FactoryTarget3, makeBindingParser as makeBindingParser2, R3TargetBinder, R3TemplateDependencyKind, SelectorMatcher as SelectorMatcher2, ViewEncapsulation, WrappedNodeExpr as WrappedNodeExpr7 } from \"@angular/compiler\";\nimport ts24 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api.mjs\nimport ts10 from \"typescript\";\nvar SemanticSymbol = class {\n  constructor(decl) {\n    this.decl = decl;\n    this.path = absoluteFromSourceFile(decl.getSourceFile());\n    this.identifier = getSymbolIdentifier(decl);\n  }\n};\nfunction getSymbolIdentifier(decl) {\n  if (!ts10.isSourceFile(decl.parent)) {\n    return null;\n  }\n  return decl.name.text;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/graph.mjs\nimport { ExternalExpr as ExternalExpr2 } from \"@angular/compiler\";\nvar OpaqueSymbol = class extends SemanticSymbol {\n  isPublicApiAffected() {\n    return false;\n  }\n  isTypeCheckApiAffected() {\n    return false;\n  }\n};\nvar SemanticDepGraph = class {\n  constructor() {\n    this.files = /* @__PURE__ */new Map();\n    this.symbolByDecl = /* @__PURE__ */new Map();\n  }\n  registerSymbol(symbol) {\n    this.symbolByDecl.set(symbol.decl, symbol);\n    if (symbol.identifier !== null) {\n      if (!this.files.has(symbol.path)) {\n        this.files.set(symbol.path, /* @__PURE__ */new Map());\n      }\n      this.files.get(symbol.path).set(symbol.identifier, symbol);\n    }\n  }\n  getEquivalentSymbol(symbol) {\n    let previousSymbol = this.getSymbolByDecl(symbol.decl);\n    if (previousSymbol === null && symbol.identifier !== null) {\n      previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);\n    }\n    return previousSymbol;\n  }\n  getSymbolByName(path, identifier) {\n    if (!this.files.has(path)) {\n      return null;\n    }\n    const file = this.files.get(path);\n    if (!file.has(identifier)) {\n      return null;\n    }\n    return file.get(identifier);\n  }\n  getSymbolByDecl(decl) {\n    if (!this.symbolByDecl.has(decl)) {\n      return null;\n    }\n    return this.symbolByDecl.get(decl);\n  }\n};\nvar SemanticDepGraphUpdater = class {\n  constructor(priorGraph) {\n    this.priorGraph = priorGraph;\n    this.newGraph = new SemanticDepGraph();\n    this.opaqueSymbols = /* @__PURE__ */new Map();\n  }\n  registerSymbol(symbol) {\n    this.newGraph.registerSymbol(symbol);\n  }\n  finalize() {\n    if (this.priorGraph === null) {\n      return {\n        needsEmit: /* @__PURE__ */new Set(),\n        needsTypeCheckEmit: /* @__PURE__ */new Set(),\n        newGraph: this.newGraph\n      };\n    }\n    const needsEmit = this.determineInvalidatedFiles(this.priorGraph);\n    const needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);\n    return {\n      needsEmit,\n      needsTypeCheckEmit,\n      newGraph: this.newGraph\n    };\n  }\n  determineInvalidatedFiles(priorGraph) {\n    const isPublicApiAffected = /* @__PURE__ */new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {\n        isPublicApiAffected.add(symbol);\n      }\n    }\n    const needsEmit = /* @__PURE__ */new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isEmitAffected === void 0) {\n        continue;\n      }\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {\n        needsEmit.add(symbol.path);\n      }\n    }\n    return needsEmit;\n  }\n  determineInvalidatedTypeCheckFiles(priorGraph) {\n    const isTypeCheckApiAffected = /* @__PURE__ */new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {\n        isTypeCheckApiAffected.add(symbol);\n      }\n    }\n    const needsTypeCheckEmit = /* @__PURE__ */new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isTypeCheckBlockAffected === void 0) {\n        continue;\n      }\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {\n        needsTypeCheckEmit.add(symbol.path);\n      }\n    }\n    return needsTypeCheckEmit;\n  }\n  getSemanticReference(decl, expr) {\n    return {\n      symbol: this.getSymbol(decl),\n      importPath: getImportPath(expr)\n    };\n  }\n  getSymbol(decl) {\n    const symbol = this.newGraph.getSymbolByDecl(decl);\n    if (symbol === null) {\n      return this.getOpaqueSymbol(decl);\n    }\n    return symbol;\n  }\n  getOpaqueSymbol(decl) {\n    if (this.opaqueSymbols.has(decl)) {\n      return this.opaqueSymbols.get(decl);\n    }\n    const symbol = new OpaqueSymbol(decl);\n    this.opaqueSymbols.set(decl, symbol);\n    return symbol;\n  }\n};\nfunction getImportPath(expr) {\n  if (expr instanceof ExternalExpr2) {\n    return `${expr.value.moduleName}$${expr.value.name}`;\n  } else {\n    return null;\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.mjs\nimport ts11 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util.mjs\nfunction isSymbolEqual(a, b) {\n  if (a.decl === b.decl) {\n    return true;\n  }\n  if (a.identifier === null || b.identifier === null) {\n    return false;\n  }\n  return a.path === b.path && a.identifier === b.identifier;\n}\nfunction isReferenceEqual(a, b) {\n  if (!isSymbolEqual(a.symbol, b.symbol)) {\n    return false;\n  }\n  return a.importPath === b.importPath;\n}\nfunction referenceEquality(a, b) {\n  return a === b;\n}\nfunction isArrayEqual(a, b, equalityTester = referenceEquality) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  return !a.some((item, index) => !equalityTester(item, b[index]));\n}\nfunction isSetEqual(a, b, equalityTester = referenceEquality) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const itemA of a) {\n    let found = false;\n    for (const itemB of b) {\n      if (equalityTester(itemA, itemB)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.mjs\nfunction extractSemanticTypeParameters(node) {\n  if (!ts11.isClassDeclaration(node) || node.typeParameters === void 0) {\n    return null;\n  }\n  return node.typeParameters.map(typeParam => ({\n    hasGenericTypeBound: typeParam.constraint !== void 0\n  }));\n}\nfunction areTypeParametersEqual(current, previous) {\n  if (!isArrayEqual(current, previous, isTypeParameterEqual)) {\n    return false;\n  }\n  if (current !== null && current.some(typeParam => typeParam.hasGenericTypeBound)) {\n    return false;\n  }\n  return true;\n}\nfunction isTypeParameterEqual(a, b) {\n  return a.hasGenericTypeBound === b.hasGenericTypeBound;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/api.mjs\nvar ComponentScopeKind;\n(function (ComponentScopeKind2) {\n  ComponentScopeKind2[ComponentScopeKind2[\"NgModule\"] = 0] = \"NgModule\";\n  ComponentScopeKind2[ComponentScopeKind2[\"Standalone\"] = 1] = \"Standalone\";\n})(ComponentScopeKind || (ComponentScopeKind = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/component_scope.mjs\nvar CompoundComponentScopeReader = class {\n  constructor(readers) {\n    this.readers = readers;\n  }\n  getScopeForComponent(clazz) {\n    for (const reader of this.readers) {\n      const meta = reader.getScopeForComponent(clazz);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getRemoteScope(clazz) {\n    for (const reader of this.readers) {\n      const remoteScope = reader.getRemoteScope(clazz);\n      if (remoteScope !== null) {\n        return remoteScope;\n      }\n    }\n    return null;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/dependency.mjs\nvar MetadataDtsModuleScopeResolver = class {\n  constructor(dtsMetaReader, aliasingHost) {\n    this.dtsMetaReader = dtsMetaReader;\n    this.aliasingHost = aliasingHost;\n    this.cache = /* @__PURE__ */new Map();\n  }\n  resolve(ref) {\n    const clazz = ref.node;\n    const sourceFile = clazz.getSourceFile();\n    if (!sourceFile.isDeclarationFile) {\n      throw new Error(`Debug error: DtsModuleScopeResolver.read(${ref.debugName} from ${sourceFile.fileName}), but not a .d.ts file`);\n    }\n    if (this.cache.has(clazz)) {\n      return this.cache.get(clazz);\n    }\n    const dependencies = [];\n    const meta = this.dtsMetaReader.getNgModuleMetadata(ref);\n    if (meta === null) {\n      this.cache.set(clazz, null);\n      return null;\n    }\n    const declarations = /* @__PURE__ */new Set();\n    for (const declRef of meta.declarations) {\n      declarations.add(declRef.node);\n    }\n    for (const exportRef of meta.exports) {\n      const directive = this.dtsMetaReader.getDirectiveMetadata(exportRef);\n      if (directive !== null) {\n        const isReExport = !declarations.has(exportRef.node);\n        dependencies.push(this.maybeAlias(directive, sourceFile, isReExport));\n        continue;\n      }\n      const pipe = this.dtsMetaReader.getPipeMetadata(exportRef);\n      if (pipe !== null) {\n        const isReExport = !declarations.has(exportRef.node);\n        dependencies.push(this.maybeAlias(pipe, sourceFile, isReExport));\n        continue;\n      }\n      const exportScope2 = this.resolve(exportRef);\n      if (exportScope2 !== null) {\n        if (this.aliasingHost === null) {\n          dependencies.push(...exportScope2.exported.dependencies);\n        } else {\n          for (const dep of exportScope2.exported.dependencies) {\n            dependencies.push(this.maybeAlias(dep, sourceFile, true));\n          }\n        }\n      }\n      continue;\n    }\n    const exportScope = {\n      exported: {\n        dependencies,\n        isPoisoned: false\n      }\n    };\n    this.cache.set(clazz, exportScope);\n    return exportScope;\n  }\n  maybeAlias(dirOrPipe, maybeAliasFrom, isReExport) {\n    const ref = dirOrPipe.ref;\n    if (this.aliasingHost === null || ref.node.getSourceFile() === maybeAliasFrom) {\n      return dirOrPipe;\n    }\n    const alias = this.aliasingHost.getAliasIn(ref.node, maybeAliasFrom, isReExport);\n    if (alias === null) {\n      return dirOrPipe;\n    }\n    return {\n      ...dirOrPipe,\n      ref: ref.cloneWithAlias(alias)\n    };\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/local.mjs\nimport { ExternalExpr as ExternalExpr3 } from \"@angular/compiler\";\nimport ts12 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/util.mjs\nfunction getDiagnosticNode(ref, rawExpr) {\n  return rawExpr !== null ? ref.getOriginForDiagnostics(rawExpr) : ref.node.name;\n}\nfunction makeNotStandaloneDiagnostic(scopeReader, ref, rawExpr, kind) {\n  const scope = scopeReader.getScopeForComponent(ref.node);\n  let message = `The ${kind} '${ref.node.name.text}' appears in 'imports', but is not standalone and cannot be imported directly.`;\n  let relatedInformation = void 0;\n  if (scope !== null && scope.kind === ComponentScopeKind.NgModule) {\n    const isExported = scope.exported.dependencies.some(dep => dep.ref.node === ref.node);\n    const relatedInfoMessageText = isExported ? `It can be imported using its '${scope.ngModule.name.text}' NgModule instead.` : `It's declared in the '${scope.ngModule.name.text}' NgModule, but is not exported. Consider exporting it and importing the NgModule instead.`;\n    relatedInformation = [makeRelatedInformation(scope.ngModule.name, relatedInfoMessageText)];\n  } else {}\n  if (relatedInformation === void 0) {\n    message += \" It must be imported via an NgModule.\";\n  }\n  return makeDiagnostic(ErrorCode.COMPONENT_IMPORT_NOT_STANDALONE, getDiagnosticNode(ref, rawExpr), message, relatedInformation);\n}\nfunction makeUnknownComponentImportDiagnostic(ref, rawExpr) {\n  return makeDiagnostic(ErrorCode.COMPONENT_UNKNOWN_IMPORT, getDiagnosticNode(ref, rawExpr), `Component imports must be standalone components, directives, pipes, or must be NgModules.`);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/local.mjs\nvar LocalModuleScopeRegistry = class {\n  constructor(localReader, fullReader, dependencyScopeReader, refEmitter, aliasingHost) {\n    this.localReader = localReader;\n    this.fullReader = fullReader;\n    this.dependencyScopeReader = dependencyScopeReader;\n    this.refEmitter = refEmitter;\n    this.aliasingHost = aliasingHost;\n    this.sealed = false;\n    this.declarationToModule = /* @__PURE__ */new Map();\n    this.duplicateDeclarations = /* @__PURE__ */new Map();\n    this.moduleToRef = /* @__PURE__ */new Map();\n    this.cache = /* @__PURE__ */new Map();\n    this.remoteScoping = /* @__PURE__ */new Map();\n    this.scopeErrors = /* @__PURE__ */new Map();\n    this.modulesWithStructuralErrors = /* @__PURE__ */new Set();\n  }\n  registerNgModuleMetadata(data) {\n    this.assertCollecting();\n    const ngModule = data.ref.node;\n    this.moduleToRef.set(data.ref.node, data.ref);\n    for (const decl of data.declarations) {\n      this.registerDeclarationOfModule(ngModule, decl, data.rawDeclarations);\n    }\n  }\n  registerDirectiveMetadata(directive) {}\n  registerPipeMetadata(pipe) {}\n  getScopeForComponent(clazz) {\n    const scope = !this.declarationToModule.has(clazz) ? null : this.getScopeOfModule(this.declarationToModule.get(clazz).ngModule);\n    return scope;\n  }\n  getDuplicateDeclarations(node) {\n    if (!this.duplicateDeclarations.has(node)) {\n      return null;\n    }\n    return Array.from(this.duplicateDeclarations.get(node).values());\n  }\n  getScopeOfModule(clazz) {\n    return this.moduleToRef.has(clazz) ? this.getScopeOfModuleReference(this.moduleToRef.get(clazz)) : null;\n  }\n  getDiagnosticsOfModule(clazz) {\n    this.getScopeOfModule(clazz);\n    if (this.scopeErrors.has(clazz)) {\n      return this.scopeErrors.get(clazz);\n    } else {\n      return null;\n    }\n  }\n  registerDeclarationOfModule(ngModule, decl, rawDeclarations) {\n    const declData = {\n      ngModule,\n      ref: decl,\n      rawDeclarations\n    };\n    if (this.duplicateDeclarations.has(decl.node)) {\n      this.duplicateDeclarations.get(decl.node).set(ngModule, declData);\n    } else if (this.declarationToModule.has(decl.node) && this.declarationToModule.get(decl.node).ngModule !== ngModule) {\n      const duplicateDeclMap = /* @__PURE__ */new Map();\n      const firstDeclData = this.declarationToModule.get(decl.node);\n      this.modulesWithStructuralErrors.add(firstDeclData.ngModule);\n      this.modulesWithStructuralErrors.add(ngModule);\n      duplicateDeclMap.set(firstDeclData.ngModule, firstDeclData);\n      duplicateDeclMap.set(ngModule, declData);\n      this.duplicateDeclarations.set(decl.node, duplicateDeclMap);\n      this.declarationToModule.delete(decl.node);\n    } else {\n      this.declarationToModule.set(decl.node, declData);\n    }\n  }\n  getScopeOfModuleReference(ref) {\n    if (this.cache.has(ref.node)) {\n      return this.cache.get(ref.node);\n    }\n    this.sealed = true;\n    const ngModule = this.localReader.getNgModuleMetadata(ref);\n    if (ngModule === null) {\n      this.cache.set(ref.node, null);\n      return null;\n    }\n    const diagnostics = [];\n    const compilationDirectives = /* @__PURE__ */new Map();\n    const compilationPipes = /* @__PURE__ */new Map();\n    const declared = /* @__PURE__ */new Set();\n    const exportDirectives = /* @__PURE__ */new Map();\n    const exportPipes = /* @__PURE__ */new Map();\n    let isPoisoned = false;\n    if (this.modulesWithStructuralErrors.has(ngModule.ref.node)) {\n      isPoisoned = true;\n    }\n    for (const decl of ngModule.imports) {\n      const importScope = this.getExportedScope(decl, diagnostics, ref.node, \"import\");\n      if (importScope !== null) {\n        if (importScope === \"invalid\" || importScope.exported.isPoisoned) {\n          diagnostics.push(invalidTransitiveNgModuleRef(decl, ngModule.rawImports, \"import\"));\n          isPoisoned = true;\n          if (importScope === \"invalid\") {\n            continue;\n          }\n        }\n        for (const dep of importScope.exported.dependencies) {\n          if (dep.kind === MetaKind.Directive) {\n            compilationDirectives.set(dep.ref.node, dep);\n          } else if (dep.kind === MetaKind.Pipe) {\n            compilationPipes.set(dep.ref.node, dep);\n          }\n        }\n        continue;\n      }\n      const directive = this.fullReader.getDirectiveMetadata(decl);\n      if (directive !== null) {\n        if (directive.isStandalone) {\n          compilationDirectives.set(directive.ref.node, directive);\n        } else {\n          diagnostics.push(makeNotStandaloneDiagnostic(this, decl, ngModule.rawImports, directive.isComponent ? \"component\" : \"directive\"));\n          isPoisoned = true;\n        }\n        continue;\n      }\n      const pipe = this.fullReader.getPipeMetadata(decl);\n      if (pipe !== null) {\n        if (pipe.isStandalone) {\n          compilationPipes.set(pipe.ref.node, pipe);\n        } else {\n          diagnostics.push(makeNotStandaloneDiagnostic(this, decl, ngModule.rawImports, \"pipe\"));\n          isPoisoned = true;\n        }\n        continue;\n      }\n      diagnostics.push(invalidRef(decl, ngModule.rawImports, \"import\"));\n      isPoisoned = true;\n    }\n    for (const decl of ngModule.declarations) {\n      const directive = this.localReader.getDirectiveMetadata(decl);\n      const pipe = this.localReader.getPipeMetadata(decl);\n      if (directive !== null) {\n        if (directive.isStandalone) {\n          const refType = directive.isComponent ? \"Component\" : \"Directive\";\n          diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_IS_STANDALONE, decl.getOriginForDiagnostics(ngModule.rawDeclarations), `${refType} ${decl.node.name.text} is standalone, and cannot be declared in an NgModule. Did you mean to import it instead?`));\n          isPoisoned = true;\n          continue;\n        }\n        compilationDirectives.set(decl.node, {\n          ...directive,\n          ref: decl\n        });\n        if (directive.isPoisoned) {\n          isPoisoned = true;\n        }\n      } else if (pipe !== null) {\n        if (pipe.isStandalone) {\n          diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_IS_STANDALONE, decl.getOriginForDiagnostics(ngModule.rawDeclarations), `Pipe ${decl.node.name.text} is standalone, and cannot be declared in an NgModule. Did you mean to import it instead?`));\n          isPoisoned = true;\n          continue;\n        }\n        compilationPipes.set(decl.node, {\n          ...pipe,\n          ref: decl\n        });\n      } else {\n        const errorNode = decl.getOriginForDiagnostics(ngModule.rawDeclarations);\n        diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `The class '${decl.node.name.text}' is listed in the declarations of the NgModule '${ngModule.ref.node.name.text}', but is not a directive, a component, or a pipe. Either remove it from the NgModule's declarations, or add an appropriate Angular decorator.`, [makeRelatedInformation(decl.node.name, `'${decl.node.name.text}' is declared here.`)]));\n        isPoisoned = true;\n        continue;\n      }\n      declared.add(decl.node);\n    }\n    for (const decl of ngModule.exports) {\n      const exportScope = this.getExportedScope(decl, diagnostics, ref.node, \"export\");\n      if (exportScope === \"invalid\" || exportScope !== null && exportScope.exported.isPoisoned) {\n        diagnostics.push(invalidTransitiveNgModuleRef(decl, ngModule.rawExports, \"export\"));\n        isPoisoned = true;\n        if (exportScope === \"invalid\") {\n          continue;\n        }\n      } else if (exportScope !== null) {\n        for (const dep of exportScope.exported.dependencies) {\n          if (dep.kind == MetaKind.Directive) {\n            exportDirectives.set(dep.ref.node, dep);\n          } else if (dep.kind === MetaKind.Pipe) {\n            exportPipes.set(dep.ref.node, dep);\n          }\n        }\n      } else if (compilationDirectives.has(decl.node)) {\n        const directive = compilationDirectives.get(decl.node);\n        exportDirectives.set(decl.node, directive);\n      } else if (compilationPipes.has(decl.node)) {\n        const pipe = compilationPipes.get(decl.node);\n        exportPipes.set(decl.node, pipe);\n      } else {\n        const dirMeta = this.fullReader.getDirectiveMetadata(decl);\n        const pipeMeta = this.fullReader.getPipeMetadata(decl);\n        if (dirMeta !== null || pipeMeta !== null) {\n          const isStandalone = dirMeta !== null ? dirMeta.isStandalone : pipeMeta.isStandalone;\n          diagnostics.push(invalidReexport(decl, ngModule.rawExports, isStandalone));\n        } else {\n          diagnostics.push(invalidRef(decl, ngModule.rawExports, \"export\"));\n        }\n        isPoisoned = true;\n        continue;\n      }\n    }\n    const exported = {\n      dependencies: [...exportDirectives.values(), ...exportPipes.values()],\n      isPoisoned\n    };\n    const reexports = this.getReexports(ngModule, ref, declared, exported.dependencies, diagnostics);\n    const scope = {\n      kind: ComponentScopeKind.NgModule,\n      ngModule: ngModule.ref.node,\n      compilation: {\n        dependencies: [...compilationDirectives.values(), ...compilationPipes.values()],\n        isPoisoned\n      },\n      exported,\n      reexports,\n      schemas: ngModule.schemas\n    };\n    if (diagnostics.length > 0) {\n      this.scopeErrors.set(ref.node, diagnostics);\n      this.modulesWithStructuralErrors.add(ref.node);\n    }\n    this.cache.set(ref.node, scope);\n    return scope;\n  }\n  getRemoteScope(node) {\n    return this.remoteScoping.has(node) ? this.remoteScoping.get(node) : null;\n  }\n  setComponentRemoteScope(node, directives, pipes) {\n    this.remoteScoping.set(node, {\n      directives,\n      pipes\n    });\n  }\n  getExportedScope(ref, diagnostics, ownerForErrors, type) {\n    if (ref.node.getSourceFile().isDeclarationFile) {\n      if (!ts12.isClassDeclaration(ref.node)) {\n        const code = type === \"import\" ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;\n        diagnostics.push(makeDiagnostic(code, identifierOfNode(ref.node) || ref.node, `Appears in the NgModule.${type}s of ${nodeNameForError(ownerForErrors)}, but could not be resolved to an NgModule`));\n        return \"invalid\";\n      }\n      return this.dependencyScopeReader.resolve(ref);\n    } else {\n      return this.getScopeOfModuleReference(ref);\n    }\n  }\n  getReexports(ngModule, ref, declared, exported, diagnostics) {\n    let reexports = null;\n    const sourceFile = ref.node.getSourceFile();\n    if (this.aliasingHost === null) {\n      return null;\n    }\n    reexports = [];\n    const reexportMap = /* @__PURE__ */new Map();\n    const ngModuleRef = ref;\n    const addReexport = exportRef => {\n      if (exportRef.node.getSourceFile() === sourceFile) {\n        return;\n      }\n      const isReExport = !declared.has(exportRef.node);\n      const exportName = this.aliasingHost.maybeAliasSymbolAs(exportRef, sourceFile, ngModule.ref.node.name.text, isReExport);\n      if (exportName === null) {\n        return;\n      }\n      if (!reexportMap.has(exportName)) {\n        if (exportRef.alias && exportRef.alias instanceof ExternalExpr3) {\n          reexports.push({\n            fromModule: exportRef.alias.value.moduleName,\n            symbolName: exportRef.alias.value.name,\n            asAlias: exportName\n          });\n        } else {\n          const emittedRef = this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile);\n          assertSuccessfulReferenceEmit(emittedRef, ngModuleRef.node.name, \"class\");\n          const expr = emittedRef.expression;\n          if (!(expr instanceof ExternalExpr3) || expr.value.moduleName === null || expr.value.name === null) {\n            throw new Error(\"Expected ExternalExpr\");\n          }\n          reexports.push({\n            fromModule: expr.value.moduleName,\n            symbolName: expr.value.name,\n            asAlias: exportName\n          });\n        }\n        reexportMap.set(exportName, exportRef);\n      } else {\n        const prevRef = reexportMap.get(exportName);\n        diagnostics.push(reexportCollision(ngModuleRef.node, prevRef, exportRef));\n      }\n    };\n    for (const {\n      ref: ref2\n    } of exported) {\n      addReexport(ref2);\n    }\n    return reexports;\n  }\n  assertCollecting() {\n    if (this.sealed) {\n      throw new Error(`Assertion: LocalModuleScopeRegistry is not COLLECTING`);\n    }\n  }\n};\nfunction invalidRef(decl, rawExpr, type) {\n  const code = type === \"import\" ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;\n  const resolveTarget = type === \"import\" ? \"NgModule\" : \"NgModule, Component, Directive, or Pipe\";\n  const message = `'${decl.node.name.text}' does not appear to be an ${resolveTarget} class.`;\n  const library = decl.ownedByModuleGuess !== null ? ` (${decl.ownedByModuleGuess})` : \"\";\n  const sf = decl.node.getSourceFile();\n  let relatedMessage;\n  if (!sf.isDeclarationFile) {\n    const annotationType = type === \"import\" ? \"@NgModule\" : \"Angular\";\n    relatedMessage = `Is it missing an ${annotationType} annotation?`;\n  } else if (sf.fileName.indexOf(\"node_modules\") !== -1) {\n    relatedMessage = `This likely means that the library${library} which declares ${decl.debugName} is not compatible with Angular Ivy. Check if a newer version of the library is available, and update if so. Also consider checking with the library's authors to see if the library is expected to be compatible with Ivy.`;\n  } else {\n    relatedMessage = `This likely means that the dependency${library} which declares ${decl.debugName} is not compatible with Angular Ivy.`;\n  }\n  return makeDiagnostic(code, getDiagnosticNode(decl, rawExpr), message, [makeRelatedInformation(decl.node.name, relatedMessage)]);\n}\nfunction invalidTransitiveNgModuleRef(decl, rawExpr, type) {\n  const code = type === \"import\" ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;\n  return makeDiagnostic(code, getDiagnosticNode(decl, rawExpr), `This ${type} contains errors, which may affect components that depend on this NgModule.`);\n}\nfunction invalidReexport(decl, rawExpr, isStandalone) {\n  let message = `Can't be exported from this NgModule, as `;\n  if (isStandalone) {\n    message += \"it must be imported first\";\n  } else if (decl.node.getSourceFile().isDeclarationFile) {\n    message += \"it must be imported via its NgModule first\";\n  } else {\n    message += \"it must be either declared by this NgModule, or imported here via its NgModule first\";\n  }\n  return makeDiagnostic(ErrorCode.NGMODULE_INVALID_REEXPORT, getDiagnosticNode(decl, rawExpr), message);\n}\nfunction reexportCollision(module, refA, refB) {\n  const childMessageText = `This directive/pipe is part of the exports of '${module.name.text}' and shares the same name as another exported directive/pipe.`;\n  return makeDiagnostic(ErrorCode.NGMODULE_REEXPORT_NAME_COLLISION, module.name, `\n    There was a name collision between two classes named '${refA.node.name.text}', which are both part of the exports of '${module.name.text}'.\n\n    Angular generates re-exports of an NgModule's exported directives/pipes from the module's source file in certain cases, using the declared name of the class. If two classes of the same name are exported, this automatic naming does not work.\n\n    To fix this problem please re-export one or both classes directly from this file.\n  `.trim(), [makeRelatedInformation(refA.node.name, childMessageText), makeRelatedInformation(refB.node.name, childMessageText)]);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/typecheck.mjs\nimport { CssSelector, SelectorMatcher } from \"@angular/compiler\";\nimport ts13 from \"typescript\";\nvar TypeCheckScopeRegistry = class {\n  constructor(scopeReader, metaReader, hostDirectivesResolver) {\n    this.scopeReader = scopeReader;\n    this.metaReader = metaReader;\n    this.hostDirectivesResolver = hostDirectivesResolver;\n    this.flattenedDirectiveMetaCache = /* @__PURE__ */new Map();\n    this.scopeCache = /* @__PURE__ */new Map();\n  }\n  getTypeCheckScope(node) {\n    const matcher = new SelectorMatcher();\n    const directives = [];\n    const pipes = /* @__PURE__ */new Map();\n    const scope = this.scopeReader.getScopeForComponent(node);\n    if (scope === null) {\n      return {\n        matcher,\n        directives,\n        pipes,\n        schemas: [],\n        isPoisoned: false\n      };\n    }\n    const cacheKey = scope.kind === ComponentScopeKind.NgModule ? scope.ngModule : scope.component;\n    const dependencies = scope.kind === ComponentScopeKind.NgModule ? scope.compilation.dependencies : scope.dependencies;\n    if (this.scopeCache.has(cacheKey)) {\n      return this.scopeCache.get(cacheKey);\n    }\n    for (const meta of dependencies) {\n      if (meta.kind === MetaKind.Directive && meta.selector !== null) {\n        const extMeta = this.getTypeCheckDirectiveMetadata(meta.ref);\n        if (extMeta === null) {\n          continue;\n        }\n        matcher.addSelectables(CssSelector.parse(meta.selector), [...this.hostDirectivesResolver.resolve(extMeta), extMeta]);\n        directives.push(extMeta);\n      } else if (meta.kind === MetaKind.Pipe) {\n        if (!ts13.isClassDeclaration(meta.ref.node)) {\n          throw new Error(`Unexpected non-class declaration ${ts13.SyntaxKind[meta.ref.node.kind]} for pipe ${meta.ref.debugName}`);\n        }\n        pipes.set(meta.name, meta.ref);\n      }\n    }\n    const typeCheckScope = {\n      matcher,\n      directives,\n      pipes,\n      schemas: scope.schemas,\n      isPoisoned: scope.kind === ComponentScopeKind.NgModule ? scope.compilation.isPoisoned || scope.exported.isPoisoned : scope.isPoisoned\n    };\n    this.scopeCache.set(cacheKey, typeCheckScope);\n    return typeCheckScope;\n  }\n  getTypeCheckDirectiveMetadata(ref) {\n    const clazz = ref.node;\n    if (this.flattenedDirectiveMetaCache.has(clazz)) {\n      return this.flattenedDirectiveMetaCache.get(clazz);\n    }\n    const meta = flattenInheritedDirectiveMetadata(this.metaReader, ref);\n    if (meta === null) {\n      return null;\n    }\n    this.flattenedDirectiveMetaCache.set(clazz, meta);\n    return meta;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/api.mjs\nvar CompilationMode;\n(function (CompilationMode2) {\n  CompilationMode2[CompilationMode2[\"FULL\"] = 0] = \"FULL\";\n  CompilationMode2[CompilationMode2[\"PARTIAL\"] = 1] = \"PARTIAL\";\n  CompilationMode2[CompilationMode2[\"LOCAL\"] = 2] = \"LOCAL\";\n})(CompilationMode || (CompilationMode = {}));\nvar HandlerPrecedence;\n(function (HandlerPrecedence2) {\n  HandlerPrecedence2[HandlerPrecedence2[\"PRIMARY\"] = 0] = \"PRIMARY\";\n  HandlerPrecedence2[HandlerPrecedence2[\"SHARED\"] = 1] = \"SHARED\";\n  HandlerPrecedence2[HandlerPrecedence2[\"WEAK\"] = 2] = \"WEAK\";\n})(HandlerPrecedence || (HandlerPrecedence = {}));\nvar HandlerFlags;\n(function (HandlerFlags2) {\n  HandlerFlags2[HandlerFlags2[\"NONE\"] = 0] = \"NONE\";\n  HandlerFlags2[HandlerFlags2[\"FULL_INHERITANCE\"] = 1] = \"FULL_INHERITANCE\";\n})(HandlerFlags || (HandlerFlags = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/alias.mjs\nimport ts14 from \"typescript\";\nfunction aliasTransformFactory(exportStatements) {\n  return () => {\n    return file => {\n      if (ts14.isBundle(file) || !exportStatements.has(file.fileName)) {\n        return file;\n      }\n      const statements = [...file.statements];\n      exportStatements.get(file.fileName).forEach(([moduleName, symbolName], aliasName) => {\n        const stmt = ts14.factory.createExportDeclaration(void 0, false, ts14.factory.createNamedExports([ts14.factory.createExportSpecifier(false, symbolName, aliasName)]), ts14.factory.createStringLiteral(moduleName));\n        statements.push(stmt);\n      });\n      return ts14.factory.updateSourceFile(file, statements);\n    };\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/compilation.mjs\nimport ts15 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/trait.mjs\nvar TraitState;\n(function (TraitState2) {\n  TraitState2[TraitState2[\"Pending\"] = 0] = \"Pending\";\n  TraitState2[TraitState2[\"Analyzed\"] = 1] = \"Analyzed\";\n  TraitState2[TraitState2[\"Resolved\"] = 2] = \"Resolved\";\n  TraitState2[TraitState2[\"Skipped\"] = 3] = \"Skipped\";\n})(TraitState || (TraitState = {}));\nvar Trait = {\n  pending: (handler, detected) => TraitImpl.pending(handler, detected)\n};\nvar TraitImpl = class {\n  constructor(handler, detected) {\n    this.state = TraitState.Pending;\n    this.analysis = null;\n    this.symbol = null;\n    this.resolution = null;\n    this.analysisDiagnostics = null;\n    this.resolveDiagnostics = null;\n    this.typeCheckDiagnostics = null;\n    this.handler = handler;\n    this.detected = detected;\n  }\n  toAnalyzed(analysis, diagnostics, symbol) {\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);\n    this.analysis = analysis;\n    this.analysisDiagnostics = diagnostics;\n    this.symbol = symbol;\n    this.state = TraitState.Analyzed;\n    return this;\n  }\n  toResolved(resolution, diagnostics) {\n    this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);\n    if (this.analysis === null) {\n      throw new Error(`Cannot transition an Analyzed trait with a null analysis to Resolved`);\n    }\n    this.resolution = resolution;\n    this.state = TraitState.Resolved;\n    this.resolveDiagnostics = diagnostics;\n    this.typeCheckDiagnostics = null;\n    return this;\n  }\n  toSkipped() {\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);\n    this.state = TraitState.Skipped;\n    return this;\n  }\n  assertTransitionLegal(allowedState, transitionTo) {\n    if (!(this.state === allowedState)) {\n      throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${TraitState[transitionTo]}.`);\n    }\n  }\n  static pending(handler, detected) {\n    return new TraitImpl(handler, detected);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/compilation.mjs\nvar TraitCompiler = class {\n  constructor(handlers, reflector, perf, incrementalBuild, compileNonExportedClasses, compilationMode, dtsTransforms, semanticDepGraphUpdater, sourceFileTypeIdentifier) {\n    this.handlers = handlers;\n    this.reflector = reflector;\n    this.perf = perf;\n    this.incrementalBuild = incrementalBuild;\n    this.compileNonExportedClasses = compileNonExportedClasses;\n    this.compilationMode = compilationMode;\n    this.dtsTransforms = dtsTransforms;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.sourceFileTypeIdentifier = sourceFileTypeIdentifier;\n    this.classes = /* @__PURE__ */new Map();\n    this.fileToClasses = /* @__PURE__ */new Map();\n    this.filesWithoutTraits = /* @__PURE__ */new Set();\n    this.reexportMap = /* @__PURE__ */new Map();\n    this.handlersByName = /* @__PURE__ */new Map();\n    for (const handler of handlers) {\n      this.handlersByName.set(handler.name, handler);\n    }\n  }\n  analyzeSync(sf) {\n    this.analyze(sf, false);\n  }\n  analyzeAsync(sf) {\n    return this.analyze(sf, true);\n  }\n  analyze(sf, preanalyze) {\n    if (sf.isDeclarationFile || this.sourceFileTypeIdentifier.isShim(sf) || this.sourceFileTypeIdentifier.isResource(sf)) {\n      return void 0;\n    }\n    const promises = [];\n    const priorWork = this.incrementalBuild.priorAnalysisFor(sf);\n    if (priorWork !== null) {\n      this.perf.eventCount(PerfEvent.SourceFileReuseAnalysis);\n      if (priorWork.length > 0) {\n        for (const priorRecord of priorWork) {\n          this.adopt(priorRecord);\n        }\n        this.perf.eventCount(PerfEvent.TraitReuseAnalysis, priorWork.length);\n      } else {\n        this.filesWithoutTraits.add(sf);\n      }\n      return;\n    }\n    const visit2 = node => {\n      if (this.reflector.isClass(node)) {\n        this.analyzeClass(node, preanalyze ? promises : null);\n      }\n      ts15.forEachChild(node, visit2);\n    };\n    visit2(sf);\n    if (!this.fileToClasses.has(sf)) {\n      this.filesWithoutTraits.add(sf);\n    }\n    if (preanalyze && promises.length > 0) {\n      return Promise.all(promises).then(() => void 0);\n    } else {\n      return void 0;\n    }\n  }\n  recordFor(clazz) {\n    if (this.classes.has(clazz)) {\n      return this.classes.get(clazz);\n    } else {\n      return null;\n    }\n  }\n  getAnalyzedRecords() {\n    const result = /* @__PURE__ */new Map();\n    for (const [sf, classes] of this.fileToClasses) {\n      const records = [];\n      for (const clazz of classes) {\n        records.push(this.classes.get(clazz));\n      }\n      result.set(sf, records);\n    }\n    for (const sf of this.filesWithoutTraits) {\n      result.set(sf, []);\n    }\n    return result;\n  }\n  adopt(priorRecord) {\n    const record = {\n      hasPrimaryHandler: priorRecord.hasPrimaryHandler,\n      hasWeakHandlers: priorRecord.hasWeakHandlers,\n      metaDiagnostics: priorRecord.metaDiagnostics,\n      node: priorRecord.node,\n      traits: []\n    };\n    for (const priorTrait of priorRecord.traits) {\n      const handler = this.handlersByName.get(priorTrait.handler.name);\n      let trait = Trait.pending(handler, priorTrait.detected);\n      if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {\n        const symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);\n        trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);\n        if (trait.analysis !== null && trait.handler.register !== void 0) {\n          trait.handler.register(record.node, trait.analysis);\n        }\n      } else if (priorTrait.state === TraitState.Skipped) {\n        trait = trait.toSkipped();\n      }\n      record.traits.push(trait);\n    }\n    this.classes.set(record.node, record);\n    const sf = record.node.getSourceFile();\n    if (!this.fileToClasses.has(sf)) {\n      this.fileToClasses.set(sf, /* @__PURE__ */new Set());\n    }\n    this.fileToClasses.get(sf).add(record.node);\n  }\n  scanClassForTraits(clazz) {\n    if (!this.compileNonExportedClasses && !this.reflector.isStaticallyExported(clazz)) {\n      return null;\n    }\n    const decorators = this.reflector.getDecoratorsOfDeclaration(clazz);\n    return this.detectTraits(clazz, decorators);\n  }\n  detectTraits(clazz, decorators) {\n    let record = this.recordFor(clazz);\n    let foundTraits = [];\n    for (const handler of this.handlers) {\n      const result = handler.detect(clazz, decorators);\n      if (result === void 0) {\n        continue;\n      }\n      const isPrimaryHandler = handler.precedence === HandlerPrecedence.PRIMARY;\n      const isWeakHandler = handler.precedence === HandlerPrecedence.WEAK;\n      const trait = Trait.pending(handler, result);\n      foundTraits.push(trait);\n      if (record === null) {\n        record = {\n          node: clazz,\n          traits: [trait],\n          metaDiagnostics: null,\n          hasPrimaryHandler: isPrimaryHandler,\n          hasWeakHandlers: isWeakHandler\n        };\n        this.classes.set(clazz, record);\n        const sf = clazz.getSourceFile();\n        if (!this.fileToClasses.has(sf)) {\n          this.fileToClasses.set(sf, /* @__PURE__ */new Set());\n        }\n        this.fileToClasses.get(sf).add(clazz);\n      } else {\n        if (!isWeakHandler && record.hasWeakHandlers) {\n          record.traits = record.traits.filter(field => field.handler.precedence !== HandlerPrecedence.WEAK);\n          record.hasWeakHandlers = false;\n        } else if (isWeakHandler && !record.hasWeakHandlers) {\n          continue;\n        }\n        if (isPrimaryHandler && record.hasPrimaryHandler) {\n          record.metaDiagnostics = [{\n            category: ts15.DiagnosticCategory.Error,\n            code: Number(\"-99\" + ErrorCode.DECORATOR_COLLISION),\n            file: getSourceFile(clazz),\n            start: clazz.getStart(void 0, false),\n            length: clazz.getWidth(),\n            messageText: \"Two incompatible decorators on class\"\n          }];\n          record.traits = foundTraits = [];\n          break;\n        }\n        record.traits.push(trait);\n        record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;\n      }\n    }\n    return foundTraits.length > 0 ? foundTraits : null;\n  }\n  makeSymbolForTrait(handler, decl, analysis) {\n    if (analysis === null) {\n      return null;\n    }\n    const symbol = handler.symbol(decl, analysis);\n    if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n      const isPrimary = handler.precedence === HandlerPrecedence.PRIMARY;\n      if (!isPrimary) {\n        throw new Error(`AssertionError: ${handler.name} returned a symbol but is not a primary handler.`);\n      }\n      this.semanticDepGraphUpdater.registerSymbol(symbol);\n    }\n    return symbol;\n  }\n  analyzeClass(clazz, preanalyzeQueue) {\n    const traits = this.scanClassForTraits(clazz);\n    if (traits === null) {\n      return;\n    }\n    for (const trait of traits) {\n      const analyze = () => this.analyzeTrait(clazz, trait);\n      let preanalysis = null;\n      if (preanalyzeQueue !== null && trait.handler.preanalyze !== void 0) {\n        try {\n          preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait.toAnalyzed(null, [err.toDiagnostic()], null);\n            return;\n          } else {\n            throw err;\n          }\n        }\n      }\n      if (preanalysis !== null) {\n        preanalyzeQueue.push(preanalysis.then(analyze));\n      } else {\n        analyze();\n      }\n    }\n  }\n  analyzeTrait(clazz, trait, flags) {\n    var _a, _b, _c;\n    if (trait.state !== TraitState.Pending) {\n      throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${TraitState[trait.state]} (expected DETECTED)`);\n    }\n    this.perf.eventCount(PerfEvent.TraitAnalyze);\n    let result;\n    try {\n      result = trait.handler.analyze(clazz, trait.detected.metadata, flags);\n    } catch (err) {\n      if (err instanceof FatalDiagnosticError) {\n        trait.toAnalyzed(null, [err.toDiagnostic()], null);\n        return;\n      } else {\n        throw err;\n      }\n    }\n    const symbol = this.makeSymbolForTrait(trait.handler, clazz, (_a = result.analysis) != null ? _a : null);\n    if (result.analysis !== void 0 && trait.handler.register !== void 0) {\n      trait.handler.register(clazz, result.analysis);\n    }\n    trait = trait.toAnalyzed((_b = result.analysis) != null ? _b : null, (_c = result.diagnostics) != null ? _c : null, symbol);\n  }\n  resolve() {\n    var _a, _b;\n    const classes = this.classes.keys();\n    for (const clazz of classes) {\n      const record = this.classes.get(clazz);\n      for (let trait of record.traits) {\n        const handler = trait.handler;\n        switch (trait.state) {\n          case TraitState.Skipped:\n            continue;\n          case TraitState.Pending:\n            throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${trait.handler.name}`);\n          case TraitState.Resolved:\n            throw new Error(`Resolving an already resolved trait`);\n        }\n        if (trait.analysis === null) {\n          continue;\n        }\n        if (handler.resolve === void 0) {\n          trait = trait.toResolved(null, null);\n          continue;\n        }\n        let result;\n        try {\n          result = handler.resolve(clazz, trait.analysis, trait.symbol);\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait = trait.toResolved(null, [err.toDiagnostic()]);\n            continue;\n          } else {\n            throw err;\n          }\n        }\n        trait = trait.toResolved((_a = result.data) != null ? _a : null, (_b = result.diagnostics) != null ? _b : null);\n        if (result.reexports !== void 0) {\n          const fileName = clazz.getSourceFile().fileName;\n          if (!this.reexportMap.has(fileName)) {\n            this.reexportMap.set(fileName, /* @__PURE__ */new Map());\n          }\n          const fileReexports = this.reexportMap.get(fileName);\n          for (const reexport of result.reexports) {\n            fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);\n          }\n        }\n      }\n    }\n  }\n  typeCheck(sf, ctx) {\n    if (!this.fileToClasses.has(sf)) {\n      return;\n    }\n    for (const clazz of this.fileToClasses.get(sf)) {\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.typeCheck === void 0) {\n          continue;\n        }\n        if (trait.resolution !== null) {\n          trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n  extendedTemplateCheck(sf, extendedTemplateChecker) {\n    const classes = this.fileToClasses.get(sf);\n    if (classes === void 0) {\n      return [];\n    }\n    const diagnostics = [];\n    for (const clazz of classes) {\n      if (!isNamedClassDeclaration(clazz)) {\n        continue;\n      }\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.handler.extendedTemplateCheck === void 0) {\n          continue;\n        }\n        diagnostics.push(...trait.handler.extendedTemplateCheck(clazz, extendedTemplateChecker));\n      }\n    }\n    return diagnostics;\n  }\n  index(ctx) {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.index === void 0) {\n          continue;\n        }\n        if (trait.resolution !== null) {\n          trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n  xi18n(bundle) {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Analyzed && trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.xi18n === void 0) {\n          continue;\n        }\n        if (trait.analysis !== null) {\n          trait.handler.xi18n(bundle, clazz, trait.analysis);\n        }\n      }\n    }\n  }\n  updateResources(clazz) {\n    if (!this.reflector.isClass(clazz) || !this.classes.has(clazz)) {\n      return;\n    }\n    const record = this.classes.get(clazz);\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || trait.handler.updateResources === void 0) {\n        continue;\n      }\n      trait.handler.updateResources(clazz, trait.analysis, trait.resolution);\n    }\n  }\n  compile(clazz, constantPool) {\n    const original = ts15.getOriginalNode(clazz);\n    if (!this.reflector.isClass(clazz) || !this.reflector.isClass(original) || !this.classes.has(original)) {\n      return null;\n    }\n    const record = this.classes.get(original);\n    let res = [];\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || containsErrors(trait.analysisDiagnostics) || containsErrors(trait.resolveDiagnostics)) {\n        continue;\n      }\n      let compileRes;\n      if (this.compilationMode === CompilationMode.PARTIAL && trait.handler.compilePartial !== void 0) {\n        compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution);\n      } else {\n        compileRes = trait.handler.compileFull(clazz, trait.analysis, trait.resolution, constantPool);\n      }\n      const compileMatchRes = compileRes;\n      if (Array.isArray(compileMatchRes)) {\n        for (const result of compileMatchRes) {\n          if (!res.some(r => r.name === result.name)) {\n            res.push(result);\n          }\n        }\n      } else if (!res.some(result => result.name === compileMatchRes.name)) {\n        res.push(compileMatchRes);\n      }\n    }\n    this.dtsTransforms.getIvyDeclarationTransform(original.getSourceFile()).addFields(original, res);\n    return res.length > 0 ? res : null;\n  }\n  decoratorsFor(node) {\n    const original = ts15.getOriginalNode(node);\n    if (!this.reflector.isClass(original) || !this.classes.has(original)) {\n      return [];\n    }\n    const record = this.classes.get(original);\n    const decorators = [];\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved) {\n        continue;\n      }\n      if (trait.detected.trigger !== null && ts15.isDecorator(trait.detected.trigger)) {\n        decorators.push(trait.detected.trigger);\n      }\n    }\n    return decorators;\n  }\n  get diagnostics() {\n    var _a;\n    const diagnostics = [];\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n      if (record.metaDiagnostics !== null) {\n        diagnostics.push(...record.metaDiagnostics);\n      }\n      for (const trait of record.traits) {\n        if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) && trait.analysisDiagnostics !== null) {\n          diagnostics.push(...trait.analysisDiagnostics);\n        }\n        if (trait.state === TraitState.Resolved) {\n          diagnostics.push(...((_a = trait.resolveDiagnostics) != null ? _a : []));\n        }\n      }\n    }\n    return diagnostics;\n  }\n  get exportStatements() {\n    return this.reexportMap;\n  }\n};\nfunction containsErrors(diagnostics) {\n  return diagnostics !== null && diagnostics.some(diag => diag.category === ts15.DiagnosticCategory.Error);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/declaration.mjs\nimport ts17 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/utils.mjs\nimport ts16 from \"typescript\";\nfunction addImports(importManager, sf, extraStatements = []) {\n  const addedImports = importManager.getAllImports(sf.fileName).map(i => {\n    const qualifier = ts16.factory.createIdentifier(i.qualifier.text);\n    const importClause = ts16.factory.createImportClause(false, void 0, ts16.factory.createNamespaceImport(qualifier));\n    const decl = ts16.factory.createImportDeclaration(void 0, importClause, ts16.factory.createStringLiteral(i.specifier));\n    ts16.setOriginalNode(i.qualifier, decl);\n    return decl;\n  });\n  const existingImports = sf.statements.filter(stmt => isImportStatement(stmt));\n  const body = sf.statements.filter(stmt => !isImportStatement(stmt));\n  if (addedImports.length > 0) {\n    const fileoverviewAnchorStmt = ts16.factory.createNotEmittedStatement(sf);\n    return ts16.factory.updateSourceFile(sf, ts16.factory.createNodeArray([fileoverviewAnchorStmt, ...existingImports, ...addedImports, ...extraStatements, ...body]));\n  }\n  return sf;\n}\nfunction isImportStatement(stmt) {\n  return ts16.isImportDeclaration(stmt) || ts16.isImportEqualsDeclaration(stmt) || ts16.isNamespaceImport(stmt);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/declaration.mjs\nvar DtsTransformRegistry = class {\n  constructor() {\n    this.ivyDeclarationTransforms = /* @__PURE__ */new Map();\n  }\n  getIvyDeclarationTransform(sf) {\n    if (!this.ivyDeclarationTransforms.has(sf)) {\n      this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());\n    }\n    return this.ivyDeclarationTransforms.get(sf);\n  }\n  getAllTransforms(sf) {\n    if (!sf.isDeclarationFile) {\n      return null;\n    }\n    const originalSf = ts17.getOriginalNode(sf);\n    let transforms = null;\n    if (this.ivyDeclarationTransforms.has(originalSf)) {\n      transforms = [];\n      transforms.push(this.ivyDeclarationTransforms.get(originalSf));\n    }\n    return transforms;\n  }\n};\nfunction declarationTransformFactory(transformRegistry, reflector, refEmitter, importRewriter, importPrefix) {\n  return context => {\n    const transformer = new DtsTransformer(context, reflector, refEmitter, importRewriter, importPrefix);\n    return fileOrBundle => {\n      if (ts17.isBundle(fileOrBundle)) {\n        return fileOrBundle;\n      }\n      const transforms = transformRegistry.getAllTransforms(fileOrBundle);\n      if (transforms === null) {\n        return fileOrBundle;\n      }\n      return transformer.transform(fileOrBundle, transforms);\n    };\n  };\n}\nvar DtsTransformer = class {\n  constructor(ctx, reflector, refEmitter, importRewriter, importPrefix) {\n    this.ctx = ctx;\n    this.reflector = reflector;\n    this.refEmitter = refEmitter;\n    this.importRewriter = importRewriter;\n    this.importPrefix = importPrefix;\n  }\n  transform(sf, transforms) {\n    const imports = new ImportManager(this.importRewriter, this.importPrefix);\n    const visitor = node => {\n      if (ts17.isClassDeclaration(node)) {\n        return this.transformClassDeclaration(node, transforms, imports);\n      } else if (ts17.isFunctionDeclaration(node)) {\n        return this.transformFunctionDeclaration(node, transforms, imports);\n      } else {\n        return ts17.visitEachChild(node, visitor, this.ctx);\n      }\n    };\n    sf = ts17.visitNode(sf, visitor, ts17.isSourceFile) || sf;\n    return addImports(imports, sf);\n  }\n  transformClassDeclaration(clazz, transforms, imports) {\n    let elements = clazz.members;\n    let elementsChanged = false;\n    for (const transform of transforms) {\n      if (transform.transformClassElement !== void 0) {\n        for (let i = 0; i < elements.length; i++) {\n          const res = transform.transformClassElement(elements[i], imports);\n          if (res !== elements[i]) {\n            if (!elementsChanged) {\n              elements = [...elements];\n              elementsChanged = true;\n            }\n            elements[i] = res;\n          }\n        }\n      }\n    }\n    let newClazz = clazz;\n    for (const transform of transforms) {\n      if (transform.transformClass !== void 0) {\n        const inputMembers = clazz === newClazz ? elements : newClazz.members;\n        newClazz = transform.transformClass(newClazz, inputMembers, this.reflector, this.refEmitter, imports);\n      }\n    }\n    if (elementsChanged && clazz === newClazz) {\n      newClazz = ts17.factory.updateClassDeclaration(clazz, clazz.modifiers, clazz.name, clazz.typeParameters, clazz.heritageClauses, elements);\n    }\n    return newClazz;\n  }\n  transformFunctionDeclaration(declaration, transforms, imports) {\n    let newDecl = declaration;\n    for (const transform of transforms) {\n      if (transform.transformFunctionDeclaration !== void 0) {\n        newDecl = transform.transformFunctionDeclaration(newDecl, imports);\n      }\n    }\n    return newDecl;\n  }\n};\nvar IvyDeclarationDtsTransform = class {\n  constructor() {\n    this.declarationFields = /* @__PURE__ */new Map();\n  }\n  addFields(decl, fields) {\n    this.declarationFields.set(decl, fields);\n  }\n  transformClass(clazz, members, reflector, refEmitter, imports) {\n    const original = ts17.getOriginalNode(clazz);\n    if (!this.declarationFields.has(original)) {\n      return clazz;\n    }\n    const fields = this.declarationFields.get(original);\n    const newMembers = fields.map(decl => {\n      const modifiers = [ts17.factory.createModifier(ts17.SyntaxKind.StaticKeyword)];\n      const typeRef = translateType(decl.type, original.getSourceFile(), reflector, refEmitter, imports);\n      markForEmitAsSingleLine(typeRef);\n      return ts17.factory.createPropertyDeclaration(modifiers, decl.name, void 0, typeRef, void 0);\n    });\n    return ts17.factory.updateClassDeclaration(clazz, clazz.modifiers, clazz.name, clazz.typeParameters, clazz.heritageClauses, [...members, ...newMembers]);\n  }\n};\nfunction markForEmitAsSingleLine(node) {\n  ts17.setEmitFlags(node, ts17.EmitFlags.SingleLine);\n  ts17.forEachChild(node, markForEmitAsSingleLine);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/transform.mjs\nimport { ConstantPool } from \"@angular/compiler\";\nimport ts19 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/util/src/visitor.mjs\nimport ts18 from \"typescript\";\nfunction visit(node, visitor, context) {\n  return visitor._visit(node, context);\n}\nvar Visitor = class {\n  constructor() {\n    this._before = /* @__PURE__ */new Map();\n    this._after = /* @__PURE__ */new Map();\n  }\n  _visitListEntryNode(node, visitor) {\n    const result = visitor(node);\n    if (result.before !== void 0) {\n      this._before.set(result.node, result.before);\n    }\n    if (result.after !== void 0) {\n      this._after.set(result.node, result.after);\n    }\n    return result.node;\n  }\n  visitOtherNode(node) {\n    return node;\n  }\n  _visit(node, context) {\n    let visitedNode = null;\n    node = ts18.visitEachChild(node, child => this._visit(child, context), context);\n    if (ts18.isClassDeclaration(node)) {\n      visitedNode = this._visitListEntryNode(node, node2 => this.visitClassDeclaration(node2));\n    } else {\n      visitedNode = this.visitOtherNode(node);\n    }\n    if (ts18.isBlock(visitedNode) || ts18.isSourceFile(visitedNode)) {\n      visitedNode = this._maybeProcessStatements(visitedNode);\n    }\n    return visitedNode;\n  }\n  _maybeProcessStatements(node) {\n    if (node.statements.every(stmt => !this._before.has(stmt) && !this._after.has(stmt))) {\n      return node;\n    }\n    const newStatements = [];\n    node.statements.forEach(stmt => {\n      if (this._before.has(stmt)) {\n        newStatements.push(...this._before.get(stmt));\n        this._before.delete(stmt);\n      }\n      newStatements.push(stmt);\n      if (this._after.has(stmt)) {\n        newStatements.push(...this._after.get(stmt));\n        this._after.delete(stmt);\n      }\n    });\n    const statementsArray = ts18.factory.createNodeArray(newStatements, node.statements.hasTrailingComma);\n    if (ts18.isBlock(node)) {\n      return ts18.factory.updateBlock(node, statementsArray);\n    } else {\n      return ts18.factory.updateSourceFile(node, statementsArray, node.isDeclarationFile, node.referencedFiles, node.typeReferenceDirectives, node.hasNoDefaultLib, node.libReferenceDirectives);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/transform.mjs\nvar NO_DECORATORS = /* @__PURE__ */new Set();\nvar CLOSURE_FILE_OVERVIEW_REGEXP = /\\s+@fileoverview\\s+/i;\nfunction ivyTransformFactory(compilation, reflector, importRewriter, defaultImportTracker, perf, isCore, isClosureCompilerEnabled) {\n  const recordWrappedNode = createRecorderFn(defaultImportTracker);\n  return context => {\n    return file => {\n      return perf.inPhase(PerfPhase.Compile, () => transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode));\n    };\n  };\n}\nvar IvyCompilationVisitor = class extends Visitor {\n  constructor(compilation, constantPool) {\n    super();\n    this.compilation = compilation;\n    this.constantPool = constantPool;\n    this.classCompilationMap = /* @__PURE__ */new Map();\n  }\n  visitClassDeclaration(node) {\n    const result = this.compilation.compile(node, this.constantPool);\n    if (result !== null) {\n      this.classCompilationMap.set(node, result);\n    }\n    return {\n      node\n    };\n  }\n};\nvar IvyTransformationVisitor = class extends Visitor {\n  constructor(compilation, classCompilationMap, reflector, importManager, recordWrappedNodeExpr, isClosureCompilerEnabled, isCore) {\n    super();\n    this.compilation = compilation;\n    this.classCompilationMap = classCompilationMap;\n    this.reflector = reflector;\n    this.importManager = importManager;\n    this.recordWrappedNodeExpr = recordWrappedNodeExpr;\n    this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n    this.isCore = isCore;\n  }\n  visitClassDeclaration(node) {\n    if (!this.classCompilationMap.has(node)) {\n      return {\n        node\n      };\n    }\n    const translateOptions = {\n      recordWrappedNode: this.recordWrappedNodeExpr,\n      annotateForClosureCompiler: this.isClosureCompilerEnabled\n    };\n    const statements = [];\n    const members = [...node.members];\n    for (const field of this.classCompilationMap.get(node)) {\n      if (field.initializer === null) {\n        continue;\n      }\n      const exprNode = translateExpression(field.initializer, this.importManager, translateOptions);\n      const property = ts19.factory.createPropertyDeclaration([ts19.factory.createToken(ts19.SyntaxKind.StaticKeyword)], field.name, void 0, void 0, exprNode);\n      if (this.isClosureCompilerEnabled) {\n        ts19.addSyntheticLeadingComment(property, ts19.SyntaxKind.MultiLineCommentTrivia, \"* @nocollapse \", false);\n      }\n      field.statements.map(stmt => translateStatement(stmt, this.importManager, translateOptions)).forEach(stmt => statements.push(stmt));\n      members.push(property);\n    }\n    const filteredDecorators = maybeFilterDecorator(ts19.getDecorators(node), this.compilation.decoratorsFor(node));\n    const nodeModifiers = ts19.getModifiers(node);\n    let updatedModifiers;\n    if ((filteredDecorators == null ? void 0 : filteredDecorators.length) || (nodeModifiers == null ? void 0 : nodeModifiers.length)) {\n      updatedModifiers = [...(filteredDecorators || []), ...(nodeModifiers || [])];\n    }\n    node = ts19.factory.updateClassDeclaration(node, updatedModifiers, node.name, node.typeParameters, node.heritageClauses || [], members.map(member => this._stripAngularDecorators(member)));\n    return {\n      node,\n      after: statements\n    };\n  }\n  _angularCoreDecorators(decl) {\n    const decorators = this.reflector.getDecoratorsOfDeclaration(decl);\n    if (decorators === null) {\n      return NO_DECORATORS;\n    }\n    const coreDecorators = decorators.filter(dec => this.isCore || isFromAngularCore(dec)).map(dec => dec.node);\n    if (coreDecorators.length > 0) {\n      return new Set(coreDecorators);\n    } else {\n      return NO_DECORATORS;\n    }\n  }\n  _nonCoreDecoratorsOnly(node) {\n    const decorators = ts19.getDecorators(node);\n    if (decorators === void 0) {\n      return void 0;\n    }\n    const coreDecorators = this._angularCoreDecorators(node);\n    if (coreDecorators.size === decorators.length) {\n      return void 0;\n    } else if (coreDecorators.size === 0) {\n      return nodeArrayFromDecoratorsArray(decorators);\n    }\n    const filtered = decorators.filter(dec => !coreDecorators.has(dec));\n    if (filtered.length === 0) {\n      return void 0;\n    }\n    return nodeArrayFromDecoratorsArray(filtered);\n  }\n  _stripAngularDecorators(node) {\n    const modifiers = ts19.canHaveModifiers(node) ? ts19.getModifiers(node) : void 0;\n    const nonCoreDecorators = ts19.canHaveDecorators(node) ? this._nonCoreDecoratorsOnly(node) : void 0;\n    const combinedModifiers = [...(nonCoreDecorators || []), ...(modifiers || [])];\n    if (ts19.isParameter(node)) {\n      node = ts19.factory.updateParameterDeclaration(node, combinedModifiers, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer);\n    } else if (ts19.isMethodDeclaration(node)) {\n      node = ts19.factory.updateMethodDeclaration(node, combinedModifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);\n    } else if (ts19.isPropertyDeclaration(node)) {\n      node = ts19.factory.updatePropertyDeclaration(node, combinedModifiers, node.name, node.questionToken, node.type, node.initializer);\n    } else if (ts19.isGetAccessor(node)) {\n      node = ts19.factory.updateGetAccessorDeclaration(node, combinedModifiers, node.name, node.parameters, node.type, node.body);\n    } else if (ts19.isSetAccessor(node)) {\n      node = ts19.factory.updateSetAccessorDeclaration(node, combinedModifiers, node.name, node.parameters, node.body);\n    } else if (ts19.isConstructorDeclaration(node)) {\n      const parameters = node.parameters.map(param => this._stripAngularDecorators(param));\n      node = ts19.factory.updateConstructorDeclaration(node, modifiers, parameters, node.body);\n    }\n    return node;\n  }\n};\nfunction transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode) {\n  const constantPool = new ConstantPool(isClosureCompilerEnabled);\n  const importManager = new ImportManager(importRewriter);\n  const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);\n  visit(file, compilationVisitor, context);\n  const transformationVisitor = new IvyTransformationVisitor(compilation, compilationVisitor.classCompilationMap, reflector, importManager, recordWrappedNode, isClosureCompilerEnabled, isCore);\n  let sf = visit(file, transformationVisitor, context);\n  const downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts19.ScriptTarget.ES2015;\n  const constants = constantPool.statements.map(stmt => translateStatement(stmt, importManager, {\n    recordWrappedNode,\n    downlevelTaggedTemplates: downlevelTranslatedCode,\n    downlevelVariableDeclarations: downlevelTranslatedCode,\n    annotateForClosureCompiler: isClosureCompilerEnabled\n  }));\n  const fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null;\n  sf = addImports(importManager, sf, constants);\n  if (fileOverviewMeta !== null) {\n    setFileOverviewComment(sf, fileOverviewMeta);\n  }\n  return sf;\n}\nfunction getLocalizeCompileTarget(context) {\n  const target = context.getCompilerOptions().target || ts19.ScriptTarget.ES2015;\n  return target !== ts19.ScriptTarget.JSON ? target : ts19.ScriptTarget.ES2015;\n}\nfunction getFileOverviewComment(statements) {\n  if (statements.length > 0) {\n    const host = statements[0];\n    let trailing = false;\n    let comments = ts19.getSyntheticLeadingComments(host);\n    if (!comments || comments.length === 0) {\n      trailing = true;\n      comments = ts19.getSyntheticTrailingComments(host);\n    }\n    if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {\n      return {\n        comments,\n        host,\n        trailing\n      };\n    }\n  }\n  return null;\n}\nfunction setFileOverviewComment(sf, fileoverview) {\n  const {\n    comments,\n    host,\n    trailing\n  } = fileoverview;\n  if (sf.statements.length > 0 && host !== sf.statements[0]) {\n    if (trailing) {\n      ts19.setSyntheticTrailingComments(host, void 0);\n    } else {\n      ts19.setSyntheticLeadingComments(host, void 0);\n    }\n    ts19.setSyntheticLeadingComments(sf.statements[0], comments);\n  }\n}\nfunction maybeFilterDecorator(decorators, toRemove) {\n  if (decorators === void 0) {\n    return void 0;\n  }\n  const filtered = decorators.filter(dec => toRemove.find(decToRemove => ts19.getOriginalNode(dec) === decToRemove) === void 0);\n  if (filtered.length === 0) {\n    return void 0;\n  }\n  return ts19.factory.createNodeArray(filtered);\n}\nfunction isFromAngularCore(decorator) {\n  return decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\nfunction createRecorderFn(defaultImportTracker) {\n  return node => {\n    const importDecl = getDefaultImportDeclaration(node);\n    if (importDecl !== null) {\n      defaultImportTracker.recordUsedImport(importDecl);\n    }\n  };\n}\nfunction nodeArrayFromDecoratorsArray(decorators) {\n  const array = ts19.factory.createNodeArray(decorators);\n  if (array.length > 0) {\n    array.pos = decorators[0].pos;\n    array.end = decorators[decorators.length - 1].end;\n  }\n  return array;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/directive/src/handler.mjs\nimport { compileClassMetadata, compileDeclareClassMetadata, compileDeclareDirectiveFromMetadata, compileDirectiveFromMetadata, FactoryTarget, makeBindingParser, WrappedNodeExpr as WrappedNodeExpr5 } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/directive/src/shared.mjs\nimport { createMayBeForwardRefExpression, emitDistinctChangesOnlyDefaultValue, ExternalExpr as ExternalExpr4, getSafePropertyAccessString, parseHostBindings, verifyHostBindings, WrappedNodeExpr as WrappedNodeExpr4 } from \"@angular/compiler\";\nimport ts20 from \"typescript\";\nvar EMPTY_OBJECT = {};\nvar QUERY_TYPES = /* @__PURE__ */new Set([\"ContentChild\", \"ContentChildren\", \"ViewChild\", \"ViewChildren\"]);\nfunction extractDirectiveMetadata(clazz, decorator, reflector, evaluator, refEmitter, referencesRegistry, isCore, flags, annotateForClosureCompiler, defaultSelector = null) {\n  let directive;\n  if (decorator === null || decorator.args === null || decorator.args.length === 0) {\n    directive = /* @__PURE__ */new Map();\n  } else if (decorator.args.length !== 1) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @${decorator.name} decorator`);\n  } else {\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts20.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `@${decorator.name} argument must be an object literal`);\n    }\n    directive = reflectObjectLiteral(meta);\n  }\n  if (directive.has(\"jit\")) {\n    return void 0;\n  }\n  const members = reflector.getMembersOfClass(clazz);\n  const decoratedElements = members.filter(member => !member.isStatic && member.decorators !== null);\n  const coreModule = isCore ? void 0 : \"@angular/core\";\n  const inputsFromMeta = parseInputsArray(clazz, directive, evaluator, reflector, refEmitter);\n  const inputsFromFields = parseInputFields(clazz, filterToMembersWithDecorator(decoratedElements, \"Input\", coreModule), evaluator, reflector, refEmitter);\n  const inputs = ClassPropertyMapping.fromMappedObject({\n    ...inputsFromMeta,\n    ...inputsFromFields\n  });\n  const outputsFromMeta = parseOutputsArray(directive, evaluator);\n  const outputsFromFields = parseOutputFields(filterToMembersWithDecorator(decoratedElements, \"Output\", coreModule), evaluator);\n  const outputs = ClassPropertyMapping.fromMappedObject({\n    ...outputsFromMeta,\n    ...outputsFromFields\n  });\n  const contentChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ContentChild\", coreModule), reflector, evaluator);\n  const contentChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ContentChildren\", coreModule), reflector, evaluator);\n  const queries = [...contentChildFromFields, ...contentChildrenFromFields];\n  const viewChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ViewChild\", coreModule), reflector, evaluator);\n  const viewChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ViewChildren\", coreModule), reflector, evaluator);\n  const viewQueries = [...viewChildFromFields, ...viewChildrenFromFields];\n  if (directive.has(\"queries\")) {\n    const queriesFromDecorator = extractQueriesFromDecorator(directive.get(\"queries\"), reflector, evaluator, isCore);\n    queries.push(...queriesFromDecorator.content);\n    viewQueries.push(...queriesFromDecorator.view);\n  }\n  let selector = defaultSelector;\n  if (directive.has(\"selector\")) {\n    const expr = directive.get(\"selector\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"string\") {\n      throw createValueHasWrongTypeError(expr, resolved, `selector must be a string`);\n    }\n    selector = resolved === \"\" ? defaultSelector : resolved;\n    if (!selector) {\n      throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr, `Directive ${clazz.name.text} has no selector, please add it!`);\n    }\n  }\n  const host = extractHostBindings(decoratedElements, evaluator, coreModule, directive);\n  const providers = directive.has(\"providers\") ? new WrappedNodeExpr4(annotateForClosureCompiler ? wrapFunctionExpressionsInParens(directive.get(\"providers\")) : directive.get(\"providers\")) : null;\n  const usesOnChanges = members.some(member => !member.isStatic && member.kind === ClassMemberKind.Method && member.name === \"ngOnChanges\");\n  let exportAs = null;\n  if (directive.has(\"exportAs\")) {\n    const expr = directive.get(\"exportAs\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"string\") {\n      throw createValueHasWrongTypeError(expr, resolved, `exportAs must be a string`);\n    }\n    exportAs = resolved.split(\",\").map(part => part.trim());\n  }\n  const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n  const ctorDeps = selector !== null ? validateConstructorDependencies(clazz, rawCtorDeps) : unwrapConstructorDependencies(rawCtorDeps);\n  const isStructural = ctorDeps !== null && ctorDeps !== \"invalid\" && ctorDeps.some(dep => dep.token instanceof ExternalExpr4 && dep.token.value.moduleName === \"@angular/core\" && dep.token.value.name === \"TemplateRef\");\n  let isStandalone = false;\n  if (directive.has(\"standalone\")) {\n    const expr = directive.get(\"standalone\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"boolean\") {\n      throw createValueHasWrongTypeError(expr, resolved, `standalone flag must be a boolean`);\n    }\n    isStandalone = resolved;\n  }\n  let isSignal = false;\n  if (directive.has(\"signals\")) {\n    const expr = directive.get(\"signals\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"boolean\") {\n      throw createValueHasWrongTypeError(expr, resolved, `signals flag must be a boolean`);\n    }\n    isSignal = resolved;\n  }\n  const usesInheritance = reflector.hasBaseClass(clazz);\n  const sourceFile = clazz.getSourceFile();\n  const type = wrapTypeReference(reflector, clazz);\n  const rawHostDirectives = directive.get(\"hostDirectives\") || null;\n  const hostDirectives = rawHostDirectives === null ? null : extractHostDirectives(rawHostDirectives, evaluator);\n  if (hostDirectives !== null) {\n    referencesRegistry.add(clazz, ...hostDirectives.map(hostDir => hostDir.directive));\n  }\n  const metadata = {\n    name: clazz.name.text,\n    deps: ctorDeps,\n    host,\n    lifecycle: {\n      usesOnChanges\n    },\n    inputs: inputs.toJointMappedObject(toR3InputMetadata),\n    outputs: outputs.toDirectMappedObject(),\n    queries,\n    viewQueries,\n    selector,\n    fullInheritance: !!(flags & HandlerFlags.FULL_INHERITANCE),\n    type,\n    typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,\n    typeSourceSpan: createSourceSpan(clazz.name),\n    usesInheritance,\n    exportAs,\n    providers,\n    isStandalone,\n    isSignal,\n    hostDirectives: (hostDirectives == null ? void 0 : hostDirectives.map(hostDir => toHostDirectiveMetadata(hostDir, sourceFile, refEmitter))) || null\n  };\n  return {\n    decorator: directive,\n    metadata,\n    inputs,\n    outputs,\n    isStructural,\n    hostDirectives,\n    rawHostDirectives\n  };\n}\nfunction extractQueryMetadata(exprNode, name, args, propertyName, reflector, evaluator) {\n  if (args.length === 0) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, exprNode, `@${name} must have arguments`);\n  }\n  const first = name === \"ViewChild\" || name === \"ContentChild\";\n  const forwardReferenceTarget = tryUnwrapForwardRef(args[0], reflector);\n  const node = forwardReferenceTarget != null ? forwardReferenceTarget : args[0];\n  const arg = evaluator.evaluate(node);\n  let isStatic = false;\n  let predicate = null;\n  if (arg instanceof Reference || arg instanceof DynamicValue) {\n    predicate = createMayBeForwardRefExpression(new WrappedNodeExpr4(node), forwardReferenceTarget !== null ? 2 : 0);\n  } else if (typeof arg === \"string\") {\n    predicate = [arg];\n  } else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {\n    predicate = arg;\n  } else {\n    throw createValueHasWrongTypeError(node, arg, `@${name} predicate cannot be interpreted`);\n  }\n  let read = null;\n  let descendants = name !== \"ContentChildren\";\n  let emitDistinctChangesOnly = emitDistinctChangesOnlyDefaultValue;\n  if (args.length === 2) {\n    const optionsExpr = unwrapExpression(args[1]);\n    if (!ts20.isObjectLiteralExpression(optionsExpr)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr, `@${name} options must be an object literal`);\n    }\n    const options = reflectObjectLiteral(optionsExpr);\n    if (options.has(\"read\")) {\n      read = new WrappedNodeExpr4(options.get(\"read\"));\n    }\n    if (options.has(\"descendants\")) {\n      const descendantsExpr = options.get(\"descendants\");\n      const descendantsValue = evaluator.evaluate(descendantsExpr);\n      if (typeof descendantsValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(descendantsExpr, descendantsValue, `@${name} options.descendants must be a boolean`);\n      }\n      descendants = descendantsValue;\n    }\n    if (options.has(\"emitDistinctChangesOnly\")) {\n      const emitDistinctChangesOnlyExpr = options.get(\"emitDistinctChangesOnly\");\n      const emitDistinctChangesOnlyValue = evaluator.evaluate(emitDistinctChangesOnlyExpr);\n      if (typeof emitDistinctChangesOnlyValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(emitDistinctChangesOnlyExpr, emitDistinctChangesOnlyValue, `@${name} options.emitDistinctChangesOnly must be a boolean`);\n      }\n      emitDistinctChangesOnly = emitDistinctChangesOnlyValue;\n    }\n    if (options.has(\"static\")) {\n      const staticValue = evaluator.evaluate(options.get(\"static\"));\n      if (typeof staticValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(node, staticValue, `@${name} options.static must be a boolean`);\n      }\n      isStatic = staticValue;\n    }\n  } else if (args.length > 2) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, node, `@${name} has too many arguments`);\n  }\n  return {\n    propertyName,\n    predicate,\n    first,\n    descendants,\n    read,\n    static: isStatic,\n    emitDistinctChangesOnly\n  };\n}\nfunction extractHostBindings(members, evaluator, coreModule, metadata) {\n  let bindings;\n  if (metadata && metadata.has(\"host\")) {\n    bindings = evaluateHostExpressionBindings(metadata.get(\"host\"), evaluator);\n  } else {\n    bindings = parseHostBindings({});\n  }\n  filterToMembersWithDecorator(members, \"HostBinding\", coreModule).forEach(({\n    member,\n    decorators\n  }) => {\n    decorators.forEach(decorator => {\n      let hostPropertyName = member.name;\n      if (decorator.args !== null && decorator.args.length > 0) {\n        if (decorator.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `@HostBinding can have at most one argument, got ${decorator.args.length} argument(s)`);\n        }\n        const resolved = evaluator.evaluate(decorator.args[0]);\n        if (typeof resolved !== \"string\") {\n          throw createValueHasWrongTypeError(decorator.node, resolved, `@HostBinding's argument must be a string`);\n        }\n        hostPropertyName = resolved;\n      }\n      bindings.properties[hostPropertyName] = getSafePropertyAccessString(\"this\", member.name);\n    });\n  });\n  filterToMembersWithDecorator(members, \"HostListener\", coreModule).forEach(({\n    member,\n    decorators\n  }) => {\n    decorators.forEach(decorator => {\n      let eventName = member.name;\n      let args = [];\n      if (decorator.args !== null && decorator.args.length > 0) {\n        if (decorator.args.length > 2) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], `@HostListener can have at most two arguments`);\n        }\n        const resolved = evaluator.evaluate(decorator.args[0]);\n        if (typeof resolved !== \"string\") {\n          throw createValueHasWrongTypeError(decorator.args[0], resolved, `@HostListener's event name argument must be a string`);\n        }\n        eventName = resolved;\n        if (decorator.args.length === 2) {\n          const expression = decorator.args[1];\n          const resolvedArgs = evaluator.evaluate(decorator.args[1]);\n          if (!isStringArrayOrDie(resolvedArgs, \"@HostListener.args\", expression)) {\n            throw createValueHasWrongTypeError(decorator.args[1], resolvedArgs, `@HostListener's second argument must be a string array`);\n          }\n          args = resolvedArgs;\n        }\n      }\n      bindings.listeners[eventName] = `${member.name}(${args.join(\",\")})`;\n    });\n  });\n  return bindings;\n}\nfunction extractQueriesFromDecorator(queryData, reflector, evaluator, isCore) {\n  const content = [],\n    view = [];\n  if (!ts20.isObjectLiteralExpression(queryData)) {\n    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator queries metadata must be an object literal\");\n  }\n  reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {\n    queryExpr = unwrapExpression(queryExpr);\n    if (!ts20.isNewExpression(queryExpr)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n    const queryType = ts20.isPropertyAccessExpression(queryExpr.expression) ? queryExpr.expression.name : queryExpr.expression;\n    if (!ts20.isIdentifier(queryType)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n    const type = reflector.getImportOfIdentifier(queryType);\n    if (type === null || !isCore && type.from !== \"@angular/core\" || !QUERY_TYPES.has(type.name)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n    const query = extractQueryMetadata(queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);\n    if (type.name.startsWith(\"Content\")) {\n      content.push(query);\n    } else {\n      view.push(query);\n    }\n  });\n  return {\n    content,\n    view\n  };\n}\nfunction parseFieldStringArrayValue(directive, field, evaluator) {\n  if (!directive.has(field)) {\n    return null;\n  }\n  const expression = directive.get(field);\n  const value = evaluator.evaluate(expression);\n  if (!isStringArrayOrDie(value, field, expression)) {\n    throw createValueHasWrongTypeError(expression, value, `Failed to resolve @Directive.${field} to a string array`);\n  }\n  return value;\n}\nfunction isStringArrayOrDie(value, name, node) {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  for (let i = 0; i < value.length; i++) {\n    if (typeof value[i] !== \"string\") {\n      throw createValueHasWrongTypeError(node, value[i], `Failed to resolve ${name} at position ${i} to a string`);\n    }\n  }\n  return true;\n}\nfunction queriesFromFields(fields, reflector, evaluator) {\n  return fields.map(({\n    member,\n    decorators\n  }) => {\n    const decorator = decorators[0];\n    const node = member.node || decorator.node;\n    if (member.decorators.some(v => v.name === \"Input\")) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, \"Cannot combine @Input decorators with query decorators\");\n    }\n    if (decorators.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, \"Cannot have multiple query decorators on the same class member\");\n    } else if (!isPropertyTypeMember(member)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, node, \"Query decorator must go on a property-type member\");\n    }\n    return extractQueryMetadata(node, decorator.name, decorator.args || [], member.name, reflector, evaluator);\n  });\n}\nfunction isPropertyTypeMember(member) {\n  return member.kind === ClassMemberKind.Getter || member.kind === ClassMemberKind.Setter || member.kind === ClassMemberKind.Property;\n}\nfunction parseMappingStringArray(values) {\n  return values.reduce((results, value) => {\n    if (typeof value !== \"string\") {\n      throw new Error(\"Mapping value must be a string\");\n    }\n    const [bindingPropertyName, fieldName] = parseMappingString(value);\n    results[fieldName] = bindingPropertyName;\n    return results;\n  }, {});\n}\nfunction parseMappingString(value) {\n  const [fieldName, bindingPropertyName] = value.split(\":\", 2).map(str => str.trim());\n  return [bindingPropertyName != null ? bindingPropertyName : fieldName, fieldName];\n}\nfunction parseDecoratedFields(fields, evaluator, callback) {\n  for (const field of fields) {\n    const fieldName = field.member.name;\n    for (const decorator of field.decorators) {\n      if (decorator.args != null && decorator.args.length > 1) {\n        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `@${decorator.name} can have at most one argument, got ${decorator.args.length} argument(s)`);\n      }\n      const value = decorator.args != null && decorator.args.length > 0 ? evaluator.evaluate(decorator.args[0]) : null;\n      callback(fieldName, value, decorator);\n    }\n  }\n}\nfunction parseInputsArray(clazz, decoratorMetadata, evaluator, reflector, refEmitter) {\n  const inputsField = decoratorMetadata.get(\"inputs\");\n  if (inputsField === void 0) {\n    return {};\n  }\n  const inputs = {};\n  const inputsArray = evaluator.evaluate(inputsField);\n  if (!Array.isArray(inputsArray)) {\n    throw createValueHasWrongTypeError(inputsField, inputsArray, `Failed to resolve @Directive.inputs to an array`);\n  }\n  for (let i = 0; i < inputsArray.length; i++) {\n    const value = inputsArray[i];\n    if (typeof value === \"string\") {\n      const [bindingPropertyName, classPropertyName] = parseMappingString(value);\n      inputs[classPropertyName] = {\n        bindingPropertyName,\n        classPropertyName,\n        required: false,\n        transform: null\n      };\n    } else if (value instanceof Map) {\n      const name = value.get(\"name\");\n      const alias = value.get(\"alias\");\n      const required = value.get(\"required\");\n      let transform = null;\n      if (typeof name !== \"string\") {\n        throw createValueHasWrongTypeError(inputsField, name, `Value at position ${i} of @Directive.inputs array must have a \"name\" property`);\n      }\n      if (value.has(\"transform\")) {\n        const transformValue = value.get(\"transform\");\n        if (!(transformValue instanceof DynamicValue) && !(transformValue instanceof Reference)) {\n          throw createValueHasWrongTypeError(inputsField, transformValue, `Transform of value at position ${i} of @Directive.inputs array must be a function`);\n        }\n        transform = parseInputTransformFunction(clazz, name, transformValue, reflector, refEmitter);\n      }\n      inputs[name] = {\n        classPropertyName: name,\n        bindingPropertyName: typeof alias === \"string\" ? alias : name,\n        required: required === true,\n        transform\n      };\n    } else {\n      throw createValueHasWrongTypeError(inputsField, value, `@Directive.inputs array can only contain strings or object literals`);\n    }\n  }\n  return inputs;\n}\nfunction parseInputFields(clazz, inputMembers, evaluator, reflector, refEmitter) {\n  const inputs = {};\n  parseDecoratedFields(inputMembers, evaluator, (classPropertyName, options, decorator) => {\n    let bindingPropertyName;\n    let required = false;\n    let transform = null;\n    if (options === null) {\n      bindingPropertyName = classPropertyName;\n    } else if (typeof options === \"string\") {\n      bindingPropertyName = options;\n    } else if (options instanceof Map) {\n      const aliasInConfig = options.get(\"alias\");\n      bindingPropertyName = typeof aliasInConfig === \"string\" ? aliasInConfig : classPropertyName;\n      required = options.get(\"required\") === true;\n      if (options.has(\"transform\")) {\n        const transformValue = options.get(\"transform\");\n        if (!(transformValue instanceof DynamicValue) && !(transformValue instanceof Reference)) {\n          throw createValueHasWrongTypeError(decorator.node, transformValue, `Input transform must be a function`);\n        }\n        transform = parseInputTransformFunction(clazz, classPropertyName, transformValue, reflector, refEmitter);\n      }\n    } else {\n      throw createValueHasWrongTypeError(decorator.node, options, `@${decorator.name} decorator argument must resolve to a string or an object literal`);\n    }\n    inputs[classPropertyName] = {\n      bindingPropertyName,\n      classPropertyName,\n      required,\n      transform\n    };\n  });\n  return inputs;\n}\nfunction parseInputTransformFunction(clazz, classPropertyName, value, reflector, refEmitter) {\n  var _a;\n  const definition = reflector.getDefinitionOfFunction(value.node);\n  if (definition === null) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform must be a function\");\n  }\n  if (definition.typeParameters !== null && definition.typeParameters.length > 0) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function cannot be generic\");\n  }\n  if (definition.signatureCount > 1) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function cannot have multiple signatures\");\n  }\n  const members = reflector.getMembersOfClass(clazz);\n  for (const member of members) {\n    const conflictingName = `ngAcceptInputType_${classPropertyName}`;\n    if (member.name === conflictingName && member.isStatic) {\n      throw new FatalDiagnosticError(ErrorCode.CONFLICTING_INPUT_TRANSFORM, value.node, `Class cannot have both a transform function on Input ${classPropertyName} and a static member called ${conflictingName}`);\n    }\n  }\n  const node = value instanceof Reference ? value.getIdentityIn(clazz.getSourceFile()) : value.node;\n  if (node === null) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function could not be referenced\");\n  }\n  const firstParam = ((_a = definition.parameters[0]) == null ? void 0 : _a.name) === \"this\" ? definition.parameters[1] : definition.parameters[0];\n  if (!firstParam) {\n    return {\n      node,\n      type: ts20.factory.createKeywordTypeNode(ts20.SyntaxKind.UnknownKeyword)\n    };\n  }\n  if (!firstParam.type) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function first parameter must have a type\");\n  }\n  if (firstParam.node.dotDotDotToken) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function first parameter cannot be a spread parameter\");\n  }\n  assertEmittableInputType(firstParam.type, clazz.getSourceFile(), reflector, refEmitter);\n  return {\n    node,\n    type: firstParam.type\n  };\n}\nfunction assertEmittableInputType(type, contextFile, reflector, refEmitter) {\n  (function walk(node) {\n    if (ts20.isTypeReferenceNode(node) && ts20.isIdentifier(node.typeName)) {\n      const declaration = reflector.getDeclarationOfIdentifier(node.typeName);\n      if (declaration !== null) {\n        if (declaration.node.getSourceFile() !== contextFile) {\n          const emittedType = refEmitter.emit(new Reference(declaration.node), contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports);\n          assertSuccessfulReferenceEmit(emittedType, node, \"type\");\n        } else if (!reflector.isStaticallyExported(declaration.node)) {\n          throw new FatalDiagnosticError(ErrorCode.SYMBOL_NOT_EXPORTED, type, `Symbol must be exported in order to be used as the type of an Input transform function`, [makeRelatedInformation(declaration.node, `The symbol is declared here.`)]);\n        }\n      }\n    }\n    node.forEachChild(walk);\n  })(type);\n}\nfunction parseOutputsArray(directive, evaluator) {\n  const metaValues = parseFieldStringArrayValue(directive, \"outputs\", evaluator);\n  return metaValues ? parseMappingStringArray(metaValues) : EMPTY_OBJECT;\n}\nfunction parseOutputFields(outputMembers, evaluator) {\n  const outputs = {};\n  parseDecoratedFields(outputMembers, evaluator, (fieldName, bindingPropertyName, decorator) => {\n    if (bindingPropertyName != null && typeof bindingPropertyName !== \"string\") {\n      throw createValueHasWrongTypeError(decorator.node, bindingPropertyName, `@${decorator.name} decorator argument must resolve to a string`);\n    }\n    outputs[fieldName] = bindingPropertyName != null ? bindingPropertyName : fieldName;\n  });\n  return outputs;\n}\nfunction evaluateHostExpressionBindings(hostExpr, evaluator) {\n  const hostMetaMap = evaluator.evaluate(hostExpr);\n  if (!(hostMetaMap instanceof Map)) {\n    throw createValueHasWrongTypeError(hostExpr, hostMetaMap, `Decorator host metadata must be an object`);\n  }\n  const hostMetadata = {};\n  hostMetaMap.forEach((value, key) => {\n    if (value instanceof EnumValue) {\n      value = value.resolved;\n    }\n    if (typeof key !== \"string\") {\n      throw createValueHasWrongTypeError(hostExpr, key, `Decorator host metadata must be a string -> string object, but found unparseable key`);\n    }\n    if (typeof value == \"string\") {\n      hostMetadata[key] = value;\n    } else if (value instanceof DynamicValue) {\n      hostMetadata[key] = new WrappedNodeExpr4(value.node);\n    } else {\n      throw createValueHasWrongTypeError(hostExpr, value, `Decorator host metadata must be a string -> string object, but found unparseable value`);\n    }\n  });\n  const bindings = parseHostBindings(hostMetadata);\n  const errors = verifyHostBindings(bindings, createSourceSpan(hostExpr));\n  if (errors.length > 0) {\n    throw new FatalDiagnosticError(ErrorCode.HOST_BINDING_PARSE_ERROR, hostExpr, errors.map(error => error.msg).join(\"\\n\"));\n  }\n  return bindings;\n}\nfunction extractHostDirectives(rawHostDirectives, evaluator) {\n  const resolved = evaluator.evaluate(rawHostDirectives, forwardRefResolver);\n  if (!Array.isArray(resolved)) {\n    throw createValueHasWrongTypeError(rawHostDirectives, resolved, \"hostDirectives must be an array\");\n  }\n  return resolved.map(value => {\n    const hostReference = value instanceof Map ? value.get(\"directive\") : value;\n    if (!(hostReference instanceof Reference)) {\n      throw createValueHasWrongTypeError(rawHostDirectives, hostReference, \"Host directive must be a reference\");\n    }\n    if (!isNamedClassDeclaration(hostReference.node)) {\n      throw createValueHasWrongTypeError(rawHostDirectives, hostReference, \"Host directive reference must be a class\");\n    }\n    const meta = {\n      directive: hostReference,\n      isForwardReference: hostReference.synthetic,\n      inputs: parseHostDirectivesMapping(\"inputs\", value, hostReference.node, rawHostDirectives),\n      outputs: parseHostDirectivesMapping(\"outputs\", value, hostReference.node, rawHostDirectives)\n    };\n    return meta;\n  });\n}\nfunction parseHostDirectivesMapping(field, resolvedValue, classReference, sourceExpression) {\n  if (resolvedValue instanceof Map && resolvedValue.has(field)) {\n    const nameForErrors = `@Directive.hostDirectives.${classReference.name.text}.${field}`;\n    const rawInputs = resolvedValue.get(field);\n    if (isStringArrayOrDie(rawInputs, nameForErrors, sourceExpression)) {\n      return parseMappingStringArray(rawInputs);\n    }\n  }\n  return null;\n}\nfunction toHostDirectiveMetadata(hostDirective, context, refEmitter) {\n  return {\n    directive: toR3Reference(hostDirective.directive.node, hostDirective.directive, context, refEmitter),\n    isForwardReference: hostDirective.isForwardReference,\n    inputs: hostDirective.inputs || null,\n    outputs: hostDirective.outputs || null\n  };\n}\nfunction toR3InputMetadata(mapping) {\n  return {\n    classPropertyName: mapping.classPropertyName,\n    bindingPropertyName: mapping.bindingPropertyName,\n    required: mapping.required,\n    transformFunction: mapping.transform !== null ? new WrappedNodeExpr4(mapping.transform.node) : null\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/directive/src/symbol.mjs\nvar DirectiveSymbol = class extends SemanticSymbol {\n  constructor(decl, selector, inputs, outputs, exportAs, typeCheckMeta, typeParameters) {\n    super(decl);\n    this.selector = selector;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.exportAs = exportAs;\n    this.typeCheckMeta = typeCheckMeta;\n    this.typeParameters = typeParameters;\n    this.baseClass = null;\n  }\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n    return this.selector !== previousSymbol.selector || !isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) || !isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) || !isArrayEqual(this.exportAs, previousSymbol.exportAs);\n  }\n  isTypeCheckApiAffected(previousSymbol) {\n    if (this.isPublicApiAffected(previousSymbol)) {\n      return true;\n    }\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n    if (!isArrayEqual(Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) || !isArrayEqual(Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputOrOutputEqual)) {\n      return true;\n    }\n    if (!areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {\n      return true;\n    }\n    if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {\n      return true;\n    }\n    if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {\n      return true;\n    }\n    return false;\n  }\n};\nfunction isInputMappingEqual(current, previous) {\n  return isInputOrOutputEqual(current, previous) && current.required === previous.required;\n}\nfunction isInputOrOutputEqual(current, previous) {\n  return current.classPropertyName === previous.classPropertyName && current.bindingPropertyName === previous.bindingPropertyName;\n}\nfunction isTypeCheckMetaEqual(current, previous) {\n  if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {\n    return false;\n  }\n  if (current.isGeneric !== previous.isGeneric) {\n    return false;\n  }\n  if (!isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {\n    return false;\n  }\n  if (!isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {\n    return false;\n  }\n  return true;\n}\nfunction isTemplateGuardEqual(current, previous) {\n  return current.inputName === previous.inputName && current.type === previous.type;\n}\nfunction isBaseClassEqual(current, previous) {\n  if (current === null || previous === null) {\n    return current === previous;\n  }\n  return isSymbolEqual(current, previous);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/directive/src/handler.mjs\nvar FIELD_DECORATORS = [\"Input\", \"Output\", \"ViewChild\", \"ViewChildren\", \"ContentChild\", \"ContentChildren\", \"HostBinding\", \"HostListener\"];\nvar LIFECYCLE_HOOKS = /* @__PURE__ */new Set([\"ngOnChanges\", \"ngOnInit\", \"ngOnDestroy\", \"ngDoCheck\", \"ngAfterViewInit\", \"ngAfterViewChecked\", \"ngAfterContentInit\", \"ngAfterContentChecked\"]);\nvar DirectiveDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, injectableRegistry, refEmitter, referencesRegistry, isCore, strictCtorDeps, semanticDepGraphUpdater, annotateForClosureCompiler, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.metaReader = metaReader;\n    this.injectableRegistry = injectableRegistry;\n    this.refEmitter = refEmitter;\n    this.referencesRegistry = referencesRegistry;\n    this.isCore = isCore;\n    this.strictCtorDeps = strictCtorDeps;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = \"DirectiveDecoratorHandler\";\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      const angularField = this.findClassFieldWithAngularFeatures(node);\n      return angularField ? {\n        trigger: angularField.node,\n        decorator: null,\n        metadata: null\n      } : void 0;\n    } else {\n      const decorator = findAngularDecorator(decorators, \"Directive\", this.isCore);\n      return decorator ? {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      } : void 0;\n    }\n  }\n  analyze(node, decorator, flags = HandlerFlags.NONE) {\n    var _a;\n    if (decorator === null) {\n      if (this.isCore) {\n        return {};\n      }\n      return {\n        diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)]\n      };\n    }\n    this.perf.eventCount(PerfEvent.AnalyzeDirective);\n    const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.refEmitter, this.referencesRegistry, this.isCore, flags, this.annotateForClosureCompiler);\n    if (directiveResult === void 0) {\n      return {};\n    }\n    const analysis = directiveResult.metadata;\n    let providersRequiringFactory = null;\n    if (directiveResult !== void 0 && directiveResult.decorator.has(\"providers\")) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(directiveResult.decorator.get(\"providers\"), this.reflector, this.evaluator);\n    }\n    return {\n      analysis: {\n        inputs: directiveResult.inputs,\n        outputs: directiveResult.outputs,\n        meta: analysis,\n        hostDirectives: directiveResult.hostDirectives,\n        rawHostDirectives: directiveResult.rawHostDirectives,\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),\n        providersRequiringFactory,\n        isPoisoned: false,\n        isStructural: directiveResult.isStructural,\n        decorator: (_a = decorator == null ? void 0 : decorator.node) != null ? _a : null\n      }\n    };\n  }\n  symbol(node, analysis) {\n    const typeParameters = extractSemanticTypeParameters(node);\n    return new DirectiveSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n  }\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata({\n      kind: MetaKind.Directive,\n      matchSource: MatchSource.Selector,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map(query => query.propertyName),\n      isComponent: false,\n      baseClass: analysis.baseClass,\n      hostDirectives: analysis.hostDirectives,\n      ...analysis.typeCheckMeta,\n      isPoisoned: analysis.isPoisoned,\n      isStructural: analysis.isStructural,\n      animationTriggerNames: null,\n      isStandalone: analysis.meta.isStandalone,\n      isSignal: analysis.meta.isSignal,\n      imports: null,\n      schemas: null,\n      decorator: analysis.decorator,\n      assumedToExportProviders: false\n    });\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.meta.deps\n    });\n  }\n  resolve(node, analysis, symbol) {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n    const diagnostics = [];\n    if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof WrappedNodeExpr5) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n    const directiveDiagnostics = getDirectiveDiagnostics(node, this.injectableRegistry, this.evaluator, this.reflector, this.scopeRegistry, this.strictCtorDeps, \"Directive\");\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n    const hostDirectivesDiagnotics = analysis.hostDirectives && analysis.rawHostDirectives ? validateHostDirectives(analysis.rawHostDirectives, analysis.hostDirectives, this.metaReader) : null;\n    if (hostDirectivesDiagnotics !== null) {\n      diagnostics.push(...hostDirectivesDiagnotics);\n    }\n    return {\n      diagnostics: diagnostics.length > 0 ? diagnostics : void 0\n    };\n  }\n  compileFull(node, analysis, resolution, pool) {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDirectiveFromMetadata(analysis.meta, pool, makeBindingParser());\n    const inputTransformFields = compileInputTransformFields(analysis.inputs);\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275dir\", inputTransformFields);\n  }\n  compilePartial(node, analysis, resolution) {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDeclareDirectiveFromMetadata(analysis.meta);\n    const inputTransformFields = compileInputTransformFields(analysis.inputs);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275dir\", inputTransformFields);\n  }\n  findClassFieldWithAngularFeatures(node) {\n    return this.reflector.getMembersOfClass(node).find(member => {\n      if (!member.isStatic && member.kind === ClassMemberKind.Method && LIFECYCLE_HOOKS.has(member.name)) {\n        return true;\n      }\n      if (member.decorators) {\n        return member.decorators.some(decorator => FIELD_DECORATORS.some(decoratorName => isAngularDecorator(decorator, decoratorName, this.isCore)));\n      }\n      return false;\n    });\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/ng_module/src/handler.mjs\nimport { compileClassMetadata as compileClassMetadata2, compileDeclareClassMetadata as compileDeclareClassMetadata2, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileInjector, compileNgModule, ExternalExpr as ExternalExpr5, FactoryTarget as FactoryTarget2, FunctionExpr as FunctionExpr2, InvokeFunctionExpr, LiteralArrayExpr as LiteralArrayExpr2, R3Identifiers, R3SelectorScopeMode, ReturnStatement as ReturnStatement2, WrappedNodeExpr as WrappedNodeExpr6 } from \"@angular/compiler\";\nimport ts22 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/ng_module/src/module_with_providers.mjs\nimport ts21 from \"typescript\";\nfunction createModuleWithProvidersResolver(reflector, isCore) {\n  function _reflectModuleFromTypeParam(type, node) {\n    if (!ts21.isTypeReferenceNode(type)) {\n      return null;\n    }\n    const typeName = type && (ts21.isIdentifier(type.typeName) && type.typeName || ts21.isQualifiedName(type.typeName) && type.typeName.right) || null;\n    if (typeName === null) {\n      return null;\n    }\n    const id = reflector.getImportOfIdentifier(typeName);\n    if (id === null || id.name !== \"ModuleWithProviders\") {\n      return null;\n    }\n    if (!isCore && id.from !== \"@angular/core\") {\n      return null;\n    }\n    if (type.typeArguments === void 0 || type.typeArguments.length !== 1) {\n      const parent = ts21.isMethodDeclaration(node) && ts21.isClassDeclaration(node.parent) ? node.parent : null;\n      const symbolName = (parent && parent.name ? parent.name.getText() + \".\" : \"\") + (node.name ? node.name.getText() : \"anonymous\");\n      throw new FatalDiagnosticError(ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type, `${symbolName} returns a ModuleWithProviders type without a generic type argument. Please add a generic type argument to the ModuleWithProviders type. If this occurrence is in library code you don't control, please contact the library authors.`);\n    }\n    const arg = type.typeArguments[0];\n    return typeNodeToValueExpr(arg);\n  }\n  function _reflectModuleFromLiteralType(type) {\n    if (!ts21.isIntersectionTypeNode(type)) {\n      return null;\n    }\n    for (const t of type.types) {\n      if (ts21.isTypeLiteralNode(t)) {\n        for (const m of t.members) {\n          const ngModuleType = ts21.isPropertySignature(m) && ts21.isIdentifier(m.name) && m.name.text === \"ngModule\" && m.type || null;\n          const ngModuleExpression = ngModuleType && typeNodeToValueExpr(ngModuleType);\n          if (ngModuleExpression) {\n            return ngModuleExpression;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  return (fn, callExpr, resolve, unresolvable) => {\n    var _a;\n    const rawType = fn.node.type;\n    if (rawType === void 0) {\n      return unresolvable;\n    }\n    const type = (_a = _reflectModuleFromTypeParam(rawType, fn.node)) != null ? _a : _reflectModuleFromLiteralType(rawType);\n    if (type === null) {\n      return unresolvable;\n    }\n    const ngModule = resolve(type);\n    if (!(ngModule instanceof Reference) || !isNamedClassDeclaration(ngModule.node)) {\n      return unresolvable;\n    }\n    return new SyntheticValue({\n      ngModule,\n      mwpCall: callExpr\n    });\n  };\n}\nfunction isResolvedModuleWithProviders(sv) {\n  return typeof sv.value === \"object\" && sv.value != null && sv.value.hasOwnProperty(\"ngModule\") && sv.value.hasOwnProperty(\"mwpCall\");\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/ng_module/src/handler.mjs\nvar NgModuleSymbol = class extends SemanticSymbol {\n  constructor(decl, hasProviders) {\n    super(decl);\n    this.hasProviders = hasProviders;\n    this.remotelyScopedComponents = [];\n    this.transitiveImportsFromStandaloneComponents = /* @__PURE__ */new Set();\n  }\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n    if (previousSymbol.hasProviders !== this.hasProviders) {\n      return true;\n    }\n    return false;\n  }\n  isEmitAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n    if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {\n      return true;\n    }\n    for (const currEntry of this.remotelyScopedComponents) {\n      const prevEntry = previousSymbol.remotelyScopedComponents.find(prevEntry2 => {\n        return isSymbolEqual(prevEntry2.component, currEntry.component);\n      });\n      if (prevEntry === void 0) {\n        return true;\n      }\n      if (!isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, isReferenceEqual)) {\n        return true;\n      }\n      if (!isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, isReferenceEqual)) {\n        return true;\n      }\n    }\n    if (previousSymbol.transitiveImportsFromStandaloneComponents.size !== this.transitiveImportsFromStandaloneComponents.size) {\n      return true;\n    }\n    const previousImports = Array.from(previousSymbol.transitiveImportsFromStandaloneComponents);\n    for (const transitiveImport of this.transitiveImportsFromStandaloneComponents) {\n      const prevEntry = previousImports.find(prevEntry2 => isSymbolEqual(prevEntry2, transitiveImport));\n      if (prevEntry === void 0) {\n        return true;\n      }\n      if (transitiveImport.isPublicApiAffected(prevEntry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isTypeCheckApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n    return false;\n  }\n  addRemotelyScopedComponent(component, usedDirectives, usedPipes) {\n    this.remotelyScopedComponents.push({\n      component,\n      usedDirectives,\n      usedPipes\n    });\n  }\n  addTransitiveImportFromStandaloneComponent(importedSymbol) {\n    this.transitiveImportsFromStandaloneComponents.add(importedSymbol);\n  }\n};\nvar NgModuleDecoratorHandler = class {\n  constructor(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, exportedProviderStatusResolver, semanticDepGraphUpdater, isCore, refEmitter, annotateForClosureCompiler, onlyPublishPublicTypings, injectableRegistry, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaReader = metaReader;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.referencesRegistry = referencesRegistry;\n    this.exportedProviderStatusResolver = exportedProviderStatusResolver;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.isCore = isCore;\n    this.refEmitter = refEmitter;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.onlyPublishPublicTypings = onlyPublishPublicTypings;\n    this.injectableRegistry = injectableRegistry;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = \"NgModuleDecoratorHandler\";\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"NgModule\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  analyze(node, decorator) {\n    var _a;\n    this.perf.eventCount(PerfEvent.AnalyzeNgModule);\n    const name = node.name.text;\n    if (decorator.args === null || decorator.args.length > 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @NgModule decorator`);\n    }\n    const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) : ts22.factory.createObjectLiteralExpression([]);\n    if (!ts22.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"@NgModule argument must be an object literal\");\n    }\n    const ngModule = reflectObjectLiteral(meta);\n    if (ngModule.has(\"jit\")) {\n      return {};\n    }\n    const moduleResolvers = combineResolvers([createModuleWithProvidersResolver(this.reflector, this.isCore), forwardRefResolver]);\n    const diagnostics = [];\n    let declarationRefs = [];\n    let rawDeclarations = null;\n    if (ngModule.has(\"declarations\")) {\n      rawDeclarations = ngModule.get(\"declarations\");\n      const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver);\n      declarationRefs = this.resolveTypeList(rawDeclarations, declarationMeta, name, \"declarations\", 0).references;\n      for (const ref of declarationRefs) {\n        if (ref.node.getSourceFile().isDeclarationFile) {\n          const errorNode = ref.getOriginForDiagnostics(rawDeclarations);\n          diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `Cannot declare '${ref.node.name.text}' in an NgModule as it's not a part of the current compilation.`, [makeRelatedInformation(ref.node.name, `'${ref.node.name.text}' is declared here.`)]));\n        }\n      }\n    }\n    if (diagnostics.length > 0) {\n      return {\n        diagnostics\n      };\n    }\n    let importRefs = [];\n    let rawImports = null;\n    if (ngModule.has(\"imports\")) {\n      rawImports = ngModule.get(\"imports\");\n      const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);\n      importRefs = this.resolveTypeList(rawImports, importsMeta, name, \"imports\", 0).references;\n    }\n    let exportRefs = [];\n    let rawExports = null;\n    if (ngModule.has(\"exports\")) {\n      rawExports = ngModule.get(\"exports\");\n      const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);\n      exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, \"exports\", 0).references;\n      this.referencesRegistry.add(node, ...exportRefs);\n    }\n    let bootstrapRefs = [];\n    if (ngModule.has(\"bootstrap\")) {\n      const expr = ngModule.get(\"bootstrap\");\n      const bootstrapMeta = this.evaluator.evaluate(expr, forwardRefResolver);\n      bootstrapRefs = this.resolveTypeList(expr, bootstrapMeta, name, \"bootstrap\", 0).references;\n      for (const ref of bootstrapRefs) {\n        const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n        if (dirMeta == null ? void 0 : dirMeta.isStandalone) {\n          diagnostics.push(makeStandaloneBootstrapDiagnostic(node, ref, expr));\n        }\n      }\n    }\n    const schemas = ngModule.has(\"schemas\") ? extractSchemas(ngModule.get(\"schemas\"), this.evaluator, \"NgModule\") : [];\n    let id = null;\n    if (ngModule.has(\"id\")) {\n      const idExpr = ngModule.get(\"id\");\n      if (!isModuleIdExpression(idExpr)) {\n        id = new WrappedNodeExpr6(idExpr);\n      } else {\n        const diag = makeDiagnostic(ErrorCode.WARN_NGMODULE_ID_UNNECESSARY, idExpr, `Using 'module.id' for NgModule.id is a common anti-pattern that is ignored by the Angular compiler.`);\n        diag.category = ts22.DiagnosticCategory.Warning;\n        diagnostics.push(diag);\n      }\n    }\n    const valueContext = node.getSourceFile();\n    const exportedNodes = new Set(exportRefs.map(ref => ref.node));\n    const declarations = [];\n    const exportedDeclarations = [];\n    const bootstrap = bootstrapRefs.map(bootstrap2 => this._toR3Reference(bootstrap2.getOriginForDiagnostics(meta, node.name), bootstrap2, valueContext));\n    for (const ref of declarationRefs) {\n      const decl = this._toR3Reference(ref.getOriginForDiagnostics(meta, node.name), ref, valueContext);\n      declarations.push(decl);\n      if (exportedNodes.has(ref.node)) {\n        exportedDeclarations.push(decl.type);\n      }\n    }\n    const imports = importRefs.map(imp => this._toR3Reference(imp.getOriginForDiagnostics(meta, node.name), imp, valueContext));\n    const exports = exportRefs.map(exp => this._toR3Reference(exp.getOriginForDiagnostics(meta, node.name), exp, valueContext));\n    const isForwardReference = ref => isExpressionForwardReference(ref.value, node.name, valueContext);\n    const containsForwardDecls = bootstrap.some(isForwardReference) || declarations.some(isForwardReference) || imports.some(isForwardReference) || exports.some(isForwardReference);\n    const type = wrapTypeReference(this.reflector, node);\n    const ngModuleMetadata = {\n      type,\n      bootstrap,\n      declarations,\n      publicDeclarationTypes: this.onlyPublishPublicTypings ? exportedDeclarations : null,\n      exports,\n      imports,\n      includeImportTypes: !this.onlyPublishPublicTypings,\n      containsForwardDecls,\n      id,\n      selectorScopeMode: R3SelectorScopeMode.SideEffect,\n      schemas: []\n    };\n    const rawProviders = ngModule.has(\"providers\") ? ngModule.get(\"providers\") : null;\n    let wrappedProviders = null;\n    if (rawProviders !== null && (!ts22.isArrayLiteralExpression(rawProviders) || rawProviders.elements.length > 0)) {\n      wrappedProviders = new WrappedNodeExpr6(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(rawProviders) : rawProviders);\n    }\n    const topLevelImports = [];\n    if (ngModule.has(\"imports\")) {\n      const rawImports2 = unwrapExpression(ngModule.get(\"imports\"));\n      let topLevelExpressions = [];\n      if (ts22.isArrayLiteralExpression(rawImports2)) {\n        for (const element of rawImports2.elements) {\n          if (ts22.isSpreadElement(element)) {\n            topLevelExpressions.push(element.expression);\n            continue;\n          }\n          topLevelExpressions.push(element);\n        }\n      } else {\n        topLevelExpressions.push(rawImports2);\n      }\n      let absoluteIndex = 0;\n      for (const importExpr of topLevelExpressions) {\n        const resolved = this.evaluator.evaluate(importExpr, moduleResolvers);\n        const {\n          references,\n          hasModuleWithProviders\n        } = this.resolveTypeList(importExpr, [resolved], node.name.text, \"imports\", absoluteIndex);\n        absoluteIndex += references.length;\n        topLevelImports.push({\n          expression: importExpr,\n          resolvedReferences: references,\n          hasModuleWithProviders\n        });\n      }\n    }\n    const injectorMetadata = {\n      name,\n      type,\n      providers: wrappedProviders\n    };\n    const factoryMetadata = {\n      name,\n      type,\n      typeArgumentCount: 0,\n      deps: getValidConstructorDependencies(node, this.reflector, this.isCore),\n      target: FactoryTarget2.NgModule\n    };\n    const remoteScopesMayRequireCycleProtection = declarationRefs.some(isSyntheticReference) || importRefs.some(isSyntheticReference);\n    return {\n      diagnostics: diagnostics.length > 0 ? diagnostics : void 0,\n      analysis: {\n        id,\n        schemas,\n        mod: ngModuleMetadata,\n        inj: injectorMetadata,\n        fac: factoryMetadata,\n        declarations: declarationRefs,\n        rawDeclarations,\n        imports: topLevelImports,\n        rawImports,\n        importRefs,\n        exports: exportRefs,\n        rawExports,\n        providers: rawProviders,\n        providersRequiringFactory: rawProviders ? resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator) : null,\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        factorySymbolName: node.name.text,\n        remoteScopesMayRequireCycleProtection,\n        decorator: (_a = decorator == null ? void 0 : decorator.node) != null ? _a : null\n      }\n    };\n  }\n  symbol(node, analysis) {\n    return new NgModuleSymbol(node, analysis.providers !== null);\n  }\n  register(node, analysis) {\n    this.metaRegistry.registerNgModuleMetadata({\n      kind: MetaKind.NgModule,\n      ref: new Reference(node),\n      schemas: analysis.schemas,\n      declarations: analysis.declarations,\n      imports: analysis.importRefs,\n      exports: analysis.exports,\n      rawDeclarations: analysis.rawDeclarations,\n      rawImports: analysis.rawImports,\n      rawExports: analysis.rawExports,\n      decorator: analysis.decorator,\n      mayDeclareProviders: analysis.providers !== null\n    });\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.fac.deps\n    });\n  }\n  resolve(node, analysis) {\n    const scope = this.scopeRegistry.getScopeOfModule(node);\n    const diagnostics = [];\n    const scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);\n    if (scopeDiagnostics !== null) {\n      diagnostics.push(...scopeDiagnostics);\n    }\n    if (analysis.providersRequiringFactory !== null) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.providers, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n    const data = {\n      injectorImports: []\n    };\n    for (const topLevelImport of analysis.imports) {\n      if (topLevelImport.hasModuleWithProviders) {\n        data.injectorImports.push(new WrappedNodeExpr6(topLevelImport.expression));\n        continue;\n      }\n      const refsToEmit = [];\n      let symbol = null;\n      if (this.semanticDepGraphUpdater !== null) {\n        const sym = this.semanticDepGraphUpdater.getSymbol(node);\n        if (sym instanceof NgModuleSymbol) {\n          symbol = sym;\n        }\n      }\n      for (const ref of topLevelImport.resolvedReferences) {\n        const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n        if (dirMeta !== null) {\n          if (!dirMeta.isComponent) {\n            continue;\n          }\n          const mayExportProviders = this.exportedProviderStatusResolver.mayExportProviders(dirMeta.ref, importRef => {\n            if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n              const importSymbol = this.semanticDepGraphUpdater.getSymbol(importRef.node);\n              symbol.addTransitiveImportFromStandaloneComponent(importSymbol);\n            }\n          });\n          if (!mayExportProviders) {\n            continue;\n          }\n        }\n        const pipeMeta = dirMeta === null ? this.metaReader.getPipeMetadata(ref) : null;\n        if (pipeMeta !== null) {\n          continue;\n        }\n        refsToEmit.push(ref);\n      }\n      if (refsToEmit.length === topLevelImport.resolvedReferences.length) {\n        data.injectorImports.push(new WrappedNodeExpr6(topLevelImport.expression));\n      } else {\n        const context = node.getSourceFile();\n        for (const ref of refsToEmit) {\n          const emittedRef = this.refEmitter.emit(ref, context);\n          assertSuccessfulReferenceEmit(emittedRef, topLevelImport.expression, \"class\");\n          data.injectorImports.push(emittedRef.expression);\n        }\n      }\n    }\n    if (scope !== null && !scope.compilation.isPoisoned) {\n      const context = getSourceFile(node);\n      for (const exportRef of analysis.exports) {\n        if (isNgModule(exportRef.node, scope.compilation)) {\n          const type = this.refEmitter.emit(exportRef, context);\n          assertSuccessfulReferenceEmit(type, node, \"NgModule\");\n          data.injectorImports.push(type.expression);\n        }\n      }\n      for (const decl of analysis.declarations) {\n        const dirMeta = this.metaReader.getDirectiveMetadata(decl);\n        if (dirMeta !== null) {\n          const refType = dirMeta.isComponent ? \"Component\" : \"Directive\";\n          if (dirMeta.selector === null) {\n            throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node, `${refType} ${decl.node.name.text} has no selector, please add it!`);\n          }\n          continue;\n        }\n      }\n    }\n    if (diagnostics.length > 0) {\n      return {\n        diagnostics\n      };\n    }\n    if (scope === null || scope.compilation.isPoisoned || scope.exported.isPoisoned || scope.reexports === null) {\n      return {\n        data\n      };\n    } else {\n      return {\n        data,\n        reexports: scope.reexports\n      };\n    }\n  }\n  compileFull(node, {\n    inj,\n    mod,\n    fac,\n    classMetadata,\n    declarations,\n    remoteScopesMayRequireCycleProtection\n  }, {\n    injectorImports\n  }) {\n    const factoryFn = compileNgFactoryDefField(fac);\n    const ngInjectorDef = compileInjector({\n      ...inj,\n      imports: injectorImports\n    });\n    const ngModuleDef = compileNgModule(mod);\n    const statements = ngModuleDef.statements;\n    const metadata = classMetadata !== null ? compileClassMetadata2(classMetadata) : null;\n    this.insertMetadataStatement(statements, metadata);\n    this.appendRemoteScopingStatements(statements, node, declarations, remoteScopesMayRequireCycleProtection);\n    return this.compileNgModule(factoryFn, ngInjectorDef, ngModuleDef);\n  }\n  compilePartial(node, {\n    inj,\n    fac,\n    mod,\n    classMetadata\n  }, {\n    injectorImports\n  }) {\n    const factoryFn = compileDeclareFactory(fac);\n    const injectorDef = compileDeclareInjectorFromMetadata({\n      ...inj,\n      imports: injectorImports\n    });\n    const ngModuleDef = compileDeclareNgModuleFromMetadata(mod);\n    const metadata = classMetadata !== null ? compileDeclareClassMetadata2(classMetadata) : null;\n    this.insertMetadataStatement(ngModuleDef.statements, metadata);\n    return this.compileNgModule(factoryFn, injectorDef, ngModuleDef);\n  }\n  insertMetadataStatement(ngModuleStatements, metadata) {\n    if (metadata !== null) {\n      ngModuleStatements.unshift(metadata.toStmt());\n    }\n  }\n  appendRemoteScopingStatements(ngModuleStatements, node, declarations, remoteScopesMayRequireCycleProtection) {\n    const context = getSourceFile(node);\n    for (const decl of declarations) {\n      const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);\n      if (remoteScope !== null) {\n        const directives = remoteScope.directives.map(directive => {\n          const type = this.refEmitter.emit(directive, context);\n          assertSuccessfulReferenceEmit(type, node, \"directive\");\n          return type.expression;\n        });\n        const pipes = remoteScope.pipes.map(pipe => {\n          const type = this.refEmitter.emit(pipe, context);\n          assertSuccessfulReferenceEmit(type, node, \"pipe\");\n          return type.expression;\n        });\n        const directiveArray = new LiteralArrayExpr2(directives);\n        const pipesArray = new LiteralArrayExpr2(pipes);\n        const directiveExpr = remoteScopesMayRequireCycleProtection && directives.length > 0 ? new FunctionExpr2([], [new ReturnStatement2(directiveArray)]) : directiveArray;\n        const pipesExpr = remoteScopesMayRequireCycleProtection && pipes.length > 0 ? new FunctionExpr2([], [new ReturnStatement2(pipesArray)]) : pipesArray;\n        const componentType = this.refEmitter.emit(decl, context);\n        assertSuccessfulReferenceEmit(componentType, node, \"component\");\n        const declExpr = componentType.expression;\n        const setComponentScope = new ExternalExpr5(R3Identifiers.setComponentScope);\n        const callExpr = new InvokeFunctionExpr(setComponentScope, [declExpr, directiveExpr, pipesExpr]);\n        ngModuleStatements.push(callExpr.toStmt());\n      }\n    }\n  }\n  compileNgModule(factoryFn, injectorDef, ngModuleDef) {\n    const res = [factoryFn, {\n      name: \"\\u0275mod\",\n      initializer: ngModuleDef.expression,\n      statements: ngModuleDef.statements,\n      type: ngModuleDef.type\n    }, {\n      name: \"\\u0275inj\",\n      initializer: injectorDef.expression,\n      statements: injectorDef.statements,\n      type: injectorDef.type\n    }];\n    return res;\n  }\n  _toR3Reference(origin, valueRef, valueContext) {\n    if (valueRef.hasOwningModuleGuess) {\n      return toR3Reference(origin, valueRef, valueContext, this.refEmitter);\n    } else {\n      return toR3Reference(origin, valueRef, valueContext, this.refEmitter);\n    }\n  }\n  isClassDeclarationReference(ref) {\n    return this.reflector.isClass(ref.node);\n  }\n  resolveTypeList(expr, resolvedList, className, arrayName, absoluteIndex) {\n    let hasModuleWithProviders = false;\n    const refList = [];\n    if (!Array.isArray(resolvedList)) {\n      throw createValueHasWrongTypeError(expr, resolvedList, `Expected array when reading the NgModule.${arrayName} of ${className}`);\n    }\n    for (let idx = 0; idx < resolvedList.length; idx++) {\n      let entry = resolvedList[idx];\n      if (entry instanceof SyntheticValue && isResolvedModuleWithProviders(entry)) {\n        entry = entry.value.ngModule;\n        hasModuleWithProviders = true;\n      } else if (entry instanceof Map && entry.has(\"ngModule\")) {\n        entry = entry.get(\"ngModule\");\n        hasModuleWithProviders = true;\n      }\n      if (Array.isArray(entry)) {\n        const recursiveResult = this.resolveTypeList(expr, entry, className, arrayName, absoluteIndex);\n        refList.push(...recursiveResult.references);\n        absoluteIndex += recursiveResult.references.length;\n        hasModuleWithProviders = hasModuleWithProviders || recursiveResult.hasModuleWithProviders;\n      } else if (entry instanceof Reference) {\n        if (!this.isClassDeclarationReference(entry)) {\n          throw createValueHasWrongTypeError(entry.node, entry, `Value at position ${absoluteIndex} in the NgModule.${arrayName} of ${className} is not a class`);\n        }\n        refList.push(entry);\n        absoluteIndex += 1;\n      } else {\n        throw createValueHasWrongTypeError(expr, entry, `Value at position ${absoluteIndex} in the NgModule.${arrayName} of ${className} is not a reference`);\n      }\n    }\n    return {\n      references: refList,\n      hasModuleWithProviders\n    };\n  }\n};\nfunction isNgModule(node, compilation) {\n  return !compilation.dependencies.some(dep => dep.ref.node === node);\n}\nfunction isModuleIdExpression(expr) {\n  return ts22.isPropertyAccessExpression(expr) && ts22.isIdentifier(expr.expression) && expr.expression.text === \"module\" && expr.name.text === \"id\";\n}\nfunction makeStandaloneBootstrapDiagnostic(ngModuleClass, bootstrappedClassRef, rawBootstrapExpr) {\n  const componentClassName = bootstrappedClassRef.node.name.text;\n  const message = `The \\`${componentClassName}\\` class is a standalone component, which can not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` function for bootstrap instead.`;\n  const relatedInformation = [makeRelatedInformation(ngModuleClass, `The 'bootstrap' array is present on this NgModule.`)];\n  return makeDiagnostic(ErrorCode.NGMODULE_BOOTSTRAP_IS_STANDALONE, getDiagnosticNode(bootstrappedClassRef, rawBootstrapExpr), message, relatedInformation);\n}\nfunction isSyntheticReference(ref) {\n  return ref.synthetic;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/diagnostics.mjs\nfunction makeCyclicImportInfo(ref, type, cycle) {\n  const name = ref.debugName || \"(unknown)\";\n  const path = cycle.getPath().map(sf => sf.fileName).join(\" -> \");\n  const message = `The ${type} '${name}' is used in the template but importing it would create a cycle: `;\n  return makeRelatedInformation(ref.node, message + path);\n}\nfunction checkCustomElementSelectorForErrors(selector) {\n  if (selector.includes(\".\") || selector.includes(\"[\") && selector.includes(\"]\")) {\n    return null;\n  }\n  if (!/^[a-z]/.test(selector)) {\n    return \"Selector of a ShadowDom-encapsulated component must start with a lower case letter.\";\n  }\n  if (/[A-Z]/.test(selector)) {\n    return \"Selector of a ShadowDom-encapsulated component must all be in lower case.\";\n  }\n  if (!selector.includes(\"-\")) {\n    return \"Selector of a component that uses ViewEncapsulation.ShadowDom must contain a hyphen.\";\n  }\n  return null;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/resources.mjs\nimport { DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig, ParseSourceFile as ParseSourceFile2, parseTemplate } from \"@angular/compiler\";\nimport ts23 from \"typescript\";\nfunction getTemplateDeclarationNodeForError(declaration) {\n  return declaration.isInline ? declaration.expression : declaration.templateUrlExpression;\n}\nfunction extractTemplate(node, template, evaluator, depTracker, resourceLoader, options) {\n  if (template.isInline) {\n    let sourceStr;\n    let sourceParseRange = null;\n    let templateContent;\n    let sourceMapping;\n    let escapedString = false;\n    let sourceMapUrl;\n    if (ts23.isStringLiteral(template.expression) || ts23.isNoSubstitutionTemplateLiteral(template.expression)) {\n      sourceParseRange = getTemplateRange(template.expression);\n      sourceStr = template.expression.getSourceFile().text;\n      templateContent = template.expression.text;\n      escapedString = true;\n      sourceMapping = {\n        type: \"direct\",\n        node: template.expression\n      };\n      sourceMapUrl = template.resolvedTemplateUrl;\n    } else {\n      const resolvedTemplate = evaluator.evaluate(template.expression);\n      if (typeof resolvedTemplate !== \"string\") {\n        throw createValueHasWrongTypeError(template.expression, resolvedTemplate, \"template must be a string\");\n      }\n      sourceStr = resolvedTemplate;\n      templateContent = resolvedTemplate;\n      sourceMapping = {\n        type: \"indirect\",\n        node: template.expression,\n        componentClass: node,\n        template: templateContent\n      };\n      sourceMapUrl = null;\n    }\n    return {\n      ...parseExtractedTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl, options),\n      content: templateContent,\n      sourceMapping,\n      declaration: template\n    };\n  } else {\n    const templateContent = resourceLoader.load(template.resolvedTemplateUrl);\n    if (depTracker !== null) {\n      depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));\n    }\n    return {\n      ...parseExtractedTemplate(template, templateContent, null, false, template.resolvedTemplateUrl, options),\n      content: templateContent,\n      sourceMapping: {\n        type: \"external\",\n        componentClass: node,\n        node: template.templateUrlExpression,\n        template: templateContent,\n        templateUrl: template.resolvedTemplateUrl\n      },\n      declaration: template\n    };\n  }\n}\nfunction parseExtractedTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl, options) {\n  const i18nNormalizeLineEndingsInICUs = escapedString || options.i18nNormalizeLineEndingsInICUs;\n  const parsedTemplate = parseTemplate(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\", {\n    preserveWhitespaces: template.preserveWhitespaces,\n    interpolationConfig: template.interpolationConfig,\n    range: sourceParseRange != null ? sourceParseRange : void 0,\n    escapedString,\n    enableI18nLegacyMessageIdFormat: options.enableI18nLegacyMessageIdFormat,\n    i18nNormalizeLineEndingsInICUs,\n    alwaysAttemptHtmlToR3AstConversion: options.usePoisonedData\n  });\n  const {\n    nodes: diagNodes\n  } = parseTemplate(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\", {\n    preserveWhitespaces: true,\n    preserveLineEndings: true,\n    interpolationConfig: template.interpolationConfig,\n    range: sourceParseRange != null ? sourceParseRange : void 0,\n    escapedString,\n    enableI18nLegacyMessageIdFormat: options.enableI18nLegacyMessageIdFormat,\n    i18nNormalizeLineEndingsInICUs,\n    leadingTriviaChars: [],\n    alwaysAttemptHtmlToR3AstConversion: options.usePoisonedData\n  });\n  return {\n    ...parsedTemplate,\n    diagNodes,\n    file: new ParseSourceFile2(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\")\n  };\n}\nfunction parseTemplateDeclaration(node, decorator, component, containingFile, evaluator, depTracker, resourceLoader, defaultPreserveWhitespaces) {\n  let preserveWhitespaces = defaultPreserveWhitespaces;\n  if (component.has(\"preserveWhitespaces\")) {\n    const expr = component.get(\"preserveWhitespaces\");\n    const value = evaluator.evaluate(expr);\n    if (typeof value !== \"boolean\") {\n      throw createValueHasWrongTypeError(expr, value, \"preserveWhitespaces must be a boolean\");\n    }\n    preserveWhitespaces = value;\n  }\n  let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n  if (component.has(\"interpolation\")) {\n    const expr = component.get(\"interpolation\");\n    const value = evaluator.evaluate(expr);\n    if (!Array.isArray(value) || value.length !== 2 || !value.every(element => typeof element === \"string\")) {\n      throw createValueHasWrongTypeError(expr, value, \"interpolation must be an array with 2 elements of string type\");\n    }\n    interpolationConfig = InterpolationConfig.fromArray(value);\n  }\n  if (component.has(\"templateUrl\")) {\n    const templateUrlExpr = component.get(\"templateUrl\");\n    const templateUrl = evaluator.evaluate(templateUrlExpr);\n    if (typeof templateUrl !== \"string\") {\n      throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, \"templateUrl must be a string\");\n    }\n    try {\n      const resourceUrl = resourceLoader.resolve(templateUrl, containingFile);\n      return {\n        isInline: false,\n        interpolationConfig,\n        preserveWhitespaces,\n        templateUrl,\n        templateUrlExpression: templateUrlExpr,\n        resolvedTemplateUrl: resourceUrl\n      };\n    } catch (e) {\n      if (depTracker !== null) {\n        depTracker.recordDependencyAnalysisFailure(node.getSourceFile());\n      }\n      throw makeResourceNotFoundError(templateUrl, templateUrlExpr, 0);\n    }\n  } else if (component.has(\"template\")) {\n    return {\n      isInline: true,\n      interpolationConfig,\n      preserveWhitespaces,\n      expression: component.get(\"template\"),\n      templateUrl: containingFile,\n      resolvedTemplateUrl: containingFile\n    };\n  } else {\n    throw new FatalDiagnosticError(ErrorCode.COMPONENT_MISSING_TEMPLATE, decorator.node, \"component is missing a template\");\n  }\n}\nfunction preloadAndParseTemplate(evaluator, resourceLoader, depTracker, preanalyzeTemplateCache, node, decorator, component, containingFile, defaultPreserveWhitespaces, options) {\n  if (component.has(\"templateUrl\")) {\n    const templateUrlExpr = component.get(\"templateUrl\");\n    const templateUrl = evaluator.evaluate(templateUrlExpr);\n    if (typeof templateUrl !== \"string\") {\n      throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, \"templateUrl must be a string\");\n    }\n    try {\n      const resourceUrl = resourceLoader.resolve(templateUrl, containingFile);\n      const templatePromise = resourceLoader.preload(resourceUrl, {\n        type: \"template\",\n        containingFile\n      });\n      if (templatePromise !== void 0) {\n        return templatePromise.then(() => {\n          const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, evaluator, depTracker, resourceLoader, defaultPreserveWhitespaces);\n          const template = extractTemplate(node, templateDecl, evaluator, depTracker, resourceLoader, options);\n          preanalyzeTemplateCache.set(node, template);\n          return template;\n        });\n      } else {\n        return Promise.resolve(null);\n      }\n    } catch (e) {\n      if (depTracker !== null) {\n        depTracker.recordDependencyAnalysisFailure(node.getSourceFile());\n      }\n      throw makeResourceNotFoundError(templateUrl, templateUrlExpr, 0);\n    }\n  } else {\n    const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, evaluator, depTracker, resourceLoader, defaultPreserveWhitespaces);\n    const template = extractTemplate(node, templateDecl, evaluator, depTracker, resourceLoader, options);\n    preanalyzeTemplateCache.set(node, template);\n    return Promise.resolve(template);\n  }\n}\nfunction getTemplateRange(templateExpr) {\n  const startPos = templateExpr.getStart() + 1;\n  const {\n    line,\n    character\n  } = ts23.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos);\n  return {\n    startPos,\n    startLine: line,\n    startCol: character,\n    endPos: templateExpr.getEnd() - 1\n  };\n}\nfunction makeResourceNotFoundError(file, nodeForError, resourceType) {\n  let errorText;\n  switch (resourceType) {\n    case 0:\n      errorText = `Could not find template file '${file}'.`;\n      break;\n    case 1:\n      errorText = `Could not find stylesheet file '${file}' linked from the template.`;\n      break;\n    case 2:\n      errorText = `Could not find stylesheet file '${file}'.`;\n      break;\n  }\n  return new FatalDiagnosticError(ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n}\nfunction transformDecoratorResources(dec, component, styles, template) {\n  if (dec.name !== \"Component\") {\n    return dec;\n  }\n  if (!component.has(\"templateUrl\") && !component.has(\"styleUrls\") && !component.has(\"styles\")) {\n    return dec;\n  }\n  const metadata = new Map(component);\n  if (metadata.has(\"templateUrl\")) {\n    metadata.delete(\"templateUrl\");\n    metadata.set(\"template\", ts23.factory.createStringLiteral(template.content));\n  }\n  if (metadata.has(\"styleUrls\") || metadata.has(\"styles\")) {\n    metadata.delete(\"styles\");\n    metadata.delete(\"styleUrls\");\n    if (styles.length > 0) {\n      const styleNodes = styles.reduce((result, style) => {\n        if (style.trim().length > 0) {\n          result.push(ts23.factory.createStringLiteral(style));\n        }\n        return result;\n      }, []);\n      if (styleNodes.length > 0) {\n        metadata.set(\"styles\", ts23.factory.createArrayLiteralExpression(styleNodes));\n      }\n    }\n  }\n  const newMetadataFields = [];\n  for (const [name, value] of metadata.entries()) {\n    newMetadataFields.push(ts23.factory.createPropertyAssignment(name, value));\n  }\n  return {\n    ...dec,\n    args: [ts23.factory.createObjectLiteralExpression(newMetadataFields)]\n  };\n}\nfunction extractComponentStyleUrls(evaluator, component) {\n  if (!component.has(\"styleUrls\")) {\n    return [];\n  }\n  return extractStyleUrlsFromExpression(evaluator, component.get(\"styleUrls\"));\n}\nfunction extractStyleUrlsFromExpression(evaluator, styleUrlsExpr) {\n  const styleUrls = [];\n  if (ts23.isArrayLiteralExpression(styleUrlsExpr)) {\n    for (const styleUrlExpr of styleUrlsExpr.elements) {\n      if (ts23.isSpreadElement(styleUrlExpr)) {\n        styleUrls.push(...extractStyleUrlsFromExpression(evaluator, styleUrlExpr.expression));\n      } else {\n        const styleUrl = evaluator.evaluate(styleUrlExpr);\n        if (typeof styleUrl !== \"string\") {\n          throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, \"styleUrl must be a string\");\n        }\n        styleUrls.push({\n          url: styleUrl,\n          source: 2,\n          nodeForError: styleUrlExpr\n        });\n      }\n    }\n  } else {\n    const evaluatedStyleUrls = evaluator.evaluate(styleUrlsExpr);\n    if (!isStringArray(evaluatedStyleUrls)) {\n      throw createValueHasWrongTypeError(styleUrlsExpr, evaluatedStyleUrls, \"styleUrls must be an array of strings\");\n    }\n    for (const styleUrl of evaluatedStyleUrls) {\n      styleUrls.push({\n        url: styleUrl,\n        source: 2,\n        nodeForError: styleUrlsExpr\n      });\n    }\n  }\n  return styleUrls;\n}\nfunction extractStyleResources(resourceLoader, component, containingFile) {\n  const styles = /* @__PURE__ */new Set();\n  function stringLiteralElements(array) {\n    return array.elements.filter(e => ts23.isStringLiteralLike(e));\n  }\n  const styleUrlsExpr = component.get(\"styleUrls\");\n  if (styleUrlsExpr !== void 0 && ts23.isArrayLiteralExpression(styleUrlsExpr)) {\n    for (const expression of stringLiteralElements(styleUrlsExpr)) {\n      try {\n        const resourceUrl = resourceLoader.resolve(expression.text, containingFile);\n        styles.add({\n          path: absoluteFrom(resourceUrl),\n          expression\n        });\n      } catch {}\n    }\n  }\n  const stylesExpr = component.get(\"styles\");\n  if (stylesExpr !== void 0 && ts23.isArrayLiteralExpression(stylesExpr)) {\n    for (const expression of stringLiteralElements(stylesExpr)) {\n      styles.add({\n        path: null,\n        expression\n      });\n    }\n  }\n  return styles;\n}\nfunction _extractTemplateStyleUrls(template) {\n  if (template.styleUrls === null) {\n    return [];\n  }\n  const nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n  return template.styleUrls.map(url => ({\n    url,\n    source: 1,\n    nodeForError\n  }));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/symbol.mjs\nvar ComponentSymbol = class extends DirectiveSymbol {\n  constructor() {\n    super(...arguments);\n    this.usedDirectives = [];\n    this.usedPipes = [];\n    this.isRemotelyScoped = false;\n  }\n  isEmitAffected(previousSymbol, publicApiAffected) {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n    const isSymbolUnaffected = (current, previous) => isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);\n    return this.isRemotelyScoped !== previousSymbol.isRemotelyScoped || !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) || !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected);\n  }\n  isTypeCheckBlockAffected(previousSymbol, typeCheckApiAffected) {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n    const isInheritanceChainAffected = symbol => {\n      let currentSymbol = symbol;\n      while (currentSymbol instanceof DirectiveSymbol) {\n        if (typeCheckApiAffected.has(currentSymbol)) {\n          return true;\n        }\n        currentSymbol = currentSymbol.baseClass;\n      }\n      return false;\n    };\n    const isDirectiveUnaffected = (current, previous) => isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);\n    const isPipeUnaffected = (current, previous) => isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);\n    return !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) || !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/util.mjs\nfunction collectAnimationNames(value, animationTriggerNames) {\n  if (value instanceof Map) {\n    const name = value.get(\"name\");\n    if (typeof name === \"string\") {\n      animationTriggerNames.staticTriggerNames.push(name);\n    } else {\n      animationTriggerNames.includesDynamicAnimations = true;\n    }\n  } else if (Array.isArray(value)) {\n    for (const resolvedValue of value) {\n      collectAnimationNames(resolvedValue, animationTriggerNames);\n    }\n  } else {\n    animationTriggerNames.includesDynamicAnimations = true;\n  }\n}\nfunction isAngularAnimationsReference(reference, symbolName) {\n  return reference.ownedByModuleGuess === \"@angular/animations\" && reference.debugName === symbolName;\n}\nvar animationTriggerResolver = (fn, node, resolve, unresolvable) => {\n  const animationTriggerMethodName = \"trigger\";\n  if (!isAngularAnimationsReference(fn, animationTriggerMethodName)) {\n    return unresolvable;\n  }\n  const triggerNameExpression = node.arguments[0];\n  if (!triggerNameExpression) {\n    return unresolvable;\n  }\n  const res = /* @__PURE__ */new Map();\n  res.set(\"name\", resolve(triggerNameExpression));\n  return res;\n};\nfunction validateAndFlattenComponentImports(imports, expr) {\n  const flattened = [];\n  if (!Array.isArray(imports)) {\n    const error = createValueHasWrongTypeError(expr, imports, `'imports' must be an array of components, directives, pipes, or NgModules.`).toDiagnostic();\n    return {\n      imports: [],\n      diagnostics: [error]\n    };\n  }\n  const diagnostics = [];\n  for (const ref of imports) {\n    if (Array.isArray(ref)) {\n      const {\n        imports: childImports,\n        diagnostics: childDiagnostics\n      } = validateAndFlattenComponentImports(ref, expr);\n      flattened.push(...childImports);\n      diagnostics.push(...childDiagnostics);\n    } else if (ref instanceof Reference) {\n      if (isNamedClassDeclaration(ref.node)) {\n        flattened.push(ref);\n      } else {\n        diagnostics.push(createValueHasWrongTypeError(ref.getOriginForDiagnostics(expr), ref, `'imports' must be an array of components, directives, pipes, or NgModules.`).toDiagnostic());\n      }\n    } else if (isLikelyModuleWithProviders(ref)) {\n      let origin = expr;\n      if (ref instanceof SyntheticValue) {\n        origin = getOriginNodeForDiagnostics(ref.value.mwpCall, expr);\n      }\n      diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_UNKNOWN_IMPORT, origin, `'imports' contains a ModuleWithProviders value, likely the result of a 'Module.forRoot()'-style call. These calls are not used to configure components and are not valid in standalone component imports - consider importing them in the application bootstrap instead.`));\n    } else {\n      diagnostics.push(createValueHasWrongTypeError(expr, imports, `'imports' must be an array of components, directives, pipes, or NgModules.`).toDiagnostic());\n    }\n  }\n  return {\n    imports: flattened,\n    diagnostics\n  };\n}\nfunction isLikelyModuleWithProviders(value) {\n  if (value instanceof SyntheticValue && isResolvedModuleWithProviders(value)) {\n    return true;\n  }\n  if (value instanceof Map && value.has(\"ngModule\")) {\n    return true;\n  }\n  return false;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/handler.mjs\nvar EMPTY_ARRAY2 = [];\nvar ComponentDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, metaReader, scopeReader, dtsScopeReader, scopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, strictCtorDeps, resourceLoader, rootDirs, defaultPreserveWhitespaces, i18nUseExternalIds, enableI18nLegacyMessageIdFormat, usePoisonedData, i18nNormalizeLineEndingsInICUs, moduleResolver, cycleAnalyzer, cycleHandlingStrategy, refEmitter, referencesRegistry, depTracker, injectableRegistry, semanticDepGraphUpdater, annotateForClosureCompiler, perf, hostDirectivesResolver) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.metaReader = metaReader;\n    this.scopeReader = scopeReader;\n    this.dtsScopeReader = dtsScopeReader;\n    this.scopeRegistry = scopeRegistry;\n    this.typeCheckScopeRegistry = typeCheckScopeRegistry;\n    this.resourceRegistry = resourceRegistry;\n    this.isCore = isCore;\n    this.strictCtorDeps = strictCtorDeps;\n    this.resourceLoader = resourceLoader;\n    this.rootDirs = rootDirs;\n    this.defaultPreserveWhitespaces = defaultPreserveWhitespaces;\n    this.i18nUseExternalIds = i18nUseExternalIds;\n    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n    this.usePoisonedData = usePoisonedData;\n    this.i18nNormalizeLineEndingsInICUs = i18nNormalizeLineEndingsInICUs;\n    this.moduleResolver = moduleResolver;\n    this.cycleAnalyzer = cycleAnalyzer;\n    this.cycleHandlingStrategy = cycleHandlingStrategy;\n    this.refEmitter = refEmitter;\n    this.referencesRegistry = referencesRegistry;\n    this.depTracker = depTracker;\n    this.injectableRegistry = injectableRegistry;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.perf = perf;\n    this.hostDirectivesResolver = hostDirectivesResolver;\n    this.literalCache = /* @__PURE__ */new Map();\n    this.elementSchemaRegistry = new DomElementSchemaRegistry();\n    this.preanalyzeTemplateCache = /* @__PURE__ */new Map();\n    this.preanalyzeStylesCache = /* @__PURE__ */new Map();\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = \"ComponentDecoratorHandler\";\n    this.extractTemplateOptions = {\n      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n      i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,\n      usePoisonedData: this.usePoisonedData\n    };\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"Component\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  preanalyze(node, decorator) {\n    if (!this.resourceLoader.canPreload) {\n      return void 0;\n    }\n    const meta = resolveLiteral(decorator, this.literalCache);\n    const component = reflectObjectLiteral(meta);\n    const containingFile = node.getSourceFile().fileName;\n    const resolveStyleUrl = styleUrl => {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n        return this.resourceLoader.preload(resourceUrl, {\n          type: \"style\",\n          containingFile\n        });\n      } catch {\n        return void 0;\n      }\n    };\n    const templateAndTemplateStyleResources = preloadAndParseTemplate(this.evaluator, this.resourceLoader, this.depTracker, this.preanalyzeTemplateCache, node, decorator, component, containingFile, this.defaultPreserveWhitespaces, this.extractTemplateOptions).then(template => {\n      if (template === null) {\n        return void 0;\n      }\n      return Promise.all(template.styleUrls.map(styleUrl => resolveStyleUrl(styleUrl))).then(() => void 0);\n    });\n    const componentStyleUrls = extractComponentStyleUrls(this.evaluator, component);\n    let inlineStyles;\n    if (component.has(\"styles\")) {\n      const litStyles = parseFieldStringArrayValue(component, \"styles\", this.evaluator);\n      if (litStyles === null) {\n        this.preanalyzeStylesCache.set(node, null);\n      } else {\n        inlineStyles = Promise.all(litStyles.map(style => this.resourceLoader.preprocessInline(style, {\n          type: \"style\",\n          containingFile\n        }))).then(styles => {\n          this.preanalyzeStylesCache.set(node, styles);\n        });\n      }\n    } else {\n      this.preanalyzeStylesCache.set(node, null);\n    }\n    return Promise.all([templateAndTemplateStyleResources, inlineStyles, ...componentStyleUrls.map(styleUrl => resolveStyleUrl(styleUrl.url))]).then(() => void 0);\n  }\n  analyze(node, decorator, flags = HandlerFlags.NONE) {\n    var _a, _b, _c;\n    this.perf.eventCount(PerfEvent.AnalyzeComponent);\n    const containingFile = node.getSourceFile().fileName;\n    this.literalCache.delete(decorator);\n    let diagnostics;\n    let isPoisoned = false;\n    const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.refEmitter, this.referencesRegistry, this.isCore, flags, this.annotateForClosureCompiler, this.elementSchemaRegistry.getDefaultComponentElementName());\n    if (directiveResult === void 0) {\n      return {};\n    }\n    const {\n      decorator: component,\n      metadata,\n      inputs,\n      outputs,\n      hostDirectives,\n      rawHostDirectives\n    } = directiveResult;\n    const encapsulation = (_a = resolveEnumValue(this.evaluator, component, \"encapsulation\", \"ViewEncapsulation\")) != null ? _a : ViewEncapsulation.Emulated;\n    const changeDetection = resolveEnumValue(this.evaluator, component, \"changeDetection\", \"ChangeDetectionStrategy\");\n    let animations = null;\n    let animationTriggerNames = null;\n    if (component.has(\"animations\")) {\n      const animationExpression = component.get(\"animations\");\n      animations = new WrappedNodeExpr7(animationExpression);\n      const animationsValue = this.evaluator.evaluate(animationExpression, animationTriggerResolver);\n      animationTriggerNames = {\n        includesDynamicAnimations: false,\n        staticTriggerNames: []\n      };\n      collectAnimationNames(animationsValue, animationTriggerNames);\n    }\n    const relativeContextFilePath = this.rootDirs.reduce((previous, rootDir) => {\n      const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));\n      if (previous === void 0 || candidate.length < previous.length) {\n        return candidate;\n      } else {\n        return previous;\n      }\n    }, void 0);\n    let viewProvidersRequiringFactory = null;\n    let providersRequiringFactory = null;\n    let wrappedViewProviders = null;\n    if (component.has(\"viewProviders\")) {\n      const viewProviders = component.get(\"viewProviders\");\n      viewProvidersRequiringFactory = resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);\n      wrappedViewProviders = new WrappedNodeExpr7(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(viewProviders) : viewProviders);\n    }\n    if (component.has(\"providers\")) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(component.get(\"providers\"), this.reflector, this.evaluator);\n    }\n    let resolvedImports = null;\n    let rawImports = null;\n    if (component.has(\"imports\") && !metadata.isStandalone) {\n      if (diagnostics === void 0) {\n        diagnostics = [];\n      }\n      diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_NOT_STANDALONE, component.get(\"imports\"), `'imports' is only valid on a component that is standalone.`, [makeRelatedInformation(node.name, `Did you forget to add 'standalone: true' to this @Component?`)]));\n      isPoisoned = true;\n    } else if (component.has(\"imports\")) {\n      const expr = component.get(\"imports\");\n      const importResolvers = combineResolvers([createModuleWithProvidersResolver(this.reflector, this.isCore), forwardRefResolver]);\n      const imported = this.evaluator.evaluate(expr, importResolvers);\n      const {\n        imports: flattened,\n        diagnostics: importDiagnostics\n      } = validateAndFlattenComponentImports(imported, expr);\n      resolvedImports = flattened;\n      rawImports = expr;\n      if (importDiagnostics.length > 0) {\n        isPoisoned = true;\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n        diagnostics.push(...importDiagnostics);\n      }\n    }\n    let schemas = null;\n    if (component.has(\"schemas\") && !metadata.isStandalone) {\n      if (diagnostics === void 0) {\n        diagnostics = [];\n      }\n      diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_NOT_STANDALONE, component.get(\"schemas\"), `'schemas' is only valid on a component that is standalone.`));\n    } else if (component.has(\"schemas\")) {\n      schemas = extractSchemas(component.get(\"schemas\"), this.evaluator, \"Component\");\n    } else if (metadata.isStandalone) {\n      schemas = [];\n    }\n    let template;\n    if (this.preanalyzeTemplateCache.has(node)) {\n      const preanalyzed = this.preanalyzeTemplateCache.get(node);\n      this.preanalyzeTemplateCache.delete(node);\n      template = preanalyzed;\n    } else {\n      const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, this.evaluator, this.depTracker, this.resourceLoader, this.defaultPreserveWhitespaces);\n      template = extractTemplate(node, templateDecl, this.evaluator, this.depTracker, this.resourceLoader, {\n        enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n        i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,\n        usePoisonedData: this.usePoisonedData\n      });\n    }\n    const templateResource = template.declaration.isInline ? {\n      path: null,\n      expression: component.get(\"template\")\n    } : {\n      path: absoluteFrom(template.declaration.resolvedTemplateUrl),\n      expression: template.sourceMapping.node\n    };\n    let styles = [];\n    const styleResources = extractStyleResources(this.resourceLoader, component, containingFile);\n    const styleUrls = [...extractComponentStyleUrls(this.evaluator, component), ..._extractTemplateStyleUrls(template)];\n    for (const styleUrl of styleUrls) {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n        const resourceStr = this.resourceLoader.load(resourceUrl);\n        styles.push(resourceStr);\n        if (this.depTracker !== null) {\n          this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n        }\n      } catch {\n        if (this.depTracker !== null) {\n          this.depTracker.recordDependencyAnalysisFailure(node.getSourceFile());\n        }\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n        const resourceType = styleUrl.source === 2 ? 2 : 1;\n        diagnostics.push(makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType).toDiagnostic());\n      }\n    }\n    if (encapsulation === ViewEncapsulation.ShadowDom && metadata.selector !== null) {\n      const selectorError = checkCustomElementSelectorForErrors(metadata.selector);\n      if (selectorError !== null) {\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n        diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR, component.get(\"selector\"), selectorError));\n      }\n    }\n    let inlineStyles = null;\n    if (this.preanalyzeStylesCache.has(node)) {\n      inlineStyles = this.preanalyzeStylesCache.get(node);\n      this.preanalyzeStylesCache.delete(node);\n      if (inlineStyles !== null) {\n        styles.push(...inlineStyles);\n      }\n    } else {\n      if (this.resourceLoader.canPreprocess) {\n        throw new Error(\"Inline resource processing requires asynchronous preanalyze.\");\n      }\n      if (component.has(\"styles\")) {\n        const litStyles = parseFieldStringArrayValue(component, \"styles\", this.evaluator);\n        if (litStyles !== null) {\n          inlineStyles = [...litStyles];\n          styles.push(...litStyles);\n        }\n      }\n    }\n    if (template.styles.length > 0) {\n      styles.push(...template.styles);\n    }\n    const output = {\n      analysis: {\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        inputs,\n        outputs,\n        hostDirectives,\n        rawHostDirectives,\n        meta: {\n          ...metadata,\n          template: {\n            nodes: template.nodes,\n            ngContentSelectors: template.ngContentSelectors\n          },\n          encapsulation,\n          interpolation: (_b = template.interpolationConfig) != null ? _b : DEFAULT_INTERPOLATION_CONFIG2,\n          styles,\n          animations,\n          viewProviders: wrappedViewProviders,\n          i18nUseExternalIds: this.i18nUseExternalIds,\n          relativeContextFilePath\n        },\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, inputs, this.reflector),\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler, dec => transformDecoratorResources(dec, component, styles, template)),\n        template,\n        providersRequiringFactory,\n        viewProvidersRequiringFactory,\n        inlineStyles,\n        styleUrls,\n        resources: {\n          styles: styleResources,\n          template: templateResource\n        },\n        isPoisoned,\n        animationTriggerNames,\n        rawImports,\n        resolvedImports,\n        schemas,\n        decorator: (_c = decorator == null ? void 0 : decorator.node) != null ? _c : null\n      },\n      diagnostics\n    };\n    if (changeDetection !== null) {\n      output.analysis.meta.changeDetection = changeDetection;\n    }\n    return output;\n  }\n  symbol(node, analysis) {\n    const typeParameters = extractSemanticTypeParameters(node);\n    return new ComponentSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n  }\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata({\n      kind: MetaKind.Directive,\n      matchSource: MatchSource.Selector,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map(query => query.propertyName),\n      isComponent: true,\n      baseClass: analysis.baseClass,\n      hostDirectives: analysis.hostDirectives,\n      ...analysis.typeCheckMeta,\n      isPoisoned: analysis.isPoisoned,\n      isStructural: false,\n      isStandalone: analysis.meta.isStandalone,\n      isSignal: analysis.meta.isSignal,\n      imports: analysis.resolvedImports,\n      animationTriggerNames: analysis.animationTriggerNames,\n      schemas: analysis.schemas,\n      decorator: analysis.decorator,\n      assumedToExportProviders: false\n    });\n    this.resourceRegistry.registerResources(analysis.resources, node);\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.meta.deps\n    });\n  }\n  index(context, node, analysis) {\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return null;\n    }\n    const scope = this.scopeReader.getScopeForComponent(node);\n    const selector = analysis.meta.selector;\n    const matcher = new SelectorMatcher2();\n    if (scope !== null) {\n      let {\n        dependencies,\n        isPoisoned\n      } = scope.kind === ComponentScopeKind.NgModule ? scope.compilation : scope;\n      if ((isPoisoned || scope.kind === ComponentScopeKind.NgModule && scope.exported.isPoisoned) && !this.usePoisonedData) {\n        return null;\n      }\n      for (const dep of dependencies) {\n        if (dep.kind === MetaKind.Directive && dep.selector !== null) {\n          matcher.addSelectables(CssSelector2.parse(dep.selector), [...this.hostDirectivesResolver.resolve(dep), dep]);\n        }\n      }\n    }\n    const binder = new R3TargetBinder(matcher);\n    const boundTemplate = binder.bind({\n      template: analysis.template.diagNodes\n    });\n    context.addComponent({\n      declaration: node,\n      selector,\n      boundTemplate,\n      templateMeta: {\n        isInline: analysis.template.declaration.isInline,\n        file: analysis.template.file\n      }\n    });\n  }\n  typeCheck(ctx, node, meta) {\n    if (this.typeCheckScopeRegistry === null || !ts24.isClassDeclaration(node)) {\n      return;\n    }\n    if (meta.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n    const scope = this.typeCheckScopeRegistry.getTypeCheckScope(node);\n    if (scope.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n    const binder = new R3TargetBinder(scope.matcher);\n    ctx.addTemplate(new Reference(node), binder, meta.template.diagNodes, scope.pipes, scope.schemas, meta.template.sourceMapping, meta.template.file, meta.template.errors, meta.meta.isStandalone);\n  }\n  extendedTemplateCheck(component, extendedTemplateChecker) {\n    return extendedTemplateChecker.getDiagnosticsForComponent(component);\n  }\n  resolve(node, analysis, symbol) {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return {};\n    }\n    const context = getSourceFile(node);\n    const metadata = analysis.meta;\n    const data = {\n      declarations: EMPTY_ARRAY2,\n      declarationListEmitMode: 0\n    };\n    const diagnostics = [];\n    const scope = this.scopeReader.getScopeForComponent(node);\n    if (scope !== null) {\n      const matcher = new SelectorMatcher2();\n      const pipes = /* @__PURE__ */new Map();\n      const dependencies = scope.kind === ComponentScopeKind.NgModule ? scope.compilation.dependencies : scope.dependencies;\n      for (const dep of dependencies) {\n        if (dep.kind === MetaKind.Directive && dep.selector !== null) {\n          matcher.addSelectables(CssSelector2.parse(dep.selector), [dep]);\n        } else if (dep.kind === MetaKind.Pipe) {\n          pipes.set(dep.name, dep);\n        }\n      }\n      const binder = new R3TargetBinder(matcher);\n      const bound = binder.bind({\n        template: metadata.template.nodes\n      });\n      const used = /* @__PURE__ */new Set();\n      for (const dir of bound.getUsedDirectives()) {\n        used.add(dir.ref.node);\n      }\n      for (const name of bound.getUsedPipes()) {\n        if (!pipes.has(name)) {\n          continue;\n        }\n        used.add(pipes.get(name).ref.node);\n      }\n      const declarations = [];\n      const seen = /* @__PURE__ */new Set();\n      for (const dep of dependencies) {\n        if (seen.has(dep.ref.node)) {\n          continue;\n        }\n        seen.add(dep.ref.node);\n        switch (dep.kind) {\n          case MetaKind.Directive:\n            if (!used.has(dep.ref.node) || dep.matchSource !== MatchSource.Selector) {\n              continue;\n            }\n            const dirType = this.refEmitter.emit(dep.ref, context);\n            assertSuccessfulReferenceEmit(dirType, node.name, dep.isComponent ? \"component\" : \"directive\");\n            declarations.push({\n              kind: R3TemplateDependencyKind.Directive,\n              ref: dep.ref,\n              type: dirType.expression,\n              importedFile: dirType.importedFile,\n              selector: dep.selector,\n              inputs: dep.inputs.propertyNames,\n              outputs: dep.outputs.propertyNames,\n              exportAs: dep.exportAs,\n              isComponent: dep.isComponent\n            });\n            break;\n          case MetaKind.Pipe:\n            if (!used.has(dep.ref.node)) {\n              continue;\n            }\n            const pipeType = this.refEmitter.emit(dep.ref, context);\n            assertSuccessfulReferenceEmit(pipeType, node.name, \"pipe\");\n            declarations.push({\n              kind: R3TemplateDependencyKind.Pipe,\n              type: pipeType.expression,\n              name: dep.name,\n              ref: dep.ref,\n              importedFile: pipeType.importedFile\n            });\n            break;\n          case MetaKind.NgModule:\n            const ngModuleType = this.refEmitter.emit(dep.ref, context);\n            assertSuccessfulReferenceEmit(ngModuleType, node.name, \"NgModule\");\n            declarations.push({\n              kind: R3TemplateDependencyKind.NgModule,\n              type: ngModuleType.expression,\n              importedFile: ngModuleType.importedFile\n            });\n            break;\n        }\n      }\n      const isUsedDirective = decl => decl.kind === R3TemplateDependencyKind.Directive;\n      const isUsedPipe = decl => decl.kind === R3TemplateDependencyKind.Pipe;\n      const getSemanticReference = decl => this.semanticDepGraphUpdater.getSemanticReference(decl.ref.node, decl.type);\n      if (this.semanticDepGraphUpdater !== null) {\n        symbol.usedDirectives = declarations.filter(isUsedDirective).map(getSemanticReference);\n        symbol.usedPipes = declarations.filter(isUsedPipe).map(getSemanticReference);\n      }\n      const cyclesFromDirectives = /* @__PURE__ */new Map();\n      const cyclesFromPipes = /* @__PURE__ */new Map();\n      if (!metadata.isStandalone) {\n        for (const usedDep of declarations) {\n          const cycle = this._checkForCyclicImport(usedDep.importedFile, usedDep.type, context);\n          if (cycle !== null) {\n            switch (usedDep.kind) {\n              case R3TemplateDependencyKind.Directive:\n                cyclesFromDirectives.set(usedDep, cycle);\n                break;\n              case R3TemplateDependencyKind.Pipe:\n                cyclesFromPipes.set(usedDep, cycle);\n                break;\n            }\n          }\n        }\n      }\n      const standaloneImportMayBeForwardDeclared = analysis.resolvedImports !== null && analysis.resolvedImports.some(ref => ref.synthetic);\n      const cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;\n      if (!cycleDetected) {\n        for (const {\n          type,\n          importedFile\n        } of declarations) {\n          this.maybeRecordSyntheticImport(importedFile, type, context);\n        }\n        const declarationIsForwardDeclared = declarations.some(decl => isExpressionForwardReference(decl.type, node.name, context));\n        const wrapDirectivesAndPipesInClosure = declarationIsForwardDeclared || standaloneImportMayBeForwardDeclared;\n        data.declarations = declarations;\n        data.declarationListEmitMode = wrapDirectivesAndPipesInClosure ? 1 : 0;\n      } else {\n        if (this.cycleHandlingStrategy === 0) {\n          this.scopeRegistry.setComponentRemoteScope(node, declarations.filter(isUsedDirective).map(dir => dir.ref), declarations.filter(isUsedPipe).map(pipe => pipe.ref));\n          symbol.isRemotelyScoped = true;\n          if (this.semanticDepGraphUpdater !== null && scope.kind === ComponentScopeKind.NgModule && scope.ngModule !== null) {\n            const moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);\n            if (!(moduleSymbol instanceof NgModuleSymbol)) {\n              throw new Error(`AssertionError: Expected ${scope.ngModule.name} to be an NgModuleSymbol.`);\n            }\n            moduleSymbol.addRemotelyScopedComponent(symbol, symbol.usedDirectives, symbol.usedPipes);\n          }\n        } else {\n          const relatedMessages = [];\n          for (const [dir, cycle] of cyclesFromDirectives) {\n            relatedMessages.push(makeCyclicImportInfo(dir.ref, dir.isComponent ? \"component\" : \"directive\", cycle));\n          }\n          for (const [pipe, cycle] of cyclesFromPipes) {\n            relatedMessages.push(makeCyclicImportInfo(pipe.ref, \"pipe\", cycle));\n          }\n          throw new FatalDiagnosticError(ErrorCode.IMPORT_CYCLE_DETECTED, node, \"One or more import cycles would need to be created to compile this component, which is not supported by the current compiler configuration.\", relatedMessages);\n        }\n      }\n    }\n    if (analysis.resolvedImports !== null && analysis.rawImports !== null) {\n      const standaloneDiagnostics = validateStandaloneImports(analysis.resolvedImports, analysis.rawImports, this.metaReader, this.scopeReader);\n      diagnostics.push(...standaloneDiagnostics);\n    }\n    if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof WrappedNodeExpr7) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n    if (analysis.viewProvidersRequiringFactory !== null && analysis.meta.viewProviders instanceof WrappedNodeExpr7) {\n      const viewProviderDiagnostics = getProviderDiagnostics(analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders.node, this.injectableRegistry);\n      diagnostics.push(...viewProviderDiagnostics);\n    }\n    const directiveDiagnostics = getDirectiveDiagnostics(node, this.injectableRegistry, this.evaluator, this.reflector, this.scopeRegistry, this.strictCtorDeps, \"Component\");\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n    const hostDirectivesDiagnotics = analysis.hostDirectives && analysis.rawHostDirectives ? validateHostDirectives(analysis.rawHostDirectives, analysis.hostDirectives, this.metaReader) : null;\n    if (hostDirectivesDiagnotics !== null) {\n      diagnostics.push(...hostDirectivesDiagnotics);\n    }\n    if (diagnostics.length > 0) {\n      return {\n        diagnostics\n      };\n    }\n    return {\n      data\n    };\n  }\n  xi18n(ctx, node, analysis) {\n    var _a;\n    ctx.updateFromTemplate(analysis.template.content, analysis.template.declaration.resolvedTemplateUrl, (_a = analysis.template.interpolationConfig) != null ? _a : DEFAULT_INTERPOLATION_CONFIG2);\n  }\n  updateResources(node, analysis) {\n    const containingFile = node.getSourceFile().fileName;\n    const templateDecl = analysis.template.declaration;\n    if (!templateDecl.isInline) {\n      analysis.template = extractTemplate(node, templateDecl, this.evaluator, this.depTracker, this.resourceLoader, this.extractTemplateOptions);\n    }\n    let styles = [];\n    if (analysis.styleUrls !== null) {\n      for (const styleUrl of analysis.styleUrls) {\n        try {\n          const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n          const styleText = this.resourceLoader.load(resolvedStyleUrl);\n          styles.push(styleText);\n        } catch (e) {}\n      }\n    }\n    if (analysis.inlineStyles !== null) {\n      for (const styleText of analysis.inlineStyles) {\n        styles.push(styleText);\n      }\n    }\n    for (const styleText of analysis.template.styles) {\n      styles.push(styleText);\n    }\n    analysis.meta.styles = styles.filter(s => s.trim().length > 0);\n  }\n  compileFull(node, analysis, resolution, pool) {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const meta = {\n      ...analysis.meta,\n      ...resolution\n    };\n    const fac = compileNgFactoryDefField(toFactoryMetadata(meta, FactoryTarget3.Component));\n    const def = compileComponentFromMetadata(meta, pool, makeBindingParser2());\n    const inputTransformFields = compileInputTransformFields(analysis.inputs);\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata3(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275cmp\", inputTransformFields);\n  }\n  compilePartial(node, analysis, resolution) {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const templateInfo = {\n      content: analysis.template.content,\n      sourceUrl: analysis.template.declaration.resolvedTemplateUrl,\n      isInline: analysis.template.declaration.isInline,\n      inlineTemplateLiteralExpression: analysis.template.sourceMapping.type === \"direct\" ? new WrappedNodeExpr7(analysis.template.sourceMapping.node) : null\n    };\n    const meta = {\n      ...analysis.meta,\n      ...resolution\n    };\n    const fac = compileDeclareFactory(toFactoryMetadata(meta, FactoryTarget3.Component));\n    const inputTransformFields = compileInputTransformFields(analysis.inputs);\n    const def = compileDeclareComponentFromMetadata(meta, analysis.template, templateInfo);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata3(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275cmp\", inputTransformFields);\n  }\n  _checkForCyclicImport(importedFile, expr, origin) {\n    const imported = resolveImportedFile(this.moduleResolver, importedFile, expr, origin);\n    if (imported === null) {\n      return null;\n    }\n    return this.cycleAnalyzer.wouldCreateCycle(origin, imported);\n  }\n  maybeRecordSyntheticImport(importedFile, expr, origin) {\n    const imported = resolveImportedFile(this.moduleResolver, importedFile, expr, origin);\n    if (imported === null) {\n      return;\n    }\n    this.cycleAnalyzer.recordSyntheticImport(origin, imported);\n  }\n};\nfunction validateStandaloneImports(importRefs, importExpr, metaReader, scopeReader) {\n  const diagnostics = [];\n  for (const ref of importRefs) {\n    const dirMeta = metaReader.getDirectiveMetadata(ref);\n    if (dirMeta !== null) {\n      if (!dirMeta.isStandalone) {\n        diagnostics.push(makeNotStandaloneDiagnostic(scopeReader, ref, importExpr, dirMeta.isComponent ? \"component\" : \"directive\"));\n      }\n      continue;\n    }\n    const pipeMeta = metaReader.getPipeMetadata(ref);\n    if (pipeMeta !== null) {\n      if (!pipeMeta.isStandalone) {\n        diagnostics.push(makeNotStandaloneDiagnostic(scopeReader, ref, importExpr, \"pipe\"));\n      }\n      continue;\n    }\n    const ngModuleMeta = metaReader.getNgModuleMetadata(ref);\n    if (ngModuleMeta !== null) {\n      continue;\n    }\n    diagnostics.push(makeUnknownComponentImportDiagnostic(ref, importExpr));\n  }\n  return diagnostics;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/injectable.mjs\nimport { compileClassMetadata as compileClassMetadata4, compileDeclareClassMetadata as compileDeclareClassMetadata4, compileDeclareInjectableFromMetadata, compileInjectable, createMayBeForwardRefExpression as createMayBeForwardRefExpression2, FactoryTarget as FactoryTarget4, LiteralExpr as LiteralExpr3, WrappedNodeExpr as WrappedNodeExpr8 } from \"@angular/compiler\";\nimport ts25 from \"typescript\";\nvar InjectableDecoratorHandler = class {\n  constructor(reflector, evaluator, isCore, strictCtorDeps, injectableRegistry, perf, errorOnDuplicateProv = true) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.isCore = isCore;\n    this.strictCtorDeps = strictCtorDeps;\n    this.injectableRegistry = injectableRegistry;\n    this.perf = perf;\n    this.errorOnDuplicateProv = errorOnDuplicateProv;\n    this.precedence = HandlerPrecedence.SHARED;\n    this.name = \"InjectableDecoratorHandler\";\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"Injectable\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  analyze(node, decorator) {\n    this.perf.eventCount(PerfEvent.AnalyzeInjectable);\n    const meta = extractInjectableMetadata(node, decorator, this.reflector);\n    const decorators = this.reflector.getDecoratorsOfDeclaration(node);\n    return {\n      analysis: {\n        meta,\n        ctorDeps: extractInjectableCtorDeps(node, meta, decorator, this.reflector, this.isCore, this.strictCtorDeps),\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore),\n        needsFactory: !decorators || decorators.every(current => !isAngularCore(current) || current.name === \"Injectable\")\n      }\n    };\n  }\n  symbol() {\n    return null;\n  }\n  register(node, analysis) {\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.ctorDeps\n    });\n  }\n  resolve(node, analysis, symbol) {\n    if (requiresValidCtor(analysis.meta)) {\n      const diagnostic = checkInheritanceOfInjectable(node, this.injectableRegistry, this.reflector, this.evaluator, this.strictCtorDeps, \"Injectable\");\n      if (diagnostic !== null) {\n        return {\n          diagnostics: [diagnostic]\n        };\n      }\n    }\n    return {};\n  }\n  compileFull(node, analysis) {\n    return this.compile(compileNgFactoryDefField, meta => compileInjectable(meta, false), compileClassMetadata4, node, analysis);\n  }\n  compilePartial(node, analysis) {\n    return this.compile(compileDeclareFactory, compileDeclareInjectableFromMetadata, compileDeclareClassMetadata4, node, analysis);\n  }\n  compile(compileFactoryFn, compileInjectableFn, compileClassMetadataFn, node, analysis) {\n    const results = [];\n    if (analysis.needsFactory) {\n      const meta = analysis.meta;\n      const factoryRes = compileFactoryFn(toFactoryMetadata({\n        ...meta,\n        deps: analysis.ctorDeps\n      }, FactoryTarget4.Injectable));\n      if (analysis.classMetadata !== null) {\n        factoryRes.statements.push(compileClassMetadataFn(analysis.classMetadata).toStmt());\n      }\n      results.push(factoryRes);\n    }\n    const ɵprov = this.reflector.getMembersOfClass(node).find(member => member.name === \"\\u0275prov\");\n    if (ɵprov !== void 0 && this.errorOnDuplicateProv) {\n      throw new FatalDiagnosticError(ErrorCode.INJECTABLE_DUPLICATE_PROV, ɵprov.nameNode || ɵprov.node || node, \"Injectables cannot contain a static \\u0275prov property, because the compiler is going to generate one.\");\n    }\n    if (ɵprov === void 0) {\n      const res = compileInjectableFn(analysis.meta);\n      results.push({\n        name: \"\\u0275prov\",\n        initializer: res.expression,\n        statements: res.statements,\n        type: res.type\n      });\n    }\n    return results;\n  }\n};\nfunction extractInjectableMetadata(clazz, decorator, reflector) {\n  const name = clazz.name.text;\n  const type = wrapTypeReference(reflector, clazz);\n  const typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, decorator.node, \"@Injectable must be called\");\n  }\n  if (decorator.args.length === 0) {\n    return {\n      name,\n      type,\n      typeArgumentCount,\n      providedIn: createMayBeForwardRefExpression2(new LiteralExpr3(null), 0)\n    };\n  } else if (decorator.args.length === 1) {\n    const metaNode = decorator.args[0];\n    if (!ts25.isObjectLiteralExpression(metaNode)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode, `@Injectable argument must be an object literal`);\n    }\n    const meta = reflectObjectLiteral(metaNode);\n    const providedIn = meta.has(\"providedIn\") ? getProviderExpression(meta.get(\"providedIn\"), reflector) : createMayBeForwardRefExpression2(new LiteralExpr3(null), 0);\n    let deps = void 0;\n    if ((meta.has(\"useClass\") || meta.has(\"useFactory\")) && meta.has(\"deps\")) {\n      const depsExpr = meta.get(\"deps\");\n      if (!ts25.isArrayLiteralExpression(depsExpr)) {\n        throw new FatalDiagnosticError(ErrorCode.VALUE_NOT_LITERAL, depsExpr, `@Injectable deps metadata must be an inline array`);\n      }\n      deps = depsExpr.elements.map(dep => getDep(dep, reflector));\n    }\n    const result = {\n      name,\n      type,\n      typeArgumentCount,\n      providedIn\n    };\n    if (meta.has(\"useValue\")) {\n      result.useValue = getProviderExpression(meta.get(\"useValue\"), reflector);\n    } else if (meta.has(\"useExisting\")) {\n      result.useExisting = getProviderExpression(meta.get(\"useExisting\"), reflector);\n    } else if (meta.has(\"useClass\")) {\n      result.useClass = getProviderExpression(meta.get(\"useClass\"), reflector);\n      result.deps = deps;\n    } else if (meta.has(\"useFactory\")) {\n      result.useFactory = new WrappedNodeExpr8(meta.get(\"useFactory\"));\n      result.deps = deps;\n    }\n    return result;\n  } else {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], \"Too many arguments to @Injectable\");\n  }\n}\nfunction getProviderExpression(expression, reflector) {\n  const forwardRefValue = tryUnwrapForwardRef(expression, reflector);\n  return createMayBeForwardRefExpression2(new WrappedNodeExpr8(forwardRefValue != null ? forwardRefValue : expression), forwardRefValue !== null ? 2 : 0);\n}\nfunction extractInjectableCtorDeps(clazz, meta, decorator, reflector, isCore, strictCtorDeps) {\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, decorator.node, \"@Injectable must be called\");\n  }\n  let ctorDeps = null;\n  if (decorator.args.length === 0) {\n    if (strictCtorDeps && !isAbstractClassDeclaration(clazz)) {\n      ctorDeps = getValidConstructorDependencies(clazz, reflector, isCore);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(getConstructorDependencies(clazz, reflector, isCore));\n    }\n    return ctorDeps;\n  } else if (decorator.args.length === 1) {\n    const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n    if (strictCtorDeps && !isAbstractClassDeclaration(clazz) && requiresValidCtor(meta)) {\n      ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(rawCtorDeps);\n    }\n  }\n  return ctorDeps;\n}\nfunction requiresValidCtor(meta) {\n  return meta.useValue === void 0 && meta.useExisting === void 0 && meta.useClass === void 0 && meta.useFactory === void 0;\n}\nfunction getDep(dep, reflector) {\n  const meta = {\n    token: new WrappedNodeExpr8(dep),\n    attributeNameType: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false\n  };\n  function maybeUpdateDecorator(dec, reflector2, token) {\n    const source = reflector2.getImportOfIdentifier(dec);\n    if (source === null || source.from !== \"@angular/core\") {\n      return false;\n    }\n    switch (source.name) {\n      case \"Inject\":\n        if (token !== void 0) {\n          meta.token = new WrappedNodeExpr8(token);\n        }\n        break;\n      case \"Optional\":\n        meta.optional = true;\n        break;\n      case \"SkipSelf\":\n        meta.skipSelf = true;\n        break;\n      case \"Self\":\n        meta.self = true;\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n  if (ts25.isArrayLiteralExpression(dep)) {\n    dep.elements.forEach(el => {\n      let isDecorator = false;\n      if (ts25.isIdentifier(el)) {\n        isDecorator = maybeUpdateDecorator(el, reflector);\n      } else if (ts25.isNewExpression(el) && ts25.isIdentifier(el.expression)) {\n        const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || void 0;\n        isDecorator = maybeUpdateDecorator(el.expression, reflector, token);\n      }\n      if (!isDecorator) {\n        meta.token = new WrappedNodeExpr8(el);\n      }\n    });\n  }\n  return meta;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/pipe.mjs\nimport { compileClassMetadata as compileClassMetadata5, compileDeclareClassMetadata as compileDeclareClassMetadata5, compileDeclarePipeFromMetadata, compilePipeFromMetadata, FactoryTarget as FactoryTarget5 } from \"@angular/compiler\";\nimport ts26 from \"typescript\";\nvar PipeSymbol = class extends SemanticSymbol {\n  constructor(decl, name) {\n    super(decl);\n    this.name = name;\n  }\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof PipeSymbol)) {\n      return true;\n    }\n    return this.name !== previousSymbol.name;\n  }\n  isTypeCheckApiAffected(previousSymbol) {\n    return this.isPublicApiAffected(previousSymbol);\n  }\n};\nvar PipeDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.injectableRegistry = injectableRegistry;\n    this.isCore = isCore;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = \"PipeDecoratorHandler\";\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"Pipe\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  analyze(clazz, decorator) {\n    var _a;\n    this.perf.eventCount(PerfEvent.AnalyzePipe);\n    const name = clazz.name.text;\n    const type = wrapTypeReference(this.reflector, clazz);\n    if (decorator.args === null) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, decorator.node, `@Pipe must be called`);\n    }\n    if (decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, \"@Pipe must have exactly one argument\");\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts26.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"@Pipe must have a literal argument\");\n    }\n    const pipe = reflectObjectLiteral(meta);\n    if (!pipe.has(\"name\")) {\n      throw new FatalDiagnosticError(ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);\n    }\n    const pipeNameExpr = pipe.get(\"name\");\n    const pipeName = this.evaluator.evaluate(pipeNameExpr);\n    if (typeof pipeName !== \"string\") {\n      throw createValueHasWrongTypeError(pipeNameExpr, pipeName, `@Pipe.name must be a string`);\n    }\n    let pure = true;\n    if (pipe.has(\"pure\")) {\n      const expr = pipe.get(\"pure\");\n      const pureValue = this.evaluator.evaluate(expr);\n      if (typeof pureValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(expr, pureValue, `@Pipe.pure must be a boolean`);\n      }\n      pure = pureValue;\n    }\n    let isStandalone = false;\n    if (pipe.has(\"standalone\")) {\n      const expr = pipe.get(\"standalone\");\n      const resolved = this.evaluator.evaluate(expr);\n      if (typeof resolved !== \"boolean\") {\n        throw createValueHasWrongTypeError(expr, resolved, `standalone flag must be a boolean`);\n      }\n      isStandalone = resolved;\n    }\n    return {\n      analysis: {\n        meta: {\n          name,\n          type,\n          typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,\n          pipeName,\n          deps: getValidConstructorDependencies(clazz, this.reflector, this.isCore),\n          pure,\n          isStandalone\n        },\n        classMetadata: extractClassMetadata(clazz, this.reflector, this.isCore),\n        pipeNameExpr,\n        decorator: (_a = decorator == null ? void 0 : decorator.node) != null ? _a : null\n      }\n    };\n  }\n  symbol(node, analysis) {\n    return new PipeSymbol(node, analysis.meta.pipeName);\n  }\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerPipeMetadata({\n      kind: MetaKind.Pipe,\n      ref,\n      name: analysis.meta.pipeName,\n      nameExpr: analysis.pipeNameExpr,\n      isStandalone: analysis.meta.isStandalone,\n      decorator: analysis.decorator\n    });\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.meta.deps\n    });\n  }\n  resolve(node) {\n    const duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);\n    if (duplicateDeclData !== null) {\n      return {\n        diagnostics: [makeDuplicateDeclarationError(node, duplicateDeclData, \"Pipe\")]\n      };\n    }\n    return {};\n  }\n  compileFull(node, analysis) {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget5.Pipe));\n    const def = compilePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata5(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275pipe\", null);\n  }\n  compilePartial(node, analysis) {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget5.Pipe));\n    const def = compileDeclarePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata5(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275pipe\", null);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/api/checker.mjs\nvar OptimizeFor;\n(function (OptimizeFor2) {\n  OptimizeFor2[OptimizeFor2[\"SingleFile\"] = 0] = \"SingleFile\";\n  OptimizeFor2[OptimizeFor2[\"WholeProgram\"] = 1] = \"WholeProgram\";\n})(OptimizeFor || (OptimizeFor = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/api/scope.mjs\nvar PotentialImportKind;\n(function (PotentialImportKind2) {\n  PotentialImportKind2[PotentialImportKind2[\"NgModule\"] = 0] = \"NgModule\";\n  PotentialImportKind2[PotentialImportKind2[\"Standalone\"] = 1] = \"Standalone\";\n})(PotentialImportKind || (PotentialImportKind = {}));\nvar PotentialImportMode;\n(function (PotentialImportMode2) {\n  PotentialImportMode2[PotentialImportMode2[\"Normal\"] = 0] = \"Normal\";\n  PotentialImportMode2[PotentialImportMode2[\"ForceDirect\"] = 1] = \"ForceDirect\";\n})(PotentialImportMode || (PotentialImportMode = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/api/completion.mjs\nvar CompletionKind;\n(function (CompletionKind2) {\n  CompletionKind2[CompletionKind2[\"Reference\"] = 0] = \"Reference\";\n  CompletionKind2[CompletionKind2[\"Variable\"] = 1] = \"Variable\";\n})(CompletionKind || (CompletionKind = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/api/symbols.mjs\nvar SymbolKind;\n(function (SymbolKind2) {\n  SymbolKind2[SymbolKind2[\"Input\"] = 0] = \"Input\";\n  SymbolKind2[SymbolKind2[\"Output\"] = 1] = \"Output\";\n  SymbolKind2[SymbolKind2[\"Binding\"] = 2] = \"Binding\";\n  SymbolKind2[SymbolKind2[\"Reference\"] = 3] = \"Reference\";\n  SymbolKind2[SymbolKind2[\"Variable\"] = 4] = \"Variable\";\n  SymbolKind2[SymbolKind2[\"Directive\"] = 5] = \"Directive\";\n  SymbolKind2[SymbolKind2[\"Element\"] = 6] = \"Element\";\n  SymbolKind2[SymbolKind2[\"Template\"] = 7] = \"Template\";\n  SymbolKind2[SymbolKind2[\"Expression\"] = 8] = \"Expression\";\n  SymbolKind2[SymbolKind2[\"DomBinding\"] = 9] = \"DomBinding\";\n  SymbolKind2[SymbolKind2[\"Pipe\"] = 10] = \"Pipe\";\n})(SymbolKind || (SymbolKind = {}));\nexport { forwardRefResolver, MetaKind, CompoundMetadataReader, DtsMetadataReader, LocalMetadataRegistry, CompoundMetadataRegistry, ResourceRegistry, ExportedProviderStatusResolver, HostDirectivesResolver, DynamicValue, StaticInterpreter, PartialEvaluator, InjectableClassRegistry, NoopReferencesRegistry, SemanticDepGraphUpdater, ComponentScopeKind, CompoundComponentScopeReader, MetadataDtsModuleScopeResolver, LocalModuleScopeRegistry, TypeCheckScopeRegistry, CompilationMode, aliasTransformFactory, TraitCompiler, DtsTransformRegistry, declarationTransformFactory, ivyTransformFactory, DirectiveDecoratorHandler, NgModuleDecoratorHandler, ComponentDecoratorHandler, InjectableDecoratorHandler, PipeDecoratorHandler, OptimizeFor, CompletionKind, PotentialImportKind, PotentialImportMode, SymbolKind };\n/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */","map":{"version":3,"names":["createRequire","__cjsCompatRequire","require","import","meta","url","ClassMemberKind","filterToMembersWithDecorator","isNamedClassDeclaration","reflectObjectLiteral","reflectTypeEntityToDeclaration","typeNodeToValueExpr","ImportManager","translateExpression","translateStatement","translateType","ErrorCode","FatalDiagnosticError","ImportFlags","Reference","assertSuccessfulReferenceEmit","attachDefaultImportDeclaration","getDefaultImportDeclaration","getSourceFile","identifierOfNode","isDeclaration","isFromDtsFile","makeDiagnostic","makeRelatedInformation","nodeDebugInfo","nodeNameForError","PerfEvent","PerfPhase","absoluteFrom","absoluteFromSourceFile","relative","ExternalExpr","ParseLocation","ParseSourceFile","ParseSourceSpan","ReadPropExpr","WrappedNodeExpr","ts","valueReferenceToExpression","valueRef","kind","expr","expression","defaultImportStatement","importExpr","moduleName","name","importedName","nestedPath","property","toR3Reference","origin","ref","context","refEmitter","emittedValueRef","emit","emittedTypeRef","ForceNewImport","AllowTypeImports","value","type","isAngularCore","decorator","from","isAngularCoreReference","reference","symbolName","ownedByModuleGuess","debugName","findAngularDecorator","decorators","isCore","find","isAngularDecorator","unwrapExpression","node","isAsExpression","isParenthesizedExpression","expandForwardRef","arg","isArrowFunction","isFunctionExpression","body","isBlock","statements","length","stmt","isReturnStatement","tryUnwrapForwardRef","reflector","isCallExpression","arguments","fn","isPropertyAccessExpression","isIdentifier","imp","getImportOfIdentifier","forwardRefResolver","callExpr","resolve","unresolvable","expanded","combineResolvers","resolvers","resolver","resolved","isExpressionForwardReference","contextSource","isWrappedTsNodeExpr","getOriginalNode","pos","readBaseClass","evaluator","baseExpression","getBaseClassExpression","baseClass","evaluate","isClass","parensWrapperTransformerFactory","visitor","visited","visitEachChild","factory","createParenthesizedExpression","wrapFunctionExpressionsInParens","transform","transformed","resolveProvidersRequiringFactory","rawProviders","providers","Set","resolvedProviders","Array","isArray","forEach","processProviders","provider","tokenClass","Map","has","useExisting","get","isDeclarationFile","constructorParameters","getConstructorParameters","add","wrapTypeReference","clazz","createSourceSpan","sf","startOffset","endOffset","getStart","getEnd","line","startLine","character","startCol","getLineAndCharacterOfPosition","endLine","endCol","parseSf","getFullText","fileName","compileResults","fac","def","metadataStmt","propName","additionalFields","push","results","initializer","toFactoryMetadata","target","typeArgumentCount","deps","resolveImportedFile","moduleResolver","importedFile","resolveModule","getOriginNodeForDiagnostics","container","nodeSf","exprSf","end","isAbstractClassDeclaration","canHaveModifiers","modifiers","some","mod","SyntaxKind","AbstractKeyword","DynamicValue","constructor","reason","code","fromDynamicInput","input","fromDynamicString","fromExternalReference","fromUnsupportedSyntax","fromUnknownIdentifier","fromInvalidExpressionType","fromComplexFunctionCall","fromDynamicType","fromSyntheticInput","fromUnknown","isFromDynamicInput","isFromDynamicString","isFromExternalReference","isFromUnsupportedSyntax","isFromUnknownIdentifier","isFromInvalidExpressionType","isFromComplexFunctionCall","isFromDynamicType","isFromUnknown","accept","visitDynamicInput","visitDynamicString","visitExternalReference","visitUnsupportedSyntax","visitUnknownIdentifier","visitInvalidExpressionType","visitComplexFunctionCall","visitDynamicType","visitSyntheticInput","visitUnknown","ts2","ResolvedModule","exports","getExport","getExports","map","decl","set","EnumValue","enumRef","KnownFn","ArraySliceBuiltinFn","lhs","args","ArrayConcatBuiltinFn","result","StringConcatBuiltinFn","concat","SyntheticValue","literalBinaryOp","op","literal","referenceBinaryOp","BINARY_OPERATORS","PlusToken","a","b","MinusToken","AsteriskToken","SlashToken","PercentToken","AmpersandToken","BarToken","CaretToken","LessThanToken","LessThanEqualsToken","GreaterThanToken","GreaterThanEqualsToken","EqualsEqualsToken","EqualsEqualsEqualsToken","ExclamationEqualsToken","ExclamationEqualsEqualsToken","LessThanLessThanToken","GreaterThanGreaterThanToken","GreaterThanGreaterThanGreaterThanToken","AsteriskAsteriskToken","Math","pow","AmpersandAmpersandToken","BarBarToken","UNARY_OPERATORS","TildeToken","ExclamationToken","StaticInterpreter","host","checker","dependencyTracker","visit","visitExpression","TrueKeyword","FalseKeyword","NullKeyword","isStringLiteral","text","isNoSubstitutionTemplateLiteral","isTemplateExpression","visitTemplateExpression","isNumericLiteral","parseFloat","isObjectLiteralExpression","visitObjectLiteralExpression","visitIdentifier","visitPropertyAccessExpression","visitCallExpression","isConditionalExpression","visitConditionalExpression","isPrefixUnaryExpression","visitPrefixUnaryExpression","isBinaryExpression","visitBinaryExpression","isArrayLiteralExpression","visitArrayLiteralExpression","visitParenthesizedExpression","isElementAccessExpression","visitElementAccessExpression","isNonNullExpression","visitDeclaration","array","i","elements","element","isSpreadElement","visitSpreadElement","properties","isPropertyAssignment","stringNameFromPropertyName","isShorthandPropertyAssignment","symbol","getShorthandAssignmentValueSymbol","valueDeclaration","isSpreadAssignment","spread","key","pieces","head","templateSpans","span","join","getDeclarationOfIdentifier","getOriginalKeywordKind","UndefinedKeyword","recordDependencyAnalysisFailure","originatingFile","declContext","joinModuleContext","synthetic","addIdentifier","addDependency","getReference","isVariableDeclaration","visitVariableDeclaration","isParameter","scope","isExportAssignment","isEnumDeclaration","visitEnumDeclaration","isSourceFile","visitSourceFile","isBindingElement","visitBindingElement","getVariableValue","isVariableDeclarationDeclared","evaluatedType","visitType","members","member","rhs","argumentExpression","accessHelper","declarations","getExportsOfModule","strIndex","Number","isInteger","module","owningModule","bestGuessOwningModule","getMembersOfClass","member2","isStatic","implementation","evaluateFunctionArguments","getDefinitionOfFunction","isFunctionOrMethodReference","resolveFfrExpr","contextExtension","absoluteModuleName","specifier","resolutionContext","visitFfrExpression","foreignFunctionResolver","res","visitFunctionBody","ret","newScope","calleeContext","parameters","param","index","dotDotDotToken","slice","condition","whenTrue","whenFalse","operatorKind","operator","operand","tokenKind","operatorToken","opRecord","left","right","path","closestDeclaration","isArrayBindingPattern","isObjectBindingPattern","unshift","parent","indexOf","propertyName","isComputedPropertyName","literal2","isLiteralTypeNode","isTupleTypeNode","visitTupleType","isNamedTupleMember","isTypeOperatorNode","ReadonlyKeyword","isTypeQueryNode","visitTypeQuery","elem","exprName","isFunctionDeclaration","isMethodDeclaration","reject","isVariableDeclarationList","declList","isVariableStatement","varStmt","getModifiers","DeclareKeyword","EMPTY","existing","viaModule","override","identifier","identifierToKeywordKind","originalKeywordKind","PartialEvaluator","interpreter","sourceFile","ts3","describeResolvedType","maxDepth","_a","_b","entries","v","quoteKey","test","replace","traceDynamicValue","TraceDynamicValueVisitor","currentContainerNode","trace","shouldTrace","info","description","getContainerNode","currentNode","ExpressionStatement","VariableStatement","ReturnStatement","IfStatement","SwitchStatement","DoStatement","WhileStatement","ForStatement","ForInStatement","ForOfStatement","ContinueStatement","BreakStatement","ThrowStatement","ObjectBindingPattern","ArrayBindingPattern","LiteralExpr","WrappedNodeExpr2","ts4","getConstructorDependencies","errors","ctorParams","hasBaseClass","idx","token","typeValueReference","attributeNameType","optional","self","skipSelf","filter","dec","DECORATOR_ARITY_WRONG","attributeName","isStringLiteralLike","createKeywordTypeNode","UnknownKeyword","DECORATOR_UNEXPECTED","Error","unwrapConstructorDependencies","getValidConstructorDependencies","validateConstructorDependencies","error","createUnsuitableInjectionTokenError","chainMessage","hints","typeNode","importClause","chain","messageText","category","DiagnosticCategory","next","Message","PARAM_MISSING_TOKEN","nameNode","ts7","MetaKind","MetaKind2","MatchSource","MatchSource2","ts6","ClassPropertyMapping","forwardMap","reverseMap","reverseMapFromForwardMap","empty","fromMappedObject","obj","classPropertyName","Object","keys","inputOrOutput","bindingPropertyName","merge","classPropertyNames","propertyNames","hasBindingPropertyName","getByBindingPropertyName","getByClassPropertyName","toDirectMappedObject","toJointMappedObject","Symbol","iterator","values","_","ts5","extractReferencesFromType","extraReferenceFromTypeQuery","startsWith","readBooleanType","readStringType","readMapType","valueTransform","isTypeLiteralNode","isPropertySignature","readStringArrayType","el","extractDirectiveTypeCheckMeta","inputs","staticMembers","ngTemplateGuards","extractTemplateGuard","guard","hasNgTemplateContextGuard","Method","coercedInputFields","extractCoercedInput","inputName","restrictedInputFields","stringLiteralInputFields","undeclaredInputFields","field","isRestricted","arity","getGenericArityOfClass","isGeneric","PrivateKeyword","ProtectedKeyword","afterUnderscore","Property","CompoundMetadataReader","readers","getDirectiveMetadata","reader","getNgModuleMetadata","getPipeMetadata","str","hasInjectableFields","DtsMetadataReader","ngModuleDef","isTypeReferenceNode","typeArguments","declarationMetadata","importMetadata","exportMetadata","NgModule","imports","schemas","rawDeclarations","rawImports","rawExports","mayDeclareProviders","isComponent","isStructural","isStandalone","readInputsType","outputs","hostDirectives","readHostDirectivesType","isSignal","Directive","matchSource","Selector","selector","exportAs","queries","readBaseClass2","isPoisoned","animationTriggerNames","assumedToExportProviders","Pipe","nameExpr","inputsMap","stringValue","required","config","innerValue","alias","heritageClauses","clause","ExtendsKeyword","baseExpr","types","getSymbolAtLocation","flags","SymbolFlags","Alias","getAliasedSymbol","hostDirectiveType","directive","type2","isForwardReference","flattenInheritedDirectiveMetadata","dir","topMeta","isDynamic","addMetadata","baseMeta","coercedInputField","undeclaredInputField","restrictedInputField","LocalMetadataRegistry","directives","ngModules","pipes","registerDirectiveMetadata","registerNgModuleMetadata","registerPipeMetadata","getKnown","CompoundMetadataRegistry","registries","registry","ResourceRegistry","externalTemplateToComponentsMap","componentToTemplateMap","componentToStylesMap","externalStyleToComponentsMap","getComponentsWithTemplate","template","registerResources","resources","component","registerTemplate","style","styles","registerStyle","templateResource","getTemplate","styleResource","getStyles","getComponentsWithStyle","styleUrl","ExportedProviderStatusResolver","metaReader","calculating","mayExportProviders","dependencyCallback","dirMeta","importRef","pipeMeta","ngModuleMeta","delete","EMPTY_ARRAY","HostDirectivesResolver","cache","metadata","walkHostDirectives","current","hostMeta","HostDirective","filterMappings","resolveInput","resolveOutput","source","allowedProperties","valueResolver","publicName","hasOwnProperty","bindings","binding","bindingName","makeDuplicateDeclarationError","data","contextNode","getOriginForDiagnostics","ngModule","NGMODULE_DECLARATION_NOT_UNIQUE","createValueHasWrongTypeError","chainedMessage","relatedInformation","referenceNode","VALUE_HAS_WRONG_TYPE","getProviderDiagnostics","providerClasses","providersDeclaration","diagnostics","injectableMeta","getInjectableMeta","UNDECORATED_PROVIDER","getDirectiveDiagnostics","injectableRegistry","scopeRegistry","strictInjectionParameters","addDiagnostics","more","duplicateDeclarations","getDuplicateDeclarations","checkInheritanceOfInjectable","validateHostDirectives","HOST_DIRECTIVE_INVALID","HOST_DIRECTIVE_NOT_STANDALONE","HOST_DIRECTIVE_COMPONENT","requiredInputNames","validateHostDirectiveMappings","bindingType","hostDirectiveMeta","requiredBindings","className","hostDirectiveMappings","existingBindings","exposedRequiredBindings","HOST_DIRECTIVE_UNDEFINED_BINDING","remappedPublicName","bindingsForPublicName","HOST_DIRECTIVE_CONFLICTING_ALIAS","size","missingBindings","HOST_DIRECTIVE_MISSING_REQUIRED_BINDING","getUndecoratedClassWithAngularFeaturesDiagnostic","UNDECORATED_CLASS_USING_ANGULAR_FEATURES","classWithCtor","findInheritedCtor","isCtorValid","isDecorated","getInheritedUndecoratedCtorDiagnostic","getInheritedInvalidCtorDiagnostic","ctorDeps","baseClassConstructorParams","baseClassName","INJECTABLE_INHERITS_INVALID_CONSTRUCTOR","toLowerCase","baseNeedsDecorator","DIRECTIVE_INHERITS_UNDECORATED_CTOR","ts8","resolveEnumValue","enumSymbolName","isStringArray","resolvedValue","every","resolveLiteral","literalCache","DECORATOR_ARG_NOT_LITERAL","compileDeclareFactoryFunction","compileFactoryFunction","compileNgFactoryDefField","compileDeclareFactory","InjectableClassRegistry","classes","registerInjectable","declaration","FunctionExpr","LiteralArrayExpr","LiteralExpr2","literalMap","WrappedNodeExpr3","ts9","extractClassMetadata","reflection","annotateForClosureCompiler","angularDecoratorTransform","id","classDecorators","getDecoratorsOfDeclaration","ngClassDecorators","isAngularDecorator2","decoratorToMetadata","removeIdentifierReferences","metaDecorators","createArrayLiteralExpression","metaCtorParameters","classCtorParameters","ctorParameters","ctorParameterToMetadata","metaPropDecorators","classMembers","duplicateDecoratedMemberNames","arr","decoratedMembers","classMemberToMetadata","createObjectLiteralExpression","propDecorators","mapEntries","quoted","ngDecorators","decoratorMeta","createPropertyAssignment","wrapFunctionsInParens","root","visitNode","walk","createIdentifier","NoopReferencesRegistry","references","CUSTOM_ELEMENTS_SCHEMA","NO_ERRORS_SCHEMA","extractSchemas","rawExpr","schemaRef","getIdentityIn","outputAst","compileInputTransformFields","extraFields","transplantedType","compileClassMetadata","compileClassMetadata3","compileComponentFromMetadata","compileDeclareClassMetadata","compileDeclareClassMetadata3","compileDeclareComponentFromMetadata","CssSelector","CssSelector2","DEFAULT_INTERPOLATION_CONFIG","DEFAULT_INTERPOLATION_CONFIG2","DomElementSchemaRegistry","FactoryTarget","FactoryTarget3","makeBindingParser","makeBindingParser2","R3TargetBinder","R3TemplateDependencyKind","SelectorMatcher","SelectorMatcher2","ViewEncapsulation","WrappedNodeExpr7","ts24","ts10","SemanticSymbol","getSymbolIdentifier","ExternalExpr2","OpaqueSymbol","isPublicApiAffected","isTypeCheckApiAffected","SemanticDepGraph","files","symbolByDecl","registerSymbol","getEquivalentSymbol","previousSymbol","getSymbolByDecl","getSymbolByName","file","SemanticDepGraphUpdater","priorGraph","newGraph","opaqueSymbols","finalize","needsEmit","needsTypeCheckEmit","determineInvalidatedFiles","determineInvalidatedTypeCheckFiles","isEmitAffected","isTypeCheckBlockAffected","getSemanticReference","getSymbol","importPath","getImportPath","getOpaqueSymbol","ts11","isSymbolEqual","isReferenceEqual","referenceEquality","isArrayEqual","equalityTester","item","isSetEqual","itemA","found","itemB","extractSemanticTypeParameters","isClassDeclaration","typeParameters","typeParam","hasGenericTypeBound","constraint","areTypeParametersEqual","previous","isTypeParameterEqual","ComponentScopeKind","ComponentScopeKind2","CompoundComponentScopeReader","getScopeForComponent","getRemoteScope","remoteScope","MetadataDtsModuleScopeResolver","dtsMetaReader","aliasingHost","dependencies","declRef","exportRef","isReExport","maybeAlias","pipe","exportScope2","exported","dep","exportScope","dirOrPipe","maybeAliasFrom","getAliasIn","cloneWithAlias","ExternalExpr3","ts12","getDiagnosticNode","makeNotStandaloneDiagnostic","scopeReader","message","isExported","relatedInfoMessageText","COMPONENT_IMPORT_NOT_STANDALONE","makeUnknownComponentImportDiagnostic","COMPONENT_UNKNOWN_IMPORT","LocalModuleScopeRegistry","localReader","fullReader","dependencyScopeReader","sealed","declarationToModule","moduleToRef","remoteScoping","scopeErrors","modulesWithStructuralErrors","assertCollecting","registerDeclarationOfModule","getScopeOfModule","getScopeOfModuleReference","getDiagnosticsOfModule","declData","duplicateDeclMap","firstDeclData","compilationDirectives","compilationPipes","declared","exportDirectives","exportPipes","importScope","getExportedScope","invalidTransitiveNgModuleRef","invalidRef","refType","NGMODULE_DECLARATION_IS_STANDALONE","errorNode","NGMODULE_INVALID_DECLARATION","invalidReexport","reexports","getReexports","compilation","setComponentRemoteScope","ownerForErrors","NGMODULE_INVALID_IMPORT","NGMODULE_INVALID_EXPORT","reexportMap","ngModuleRef","addReexport","exportName","maybeAliasSymbolAs","fromModule","asAlias","emittedRef","cloneWithNoIdentifiers","prevRef","reexportCollision","ref2","resolveTarget","library","relatedMessage","annotationType","NGMODULE_INVALID_REEXPORT","refA","refB","childMessageText","NGMODULE_REEXPORT_NAME_COLLISION","trim","ts13","TypeCheckScopeRegistry","hostDirectivesResolver","flattenedDirectiveMetaCache","scopeCache","getTypeCheckScope","matcher","cacheKey","extMeta","getTypeCheckDirectiveMetadata","addSelectables","parse","typeCheckScope","CompilationMode","CompilationMode2","HandlerPrecedence","HandlerPrecedence2","HandlerFlags","HandlerFlags2","ts14","aliasTransformFactory","exportStatements","isBundle","aliasName","createExportDeclaration","createNamedExports","createExportSpecifier","createStringLiteral","updateSourceFile","ts15","TraitState","TraitState2","Trait","pending","handler","detected","TraitImpl","state","Pending","analysis","resolution","analysisDiagnostics","resolveDiagnostics","typeCheckDiagnostics","toAnalyzed","assertTransitionLegal","Analyzed","toResolved","Resolved","toSkipped","Skipped","allowedState","transitionTo","TraitCompiler","handlers","perf","incrementalBuild","compileNonExportedClasses","compilationMode","dtsTransforms","semanticDepGraphUpdater","sourceFileTypeIdentifier","fileToClasses","filesWithoutTraits","handlersByName","analyzeSync","analyze","analyzeAsync","preanalyze","isShim","isResource","promises","priorWork","priorAnalysisFor","eventCount","SourceFileReuseAnalysis","priorRecord","adopt","TraitReuseAnalysis","visit2","analyzeClass","forEachChild","Promise","all","then","recordFor","getAnalyzedRecords","records","record","hasPrimaryHandler","hasWeakHandlers","metaDiagnostics","traits","priorTrait","trait","makeSymbolForTrait","register","scanClassForTraits","isStaticallyExported","detectTraits","foundTraits","detect","isPrimaryHandler","precedence","PRIMARY","isWeakHandler","WEAK","DECORATOR_COLLISION","start","getWidth","isPrimary","preanalyzeQueue","analyzeTrait","preanalysis","err","toDiagnostic","_c","TraitAnalyze","fileReexports","reexport","typeCheck","ctx","extendedTemplateCheck","extendedTemplateChecker","xi18n","bundle","updateResources","compile","constantPool","original","containsErrors","compileRes","PARTIAL","compilePartial","compileFull","compileMatchRes","r","getIvyDeclarationTransform","addFields","decoratorsFor","trigger","isDecorator","diag","ts17","ts16","addImports","importManager","extraStatements","addedImports","getAllImports","qualifier","createImportClause","createNamespaceImport","createImportDeclaration","setOriginalNode","existingImports","isImportStatement","fileoverviewAnchorStmt","createNotEmittedStatement","createNodeArray","isImportDeclaration","isImportEqualsDeclaration","isNamespaceImport","DtsTransformRegistry","ivyDeclarationTransforms","IvyDeclarationDtsTransform","getAllTransforms","originalSf","transforms","declarationTransformFactory","transformRegistry","importRewriter","importPrefix","transformer","DtsTransformer","fileOrBundle","transformClassDeclaration","transformFunctionDeclaration","elementsChanged","transformClassElement","newClazz","transformClass","inputMembers","updateClassDeclaration","newDecl","declarationFields","fields","newMembers","createModifier","StaticKeyword","typeRef","markForEmitAsSingleLine","createPropertyDeclaration","setEmitFlags","EmitFlags","SingleLine","ConstantPool","ts19","ts18","_visit","Visitor","_before","_after","_visitListEntryNode","before","after","visitOtherNode","visitedNode","child","node2","visitClassDeclaration","_maybeProcessStatements","newStatements","statementsArray","hasTrailingComma","updateBlock","referencedFiles","typeReferenceDirectives","hasNoDefaultLib","libReferenceDirectives","NO_DECORATORS","CLOSURE_FILE_OVERVIEW_REGEXP","ivyTransformFactory","defaultImportTracker","isClosureCompilerEnabled","recordWrappedNode","createRecorderFn","inPhase","Compile","transformIvySourceFile","IvyCompilationVisitor","classCompilationMap","IvyTransformationVisitor","recordWrappedNodeExpr","translateOptions","exprNode","createToken","addSyntheticLeadingComment","MultiLineCommentTrivia","filteredDecorators","maybeFilterDecorator","getDecorators","nodeModifiers","updatedModifiers","_stripAngularDecorators","_angularCoreDecorators","coreDecorators","isFromAngularCore","_nonCoreDecoratorsOnly","nodeArrayFromDecoratorsArray","filtered","nonCoreDecorators","canHaveDecorators","combinedModifiers","updateParameterDeclaration","questionToken","updateMethodDeclaration","asteriskToken","isPropertyDeclaration","updatePropertyDeclaration","isGetAccessor","updateGetAccessorDeclaration","isSetAccessor","updateSetAccessorDeclaration","isConstructorDeclaration","updateConstructorDeclaration","compilationVisitor","transformationVisitor","downlevelTranslatedCode","getLocalizeCompileTarget","ScriptTarget","ES2015","constants","downlevelTaggedTemplates","downlevelVariableDeclarations","fileOverviewMeta","getFileOverviewComment","setFileOverviewComment","getCompilerOptions","JSON","trailing","comments","getSyntheticLeadingComments","getSyntheticTrailingComments","fileoverview","setSyntheticTrailingComments","setSyntheticLeadingComments","toRemove","decToRemove","importDecl","recordUsedImport","compileDeclareDirectiveFromMetadata","compileDirectiveFromMetadata","WrappedNodeExpr5","createMayBeForwardRefExpression","emitDistinctChangesOnlyDefaultValue","ExternalExpr4","getSafePropertyAccessString","parseHostBindings","verifyHostBindings","WrappedNodeExpr4","ts20","EMPTY_OBJECT","QUERY_TYPES","extractDirectiveMetadata","referencesRegistry","defaultSelector","decoratedElements","coreModule","inputsFromMeta","parseInputsArray","inputsFromFields","parseInputFields","outputsFromMeta","parseOutputsArray","outputsFromFields","parseOutputFields","contentChildFromFields","queriesFromFields","contentChildrenFromFields","viewChildFromFields","viewChildrenFromFields","viewQueries","queriesFromDecorator","extractQueriesFromDecorator","content","view","DIRECTIVE_MISSING_SELECTOR","extractHostBindings","usesOnChanges","split","part","rawCtorDeps","usesInheritance","rawHostDirectives","extractHostDirectives","hostDir","lifecycle","toR3InputMetadata","fullInheritance","FULL_INHERITANCE","typeSourceSpan","toHostDirectiveMetadata","extractQueryMetadata","first","forwardReferenceTarget","predicate","isStringArrayOrDie","read","descendants","emitDistinctChangesOnly","optionsExpr","options","descendantsExpr","descendantsValue","emitDistinctChangesOnlyExpr","emitDistinctChangesOnlyValue","staticValue","static","evaluateHostExpressionBindings","hostPropertyName","eventName","resolvedArgs","listeners","queryData","queryExpr","isNewExpression","queryType","query","parseFieldStringArrayValue","isPropertyTypeMember","Getter","Setter","parseMappingStringArray","reduce","fieldName","parseMappingString","parseDecoratedFields","callback","decoratorMetadata","inputsField","inputsArray","transformValue","parseInputTransformFunction","aliasInConfig","definition","signatureCount","conflictingName","CONFLICTING_INPUT_TRANSFORM","firstParam","assertEmittableInputType","contextFile","typeName","emittedType","NoAliasing","AllowRelativeDtsImports","SYMBOL_NOT_EXPORTED","metaValues","outputMembers","hostExpr","hostMetaMap","hostMetadata","HOST_BINDING_PARSE_ERROR","msg","hostReference","parseHostDirectivesMapping","classReference","sourceExpression","nameForErrors","rawInputs","hostDirective","mapping","transformFunction","DirectiveSymbol","typeCheckMeta","isInputMappingEqual","isInputOrOutputEqual","isTypeCheckMetaEqual","isBaseClassEqual","isTemplateGuardEqual","FIELD_DECORATORS","LIFECYCLE_HOOKS","DirectiveDecoratorHandler","metaRegistry","strictCtorDeps","angularField","findClassFieldWithAngularFeatures","NONE","AnalyzeDirective","directiveResult","providersRequiringFactory","classMetadata","providerDiagnostics","directiveDiagnostics","hostDirectivesDiagnotics","pool","inputTransformFields","toStmt","decoratorName","compileClassMetadata2","compileDeclareClassMetadata2","compileDeclareInjectorFromMetadata","compileDeclareNgModuleFromMetadata","compileInjector","compileNgModule","ExternalExpr5","FactoryTarget2","FunctionExpr2","InvokeFunctionExpr","LiteralArrayExpr2","R3Identifiers","R3SelectorScopeMode","ReturnStatement2","WrappedNodeExpr6","ts22","ts21","createModuleWithProvidersResolver","_reflectModuleFromTypeParam","isQualifiedName","getText","NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC","_reflectModuleFromLiteralType","isIntersectionTypeNode","t","m","ngModuleType","ngModuleExpression","rawType","mwpCall","isResolvedModuleWithProviders","sv","NgModuleSymbol","hasProviders","remotelyScopedComponents","transitiveImportsFromStandaloneComponents","currEntry","prevEntry","prevEntry2","usedDirectives","usedPipes","previousImports","transitiveImport","addRemotelyScopedComponent","addTransitiveImportFromStandaloneComponent","importedSymbol","NgModuleDecoratorHandler","exportedProviderStatusResolver","onlyPublishPublicTypings","AnalyzeNgModule","moduleResolvers","declarationRefs","declarationMeta","resolveTypeList","importRefs","importsMeta","exportRefs","exportsMeta","bootstrapRefs","bootstrapMeta","makeStandaloneBootstrapDiagnostic","idExpr","isModuleIdExpression","WARN_NGMODULE_ID_UNNECESSARY","Warning","valueContext","exportedNodes","exportedDeclarations","bootstrap","bootstrap2","_toR3Reference","exp","containsForwardDecls","ngModuleMetadata","publicDeclarationTypes","includeImportTypes","selectorScopeMode","SideEffect","wrappedProviders","topLevelImports","rawImports2","topLevelExpressions","absoluteIndex","hasModuleWithProviders","resolvedReferences","injectorMetadata","factoryMetadata","remoteScopesMayRequireCycleProtection","isSyntheticReference","inj","factorySymbolName","scopeDiagnostics","injectorImports","topLevelImport","refsToEmit","sym","importSymbol","isNgModule","factoryFn","ngInjectorDef","insertMetadataStatement","appendRemoteScopingStatements","injectorDef","ngModuleStatements","directiveArray","pipesArray","directiveExpr","pipesExpr","componentType","declExpr","setComponentScope","hasOwningModuleGuess","isClassDeclarationReference","resolvedList","arrayName","refList","entry","recursiveResult","ngModuleClass","bootstrappedClassRef","rawBootstrapExpr","componentClassName","NGMODULE_BOOTSTRAP_IS_STANDALONE","makeCyclicImportInfo","cycle","getPath","checkCustomElementSelectorForErrors","includes","InterpolationConfig","ParseSourceFile2","parseTemplate","ts23","getTemplateDeclarationNodeForError","isInline","templateUrlExpression","extractTemplate","depTracker","resourceLoader","sourceStr","sourceParseRange","templateContent","sourceMapping","escapedString","sourceMapUrl","getTemplateRange","resolvedTemplateUrl","resolvedTemplate","componentClass","parseExtractedTemplate","load","addResourceDependency","templateUrl","i18nNormalizeLineEndingsInICUs","parsedTemplate","preserveWhitespaces","interpolationConfig","range","enableI18nLegacyMessageIdFormat","alwaysAttemptHtmlToR3AstConversion","usePoisonedData","nodes","diagNodes","preserveLineEndings","leadingTriviaChars","parseTemplateDeclaration","containingFile","defaultPreserveWhitespaces","fromArray","templateUrlExpr","resourceUrl","e","makeResourceNotFoundError","COMPONENT_MISSING_TEMPLATE","preloadAndParseTemplate","preanalyzeTemplateCache","templatePromise","preload","templateDecl","templateExpr","startPos","endPos","nodeForError","resourceType","errorText","COMPONENT_RESOURCE_NOT_FOUND","transformDecoratorResources","styleNodes","newMetadataFields","extractComponentStyleUrls","extractStyleUrlsFromExpression","styleUrlsExpr","styleUrls","styleUrlExpr","evaluatedStyleUrls","extractStyleResources","stringLiteralElements","stylesExpr","_extractTemplateStyleUrls","ComponentSymbol","isRemotelyScoped","publicApiAffected","isSymbolUnaffected","typeCheckApiAffected","isInheritanceChainAffected","currentSymbol","isDirectiveUnaffected","isPipeUnaffected","collectAnimationNames","staticTriggerNames","includesDynamicAnimations","isAngularAnimationsReference","animationTriggerResolver","animationTriggerMethodName","triggerNameExpression","validateAndFlattenComponentImports","flattened","childImports","childDiagnostics","isLikelyModuleWithProviders","EMPTY_ARRAY2","ComponentDecoratorHandler","dtsScopeReader","typeCheckScopeRegistry","resourceRegistry","rootDirs","i18nUseExternalIds","cycleAnalyzer","cycleHandlingStrategy","elementSchemaRegistry","preanalyzeStylesCache","extractTemplateOptions","canPreload","resolveStyleUrl","templateAndTemplateStyleResources","componentStyleUrls","inlineStyles","litStyles","preprocessInline","AnalyzeComponent","getDefaultComponentElementName","encapsulation","Emulated","changeDetection","animations","animationExpression","animationsValue","relativeContextFilePath","rootDir","candidate","viewProvidersRequiringFactory","wrappedViewProviders","viewProviders","resolvedImports","COMPONENT_NOT_STANDALONE","importResolvers","imported","importDiagnostics","preanalyzed","styleResources","resourceStr","ShadowDom","selectorError","COMPONENT_INVALID_SHADOW_DOM_SELECTOR","canPreprocess","output","ngContentSelectors","interpolation","binder","boundTemplate","bind","addComponent","templateMeta","addTemplate","getDiagnosticsForComponent","declarationListEmitMode","bound","used","getUsedDirectives","getUsedPipes","seen","dirType","pipeType","isUsedDirective","isUsedPipe","cyclesFromDirectives","cyclesFromPipes","usedDep","_checkForCyclicImport","standaloneImportMayBeForwardDeclared","cycleDetected","maybeRecordSyntheticImport","declarationIsForwardDeclared","wrapDirectivesAndPipesInClosure","moduleSymbol","relatedMessages","IMPORT_CYCLE_DETECTED","standaloneDiagnostics","validateStandaloneImports","viewProviderDiagnostics","updateFromTemplate","resolvedStyleUrl","styleText","s","Component","templateInfo","sourceUrl","inlineTemplateLiteralExpression","wouldCreateCycle","recordSyntheticImport","compileClassMetadata4","compileDeclareClassMetadata4","compileDeclareInjectableFromMetadata","compileInjectable","createMayBeForwardRefExpression2","FactoryTarget4","LiteralExpr3","WrappedNodeExpr8","ts25","InjectableDecoratorHandler","errorOnDuplicateProv","SHARED","AnalyzeInjectable","extractInjectableMetadata","extractInjectableCtorDeps","needsFactory","requiresValidCtor","diagnostic","compileFactoryFn","compileInjectableFn","compileClassMetadataFn","factoryRes","Injectable","ɵprov","INJECTABLE_DUPLICATE_PROV","DECORATOR_NOT_CALLED","providedIn","metaNode","getProviderExpression","depsExpr","VALUE_NOT_LITERAL","getDep","useValue","useClass","useFactory","forwardRefValue","maybeUpdateDecorator","reflector2","compileClassMetadata5","compileDeclareClassMetadata5","compileDeclarePipeFromMetadata","compilePipeFromMetadata","FactoryTarget5","ts26","PipeSymbol","PipeDecoratorHandler","AnalyzePipe","PIPE_MISSING_NAME","pipeNameExpr","pipeName","pure","pureValue","duplicateDeclData","OptimizeFor","OptimizeFor2","PotentialImportKind","PotentialImportKind2","PotentialImportMode","PotentialImportMode2","CompletionKind","CompletionKind2","SymbolKind","SymbolKind2"],"sources":["C:/Users/user/Desktop/SpringBootProject/src/main/resources/my-app/node_modules/@angular/compiler-cli/bundles/chunk-JXL4GN5W.js"],"sourcesContent":["\n      import {createRequire as __cjsCompatRequire} from 'module';\n      const require = __cjsCompatRequire(import.meta.url);\n    \nimport {\n  ClassMemberKind,\n  filterToMembersWithDecorator,\n  isNamedClassDeclaration,\n  reflectObjectLiteral,\n  reflectTypeEntityToDeclaration,\n  typeNodeToValueExpr\n} from \"./chunk-OIJPCKRW.js\";\nimport {\n  ImportManager,\n  translateExpression,\n  translateStatement,\n  translateType\n} from \"./chunk-AAX4HKH5.js\";\nimport {\n  ErrorCode,\n  FatalDiagnosticError,\n  ImportFlags,\n  Reference,\n  assertSuccessfulReferenceEmit,\n  attachDefaultImportDeclaration,\n  getDefaultImportDeclaration,\n  getSourceFile,\n  identifierOfNode,\n  isDeclaration,\n  isFromDtsFile,\n  makeDiagnostic,\n  makeRelatedInformation,\n  nodeDebugInfo,\n  nodeNameForError\n} from \"./chunk-KPIJL3UY.js\";\nimport {\n  PerfEvent,\n  PerfPhase\n} from \"./chunk-HJOPJLIM.js\";\nimport {\n  absoluteFrom,\n  absoluteFromSourceFile,\n  relative\n} from \"./chunk-EC5K6QPP.js\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/util.mjs\nimport { ExternalExpr, ParseLocation, ParseSourceFile, ParseSourceSpan, ReadPropExpr, WrappedNodeExpr } from \"@angular/compiler\";\nimport ts from \"typescript\";\nfunction valueReferenceToExpression(valueRef) {\n  if (valueRef.kind === 2) {\n    return null;\n  } else if (valueRef.kind === 0) {\n    const expr = new WrappedNodeExpr(valueRef.expression);\n    if (valueRef.defaultImportStatement !== null) {\n      attachDefaultImportDeclaration(expr, valueRef.defaultImportStatement);\n    }\n    return expr;\n  } else {\n    let importExpr = new ExternalExpr({ moduleName: valueRef.moduleName, name: valueRef.importedName });\n    if (valueRef.nestedPath !== null) {\n      for (const property of valueRef.nestedPath) {\n        importExpr = new ReadPropExpr(importExpr, property);\n      }\n    }\n    return importExpr;\n  }\n}\nfunction toR3Reference(origin, ref, context, refEmitter) {\n  const emittedValueRef = refEmitter.emit(ref, context);\n  assertSuccessfulReferenceEmit(emittedValueRef, origin, \"class\");\n  const emittedTypeRef = refEmitter.emit(ref, context, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports);\n  assertSuccessfulReferenceEmit(emittedTypeRef, origin, \"class\");\n  return {\n    value: emittedValueRef.expression,\n    type: emittedTypeRef.expression\n  };\n}\nfunction isAngularCore(decorator) {\n  return decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\nfunction isAngularCoreReference(reference, symbolName) {\n  return reference.ownedByModuleGuess === \"@angular/core\" && reference.debugName === symbolName;\n}\nfunction findAngularDecorator(decorators, name, isCore) {\n  return decorators.find((decorator) => isAngularDecorator(decorator, name, isCore));\n}\nfunction isAngularDecorator(decorator, name, isCore) {\n  if (isCore) {\n    return decorator.name === name;\n  } else if (isAngularCore(decorator)) {\n    return decorator.import.name === name;\n  }\n  return false;\n}\nfunction unwrapExpression(node) {\n  while (ts.isAsExpression(node) || ts.isParenthesizedExpression(node)) {\n    node = node.expression;\n  }\n  return node;\n}\nfunction expandForwardRef(arg) {\n  arg = unwrapExpression(arg);\n  if (!ts.isArrowFunction(arg) && !ts.isFunctionExpression(arg)) {\n    return null;\n  }\n  const body = arg.body;\n  if (ts.isBlock(body)) {\n    if (body.statements.length !== 1) {\n      return null;\n    }\n    const stmt = body.statements[0];\n    if (!ts.isReturnStatement(stmt) || stmt.expression === void 0) {\n      return null;\n    }\n    return stmt.expression;\n  } else {\n    return body;\n  }\n}\nfunction tryUnwrapForwardRef(node, reflector) {\n  node = unwrapExpression(node);\n  if (!ts.isCallExpression(node) || node.arguments.length !== 1) {\n    return null;\n  }\n  const fn = ts.isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression;\n  if (!ts.isIdentifier(fn)) {\n    return null;\n  }\n  const expr = expandForwardRef(node.arguments[0]);\n  if (expr === null) {\n    return null;\n  }\n  const imp = reflector.getImportOfIdentifier(fn);\n  if (imp === null || imp.from !== \"@angular/core\" || imp.name !== \"forwardRef\") {\n    return null;\n  }\n  return expr;\n}\nvar forwardRefResolver = (fn, callExpr, resolve, unresolvable) => {\n  if (!isAngularCoreReference(fn, \"forwardRef\") || callExpr.arguments.length !== 1) {\n    return unresolvable;\n  }\n  const expanded = expandForwardRef(callExpr.arguments[0]);\n  if (expanded !== null) {\n    return resolve(expanded);\n  } else {\n    return unresolvable;\n  }\n};\nfunction combineResolvers(resolvers) {\n  return (fn, callExpr, resolve, unresolvable) => {\n    for (const resolver of resolvers) {\n      const resolved = resolver(fn, callExpr, resolve, unresolvable);\n      if (resolved !== unresolvable) {\n        return resolved;\n      }\n    }\n    return unresolvable;\n  };\n}\nfunction isExpressionForwardReference(expr, context, contextSource) {\n  if (isWrappedTsNodeExpr(expr)) {\n    const node = ts.getOriginalNode(expr.node);\n    return node.getSourceFile() === contextSource && context.pos < node.pos;\n  } else {\n    return false;\n  }\n}\nfunction isWrappedTsNodeExpr(expr) {\n  return expr instanceof WrappedNodeExpr;\n}\nfunction readBaseClass(node, reflector, evaluator) {\n  const baseExpression = reflector.getBaseClassExpression(node);\n  if (baseExpression !== null) {\n    const baseClass = evaluator.evaluate(baseExpression);\n    if (baseClass instanceof Reference && reflector.isClass(baseClass.node)) {\n      return baseClass;\n    } else {\n      return \"dynamic\";\n    }\n  }\n  return null;\n}\nvar parensWrapperTransformerFactory = (context) => {\n  const visitor = (node) => {\n    const visited = ts.visitEachChild(node, visitor, context);\n    if (ts.isArrowFunction(visited) || ts.isFunctionExpression(visited)) {\n      return ts.factory.createParenthesizedExpression(visited);\n    }\n    return visited;\n  };\n  return (node) => ts.visitEachChild(node, visitor, context);\n};\nfunction wrapFunctionExpressionsInParens(expression) {\n  return ts.transform(expression, [parensWrapperTransformerFactory]).transformed[0];\n}\nfunction resolveProvidersRequiringFactory(rawProviders, reflector, evaluator) {\n  const providers = /* @__PURE__ */ new Set();\n  const resolvedProviders = evaluator.evaluate(rawProviders);\n  if (!Array.isArray(resolvedProviders)) {\n    return providers;\n  }\n  resolvedProviders.forEach(function processProviders(provider) {\n    let tokenClass = null;\n    if (Array.isArray(provider)) {\n      provider.forEach(processProviders);\n    } else if (provider instanceof Reference) {\n      tokenClass = provider;\n    } else if (provider instanceof Map && provider.has(\"useClass\") && !provider.has(\"deps\")) {\n      const useExisting = provider.get(\"useClass\");\n      if (useExisting instanceof Reference) {\n        tokenClass = useExisting;\n      }\n    }\n    if (tokenClass !== null && !tokenClass.node.getSourceFile().isDeclarationFile && reflector.isClass(tokenClass.node)) {\n      const constructorParameters = reflector.getConstructorParameters(tokenClass.node);\n      if (constructorParameters !== null && constructorParameters.length > 0) {\n        providers.add(tokenClass);\n      }\n    }\n  });\n  return providers;\n}\nfunction wrapTypeReference(reflector, clazz) {\n  const value = new WrappedNodeExpr(clazz.name);\n  const type = value;\n  return { value, type };\n}\nfunction createSourceSpan(node) {\n  const sf = node.getSourceFile();\n  const [startOffset, endOffset] = [node.getStart(), node.getEnd()];\n  const { line: startLine, character: startCol } = sf.getLineAndCharacterOfPosition(startOffset);\n  const { line: endLine, character: endCol } = sf.getLineAndCharacterOfPosition(endOffset);\n  const parseSf = new ParseSourceFile(sf.getFullText(), sf.fileName);\n  return new ParseSourceSpan(new ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1), new ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));\n}\nfunction compileResults(fac, def, metadataStmt, propName, additionalFields) {\n  const statements = def.statements;\n  if (metadataStmt !== null) {\n    statements.push(metadataStmt);\n  }\n  const results = [\n    fac,\n    {\n      name: propName,\n      initializer: def.expression,\n      statements: def.statements,\n      type: def.type\n    }\n  ];\n  if (additionalFields !== null) {\n    results.push(...additionalFields);\n  }\n  return results;\n}\nfunction toFactoryMetadata(meta, target) {\n  return {\n    name: meta.name,\n    type: meta.type,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: meta.deps,\n    target\n  };\n}\nfunction resolveImportedFile(moduleResolver, importedFile, expr, origin) {\n  if (importedFile !== \"unknown\") {\n    return importedFile;\n  }\n  if (!(expr instanceof ExternalExpr)) {\n    return null;\n  }\n  return moduleResolver.resolveModule(expr.value.moduleName, origin.fileName);\n}\nfunction getOriginNodeForDiagnostics(expr, container) {\n  const nodeSf = expr.getSourceFile();\n  const exprSf = container.getSourceFile();\n  if (nodeSf === exprSf && expr.pos >= container.pos && expr.end <= container.end) {\n    return expr;\n  } else {\n    return container;\n  }\n}\nfunction isAbstractClassDeclaration(clazz) {\n  return ts.canHaveModifiers(clazz) && clazz.modifiers !== void 0 ? clazz.modifiers.some((mod) => mod.kind === ts.SyntaxKind.AbstractKeyword) : false;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic.mjs\nvar DynamicValue = class {\n  constructor(node, reason, code) {\n    this.node = node;\n    this.reason = reason;\n    this.code = code;\n  }\n  static fromDynamicInput(node, input) {\n    return new DynamicValue(node, input, 0);\n  }\n  static fromDynamicString(node) {\n    return new DynamicValue(node, void 0, 1);\n  }\n  static fromExternalReference(node, ref) {\n    return new DynamicValue(node, ref, 2);\n  }\n  static fromUnsupportedSyntax(node) {\n    return new DynamicValue(node, void 0, 3);\n  }\n  static fromUnknownIdentifier(node) {\n    return new DynamicValue(node, void 0, 4);\n  }\n  static fromInvalidExpressionType(node, value) {\n    return new DynamicValue(node, value, 5);\n  }\n  static fromComplexFunctionCall(node, fn) {\n    return new DynamicValue(node, fn, 6);\n  }\n  static fromDynamicType(node) {\n    return new DynamicValue(node, void 0, 7);\n  }\n  static fromSyntheticInput(node, value) {\n    return new DynamicValue(node, value, 8);\n  }\n  static fromUnknown(node) {\n    return new DynamicValue(node, void 0, 9);\n  }\n  isFromDynamicInput() {\n    return this.code === 0;\n  }\n  isFromDynamicString() {\n    return this.code === 1;\n  }\n  isFromExternalReference() {\n    return this.code === 2;\n  }\n  isFromUnsupportedSyntax() {\n    return this.code === 3;\n  }\n  isFromUnknownIdentifier() {\n    return this.code === 4;\n  }\n  isFromInvalidExpressionType() {\n    return this.code === 5;\n  }\n  isFromComplexFunctionCall() {\n    return this.code === 6;\n  }\n  isFromDynamicType() {\n    return this.code === 7;\n  }\n  isFromUnknown() {\n    return this.code === 9;\n  }\n  accept(visitor) {\n    switch (this.code) {\n      case 0:\n        return visitor.visitDynamicInput(this);\n      case 1:\n        return visitor.visitDynamicString(this);\n      case 2:\n        return visitor.visitExternalReference(this);\n      case 3:\n        return visitor.visitUnsupportedSyntax(this);\n      case 4:\n        return visitor.visitUnknownIdentifier(this);\n      case 5:\n        return visitor.visitInvalidExpressionType(this);\n      case 6:\n        return visitor.visitComplexFunctionCall(this);\n      case 7:\n        return visitor.visitDynamicType(this);\n      case 8:\n        return visitor.visitSyntheticInput(this);\n      case 9:\n        return visitor.visitUnknown(this);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.mjs\nimport ts2 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/result.mjs\nvar ResolvedModule = class {\n  constructor(exports, evaluate) {\n    this.exports = exports;\n    this.evaluate = evaluate;\n  }\n  getExport(name) {\n    if (!this.exports.has(name)) {\n      return void 0;\n    }\n    return this.evaluate(this.exports.get(name));\n  }\n  getExports() {\n    const map = /* @__PURE__ */ new Map();\n    this.exports.forEach((decl, name) => {\n      map.set(name, this.evaluate(decl));\n    });\n    return map;\n  }\n};\nvar EnumValue = class {\n  constructor(enumRef, name, resolved) {\n    this.enumRef = enumRef;\n    this.name = name;\n    this.resolved = resolved;\n  }\n};\nvar KnownFn = class {\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/builtin.mjs\nvar ArraySliceBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n  evaluate(node, args) {\n    if (args.length === 0) {\n      return this.lhs;\n    } else {\n      return DynamicValue.fromUnknown(node);\n    }\n  }\n};\nvar ArrayConcatBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n  evaluate(node, args) {\n    const result = [...this.lhs];\n    for (const arg of args) {\n      if (arg instanceof DynamicValue) {\n        result.push(DynamicValue.fromDynamicInput(node, arg));\n      } else if (Array.isArray(arg)) {\n        result.push(...arg);\n      } else {\n        result.push(arg);\n      }\n    }\n    return result;\n  }\n};\nvar StringConcatBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n  evaluate(node, args) {\n    let result = this.lhs;\n    for (const arg of args) {\n      const resolved = arg instanceof EnumValue ? arg.resolved : arg;\n      if (typeof resolved === \"string\" || typeof resolved === \"number\" || typeof resolved === \"boolean\" || resolved == null) {\n        result = result.concat(resolved);\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n    return result;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/synthetic.mjs\nvar SyntheticValue = class {\n  constructor(value) {\n    this.value = value;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.mjs\nfunction literalBinaryOp(op) {\n  return { op, literal: true };\n}\nfunction referenceBinaryOp(op) {\n  return { op, literal: false };\n}\nvar BINARY_OPERATORS = /* @__PURE__ */ new Map([\n  [ts2.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)],\n  [ts2.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)],\n  [ts2.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)],\n  [ts2.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)],\n  [ts2.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)],\n  [ts2.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)],\n  [ts2.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)],\n  [ts2.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)],\n  [ts2.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)],\n  [ts2.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)],\n  [ts2.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)],\n  [ts2.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)],\n  [ts2.SyntaxKind.EqualsEqualsToken, literalBinaryOp((a, b) => a == b)],\n  [ts2.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp((a, b) => a === b)],\n  [ts2.SyntaxKind.ExclamationEqualsToken, literalBinaryOp((a, b) => a != b)],\n  [ts2.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp((a, b) => a !== b)],\n  [ts2.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)],\n  [ts2.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)],\n  [ts2.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)],\n  [ts2.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))],\n  [ts2.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)],\n  [ts2.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]\n]);\nvar UNARY_OPERATORS = /* @__PURE__ */ new Map([\n  [ts2.SyntaxKind.TildeToken, (a) => ~a],\n  [ts2.SyntaxKind.MinusToken, (a) => -a],\n  [ts2.SyntaxKind.PlusToken, (a) => +a],\n  [ts2.SyntaxKind.ExclamationToken, (a) => !a]\n]);\nvar StaticInterpreter = class {\n  constructor(host, checker, dependencyTracker) {\n    this.host = host;\n    this.checker = checker;\n    this.dependencyTracker = dependencyTracker;\n  }\n  visit(node, context) {\n    return this.visitExpression(node, context);\n  }\n  visitExpression(node, context) {\n    let result;\n    if (node.kind === ts2.SyntaxKind.TrueKeyword) {\n      return true;\n    } else if (node.kind === ts2.SyntaxKind.FalseKeyword) {\n      return false;\n    } else if (node.kind === ts2.SyntaxKind.NullKeyword) {\n      return null;\n    } else if (ts2.isStringLiteral(node)) {\n      return node.text;\n    } else if (ts2.isNoSubstitutionTemplateLiteral(node)) {\n      return node.text;\n    } else if (ts2.isTemplateExpression(node)) {\n      result = this.visitTemplateExpression(node, context);\n    } else if (ts2.isNumericLiteral(node)) {\n      return parseFloat(node.text);\n    } else if (ts2.isObjectLiteralExpression(node)) {\n      result = this.visitObjectLiteralExpression(node, context);\n    } else if (ts2.isIdentifier(node)) {\n      result = this.visitIdentifier(node, context);\n    } else if (ts2.isPropertyAccessExpression(node)) {\n      result = this.visitPropertyAccessExpression(node, context);\n    } else if (ts2.isCallExpression(node)) {\n      result = this.visitCallExpression(node, context);\n    } else if (ts2.isConditionalExpression(node)) {\n      result = this.visitConditionalExpression(node, context);\n    } else if (ts2.isPrefixUnaryExpression(node)) {\n      result = this.visitPrefixUnaryExpression(node, context);\n    } else if (ts2.isBinaryExpression(node)) {\n      result = this.visitBinaryExpression(node, context);\n    } else if (ts2.isArrayLiteralExpression(node)) {\n      result = this.visitArrayLiteralExpression(node, context);\n    } else if (ts2.isParenthesizedExpression(node)) {\n      result = this.visitParenthesizedExpression(node, context);\n    } else if (ts2.isElementAccessExpression(node)) {\n      result = this.visitElementAccessExpression(node, context);\n    } else if (ts2.isAsExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (ts2.isNonNullExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (this.host.isClass(node)) {\n      result = this.visitDeclaration(node, context);\n    } else {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    if (result instanceof DynamicValue && result.node !== node) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n  visitArrayLiteralExpression(node, context) {\n    const array = [];\n    for (let i = 0; i < node.elements.length; i++) {\n      const element = node.elements[i];\n      if (ts2.isSpreadElement(element)) {\n        array.push(...this.visitSpreadElement(element, context));\n      } else {\n        array.push(this.visitExpression(element, context));\n      }\n    }\n    return array;\n  }\n  visitObjectLiteralExpression(node, context) {\n    const map = /* @__PURE__ */ new Map();\n    for (let i = 0; i < node.properties.length; i++) {\n      const property = node.properties[i];\n      if (ts2.isPropertyAssignment(property)) {\n        const name = this.stringNameFromPropertyName(property.name, context);\n        if (name === void 0) {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromDynamicString(property.name));\n        }\n        map.set(name, this.visitExpression(property.initializer, context));\n      } else if (ts2.isShorthandPropertyAssignment(property)) {\n        const symbol = this.checker.getShorthandAssignmentValueSymbol(property);\n        if (symbol === void 0 || symbol.valueDeclaration === void 0) {\n          map.set(property.name.text, DynamicValue.fromUnknown(property));\n        } else {\n          map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));\n        }\n      } else if (ts2.isSpreadAssignment(property)) {\n        const spread = this.visitExpression(property.expression, context);\n        if (spread instanceof DynamicValue) {\n          return DynamicValue.fromDynamicInput(node, spread);\n        } else if (spread instanceof Map) {\n          spread.forEach((value, key) => map.set(key, value));\n        } else if (spread instanceof ResolvedModule) {\n          spread.getExports().forEach((value, key) => map.set(key, value));\n        } else {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromInvalidExpressionType(property, spread));\n        }\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n    return map;\n  }\n  visitTemplateExpression(node, context) {\n    const pieces = [node.head.text];\n    for (let i = 0; i < node.templateSpans.length; i++) {\n      const span = node.templateSpans[i];\n      const value = literal(this.visit(span.expression, context), () => DynamicValue.fromDynamicString(span.expression));\n      if (value instanceof DynamicValue) {\n        return DynamicValue.fromDynamicInput(node, value);\n      }\n      pieces.push(`${value}`, span.literal.text);\n    }\n    return pieces.join(\"\");\n  }\n  visitIdentifier(node, context) {\n    const decl = this.host.getDeclarationOfIdentifier(node);\n    if (decl === null) {\n      if (getOriginalKeywordKind(node) === ts2.SyntaxKind.UndefinedKeyword) {\n        return void 0;\n      } else {\n        if (this.dependencyTracker !== null && this.host.getImportOfIdentifier(node) !== null) {\n          this.dependencyTracker.recordDependencyAnalysisFailure(context.originatingFile);\n        }\n        return DynamicValue.fromUnknownIdentifier(node);\n      }\n    }\n    const declContext = { ...context, ...joinModuleContext(context, node, decl) };\n    const result = this.visitDeclaration(decl.node, declContext);\n    if (result instanceof Reference) {\n      if (!result.synthetic) {\n        result.addIdentifier(node);\n      }\n    } else if (result instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n  visitDeclaration(node, context) {\n    if (this.dependencyTracker !== null) {\n      this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());\n    }\n    if (this.host.isClass(node)) {\n      return this.getReference(node, context);\n    } else if (ts2.isVariableDeclaration(node)) {\n      return this.visitVariableDeclaration(node, context);\n    } else if (ts2.isParameter(node) && context.scope.has(node)) {\n      return context.scope.get(node);\n    } else if (ts2.isExportAssignment(node)) {\n      return this.visitExpression(node.expression, context);\n    } else if (ts2.isEnumDeclaration(node)) {\n      return this.visitEnumDeclaration(node, context);\n    } else if (ts2.isSourceFile(node)) {\n      return this.visitSourceFile(node, context);\n    } else if (ts2.isBindingElement(node)) {\n      return this.visitBindingElement(node, context);\n    } else {\n      return this.getReference(node, context);\n    }\n  }\n  visitVariableDeclaration(node, context) {\n    const value = this.host.getVariableValue(node);\n    if (value !== null) {\n      return this.visitExpression(value, context);\n    } else if (isVariableDeclarationDeclared(node)) {\n      if (node.type !== void 0) {\n        const evaluatedType = this.visitType(node.type, context);\n        if (!(evaluatedType instanceof DynamicValue)) {\n          return evaluatedType;\n        }\n      }\n      return this.getReference(node, context);\n    } else {\n      return void 0;\n    }\n  }\n  visitEnumDeclaration(node, context) {\n    const enumRef = this.getReference(node, context);\n    const map = /* @__PURE__ */ new Map();\n    node.members.forEach((member) => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n      if (name !== void 0) {\n        const resolved = member.initializer && this.visit(member.initializer, context);\n        map.set(name, new EnumValue(enumRef, name, resolved));\n      }\n    });\n    return map;\n  }\n  visitElementAccessExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    const rhs = this.visitExpression(node.argumentExpression, context);\n    if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    }\n    if (typeof rhs !== \"string\" && typeof rhs !== \"number\") {\n      return DynamicValue.fromInvalidExpressionType(node, rhs);\n    }\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n  visitPropertyAccessExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    const rhs = node.name.text;\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n  visitSourceFile(node, context) {\n    const declarations = this.host.getExportsOfModule(node);\n    if (declarations === null) {\n      return DynamicValue.fromUnknown(node);\n    }\n    return new ResolvedModule(declarations, (decl) => {\n      const declContext = {\n        ...context,\n        ...joinModuleContext(context, node, decl)\n      };\n      return this.visitDeclaration(decl.node, declContext);\n    });\n  }\n  accessHelper(node, lhs, rhs, context) {\n    const strIndex = `${rhs}`;\n    if (lhs instanceof Map) {\n      if (lhs.has(strIndex)) {\n        return lhs.get(strIndex);\n      } else {\n        return void 0;\n      }\n    } else if (lhs instanceof ResolvedModule) {\n      return lhs.getExport(strIndex);\n    } else if (Array.isArray(lhs)) {\n      if (rhs === \"length\") {\n        return lhs.length;\n      } else if (rhs === \"slice\") {\n        return new ArraySliceBuiltinFn(lhs);\n      } else if (rhs === \"concat\") {\n        return new ArrayConcatBuiltinFn(lhs);\n      }\n      if (typeof rhs !== \"number\" || !Number.isInteger(rhs)) {\n        return DynamicValue.fromInvalidExpressionType(node, rhs);\n      }\n      return lhs[rhs];\n    } else if (typeof lhs === \"string\" && rhs === \"concat\") {\n      return new StringConcatBuiltinFn(lhs);\n    } else if (lhs instanceof Reference) {\n      const ref = lhs.node;\n      if (this.host.isClass(ref)) {\n        const module = owningModule(context, lhs.bestGuessOwningModule);\n        let value = void 0;\n        const member = this.host.getMembersOfClass(ref).find((member2) => member2.isStatic && member2.name === strIndex);\n        if (member !== void 0) {\n          if (member.value !== null) {\n            value = this.visitExpression(member.value, context);\n          } else if (member.implementation !== null) {\n            value = new Reference(member.implementation, module);\n          } else if (member.node) {\n            value = new Reference(member.node, module);\n          }\n        }\n        return value;\n      } else if (isDeclaration(ref)) {\n        return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(ref, lhs));\n      }\n    } else if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    } else if (lhs instanceof SyntheticValue) {\n      return DynamicValue.fromSyntheticInput(node, lhs);\n    }\n    return DynamicValue.fromUnknown(node);\n  }\n  visitCallExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    if (lhs instanceof KnownFn) {\n      return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));\n    }\n    if (!(lhs instanceof Reference)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n    const fn = this.host.getDefinitionOfFunction(lhs.node);\n    if (fn === null) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n    if (!isFunctionOrMethodReference(lhs)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n    const resolveFfrExpr = (expr) => {\n      let contextExtension = {};\n      if (fn.body === null && expr.getSourceFile() !== node.expression.getSourceFile() && lhs.bestGuessOwningModule !== null) {\n        contextExtension = {\n          absoluteModuleName: lhs.bestGuessOwningModule.specifier,\n          resolutionContext: lhs.bestGuessOwningModule.resolutionContext\n        };\n      }\n      return this.visitFfrExpression(expr, { ...context, ...contextExtension });\n    };\n    if (fn.body === null && context.foreignFunctionResolver !== void 0) {\n      const unresolvable = DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(node.expression, lhs));\n      return context.foreignFunctionResolver(lhs, node, resolveFfrExpr, unresolvable);\n    }\n    const res = this.visitFunctionBody(node, fn, context);\n    if (res instanceof DynamicValue && context.foreignFunctionResolver !== void 0) {\n      const unresolvable = DynamicValue.fromComplexFunctionCall(node, fn);\n      return context.foreignFunctionResolver(lhs, node, resolveFfrExpr, unresolvable);\n    }\n    return res;\n  }\n  visitFfrExpression(expr, context) {\n    const res = this.visitExpression(expr, context);\n    if (res instanceof Reference) {\n      res.synthetic = true;\n    }\n    return res;\n  }\n  visitFunctionBody(node, fn, context) {\n    if (fn.body === null) {\n      return DynamicValue.fromUnknown(node);\n    } else if (fn.body.length !== 1 || !ts2.isReturnStatement(fn.body[0])) {\n      return DynamicValue.fromComplexFunctionCall(node, fn);\n    }\n    const ret = fn.body[0];\n    const args = this.evaluateFunctionArguments(node, context);\n    const newScope = /* @__PURE__ */ new Map();\n    const calleeContext = { ...context, scope: newScope };\n    fn.parameters.forEach((param, index) => {\n      let arg = args[index];\n      if (param.node.dotDotDotToken !== void 0) {\n        arg = args.slice(index);\n      }\n      if (arg === void 0 && param.initializer !== null) {\n        arg = this.visitExpression(param.initializer, calleeContext);\n      }\n      newScope.set(param.node, arg);\n    });\n    return ret.expression !== void 0 ? this.visitExpression(ret.expression, calleeContext) : void 0;\n  }\n  visitConditionalExpression(node, context) {\n    const condition = this.visitExpression(node.condition, context);\n    if (condition instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, condition);\n    }\n    if (condition) {\n      return this.visitExpression(node.whenTrue, context);\n    } else {\n      return this.visitExpression(node.whenFalse, context);\n    }\n  }\n  visitPrefixUnaryExpression(node, context) {\n    const operatorKind = node.operator;\n    if (!UNARY_OPERATORS.has(operatorKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    const op = UNARY_OPERATORS.get(operatorKind);\n    const value = this.visitExpression(node.operand, context);\n    if (value instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, value);\n    } else {\n      return op(value);\n    }\n  }\n  visitBinaryExpression(node, context) {\n    const tokenKind = node.operatorToken.kind;\n    if (!BINARY_OPERATORS.has(tokenKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    const opRecord = BINARY_OPERATORS.get(tokenKind);\n    let lhs, rhs;\n    if (opRecord.literal) {\n      lhs = literal(this.visitExpression(node.left, context), (value) => DynamicValue.fromInvalidExpressionType(node.left, value));\n      rhs = literal(this.visitExpression(node.right, context), (value) => DynamicValue.fromInvalidExpressionType(node.right, value));\n    } else {\n      lhs = this.visitExpression(node.left, context);\n      rhs = this.visitExpression(node.right, context);\n    }\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    } else if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    } else {\n      return opRecord.op(lhs, rhs);\n    }\n  }\n  visitParenthesizedExpression(node, context) {\n    return this.visitExpression(node.expression, context);\n  }\n  evaluateFunctionArguments(node, context) {\n    const args = [];\n    for (const arg of node.arguments) {\n      if (ts2.isSpreadElement(arg)) {\n        args.push(...this.visitSpreadElement(arg, context));\n      } else {\n        args.push(this.visitExpression(arg, context));\n      }\n    }\n    return args;\n  }\n  visitSpreadElement(node, context) {\n    const spread = this.visitExpression(node.expression, context);\n    if (spread instanceof DynamicValue) {\n      return [DynamicValue.fromDynamicInput(node, spread)];\n    } else if (!Array.isArray(spread)) {\n      return [DynamicValue.fromInvalidExpressionType(node, spread)];\n    } else {\n      return spread;\n    }\n  }\n  visitBindingElement(node, context) {\n    const path = [];\n    let closestDeclaration = node;\n    while (ts2.isBindingElement(closestDeclaration) || ts2.isArrayBindingPattern(closestDeclaration) || ts2.isObjectBindingPattern(closestDeclaration)) {\n      if (ts2.isBindingElement(closestDeclaration)) {\n        path.unshift(closestDeclaration);\n      }\n      closestDeclaration = closestDeclaration.parent;\n    }\n    if (!ts2.isVariableDeclaration(closestDeclaration) || closestDeclaration.initializer === void 0) {\n      return DynamicValue.fromUnknown(node);\n    }\n    let value = this.visit(closestDeclaration.initializer, context);\n    for (const element of path) {\n      let key;\n      if (ts2.isArrayBindingPattern(element.parent)) {\n        key = element.parent.elements.indexOf(element);\n      } else {\n        const name = element.propertyName || element.name;\n        if (ts2.isIdentifier(name)) {\n          key = name.text;\n        } else {\n          return DynamicValue.fromUnknown(element);\n        }\n      }\n      value = this.accessHelper(element, value, key, context);\n      if (value instanceof DynamicValue) {\n        return value;\n      }\n    }\n    return value;\n  }\n  stringNameFromPropertyName(node, context) {\n    if (ts2.isIdentifier(node) || ts2.isStringLiteral(node) || ts2.isNumericLiteral(node)) {\n      return node.text;\n    } else if (ts2.isComputedPropertyName(node)) {\n      const literal2 = this.visitExpression(node.expression, context);\n      return typeof literal2 === \"string\" ? literal2 : void 0;\n    } else {\n      return void 0;\n    }\n  }\n  getReference(node, context) {\n    return new Reference(node, owningModule(context));\n  }\n  visitType(node, context) {\n    if (ts2.isLiteralTypeNode(node)) {\n      return this.visitExpression(node.literal, context);\n    } else if (ts2.isTupleTypeNode(node)) {\n      return this.visitTupleType(node, context);\n    } else if (ts2.isNamedTupleMember(node)) {\n      return this.visitType(node.type, context);\n    } else if (ts2.isTypeOperatorNode(node) && node.operator === ts2.SyntaxKind.ReadonlyKeyword) {\n      return this.visitType(node.type, context);\n    } else if (ts2.isTypeQueryNode(node)) {\n      return this.visitTypeQuery(node, context);\n    }\n    return DynamicValue.fromDynamicType(node);\n  }\n  visitTupleType(node, context) {\n    const res = [];\n    for (const elem of node.elements) {\n      res.push(this.visitType(elem, context));\n    }\n    return res;\n  }\n  visitTypeQuery(node, context) {\n    if (!ts2.isIdentifier(node.exprName)) {\n      return DynamicValue.fromUnknown(node);\n    }\n    const decl = this.host.getDeclarationOfIdentifier(node.exprName);\n    if (decl === null) {\n      return DynamicValue.fromUnknownIdentifier(node.exprName);\n    }\n    const declContext = { ...context, ...joinModuleContext(context, node, decl) };\n    return this.visitDeclaration(decl.node, declContext);\n  }\n};\nfunction isFunctionOrMethodReference(ref) {\n  return ts2.isFunctionDeclaration(ref.node) || ts2.isMethodDeclaration(ref.node) || ts2.isFunctionExpression(ref.node);\n}\nfunction literal(value, reject) {\n  if (value instanceof EnumValue) {\n    value = value.resolved;\n  }\n  if (value instanceof DynamicValue || value === null || value === void 0 || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n  return reject(value);\n}\nfunction isVariableDeclarationDeclared(node) {\n  if (node.parent === void 0 || !ts2.isVariableDeclarationList(node.parent)) {\n    return false;\n  }\n  const declList = node.parent;\n  if (declList.parent === void 0 || !ts2.isVariableStatement(declList.parent)) {\n    return false;\n  }\n  const varStmt = declList.parent;\n  const modifiers = ts2.getModifiers(varStmt);\n  return modifiers !== void 0 && modifiers.some((mod) => mod.kind === ts2.SyntaxKind.DeclareKeyword);\n}\nvar EMPTY = {};\nfunction joinModuleContext(existing, node, decl) {\n  if (decl.viaModule !== null && decl.viaModule !== existing.absoluteModuleName) {\n    return {\n      absoluteModuleName: decl.viaModule,\n      resolutionContext: node.getSourceFile().fileName\n    };\n  } else {\n    return EMPTY;\n  }\n}\nfunction owningModule(context, override = null) {\n  let specifier = context.absoluteModuleName;\n  if (override !== null) {\n    specifier = override.specifier;\n  }\n  if (specifier !== null) {\n    return {\n      specifier,\n      resolutionContext: context.resolutionContext\n    };\n  } else {\n    return null;\n  }\n}\nfunction getOriginalKeywordKind(identifier) {\n  return typeof ts2.identifierToKeywordKind === \"function\" ? ts2.identifierToKeywordKind(identifier) : identifier.originalKeywordKind;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interface.mjs\nvar PartialEvaluator = class {\n  constructor(host, checker, dependencyTracker) {\n    this.host = host;\n    this.checker = checker;\n    this.dependencyTracker = dependencyTracker;\n  }\n  evaluate(expr, foreignFunctionResolver) {\n    const interpreter = new StaticInterpreter(this.host, this.checker, this.dependencyTracker);\n    const sourceFile = expr.getSourceFile();\n    return interpreter.visit(expr, {\n      originatingFile: sourceFile,\n      absoluteModuleName: null,\n      resolutionContext: sourceFile.fileName,\n      scope: /* @__PURE__ */ new Map(),\n      foreignFunctionResolver\n    });\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.mjs\nimport ts3 from \"typescript\";\nfunction describeResolvedType(value, maxDepth = 1) {\n  var _a, _b;\n  if (value === null) {\n    return \"null\";\n  } else if (value === void 0) {\n    return \"undefined\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"string\") {\n    return typeof value;\n  } else if (value instanceof Map) {\n    if (maxDepth === 0) {\n      return \"object\";\n    }\n    const entries = Array.from(value.entries()).map(([key, v]) => {\n      return `${quoteKey(key)}: ${describeResolvedType(v, maxDepth - 1)}`;\n    });\n    return entries.length > 0 ? `{ ${entries.join(\"; \")} }` : \"{}\";\n  } else if (value instanceof ResolvedModule) {\n    return \"(module)\";\n  } else if (value instanceof EnumValue) {\n    return (_a = value.enumRef.debugName) != null ? _a : \"(anonymous)\";\n  } else if (value instanceof Reference) {\n    return (_b = value.debugName) != null ? _b : \"(anonymous)\";\n  } else if (Array.isArray(value)) {\n    if (maxDepth === 0) {\n      return \"Array\";\n    }\n    return `[${value.map((v) => describeResolvedType(v, maxDepth - 1)).join(\", \")}]`;\n  } else if (value instanceof DynamicValue) {\n    return \"(not statically analyzable)\";\n  } else if (value instanceof KnownFn) {\n    return \"Function\";\n  } else {\n    return \"unknown\";\n  }\n}\nfunction quoteKey(key) {\n  if (/^[a-z0-9_]+$/i.test(key)) {\n    return key;\n  } else {\n    return `'${key.replace(/'/g, \"\\\\'\")}'`;\n  }\n}\nfunction traceDynamicValue(node, value) {\n  return value.accept(new TraceDynamicValueVisitor(node));\n}\nvar TraceDynamicValueVisitor = class {\n  constructor(node) {\n    this.node = node;\n    this.currentContainerNode = null;\n  }\n  visitDynamicInput(value) {\n    const trace = value.reason.accept(this);\n    if (this.shouldTrace(value.node)) {\n      const info = makeRelatedInformation(value.node, \"Unable to evaluate this expression statically.\");\n      trace.unshift(info);\n    }\n    return trace;\n  }\n  visitSyntheticInput(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate this expression further.\")];\n  }\n  visitDynamicString(value) {\n    return [makeRelatedInformation(value.node, \"A string value could not be determined statically.\")];\n  }\n  visitExternalReference(value) {\n    const name = value.reason.debugName;\n    const description = name !== null ? `'${name}'` : \"an anonymous declaration\";\n    return [makeRelatedInformation(value.node, `A value for ${description} cannot be determined statically, as it is an external declaration.`)];\n  }\n  visitComplexFunctionCall(value) {\n    return [\n      makeRelatedInformation(value.node, \"Unable to evaluate function call of complex function. A function must have exactly one return statement.\"),\n      makeRelatedInformation(value.reason.node, \"Function is declared here.\")\n    ];\n  }\n  visitInvalidExpressionType(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate an invalid expression.\")];\n  }\n  visitUnknown(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate statically.\")];\n  }\n  visitUnknownIdentifier(value) {\n    return [makeRelatedInformation(value.node, \"Unknown reference.\")];\n  }\n  visitDynamicType(value) {\n    return [makeRelatedInformation(value.node, \"Dynamic type.\")];\n  }\n  visitUnsupportedSyntax(value) {\n    return [makeRelatedInformation(value.node, \"This syntax is not supported.\")];\n  }\n  shouldTrace(node) {\n    if (node === this.node) {\n      return false;\n    }\n    const container = getContainerNode(node);\n    if (container === this.currentContainerNode) {\n      return false;\n    }\n    this.currentContainerNode = container;\n    return true;\n  }\n};\nfunction getContainerNode(node) {\n  let currentNode = node;\n  while (currentNode !== void 0) {\n    switch (currentNode.kind) {\n      case ts3.SyntaxKind.ExpressionStatement:\n      case ts3.SyntaxKind.VariableStatement:\n      case ts3.SyntaxKind.ReturnStatement:\n      case ts3.SyntaxKind.IfStatement:\n      case ts3.SyntaxKind.SwitchStatement:\n      case ts3.SyntaxKind.DoStatement:\n      case ts3.SyntaxKind.WhileStatement:\n      case ts3.SyntaxKind.ForStatement:\n      case ts3.SyntaxKind.ForInStatement:\n      case ts3.SyntaxKind.ForOfStatement:\n      case ts3.SyntaxKind.ContinueStatement:\n      case ts3.SyntaxKind.BreakStatement:\n      case ts3.SyntaxKind.ThrowStatement:\n      case ts3.SyntaxKind.ObjectBindingPattern:\n      case ts3.SyntaxKind.ArrayBindingPattern:\n        return currentNode;\n    }\n    currentNode = currentNode.parent;\n  }\n  return node.getSourceFile();\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/di.mjs\nimport { LiteralExpr, WrappedNodeExpr as WrappedNodeExpr2 } from \"@angular/compiler\";\nimport ts4 from \"typescript\";\nfunction getConstructorDependencies(clazz, reflector, isCore) {\n  const deps = [];\n  const errors = [];\n  let ctorParams = reflector.getConstructorParameters(clazz);\n  if (ctorParams === null) {\n    if (reflector.hasBaseClass(clazz)) {\n      return null;\n    } else {\n      ctorParams = [];\n    }\n  }\n  ctorParams.forEach((param, idx) => {\n    let token = valueReferenceToExpression(param.typeValueReference);\n    let attributeNameType = null;\n    let optional = false, self = false, skipSelf = false, host = false;\n    (param.decorators || []).filter((dec) => isCore || isAngularCore(dec)).forEach((dec) => {\n      const name = isCore || dec.import === null ? dec.name : dec.import.name;\n      if (name === \"Inject\") {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, dec.node, `Unexpected number of arguments to @Inject().`);\n        }\n        token = new WrappedNodeExpr2(dec.args[0]);\n      } else if (name === \"Optional\") {\n        optional = true;\n      } else if (name === \"SkipSelf\") {\n        skipSelf = true;\n      } else if (name === \"Self\") {\n        self = true;\n      } else if (name === \"Host\") {\n        host = true;\n      } else if (name === \"Attribute\") {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, dec.node, `Unexpected number of arguments to @Attribute().`);\n        }\n        const attributeName = dec.args[0];\n        token = new WrappedNodeExpr2(attributeName);\n        if (ts4.isStringLiteralLike(attributeName)) {\n          attributeNameType = new LiteralExpr(attributeName.text);\n        } else {\n          attributeNameType = new WrappedNodeExpr2(ts4.factory.createKeywordTypeNode(ts4.SyntaxKind.UnknownKeyword));\n        }\n      } else {\n        throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, dec.node, `Unexpected decorator ${name} on parameter.`);\n      }\n    });\n    if (token === null) {\n      if (param.typeValueReference.kind !== 2) {\n        throw new Error(\"Illegal state: expected value reference to be unavailable if no token is present\");\n      }\n      errors.push({\n        index: idx,\n        param,\n        reason: param.typeValueReference.reason\n      });\n    } else {\n      deps.push({ token, attributeNameType, optional, self, skipSelf, host });\n    }\n  });\n  if (errors.length === 0) {\n    return { deps };\n  } else {\n    return { deps: null, errors };\n  }\n}\nfunction unwrapConstructorDependencies(deps) {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    return \"invalid\";\n  }\n}\nfunction getValidConstructorDependencies(clazz, reflector, isCore) {\n  return validateConstructorDependencies(clazz, getConstructorDependencies(clazz, reflector, isCore));\n}\nfunction validateConstructorDependencies(clazz, deps) {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    const error = deps.errors[0];\n    throw createUnsuitableInjectionTokenError(clazz, error);\n  }\n}\nfunction createUnsuitableInjectionTokenError(clazz, error) {\n  const { param, index, reason } = error;\n  let chainMessage = void 0;\n  let hints = void 0;\n  switch (reason.kind) {\n    case 5:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [\n        makeRelatedInformation(reason.typeNode, \"This type is not supported as injection token.\")\n      ];\n      break;\n    case 1:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [\n        makeRelatedInformation(reason.typeNode, \"This type does not have a value, so it cannot be used as injection token.\")\n      ];\n      if (reason.decl !== null) {\n        hints.push(makeRelatedInformation(reason.decl, \"The type is declared here.\"));\n      }\n      break;\n    case 2:\n      chainMessage = \"Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.\";\n      hints = [\n        makeRelatedInformation(reason.typeNode, \"This type is imported using a type-only import, which prevents it from being usable as an injection token.\"),\n        makeRelatedInformation(reason.node, \"The type-only import occurs here.\")\n      ];\n      break;\n    case 4:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [\n        makeRelatedInformation(reason.typeNode, \"This type corresponds with a namespace, which cannot be used as injection token.\"),\n        makeRelatedInformation(reason.importClause, \"The namespace import occurs here.\")\n      ];\n      break;\n    case 3:\n      chainMessage = \"The type should reference a known declaration.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type could not be resolved.\")];\n      break;\n    case 0:\n      chainMessage = \"Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.\";\n      break;\n  }\n  const chain = {\n    messageText: `No suitable injection token for parameter '${param.name || index}' of class '${clazz.name.text}'.`,\n    category: ts4.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainMessage,\n      category: ts4.DiagnosticCategory.Message,\n      code: 0\n    }]\n  };\n  return new FatalDiagnosticError(ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/diagnostics.mjs\nimport ts7 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/api.mjs\nvar MetaKind;\n(function(MetaKind2) {\n  MetaKind2[MetaKind2[\"Directive\"] = 0] = \"Directive\";\n  MetaKind2[MetaKind2[\"Pipe\"] = 1] = \"Pipe\";\n  MetaKind2[MetaKind2[\"NgModule\"] = 2] = \"NgModule\";\n})(MetaKind || (MetaKind = {}));\nvar MatchSource;\n(function(MatchSource2) {\n  MatchSource2[MatchSource2[\"Selector\"] = 0] = \"Selector\";\n  MatchSource2[MatchSource2[\"HostDirective\"] = 1] = \"HostDirective\";\n})(MatchSource || (MatchSource = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/dts.mjs\nimport ts6 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/property_mapping.mjs\nvar ClassPropertyMapping = class {\n  constructor(forwardMap) {\n    this.forwardMap = forwardMap;\n    this.reverseMap = reverseMapFromForwardMap(forwardMap);\n  }\n  static empty() {\n    return new ClassPropertyMapping(/* @__PURE__ */ new Map());\n  }\n  static fromMappedObject(obj) {\n    const forwardMap = /* @__PURE__ */ new Map();\n    for (const classPropertyName of Object.keys(obj)) {\n      const value = obj[classPropertyName];\n      let inputOrOutput;\n      if (typeof value === \"string\") {\n        inputOrOutput = { classPropertyName, bindingPropertyName: value };\n      } else if (Array.isArray(value)) {\n        inputOrOutput = { classPropertyName, bindingPropertyName: value[0] };\n      } else {\n        inputOrOutput = value;\n      }\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n    return new ClassPropertyMapping(forwardMap);\n  }\n  static merge(a, b) {\n    const forwardMap = new Map(a.forwardMap.entries());\n    for (const [classPropertyName, inputOrOutput] of b.forwardMap) {\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n    return new ClassPropertyMapping(forwardMap);\n  }\n  get classPropertyNames() {\n    return Array.from(this.forwardMap.keys());\n  }\n  get propertyNames() {\n    return Array.from(this.reverseMap.keys());\n  }\n  hasBindingPropertyName(propertyName) {\n    return this.reverseMap.has(propertyName);\n  }\n  getByBindingPropertyName(propertyName) {\n    return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName) : null;\n  }\n  getByClassPropertyName(classPropertyName) {\n    return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName) : null;\n  }\n  toDirectMappedObject() {\n    const obj = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n    }\n    return obj;\n  }\n  toJointMappedObject(transform) {\n    const obj = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      obj[classPropertyName] = transform(inputOrOutput);\n    }\n    return obj;\n  }\n  *[Symbol.iterator]() {\n    for (const inputOrOutput of this.forwardMap.values()) {\n      yield inputOrOutput;\n    }\n  }\n};\nfunction reverseMapFromForwardMap(forwardMap) {\n  const reverseMap = /* @__PURE__ */ new Map();\n  for (const [_, inputOrOutput] of forwardMap) {\n    if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {\n      reverseMap.set(inputOrOutput.bindingPropertyName, []);\n    }\n    reverseMap.get(inputOrOutput.bindingPropertyName).push(inputOrOutput);\n  }\n  return reverseMap;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/util.mjs\nimport ts5 from \"typescript\";\nfunction extractReferencesFromType(checker, def, bestGuessOwningModule) {\n  if (!ts5.isTupleTypeNode(def)) {\n    return [];\n  }\n  return def.elements.map((element) => {\n    if (!ts5.isTypeQueryNode(element)) {\n      throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(element)}`);\n    }\n    return extraReferenceFromTypeQuery(checker, element, def, bestGuessOwningModule);\n  });\n}\nfunction extraReferenceFromTypeQuery(checker, typeNode, origin, bestGuessOwningModule) {\n  const type = typeNode.exprName;\n  const { node, from } = reflectTypeEntityToDeclaration(type, checker);\n  if (!isNamedClassDeclaration(node)) {\n    throw new Error(`Expected named ClassDeclaration: ${nodeDebugInfo(node)}`);\n  }\n  if (from !== null && !from.startsWith(\".\")) {\n    return new Reference(node, { specifier: from, resolutionContext: origin.getSourceFile().fileName });\n  }\n  return new Reference(node, bestGuessOwningModule);\n}\nfunction readBooleanType(type) {\n  if (!ts5.isLiteralTypeNode(type)) {\n    return null;\n  }\n  switch (type.literal.kind) {\n    case ts5.SyntaxKind.TrueKeyword:\n      return true;\n    case ts5.SyntaxKind.FalseKeyword:\n      return false;\n    default:\n      return null;\n  }\n}\nfunction readStringType(type) {\n  if (!ts5.isLiteralTypeNode(type) || !ts5.isStringLiteral(type.literal)) {\n    return null;\n  }\n  return type.literal.text;\n}\nfunction readMapType(type, valueTransform) {\n  if (!ts5.isTypeLiteralNode(type)) {\n    return {};\n  }\n  const obj = {};\n  type.members.forEach((member) => {\n    if (!ts5.isPropertySignature(member) || member.type === void 0 || member.name === void 0 || !ts5.isStringLiteral(member.name) && !ts5.isIdentifier(member.name)) {\n      return;\n    }\n    const value = valueTransform(member.type);\n    if (value === null) {\n      return null;\n    }\n    obj[member.name.text] = value;\n  });\n  return obj;\n}\nfunction readStringArrayType(type) {\n  if (!ts5.isTupleTypeNode(type)) {\n    return [];\n  }\n  const res = [];\n  type.elements.forEach((el) => {\n    if (!ts5.isLiteralTypeNode(el) || !ts5.isStringLiteral(el.literal)) {\n      return;\n    }\n    res.push(el.literal.text);\n  });\n  return res;\n}\nfunction extractDirectiveTypeCheckMeta(node, inputs, reflector) {\n  const members = reflector.getMembersOfClass(node);\n  const staticMembers = members.filter((member) => member.isStatic);\n  const ngTemplateGuards = staticMembers.map(extractTemplateGuard).filter((guard) => guard !== null);\n  const hasNgTemplateContextGuard = staticMembers.some((member) => member.kind === ClassMemberKind.Method && member.name === \"ngTemplateContextGuard\");\n  const coercedInputFields = new Set(staticMembers.map(extractCoercedInput).filter((inputName) => inputName !== null));\n  const restrictedInputFields = /* @__PURE__ */ new Set();\n  const stringLiteralInputFields = /* @__PURE__ */ new Set();\n  const undeclaredInputFields = /* @__PURE__ */ new Set();\n  for (const { classPropertyName, transform } of inputs) {\n    const field = members.find((member) => member.name === classPropertyName);\n    if (field === void 0 || field.node === null) {\n      undeclaredInputFields.add(classPropertyName);\n      continue;\n    }\n    if (isRestricted(field.node)) {\n      restrictedInputFields.add(classPropertyName);\n    }\n    if (field.nameNode !== null && ts5.isStringLiteral(field.nameNode)) {\n      stringLiteralInputFields.add(classPropertyName);\n    }\n    if (transform !== null) {\n      coercedInputFields.add(classPropertyName);\n    }\n  }\n  const arity = reflector.getGenericArityOfClass(node);\n  return {\n    hasNgTemplateContextGuard,\n    ngTemplateGuards,\n    coercedInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    undeclaredInputFields,\n    isGeneric: arity !== null && arity > 0\n  };\n}\nfunction isRestricted(node) {\n  const modifiers = ts5.canHaveModifiers(node) ? ts5.getModifiers(node) : void 0;\n  return modifiers !== void 0 && modifiers.some(({ kind }) => {\n    return kind === ts5.SyntaxKind.PrivateKeyword || kind === ts5.SyntaxKind.ProtectedKeyword || kind === ts5.SyntaxKind.ReadonlyKeyword;\n  });\n}\nfunction extractTemplateGuard(member) {\n  if (!member.name.startsWith(\"ngTemplateGuard_\")) {\n    return null;\n  }\n  const inputName = afterUnderscore(member.name);\n  if (member.kind === ClassMemberKind.Property) {\n    let type = null;\n    if (member.type !== null && ts5.isLiteralTypeNode(member.type) && ts5.isStringLiteral(member.type.literal)) {\n      type = member.type.literal.text;\n    }\n    if (type !== \"binding\") {\n      return null;\n    }\n    return { inputName, type };\n  } else if (member.kind === ClassMemberKind.Method) {\n    return { inputName, type: \"invocation\" };\n  } else {\n    return null;\n  }\n}\nfunction extractCoercedInput(member) {\n  if (member.kind !== ClassMemberKind.Property || !member.name.startsWith(\"ngAcceptInputType_\")) {\n    return null;\n  }\n  return afterUnderscore(member.name);\n}\nvar CompoundMetadataReader = class {\n  constructor(readers) {\n    this.readers = readers;\n  }\n  getDirectiveMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getDirectiveMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getNgModuleMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getNgModuleMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getPipeMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getPipeMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n};\nfunction afterUnderscore(str) {\n  const pos = str.indexOf(\"_\");\n  if (pos === -1) {\n    throw new Error(`Expected '${str}' to contain '_'`);\n  }\n  return str.slice(pos + 1);\n}\nfunction hasInjectableFields(clazz, host) {\n  const members = host.getMembersOfClass(clazz);\n  return members.some(({ isStatic, name }) => isStatic && (name === \"\\u0275prov\" || name === \"\\u0275fac\"));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/dts.mjs\nvar DtsMetadataReader = class {\n  constructor(checker, reflector) {\n    this.checker = checker;\n    this.reflector = reflector;\n  }\n  getNgModuleMetadata(ref) {\n    const clazz = ref.node;\n    const ngModuleDef = this.reflector.getMembersOfClass(clazz).find((member) => member.name === \"\\u0275mod\" && member.isStatic);\n    if (ngModuleDef === void 0) {\n      return null;\n    } else if (ngModuleDef.type === null || !ts6.isTypeReferenceNode(ngModuleDef.type) || ngModuleDef.type.typeArguments === void 0 || ngModuleDef.type.typeArguments.length !== 4) {\n      return null;\n    }\n    const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;\n    return {\n      kind: MetaKind.NgModule,\n      ref,\n      declarations: extractReferencesFromType(this.checker, declarationMetadata, ref.bestGuessOwningModule),\n      exports: extractReferencesFromType(this.checker, exportMetadata, ref.bestGuessOwningModule),\n      imports: extractReferencesFromType(this.checker, importMetadata, ref.bestGuessOwningModule),\n      schemas: [],\n      rawDeclarations: null,\n      rawImports: null,\n      rawExports: null,\n      decorator: null,\n      mayDeclareProviders: true\n    };\n  }\n  getDirectiveMetadata(ref) {\n    var _a, _b;\n    const clazz = ref.node;\n    const def = this.reflector.getMembersOfClass(clazz).find((field) => field.isStatic && (field.name === \"\\u0275cmp\" || field.name === \"\\u0275dir\"));\n    if (def === void 0) {\n      return null;\n    } else if (def.type === null || !ts6.isTypeReferenceNode(def.type) || def.type.typeArguments === void 0 || def.type.typeArguments.length < 2) {\n      return null;\n    }\n    const isComponent = def.name === \"\\u0275cmp\";\n    const ctorParams = this.reflector.getConstructorParameters(clazz);\n    const isStructural = !isComponent && ctorParams !== null && ctorParams.some((param) => {\n      return param.typeValueReference.kind === 1 && param.typeValueReference.moduleName === \"@angular/core\" && param.typeValueReference.importedName === \"TemplateRef\";\n    });\n    const isStandalone = def.type.typeArguments.length > 7 && ((_a = readBooleanType(def.type.typeArguments[7])) != null ? _a : false);\n    const inputs = ClassPropertyMapping.fromMappedObject(readInputsType(def.type.typeArguments[3]));\n    const outputs = ClassPropertyMapping.fromMappedObject(readMapType(def.type.typeArguments[4], readStringType));\n    const hostDirectives = def.type.typeArguments.length > 8 ? readHostDirectivesType(this.checker, def.type.typeArguments[8], ref.bestGuessOwningModule) : null;\n    const isSignal = def.type.typeArguments.length > 9 && ((_b = readBooleanType(def.type.typeArguments[9])) != null ? _b : false);\n    return {\n      kind: MetaKind.Directive,\n      matchSource: MatchSource.Selector,\n      ref,\n      name: clazz.name.text,\n      isComponent,\n      selector: readStringType(def.type.typeArguments[1]),\n      exportAs: readStringArrayType(def.type.typeArguments[2]),\n      inputs,\n      outputs,\n      hostDirectives,\n      queries: readStringArrayType(def.type.typeArguments[5]),\n      ...extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector),\n      baseClass: readBaseClass2(clazz, this.checker, this.reflector),\n      isPoisoned: false,\n      isStructural,\n      animationTriggerNames: null,\n      isStandalone,\n      isSignal,\n      imports: null,\n      schemas: null,\n      decorator: null,\n      assumedToExportProviders: isComponent && isStandalone\n    };\n  }\n  getPipeMetadata(ref) {\n    var _a;\n    const def = this.reflector.getMembersOfClass(ref.node).find((field) => field.isStatic && field.name === \"\\u0275pipe\");\n    if (def === void 0) {\n      return null;\n    } else if (def.type === null || !ts6.isTypeReferenceNode(def.type) || def.type.typeArguments === void 0 || def.type.typeArguments.length < 2) {\n      return null;\n    }\n    const type = def.type.typeArguments[1];\n    if (!ts6.isLiteralTypeNode(type) || !ts6.isStringLiteral(type.literal)) {\n      return null;\n    }\n    const name = type.literal.text;\n    const isStandalone = def.type.typeArguments.length > 2 && ((_a = readBooleanType(def.type.typeArguments[2])) != null ? _a : false);\n    return {\n      kind: MetaKind.Pipe,\n      ref,\n      name,\n      nameExpr: null,\n      isStandalone,\n      decorator: null\n    };\n  }\n};\nfunction readInputsType(type) {\n  const inputsMap = {};\n  if (ts6.isTypeLiteralNode(type)) {\n    for (const member of type.members) {\n      if (!ts6.isPropertySignature(member) || member.type === void 0 || member.name === void 0 || !ts6.isStringLiteral(member.name) && !ts6.isIdentifier(member.name)) {\n        continue;\n      }\n      const stringValue = readStringType(member.type);\n      const classPropertyName = member.name.text;\n      if (stringValue != null) {\n        inputsMap[classPropertyName] = {\n          bindingPropertyName: stringValue,\n          classPropertyName,\n          required: false,\n          transform: null\n        };\n      } else {\n        const config = readMapType(member.type, (innerValue) => {\n          var _a;\n          return (_a = readStringType(innerValue)) != null ? _a : readBooleanType(innerValue);\n        });\n        inputsMap[classPropertyName] = {\n          classPropertyName,\n          bindingPropertyName: config.alias,\n          required: config.required,\n          transform: null\n        };\n      }\n    }\n  }\n  return inputsMap;\n}\nfunction readBaseClass2(clazz, checker, reflector) {\n  if (!isNamedClassDeclaration(clazz)) {\n    return reflector.hasBaseClass(clazz) ? \"dynamic\" : null;\n  }\n  if (clazz.heritageClauses !== void 0) {\n    for (const clause of clazz.heritageClauses) {\n      if (clause.token === ts6.SyntaxKind.ExtendsKeyword) {\n        const baseExpr = clause.types[0].expression;\n        let symbol = checker.getSymbolAtLocation(baseExpr);\n        if (symbol === void 0) {\n          return \"dynamic\";\n        } else if (symbol.flags & ts6.SymbolFlags.Alias) {\n          symbol = checker.getAliasedSymbol(symbol);\n        }\n        if (symbol.valueDeclaration !== void 0 && isNamedClassDeclaration(symbol.valueDeclaration)) {\n          return new Reference(symbol.valueDeclaration);\n        } else {\n          return \"dynamic\";\n        }\n      }\n    }\n  }\n  return null;\n}\nfunction readHostDirectivesType(checker, type, bestGuessOwningModule) {\n  if (!ts6.isTupleTypeNode(type) || type.elements.length === 0) {\n    return null;\n  }\n  const result = [];\n  for (const hostDirectiveType of type.elements) {\n    const { directive, inputs, outputs } = readMapType(hostDirectiveType, (type2) => type2);\n    if (directive) {\n      if (!ts6.isTypeQueryNode(directive)) {\n        throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(directive)}`);\n      }\n      result.push({\n        directive: extraReferenceFromTypeQuery(checker, directive, type, bestGuessOwningModule),\n        isForwardReference: false,\n        inputs: readMapType(inputs, readStringType),\n        outputs: readMapType(outputs, readStringType)\n      });\n    }\n  }\n  return result.length > 0 ? result : null;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/inheritance.mjs\nfunction flattenInheritedDirectiveMetadata(reader, dir) {\n  const topMeta = reader.getDirectiveMetadata(dir);\n  if (topMeta === null) {\n    return null;\n  }\n  if (topMeta.baseClass === null) {\n    return topMeta;\n  }\n  const coercedInputFields = /* @__PURE__ */ new Set();\n  const undeclaredInputFields = /* @__PURE__ */ new Set();\n  const restrictedInputFields = /* @__PURE__ */ new Set();\n  const stringLiteralInputFields = /* @__PURE__ */ new Set();\n  let isDynamic = false;\n  let inputs = ClassPropertyMapping.empty();\n  let outputs = ClassPropertyMapping.empty();\n  let isStructural = false;\n  const addMetadata = (meta) => {\n    if (meta.baseClass === \"dynamic\") {\n      isDynamic = true;\n    } else if (meta.baseClass !== null) {\n      const baseMeta = reader.getDirectiveMetadata(meta.baseClass);\n      if (baseMeta !== null) {\n        addMetadata(baseMeta);\n      } else {\n        isDynamic = true;\n      }\n    }\n    isStructural = isStructural || meta.isStructural;\n    inputs = ClassPropertyMapping.merge(inputs, meta.inputs);\n    outputs = ClassPropertyMapping.merge(outputs, meta.outputs);\n    for (const coercedInputField of meta.coercedInputFields) {\n      coercedInputFields.add(coercedInputField);\n    }\n    for (const undeclaredInputField of meta.undeclaredInputFields) {\n      undeclaredInputFields.add(undeclaredInputField);\n    }\n    for (const restrictedInputField of meta.restrictedInputFields) {\n      restrictedInputFields.add(restrictedInputField);\n    }\n    for (const field of meta.stringLiteralInputFields) {\n      stringLiteralInputFields.add(field);\n    }\n  };\n  addMetadata(topMeta);\n  return {\n    ...topMeta,\n    inputs,\n    outputs,\n    coercedInputFields,\n    undeclaredInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    baseClass: isDynamic ? \"dynamic\" : null,\n    isStructural\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/registry.mjs\nvar LocalMetadataRegistry = class {\n  constructor() {\n    this.directives = /* @__PURE__ */ new Map();\n    this.ngModules = /* @__PURE__ */ new Map();\n    this.pipes = /* @__PURE__ */ new Map();\n  }\n  getDirectiveMetadata(ref) {\n    return this.directives.has(ref.node) ? this.directives.get(ref.node) : null;\n  }\n  getNgModuleMetadata(ref) {\n    return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node) : null;\n  }\n  getPipeMetadata(ref) {\n    return this.pipes.has(ref.node) ? this.pipes.get(ref.node) : null;\n  }\n  registerDirectiveMetadata(meta) {\n    this.directives.set(meta.ref.node, meta);\n  }\n  registerNgModuleMetadata(meta) {\n    this.ngModules.set(meta.ref.node, meta);\n  }\n  registerPipeMetadata(meta) {\n    this.pipes.set(meta.ref.node, meta);\n  }\n  getKnown(kind) {\n    switch (kind) {\n      case MetaKind.Directive:\n        return Array.from(this.directives.values()).map((v) => v.ref.node);\n      case MetaKind.Pipe:\n        return Array.from(this.pipes.values()).map((v) => v.ref.node);\n      case MetaKind.NgModule:\n        return Array.from(this.ngModules.values()).map((v) => v.ref.node);\n    }\n  }\n};\nvar CompoundMetadataRegistry = class {\n  constructor(registries) {\n    this.registries = registries;\n  }\n  registerDirectiveMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerDirectiveMetadata(meta);\n    }\n  }\n  registerNgModuleMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerNgModuleMetadata(meta);\n    }\n  }\n  registerPipeMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerPipeMetadata(meta);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/resource_registry.mjs\nvar ResourceRegistry = class {\n  constructor() {\n    this.externalTemplateToComponentsMap = /* @__PURE__ */ new Map();\n    this.componentToTemplateMap = /* @__PURE__ */ new Map();\n    this.componentToStylesMap = /* @__PURE__ */ new Map();\n    this.externalStyleToComponentsMap = /* @__PURE__ */ new Map();\n  }\n  getComponentsWithTemplate(template) {\n    if (!this.externalTemplateToComponentsMap.has(template)) {\n      return /* @__PURE__ */ new Set();\n    }\n    return this.externalTemplateToComponentsMap.get(template);\n  }\n  registerResources(resources, component) {\n    if (resources.template !== null) {\n      this.registerTemplate(resources.template, component);\n    }\n    for (const style of resources.styles) {\n      this.registerStyle(style, component);\n    }\n  }\n  registerTemplate(templateResource, component) {\n    const { path } = templateResource;\n    if (path !== null) {\n      if (!this.externalTemplateToComponentsMap.has(path)) {\n        this.externalTemplateToComponentsMap.set(path, /* @__PURE__ */ new Set());\n      }\n      this.externalTemplateToComponentsMap.get(path).add(component);\n    }\n    this.componentToTemplateMap.set(component, templateResource);\n  }\n  getTemplate(component) {\n    if (!this.componentToTemplateMap.has(component)) {\n      return null;\n    }\n    return this.componentToTemplateMap.get(component);\n  }\n  registerStyle(styleResource, component) {\n    const { path } = styleResource;\n    if (!this.componentToStylesMap.has(component)) {\n      this.componentToStylesMap.set(component, /* @__PURE__ */ new Set());\n    }\n    if (path !== null) {\n      if (!this.externalStyleToComponentsMap.has(path)) {\n        this.externalStyleToComponentsMap.set(path, /* @__PURE__ */ new Set());\n      }\n      this.externalStyleToComponentsMap.get(path).add(component);\n    }\n    this.componentToStylesMap.get(component).add(styleResource);\n  }\n  getStyles(component) {\n    if (!this.componentToStylesMap.has(component)) {\n      return /* @__PURE__ */ new Set();\n    }\n    return this.componentToStylesMap.get(component);\n  }\n  getComponentsWithStyle(styleUrl) {\n    if (!this.externalStyleToComponentsMap.has(styleUrl)) {\n      return /* @__PURE__ */ new Set();\n    }\n    return this.externalStyleToComponentsMap.get(styleUrl);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/providers.mjs\nvar ExportedProviderStatusResolver = class {\n  constructor(metaReader) {\n    this.metaReader = metaReader;\n    this.calculating = /* @__PURE__ */ new Set();\n  }\n  mayExportProviders(ref, dependencyCallback) {\n    var _a;\n    if (this.calculating.has(ref.node)) {\n      return false;\n    }\n    this.calculating.add(ref.node);\n    if (dependencyCallback !== void 0) {\n      dependencyCallback(ref);\n    }\n    try {\n      const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n      if (dirMeta !== null) {\n        if (!dirMeta.isComponent || !dirMeta.isStandalone) {\n          return false;\n        }\n        if (dirMeta.assumedToExportProviders) {\n          return true;\n        }\n        return ((_a = dirMeta.imports) != null ? _a : []).some((importRef) => this.mayExportProviders(importRef, dependencyCallback));\n      }\n      const pipeMeta = this.metaReader.getPipeMetadata(ref);\n      if (pipeMeta !== null) {\n        return false;\n      }\n      const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);\n      if (ngModuleMeta !== null) {\n        if (ngModuleMeta.mayDeclareProviders) {\n          return true;\n        }\n        return ngModuleMeta.imports.some((importRef) => this.mayExportProviders(importRef, dependencyCallback));\n      }\n      return false;\n    } finally {\n      this.calculating.delete(ref.node);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/host_directives_resolver.mjs\nvar EMPTY_ARRAY = [];\nvar HostDirectivesResolver = class {\n  constructor(metaReader) {\n    this.metaReader = metaReader;\n    this.cache = /* @__PURE__ */ new Map();\n  }\n  resolve(metadata) {\n    if (this.cache.has(metadata.ref.node)) {\n      return this.cache.get(metadata.ref.node);\n    }\n    const results = metadata.hostDirectives && metadata.hostDirectives.length > 0 ? this.walkHostDirectives(metadata.hostDirectives, []) : EMPTY_ARRAY;\n    this.cache.set(metadata.ref.node, results);\n    return results;\n  }\n  walkHostDirectives(directives, results) {\n    for (const current of directives) {\n      const hostMeta = flattenInheritedDirectiveMetadata(this.metaReader, current.directive);\n      if (hostMeta === null) {\n        continue;\n      }\n      if (hostMeta.hostDirectives) {\n        this.walkHostDirectives(hostMeta.hostDirectives, results);\n      }\n      results.push({\n        ...hostMeta,\n        matchSource: MatchSource.HostDirective,\n        inputs: ClassPropertyMapping.fromMappedObject(this.filterMappings(hostMeta.inputs, current.inputs, resolveInput)),\n        outputs: ClassPropertyMapping.fromMappedObject(this.filterMappings(hostMeta.outputs, current.outputs, resolveOutput))\n      });\n    }\n    return results;\n  }\n  filterMappings(source, allowedProperties, valueResolver) {\n    const result = {};\n    if (allowedProperties !== null) {\n      for (const publicName in allowedProperties) {\n        if (allowedProperties.hasOwnProperty(publicName)) {\n          const bindings = source.getByBindingPropertyName(publicName);\n          if (bindings !== null) {\n            for (const binding of bindings) {\n              result[binding.classPropertyName] = valueResolver(allowedProperties[publicName], binding);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n};\nfunction resolveInput(bindingName, binding) {\n  return {\n    bindingPropertyName: bindingName,\n    classPropertyName: binding.classPropertyName,\n    required: binding.required,\n    transform: binding.transform\n  };\n}\nfunction resolveOutput(bindingName) {\n  return bindingName;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/diagnostics.mjs\nfunction makeDuplicateDeclarationError(node, data, kind) {\n  const context = [];\n  for (const decl of data) {\n    if (decl.rawDeclarations === null) {\n      continue;\n    }\n    const contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);\n    context.push(makeRelatedInformation(contextNode, `'${node.name.text}' is listed in the declarations of the NgModule '${decl.ngModule.name.text}'.`));\n  }\n  return makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name, `The ${kind} '${node.name.text}' is declared by more than one NgModule.`, context);\n}\nfunction createValueHasWrongTypeError(node, value, messageText) {\n  var _a;\n  let chainedMessage;\n  let relatedInformation;\n  if (value instanceof DynamicValue) {\n    chainedMessage = \"Value could not be determined statically.\";\n    relatedInformation = traceDynamicValue(node, value);\n  } else if (value instanceof Reference) {\n    const target = value.debugName !== null ? `'${value.debugName}'` : \"an anonymous declaration\";\n    chainedMessage = `Value is a reference to ${target}.`;\n    const referenceNode = (_a = identifierOfNode(value.node)) != null ? _a : value.node;\n    relatedInformation = [makeRelatedInformation(referenceNode, \"Reference is declared here.\")];\n  } else {\n    chainedMessage = `Value is of type '${describeResolvedType(value)}'.`;\n  }\n  const chain = {\n    messageText,\n    category: ts7.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainedMessage,\n      category: ts7.DiagnosticCategory.Message,\n      code: 0\n    }]\n  };\n  return new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);\n}\nfunction getProviderDiagnostics(providerClasses, providersDeclaration, registry) {\n  const diagnostics = [];\n  for (const provider of providerClasses) {\n    const injectableMeta = registry.getInjectableMeta(provider.node);\n    if (injectableMeta !== null) {\n      continue;\n    }\n    const contextNode = provider.getOriginForDiagnostics(providersDeclaration);\n    diagnostics.push(makeDiagnostic(ErrorCode.UNDECORATED_PROVIDER, contextNode, `The class '${provider.node.name.text}' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.\n\nEither add the @Injectable() decorator to '${provider.node.name.text}', or configure a different provider (such as a provider with 'useFactory').\n`, [makeRelatedInformation(provider.node, `'${provider.node.name.text}' is declared here.`)]));\n  }\n  return diagnostics;\n}\nfunction getDirectiveDiagnostics(node, injectableRegistry, evaluator, reflector, scopeRegistry, strictInjectionParameters, kind) {\n  let diagnostics = [];\n  const addDiagnostics = (more) => {\n    if (more === null) {\n      return;\n    } else if (diagnostics === null) {\n      diagnostics = Array.isArray(more) ? more : [more];\n    } else if (Array.isArray(more)) {\n      diagnostics.push(...more);\n    } else {\n      diagnostics.push(more);\n    }\n  };\n  const duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);\n  if (duplicateDeclarations !== null) {\n    addDiagnostics(makeDuplicateDeclarationError(node, duplicateDeclarations, kind));\n  }\n  addDiagnostics(checkInheritanceOfInjectable(node, injectableRegistry, reflector, evaluator, strictInjectionParameters, kind));\n  return diagnostics;\n}\nfunction validateHostDirectives(origin, hostDirectives, metaReader) {\n  const diagnostics = [];\n  for (const current of hostDirectives) {\n    const hostMeta = flattenInheritedDirectiveMetadata(metaReader, current.directive);\n    if (hostMeta === null) {\n      diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_INVALID, current.directive.getOriginForDiagnostics(origin), `${current.directive.debugName} must be a standalone directive to be used as a host directive`));\n      continue;\n    }\n    if (!hostMeta.isStandalone) {\n      diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_NOT_STANDALONE, current.directive.getOriginForDiagnostics(origin), `Host directive ${hostMeta.name} must be standalone`));\n    }\n    if (hostMeta.isComponent) {\n      diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_COMPONENT, current.directive.getOriginForDiagnostics(origin), `Host directive ${hostMeta.name} cannot be a component`));\n    }\n    const requiredInputNames = Array.from(hostMeta.inputs).filter((input) => input.required).map((input) => input.classPropertyName);\n    validateHostDirectiveMappings(\"input\", current, hostMeta, origin, diagnostics, requiredInputNames.length > 0 ? new Set(requiredInputNames) : null);\n    validateHostDirectiveMappings(\"output\", current, hostMeta, origin, diagnostics, null);\n  }\n  return diagnostics;\n}\nfunction validateHostDirectiveMappings(bindingType, hostDirectiveMeta, meta, origin, diagnostics, requiredBindings) {\n  const className = meta.name;\n  const hostDirectiveMappings = bindingType === \"input\" ? hostDirectiveMeta.inputs : hostDirectiveMeta.outputs;\n  const existingBindings = bindingType === \"input\" ? meta.inputs : meta.outputs;\n  const exposedRequiredBindings = /* @__PURE__ */ new Set();\n  for (const publicName in hostDirectiveMappings) {\n    if (hostDirectiveMappings.hasOwnProperty(publicName)) {\n      const bindings = existingBindings.getByBindingPropertyName(publicName);\n      if (bindings === null) {\n        diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING, hostDirectiveMeta.directive.getOriginForDiagnostics(origin), `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`));\n      } else if (requiredBindings !== null) {\n        for (const field of bindings) {\n          if (requiredBindings.has(field.classPropertyName)) {\n            exposedRequiredBindings.add(field.classPropertyName);\n          }\n        }\n      }\n      const remappedPublicName = hostDirectiveMappings[publicName];\n      const bindingsForPublicName = existingBindings.getByBindingPropertyName(remappedPublicName);\n      if (bindingsForPublicName !== null) {\n        for (const binding of bindingsForPublicName) {\n          if (binding.bindingPropertyName !== publicName) {\n            diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS, hostDirectiveMeta.directive.getOriginForDiagnostics(origin), `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`));\n          }\n        }\n      }\n    }\n  }\n  if (requiredBindings !== null && requiredBindings.size !== exposedRequiredBindings.size) {\n    const missingBindings = [];\n    for (const publicName of requiredBindings) {\n      if (!exposedRequiredBindings.has(publicName)) {\n        const name = existingBindings.getByClassPropertyName(publicName);\n        if (name) {\n          missingBindings.push(`'${name.bindingPropertyName}'`);\n        }\n      }\n    }\n    diagnostics.push(makeDiagnostic(ErrorCode.HOST_DIRECTIVE_MISSING_REQUIRED_BINDING, hostDirectiveMeta.directive.getOriginForDiagnostics(origin), `Required ${bindingType}${missingBindings.length === 1 ? \"\" : \"s\"} ${missingBindings.join(\", \")} from host directive ${className} must be exposed.`));\n  }\n}\nfunction getUndecoratedClassWithAngularFeaturesDiagnostic(node) {\n  return makeDiagnostic(ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name, `Class is using Angular features but is not decorated. Please add an explicit Angular decorator.`);\n}\nfunction checkInheritanceOfInjectable(node, injectableRegistry, reflector, evaluator, strictInjectionParameters, kind) {\n  const classWithCtor = findInheritedCtor(node, injectableRegistry, reflector, evaluator);\n  if (classWithCtor === null || classWithCtor.isCtorValid) {\n    return null;\n  }\n  if (!classWithCtor.isDecorated) {\n    return getInheritedUndecoratedCtorDiagnostic(node, classWithCtor.ref, kind);\n  }\n  if (isFromDtsFile(classWithCtor.ref.node)) {\n    return null;\n  }\n  if (!strictInjectionParameters || isAbstractClassDeclaration(node)) {\n    return null;\n  }\n  return getInheritedInvalidCtorDiagnostic(node, classWithCtor.ref, kind);\n}\nfunction findInheritedCtor(node, injectableRegistry, reflector, evaluator) {\n  if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {\n    return null;\n  }\n  let baseClass = readBaseClass(node, reflector, evaluator);\n  while (baseClass !== null) {\n    if (baseClass === \"dynamic\") {\n      return null;\n    }\n    const injectableMeta = injectableRegistry.getInjectableMeta(baseClass.node);\n    if (injectableMeta !== null) {\n      if (injectableMeta.ctorDeps !== null) {\n        return {\n          ref: baseClass,\n          isCtorValid: injectableMeta.ctorDeps !== \"invalid\",\n          isDecorated: true\n        };\n      }\n    } else {\n      const baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);\n      if (baseClassConstructorParams !== null) {\n        return {\n          ref: baseClass,\n          isCtorValid: baseClassConstructorParams.length === 0,\n          isDecorated: false\n        };\n      }\n    }\n    baseClass = readBaseClass(baseClass.node, reflector, evaluator);\n  }\n  return null;\n}\nfunction getInheritedInvalidCtorDiagnostic(node, baseClass, kind) {\n  const baseClassName = baseClass.debugName;\n  return makeDiagnostic(ErrorCode.INJECTABLE_INHERITS_INVALID_CONSTRUCTOR, node.name, `The ${kind.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, but the latter has a constructor parameter that is not compatible with dependency injection. Either add an explicit constructor to ${node.name.text} or change ${baseClassName}'s constructor to use parameters that are valid for DI.`);\n}\nfunction getInheritedUndecoratedCtorDiagnostic(node, baseClass, kind) {\n  const baseClassName = baseClass.debugName;\n  const baseNeedsDecorator = kind === \"Component\" || kind === \"Directive\" ? \"Directive\" : \"Injectable\";\n  return makeDiagnostic(ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name, `The ${kind.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, but the latter does not have an Angular decorator of its own. Dependency injection will not be able to resolve the parameters of ${baseClassName}'s constructor. Either add a @${baseNeedsDecorator} decorator to ${baseClassName}, or add an explicit constructor to ${node.name.text}.`);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/evaluation.mjs\nimport ts8 from \"typescript\";\nfunction resolveEnumValue(evaluator, metadata, field, enumSymbolName) {\n  let resolved = null;\n  if (metadata.has(field)) {\n    const expr = metadata.get(field);\n    const value = evaluator.evaluate(expr);\n    if (value instanceof EnumValue && isAngularCoreReference(value.enumRef, enumSymbolName)) {\n      resolved = value.resolved;\n    } else {\n      throw createValueHasWrongTypeError(expr, value, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);\n    }\n  }\n  return resolved;\n}\nfunction isStringArray(resolvedValue) {\n  return Array.isArray(resolvedValue) && resolvedValue.every((elem) => typeof elem === \"string\");\n}\nfunction resolveLiteral(decorator, literalCache) {\n  if (literalCache.has(decorator)) {\n    return literalCache.get(decorator);\n  }\n  if (decorator.args === null || decorator.args.length !== 1) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @${decorator.name} decorator`);\n  }\n  const meta = unwrapExpression(decorator.args[0]);\n  if (!ts8.isObjectLiteralExpression(meta)) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `Decorator argument must be literal.`);\n  }\n  literalCache.set(decorator, meta);\n  return meta;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/factory.mjs\nimport { compileDeclareFactoryFunction, compileFactoryFunction } from \"@angular/compiler\";\nfunction compileNgFactoryDefField(metadata) {\n  const res = compileFactoryFunction(metadata);\n  return { name: \"\\u0275fac\", initializer: res.expression, statements: res.statements, type: res.type };\n}\nfunction compileDeclareFactory(metadata) {\n  const res = compileDeclareFactoryFunction(metadata);\n  return { name: \"\\u0275fac\", initializer: res.expression, statements: res.statements, type: res.type };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/injectable_registry.mjs\nvar InjectableClassRegistry = class {\n  constructor(host, isCore) {\n    this.host = host;\n    this.isCore = isCore;\n    this.classes = /* @__PURE__ */ new Map();\n  }\n  registerInjectable(declaration, meta) {\n    this.classes.set(declaration, meta);\n  }\n  getInjectableMeta(declaration) {\n    if (this.classes.has(declaration)) {\n      return this.classes.get(declaration);\n    }\n    if (!hasInjectableFields(declaration, this.host)) {\n      return null;\n    }\n    const ctorDeps = getConstructorDependencies(declaration, this.host, this.isCore);\n    const meta = {\n      ctorDeps: unwrapConstructorDependencies(ctorDeps)\n    };\n    this.classes.set(declaration, meta);\n    return meta;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/metadata.mjs\nimport { FunctionExpr, LiteralArrayExpr, LiteralExpr as LiteralExpr2, literalMap, ReturnStatement, WrappedNodeExpr as WrappedNodeExpr3 } from \"@angular/compiler\";\nimport ts9 from \"typescript\";\nfunction extractClassMetadata(clazz, reflection, isCore, annotateForClosureCompiler, angularDecoratorTransform = (dec) => dec) {\n  if (!reflection.isClass(clazz)) {\n    return null;\n  }\n  const id = clazz.name;\n  const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);\n  if (classDecorators === null) {\n    return null;\n  }\n  const ngClassDecorators = classDecorators.filter((dec) => isAngularDecorator2(dec, isCore)).map((decorator) => decoratorToMetadata(angularDecoratorTransform(decorator), annotateForClosureCompiler)).map((decorator) => removeIdentifierReferences(decorator, id.text));\n  if (ngClassDecorators.length === 0) {\n    return null;\n  }\n  const metaDecorators = new WrappedNodeExpr3(ts9.factory.createArrayLiteralExpression(ngClassDecorators));\n  let metaCtorParameters = null;\n  const classCtorParameters = reflection.getConstructorParameters(clazz);\n  if (classCtorParameters !== null) {\n    const ctorParameters = classCtorParameters.map((param) => ctorParameterToMetadata(param, isCore));\n    metaCtorParameters = new FunctionExpr([], [\n      new ReturnStatement(new LiteralArrayExpr(ctorParameters))\n    ]);\n  }\n  let metaPropDecorators = null;\n  const classMembers = reflection.getMembersOfClass(clazz).filter((member) => !member.isStatic && member.decorators !== null && member.decorators.length > 0);\n  const duplicateDecoratedMemberNames = classMembers.map((member) => member.name).filter((name, i, arr) => arr.indexOf(name) < i);\n  if (duplicateDecoratedMemberNames.length > 0) {\n    throw new Error(`Duplicate decorated properties found on class '${clazz.name.text}': ` + duplicateDecoratedMemberNames.join(\", \"));\n  }\n  const decoratedMembers = classMembers.map((member) => {\n    var _a;\n    return classMemberToMetadata((_a = member.nameNode) != null ? _a : member.name, member.decorators, isCore);\n  });\n  if (decoratedMembers.length > 0) {\n    metaPropDecorators = new WrappedNodeExpr3(ts9.factory.createObjectLiteralExpression(decoratedMembers));\n  }\n  return {\n    type: new WrappedNodeExpr3(id),\n    decorators: metaDecorators,\n    ctorParameters: metaCtorParameters,\n    propDecorators: metaPropDecorators\n  };\n}\nfunction ctorParameterToMetadata(param, isCore) {\n  const type = param.typeValueReference.kind !== 2 ? valueReferenceToExpression(param.typeValueReference) : new LiteralExpr2(void 0);\n  const mapEntries = [\n    { key: \"type\", value: type, quoted: false }\n  ];\n  if (param.decorators !== null) {\n    const ngDecorators = param.decorators.filter((dec) => isAngularDecorator2(dec, isCore)).map((decorator) => decoratorToMetadata(decorator));\n    const value = new WrappedNodeExpr3(ts9.factory.createArrayLiteralExpression(ngDecorators));\n    mapEntries.push({ key: \"decorators\", value, quoted: false });\n  }\n  return literalMap(mapEntries);\n}\nfunction classMemberToMetadata(name, decorators, isCore) {\n  const ngDecorators = decorators.filter((dec) => isAngularDecorator2(dec, isCore)).map((decorator) => decoratorToMetadata(decorator));\n  const decoratorMeta = ts9.factory.createArrayLiteralExpression(ngDecorators);\n  return ts9.factory.createPropertyAssignment(name, decoratorMeta);\n}\nfunction decoratorToMetadata(decorator, wrapFunctionsInParens) {\n  if (decorator.identifier === null) {\n    throw new Error(\"Illegal state: synthesized decorator cannot be emitted in class metadata.\");\n  }\n  const properties = [\n    ts9.factory.createPropertyAssignment(\"type\", decorator.identifier)\n  ];\n  if (decorator.args !== null && decorator.args.length > 0) {\n    const args = decorator.args.map((arg) => {\n      return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(arg) : arg;\n    });\n    properties.push(ts9.factory.createPropertyAssignment(\"args\", ts9.factory.createArrayLiteralExpression(args)));\n  }\n  return ts9.factory.createObjectLiteralExpression(properties, true);\n}\nfunction isAngularDecorator2(decorator, isCore) {\n  return isCore || decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\nfunction removeIdentifierReferences(node, name) {\n  const result = ts9.transform(node, [(context) => (root) => ts9.visitNode(root, function walk(current) {\n    return ts9.isIdentifier(current) && current.text === name ? ts9.factory.createIdentifier(current.text) : ts9.visitEachChild(current, walk, context);\n  })]);\n  return result.transformed[0];\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/references_registry.mjs\nvar NoopReferencesRegistry = class {\n  add(source, ...references) {\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/schema.mjs\nimport { CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA } from \"@angular/compiler\";\nfunction extractSchemas(rawExpr, evaluator, context) {\n  const schemas = [];\n  const result = evaluator.evaluate(rawExpr);\n  if (!Array.isArray(result)) {\n    throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array`);\n  }\n  for (const schemaRef of result) {\n    if (!(schemaRef instanceof Reference)) {\n      throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array of schemas`);\n    }\n    const id = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());\n    if (id === null || schemaRef.ownedByModuleGuess !== \"@angular/core\") {\n      throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array of schemas`);\n    }\n    switch (id.text) {\n      case \"CUSTOM_ELEMENTS_SCHEMA\":\n        schemas.push(CUSTOM_ELEMENTS_SCHEMA);\n        break;\n      case \"NO_ERRORS_SCHEMA\":\n        schemas.push(NO_ERRORS_SCHEMA);\n        break;\n      default:\n        throw createValueHasWrongTypeError(rawExpr, schemaRef, `'${schemaRef.debugName}' is not a valid ${context} schema`);\n    }\n  }\n  return schemas;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/common/src/input_transforms.mjs\nimport { outputAst } from \"@angular/compiler\";\nfunction compileInputTransformFields(inputs) {\n  const extraFields = [];\n  for (const input of inputs) {\n    if (input.transform) {\n      extraFields.push({\n        name: `ngAcceptInputType_${input.classPropertyName}`,\n        type: outputAst.transplantedType(input.transform.type),\n        statements: [],\n        initializer: null\n      });\n    }\n  }\n  return extraFields;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/handler.mjs\nimport { compileClassMetadata as compileClassMetadata3, compileComponentFromMetadata, compileDeclareClassMetadata as compileDeclareClassMetadata3, compileDeclareComponentFromMetadata, CssSelector as CssSelector2, DEFAULT_INTERPOLATION_CONFIG as DEFAULT_INTERPOLATION_CONFIG2, DomElementSchemaRegistry, FactoryTarget as FactoryTarget3, makeBindingParser as makeBindingParser2, R3TargetBinder, R3TemplateDependencyKind, SelectorMatcher as SelectorMatcher2, ViewEncapsulation, WrappedNodeExpr as WrappedNodeExpr7 } from \"@angular/compiler\";\nimport ts24 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api.mjs\nimport ts10 from \"typescript\";\nvar SemanticSymbol = class {\n  constructor(decl) {\n    this.decl = decl;\n    this.path = absoluteFromSourceFile(decl.getSourceFile());\n    this.identifier = getSymbolIdentifier(decl);\n  }\n};\nfunction getSymbolIdentifier(decl) {\n  if (!ts10.isSourceFile(decl.parent)) {\n    return null;\n  }\n  return decl.name.text;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/graph.mjs\nimport { ExternalExpr as ExternalExpr2 } from \"@angular/compiler\";\nvar OpaqueSymbol = class extends SemanticSymbol {\n  isPublicApiAffected() {\n    return false;\n  }\n  isTypeCheckApiAffected() {\n    return false;\n  }\n};\nvar SemanticDepGraph = class {\n  constructor() {\n    this.files = /* @__PURE__ */ new Map();\n    this.symbolByDecl = /* @__PURE__ */ new Map();\n  }\n  registerSymbol(symbol) {\n    this.symbolByDecl.set(symbol.decl, symbol);\n    if (symbol.identifier !== null) {\n      if (!this.files.has(symbol.path)) {\n        this.files.set(symbol.path, /* @__PURE__ */ new Map());\n      }\n      this.files.get(symbol.path).set(symbol.identifier, symbol);\n    }\n  }\n  getEquivalentSymbol(symbol) {\n    let previousSymbol = this.getSymbolByDecl(symbol.decl);\n    if (previousSymbol === null && symbol.identifier !== null) {\n      previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);\n    }\n    return previousSymbol;\n  }\n  getSymbolByName(path, identifier) {\n    if (!this.files.has(path)) {\n      return null;\n    }\n    const file = this.files.get(path);\n    if (!file.has(identifier)) {\n      return null;\n    }\n    return file.get(identifier);\n  }\n  getSymbolByDecl(decl) {\n    if (!this.symbolByDecl.has(decl)) {\n      return null;\n    }\n    return this.symbolByDecl.get(decl);\n  }\n};\nvar SemanticDepGraphUpdater = class {\n  constructor(priorGraph) {\n    this.priorGraph = priorGraph;\n    this.newGraph = new SemanticDepGraph();\n    this.opaqueSymbols = /* @__PURE__ */ new Map();\n  }\n  registerSymbol(symbol) {\n    this.newGraph.registerSymbol(symbol);\n  }\n  finalize() {\n    if (this.priorGraph === null) {\n      return {\n        needsEmit: /* @__PURE__ */ new Set(),\n        needsTypeCheckEmit: /* @__PURE__ */ new Set(),\n        newGraph: this.newGraph\n      };\n    }\n    const needsEmit = this.determineInvalidatedFiles(this.priorGraph);\n    const needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);\n    return {\n      needsEmit,\n      needsTypeCheckEmit,\n      newGraph: this.newGraph\n    };\n  }\n  determineInvalidatedFiles(priorGraph) {\n    const isPublicApiAffected = /* @__PURE__ */ new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {\n        isPublicApiAffected.add(symbol);\n      }\n    }\n    const needsEmit = /* @__PURE__ */ new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isEmitAffected === void 0) {\n        continue;\n      }\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {\n        needsEmit.add(symbol.path);\n      }\n    }\n    return needsEmit;\n  }\n  determineInvalidatedTypeCheckFiles(priorGraph) {\n    const isTypeCheckApiAffected = /* @__PURE__ */ new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {\n        isTypeCheckApiAffected.add(symbol);\n      }\n    }\n    const needsTypeCheckEmit = /* @__PURE__ */ new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isTypeCheckBlockAffected === void 0) {\n        continue;\n      }\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {\n        needsTypeCheckEmit.add(symbol.path);\n      }\n    }\n    return needsTypeCheckEmit;\n  }\n  getSemanticReference(decl, expr) {\n    return {\n      symbol: this.getSymbol(decl),\n      importPath: getImportPath(expr)\n    };\n  }\n  getSymbol(decl) {\n    const symbol = this.newGraph.getSymbolByDecl(decl);\n    if (symbol === null) {\n      return this.getOpaqueSymbol(decl);\n    }\n    return symbol;\n  }\n  getOpaqueSymbol(decl) {\n    if (this.opaqueSymbols.has(decl)) {\n      return this.opaqueSymbols.get(decl);\n    }\n    const symbol = new OpaqueSymbol(decl);\n    this.opaqueSymbols.set(decl, symbol);\n    return symbol;\n  }\n};\nfunction getImportPath(expr) {\n  if (expr instanceof ExternalExpr2) {\n    return `${expr.value.moduleName}$${expr.value.name}`;\n  } else {\n    return null;\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.mjs\nimport ts11 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util.mjs\nfunction isSymbolEqual(a, b) {\n  if (a.decl === b.decl) {\n    return true;\n  }\n  if (a.identifier === null || b.identifier === null) {\n    return false;\n  }\n  return a.path === b.path && a.identifier === b.identifier;\n}\nfunction isReferenceEqual(a, b) {\n  if (!isSymbolEqual(a.symbol, b.symbol)) {\n    return false;\n  }\n  return a.importPath === b.importPath;\n}\nfunction referenceEquality(a, b) {\n  return a === b;\n}\nfunction isArrayEqual(a, b, equalityTester = referenceEquality) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  return !a.some((item, index) => !equalityTester(item, b[index]));\n}\nfunction isSetEqual(a, b, equalityTester = referenceEquality) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const itemA of a) {\n    let found = false;\n    for (const itemB of b) {\n      if (equalityTester(itemA, itemB)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.mjs\nfunction extractSemanticTypeParameters(node) {\n  if (!ts11.isClassDeclaration(node) || node.typeParameters === void 0) {\n    return null;\n  }\n  return node.typeParameters.map((typeParam) => ({ hasGenericTypeBound: typeParam.constraint !== void 0 }));\n}\nfunction areTypeParametersEqual(current, previous) {\n  if (!isArrayEqual(current, previous, isTypeParameterEqual)) {\n    return false;\n  }\n  if (current !== null && current.some((typeParam) => typeParam.hasGenericTypeBound)) {\n    return false;\n  }\n  return true;\n}\nfunction isTypeParameterEqual(a, b) {\n  return a.hasGenericTypeBound === b.hasGenericTypeBound;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/api.mjs\nvar ComponentScopeKind;\n(function(ComponentScopeKind2) {\n  ComponentScopeKind2[ComponentScopeKind2[\"NgModule\"] = 0] = \"NgModule\";\n  ComponentScopeKind2[ComponentScopeKind2[\"Standalone\"] = 1] = \"Standalone\";\n})(ComponentScopeKind || (ComponentScopeKind = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/component_scope.mjs\nvar CompoundComponentScopeReader = class {\n  constructor(readers) {\n    this.readers = readers;\n  }\n  getScopeForComponent(clazz) {\n    for (const reader of this.readers) {\n      const meta = reader.getScopeForComponent(clazz);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getRemoteScope(clazz) {\n    for (const reader of this.readers) {\n      const remoteScope = reader.getRemoteScope(clazz);\n      if (remoteScope !== null) {\n        return remoteScope;\n      }\n    }\n    return null;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/dependency.mjs\nvar MetadataDtsModuleScopeResolver = class {\n  constructor(dtsMetaReader, aliasingHost) {\n    this.dtsMetaReader = dtsMetaReader;\n    this.aliasingHost = aliasingHost;\n    this.cache = /* @__PURE__ */ new Map();\n  }\n  resolve(ref) {\n    const clazz = ref.node;\n    const sourceFile = clazz.getSourceFile();\n    if (!sourceFile.isDeclarationFile) {\n      throw new Error(`Debug error: DtsModuleScopeResolver.read(${ref.debugName} from ${sourceFile.fileName}), but not a .d.ts file`);\n    }\n    if (this.cache.has(clazz)) {\n      return this.cache.get(clazz);\n    }\n    const dependencies = [];\n    const meta = this.dtsMetaReader.getNgModuleMetadata(ref);\n    if (meta === null) {\n      this.cache.set(clazz, null);\n      return null;\n    }\n    const declarations = /* @__PURE__ */ new Set();\n    for (const declRef of meta.declarations) {\n      declarations.add(declRef.node);\n    }\n    for (const exportRef of meta.exports) {\n      const directive = this.dtsMetaReader.getDirectiveMetadata(exportRef);\n      if (directive !== null) {\n        const isReExport = !declarations.has(exportRef.node);\n        dependencies.push(this.maybeAlias(directive, sourceFile, isReExport));\n        continue;\n      }\n      const pipe = this.dtsMetaReader.getPipeMetadata(exportRef);\n      if (pipe !== null) {\n        const isReExport = !declarations.has(exportRef.node);\n        dependencies.push(this.maybeAlias(pipe, sourceFile, isReExport));\n        continue;\n      }\n      const exportScope2 = this.resolve(exportRef);\n      if (exportScope2 !== null) {\n        if (this.aliasingHost === null) {\n          dependencies.push(...exportScope2.exported.dependencies);\n        } else {\n          for (const dep of exportScope2.exported.dependencies) {\n            dependencies.push(this.maybeAlias(dep, sourceFile, true));\n          }\n        }\n      }\n      continue;\n    }\n    const exportScope = {\n      exported: {\n        dependencies,\n        isPoisoned: false\n      }\n    };\n    this.cache.set(clazz, exportScope);\n    return exportScope;\n  }\n  maybeAlias(dirOrPipe, maybeAliasFrom, isReExport) {\n    const ref = dirOrPipe.ref;\n    if (this.aliasingHost === null || ref.node.getSourceFile() === maybeAliasFrom) {\n      return dirOrPipe;\n    }\n    const alias = this.aliasingHost.getAliasIn(ref.node, maybeAliasFrom, isReExport);\n    if (alias === null) {\n      return dirOrPipe;\n    }\n    return {\n      ...dirOrPipe,\n      ref: ref.cloneWithAlias(alias)\n    };\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/local.mjs\nimport { ExternalExpr as ExternalExpr3 } from \"@angular/compiler\";\nimport ts12 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/util.mjs\nfunction getDiagnosticNode(ref, rawExpr) {\n  return rawExpr !== null ? ref.getOriginForDiagnostics(rawExpr) : ref.node.name;\n}\nfunction makeNotStandaloneDiagnostic(scopeReader, ref, rawExpr, kind) {\n  const scope = scopeReader.getScopeForComponent(ref.node);\n  let message = `The ${kind} '${ref.node.name.text}' appears in 'imports', but is not standalone and cannot be imported directly.`;\n  let relatedInformation = void 0;\n  if (scope !== null && scope.kind === ComponentScopeKind.NgModule) {\n    const isExported = scope.exported.dependencies.some((dep) => dep.ref.node === ref.node);\n    const relatedInfoMessageText = isExported ? `It can be imported using its '${scope.ngModule.name.text}' NgModule instead.` : `It's declared in the '${scope.ngModule.name.text}' NgModule, but is not exported. Consider exporting it and importing the NgModule instead.`;\n    relatedInformation = [makeRelatedInformation(scope.ngModule.name, relatedInfoMessageText)];\n  } else {\n  }\n  if (relatedInformation === void 0) {\n    message += \" It must be imported via an NgModule.\";\n  }\n  return makeDiagnostic(ErrorCode.COMPONENT_IMPORT_NOT_STANDALONE, getDiagnosticNode(ref, rawExpr), message, relatedInformation);\n}\nfunction makeUnknownComponentImportDiagnostic(ref, rawExpr) {\n  return makeDiagnostic(ErrorCode.COMPONENT_UNKNOWN_IMPORT, getDiagnosticNode(ref, rawExpr), `Component imports must be standalone components, directives, pipes, or must be NgModules.`);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/local.mjs\nvar LocalModuleScopeRegistry = class {\n  constructor(localReader, fullReader, dependencyScopeReader, refEmitter, aliasingHost) {\n    this.localReader = localReader;\n    this.fullReader = fullReader;\n    this.dependencyScopeReader = dependencyScopeReader;\n    this.refEmitter = refEmitter;\n    this.aliasingHost = aliasingHost;\n    this.sealed = false;\n    this.declarationToModule = /* @__PURE__ */ new Map();\n    this.duplicateDeclarations = /* @__PURE__ */ new Map();\n    this.moduleToRef = /* @__PURE__ */ new Map();\n    this.cache = /* @__PURE__ */ new Map();\n    this.remoteScoping = /* @__PURE__ */ new Map();\n    this.scopeErrors = /* @__PURE__ */ new Map();\n    this.modulesWithStructuralErrors = /* @__PURE__ */ new Set();\n  }\n  registerNgModuleMetadata(data) {\n    this.assertCollecting();\n    const ngModule = data.ref.node;\n    this.moduleToRef.set(data.ref.node, data.ref);\n    for (const decl of data.declarations) {\n      this.registerDeclarationOfModule(ngModule, decl, data.rawDeclarations);\n    }\n  }\n  registerDirectiveMetadata(directive) {\n  }\n  registerPipeMetadata(pipe) {\n  }\n  getScopeForComponent(clazz) {\n    const scope = !this.declarationToModule.has(clazz) ? null : this.getScopeOfModule(this.declarationToModule.get(clazz).ngModule);\n    return scope;\n  }\n  getDuplicateDeclarations(node) {\n    if (!this.duplicateDeclarations.has(node)) {\n      return null;\n    }\n    return Array.from(this.duplicateDeclarations.get(node).values());\n  }\n  getScopeOfModule(clazz) {\n    return this.moduleToRef.has(clazz) ? this.getScopeOfModuleReference(this.moduleToRef.get(clazz)) : null;\n  }\n  getDiagnosticsOfModule(clazz) {\n    this.getScopeOfModule(clazz);\n    if (this.scopeErrors.has(clazz)) {\n      return this.scopeErrors.get(clazz);\n    } else {\n      return null;\n    }\n  }\n  registerDeclarationOfModule(ngModule, decl, rawDeclarations) {\n    const declData = {\n      ngModule,\n      ref: decl,\n      rawDeclarations\n    };\n    if (this.duplicateDeclarations.has(decl.node)) {\n      this.duplicateDeclarations.get(decl.node).set(ngModule, declData);\n    } else if (this.declarationToModule.has(decl.node) && this.declarationToModule.get(decl.node).ngModule !== ngModule) {\n      const duplicateDeclMap = /* @__PURE__ */ new Map();\n      const firstDeclData = this.declarationToModule.get(decl.node);\n      this.modulesWithStructuralErrors.add(firstDeclData.ngModule);\n      this.modulesWithStructuralErrors.add(ngModule);\n      duplicateDeclMap.set(firstDeclData.ngModule, firstDeclData);\n      duplicateDeclMap.set(ngModule, declData);\n      this.duplicateDeclarations.set(decl.node, duplicateDeclMap);\n      this.declarationToModule.delete(decl.node);\n    } else {\n      this.declarationToModule.set(decl.node, declData);\n    }\n  }\n  getScopeOfModuleReference(ref) {\n    if (this.cache.has(ref.node)) {\n      return this.cache.get(ref.node);\n    }\n    this.sealed = true;\n    const ngModule = this.localReader.getNgModuleMetadata(ref);\n    if (ngModule === null) {\n      this.cache.set(ref.node, null);\n      return null;\n    }\n    const diagnostics = [];\n    const compilationDirectives = /* @__PURE__ */ new Map();\n    const compilationPipes = /* @__PURE__ */ new Map();\n    const declared = /* @__PURE__ */ new Set();\n    const exportDirectives = /* @__PURE__ */ new Map();\n    const exportPipes = /* @__PURE__ */ new Map();\n    let isPoisoned = false;\n    if (this.modulesWithStructuralErrors.has(ngModule.ref.node)) {\n      isPoisoned = true;\n    }\n    for (const decl of ngModule.imports) {\n      const importScope = this.getExportedScope(decl, diagnostics, ref.node, \"import\");\n      if (importScope !== null) {\n        if (importScope === \"invalid\" || importScope.exported.isPoisoned) {\n          diagnostics.push(invalidTransitiveNgModuleRef(decl, ngModule.rawImports, \"import\"));\n          isPoisoned = true;\n          if (importScope === \"invalid\") {\n            continue;\n          }\n        }\n        for (const dep of importScope.exported.dependencies) {\n          if (dep.kind === MetaKind.Directive) {\n            compilationDirectives.set(dep.ref.node, dep);\n          } else if (dep.kind === MetaKind.Pipe) {\n            compilationPipes.set(dep.ref.node, dep);\n          }\n        }\n        continue;\n      }\n      const directive = this.fullReader.getDirectiveMetadata(decl);\n      if (directive !== null) {\n        if (directive.isStandalone) {\n          compilationDirectives.set(directive.ref.node, directive);\n        } else {\n          diagnostics.push(makeNotStandaloneDiagnostic(this, decl, ngModule.rawImports, directive.isComponent ? \"component\" : \"directive\"));\n          isPoisoned = true;\n        }\n        continue;\n      }\n      const pipe = this.fullReader.getPipeMetadata(decl);\n      if (pipe !== null) {\n        if (pipe.isStandalone) {\n          compilationPipes.set(pipe.ref.node, pipe);\n        } else {\n          diagnostics.push(makeNotStandaloneDiagnostic(this, decl, ngModule.rawImports, \"pipe\"));\n          isPoisoned = true;\n        }\n        continue;\n      }\n      diagnostics.push(invalidRef(decl, ngModule.rawImports, \"import\"));\n      isPoisoned = true;\n    }\n    for (const decl of ngModule.declarations) {\n      const directive = this.localReader.getDirectiveMetadata(decl);\n      const pipe = this.localReader.getPipeMetadata(decl);\n      if (directive !== null) {\n        if (directive.isStandalone) {\n          const refType = directive.isComponent ? \"Component\" : \"Directive\";\n          diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_IS_STANDALONE, decl.getOriginForDiagnostics(ngModule.rawDeclarations), `${refType} ${decl.node.name.text} is standalone, and cannot be declared in an NgModule. Did you mean to import it instead?`));\n          isPoisoned = true;\n          continue;\n        }\n        compilationDirectives.set(decl.node, { ...directive, ref: decl });\n        if (directive.isPoisoned) {\n          isPoisoned = true;\n        }\n      } else if (pipe !== null) {\n        if (pipe.isStandalone) {\n          diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_IS_STANDALONE, decl.getOriginForDiagnostics(ngModule.rawDeclarations), `Pipe ${decl.node.name.text} is standalone, and cannot be declared in an NgModule. Did you mean to import it instead?`));\n          isPoisoned = true;\n          continue;\n        }\n        compilationPipes.set(decl.node, { ...pipe, ref: decl });\n      } else {\n        const errorNode = decl.getOriginForDiagnostics(ngModule.rawDeclarations);\n        diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `The class '${decl.node.name.text}' is listed in the declarations of the NgModule '${ngModule.ref.node.name.text}', but is not a directive, a component, or a pipe. Either remove it from the NgModule's declarations, or add an appropriate Angular decorator.`, [makeRelatedInformation(decl.node.name, `'${decl.node.name.text}' is declared here.`)]));\n        isPoisoned = true;\n        continue;\n      }\n      declared.add(decl.node);\n    }\n    for (const decl of ngModule.exports) {\n      const exportScope = this.getExportedScope(decl, diagnostics, ref.node, \"export\");\n      if (exportScope === \"invalid\" || exportScope !== null && exportScope.exported.isPoisoned) {\n        diagnostics.push(invalidTransitiveNgModuleRef(decl, ngModule.rawExports, \"export\"));\n        isPoisoned = true;\n        if (exportScope === \"invalid\") {\n          continue;\n        }\n      } else if (exportScope !== null) {\n        for (const dep of exportScope.exported.dependencies) {\n          if (dep.kind == MetaKind.Directive) {\n            exportDirectives.set(dep.ref.node, dep);\n          } else if (dep.kind === MetaKind.Pipe) {\n            exportPipes.set(dep.ref.node, dep);\n          }\n        }\n      } else if (compilationDirectives.has(decl.node)) {\n        const directive = compilationDirectives.get(decl.node);\n        exportDirectives.set(decl.node, directive);\n      } else if (compilationPipes.has(decl.node)) {\n        const pipe = compilationPipes.get(decl.node);\n        exportPipes.set(decl.node, pipe);\n      } else {\n        const dirMeta = this.fullReader.getDirectiveMetadata(decl);\n        const pipeMeta = this.fullReader.getPipeMetadata(decl);\n        if (dirMeta !== null || pipeMeta !== null) {\n          const isStandalone = dirMeta !== null ? dirMeta.isStandalone : pipeMeta.isStandalone;\n          diagnostics.push(invalidReexport(decl, ngModule.rawExports, isStandalone));\n        } else {\n          diagnostics.push(invalidRef(decl, ngModule.rawExports, \"export\"));\n        }\n        isPoisoned = true;\n        continue;\n      }\n    }\n    const exported = {\n      dependencies: [...exportDirectives.values(), ...exportPipes.values()],\n      isPoisoned\n    };\n    const reexports = this.getReexports(ngModule, ref, declared, exported.dependencies, diagnostics);\n    const scope = {\n      kind: ComponentScopeKind.NgModule,\n      ngModule: ngModule.ref.node,\n      compilation: {\n        dependencies: [...compilationDirectives.values(), ...compilationPipes.values()],\n        isPoisoned\n      },\n      exported,\n      reexports,\n      schemas: ngModule.schemas\n    };\n    if (diagnostics.length > 0) {\n      this.scopeErrors.set(ref.node, diagnostics);\n      this.modulesWithStructuralErrors.add(ref.node);\n    }\n    this.cache.set(ref.node, scope);\n    return scope;\n  }\n  getRemoteScope(node) {\n    return this.remoteScoping.has(node) ? this.remoteScoping.get(node) : null;\n  }\n  setComponentRemoteScope(node, directives, pipes) {\n    this.remoteScoping.set(node, { directives, pipes });\n  }\n  getExportedScope(ref, diagnostics, ownerForErrors, type) {\n    if (ref.node.getSourceFile().isDeclarationFile) {\n      if (!ts12.isClassDeclaration(ref.node)) {\n        const code = type === \"import\" ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;\n        diagnostics.push(makeDiagnostic(code, identifierOfNode(ref.node) || ref.node, `Appears in the NgModule.${type}s of ${nodeNameForError(ownerForErrors)}, but could not be resolved to an NgModule`));\n        return \"invalid\";\n      }\n      return this.dependencyScopeReader.resolve(ref);\n    } else {\n      return this.getScopeOfModuleReference(ref);\n    }\n  }\n  getReexports(ngModule, ref, declared, exported, diagnostics) {\n    let reexports = null;\n    const sourceFile = ref.node.getSourceFile();\n    if (this.aliasingHost === null) {\n      return null;\n    }\n    reexports = [];\n    const reexportMap = /* @__PURE__ */ new Map();\n    const ngModuleRef = ref;\n    const addReexport = (exportRef) => {\n      if (exportRef.node.getSourceFile() === sourceFile) {\n        return;\n      }\n      const isReExport = !declared.has(exportRef.node);\n      const exportName = this.aliasingHost.maybeAliasSymbolAs(exportRef, sourceFile, ngModule.ref.node.name.text, isReExport);\n      if (exportName === null) {\n        return;\n      }\n      if (!reexportMap.has(exportName)) {\n        if (exportRef.alias && exportRef.alias instanceof ExternalExpr3) {\n          reexports.push({\n            fromModule: exportRef.alias.value.moduleName,\n            symbolName: exportRef.alias.value.name,\n            asAlias: exportName\n          });\n        } else {\n          const emittedRef = this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile);\n          assertSuccessfulReferenceEmit(emittedRef, ngModuleRef.node.name, \"class\");\n          const expr = emittedRef.expression;\n          if (!(expr instanceof ExternalExpr3) || expr.value.moduleName === null || expr.value.name === null) {\n            throw new Error(\"Expected ExternalExpr\");\n          }\n          reexports.push({\n            fromModule: expr.value.moduleName,\n            symbolName: expr.value.name,\n            asAlias: exportName\n          });\n        }\n        reexportMap.set(exportName, exportRef);\n      } else {\n        const prevRef = reexportMap.get(exportName);\n        diagnostics.push(reexportCollision(ngModuleRef.node, prevRef, exportRef));\n      }\n    };\n    for (const { ref: ref2 } of exported) {\n      addReexport(ref2);\n    }\n    return reexports;\n  }\n  assertCollecting() {\n    if (this.sealed) {\n      throw new Error(`Assertion: LocalModuleScopeRegistry is not COLLECTING`);\n    }\n  }\n};\nfunction invalidRef(decl, rawExpr, type) {\n  const code = type === \"import\" ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;\n  const resolveTarget = type === \"import\" ? \"NgModule\" : \"NgModule, Component, Directive, or Pipe\";\n  const message = `'${decl.node.name.text}' does not appear to be an ${resolveTarget} class.`;\n  const library = decl.ownedByModuleGuess !== null ? ` (${decl.ownedByModuleGuess})` : \"\";\n  const sf = decl.node.getSourceFile();\n  let relatedMessage;\n  if (!sf.isDeclarationFile) {\n    const annotationType = type === \"import\" ? \"@NgModule\" : \"Angular\";\n    relatedMessage = `Is it missing an ${annotationType} annotation?`;\n  } else if (sf.fileName.indexOf(\"node_modules\") !== -1) {\n    relatedMessage = `This likely means that the library${library} which declares ${decl.debugName} is not compatible with Angular Ivy. Check if a newer version of the library is available, and update if so. Also consider checking with the library's authors to see if the library is expected to be compatible with Ivy.`;\n  } else {\n    relatedMessage = `This likely means that the dependency${library} which declares ${decl.debugName} is not compatible with Angular Ivy.`;\n  }\n  return makeDiagnostic(code, getDiagnosticNode(decl, rawExpr), message, [makeRelatedInformation(decl.node.name, relatedMessage)]);\n}\nfunction invalidTransitiveNgModuleRef(decl, rawExpr, type) {\n  const code = type === \"import\" ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;\n  return makeDiagnostic(code, getDiagnosticNode(decl, rawExpr), `This ${type} contains errors, which may affect components that depend on this NgModule.`);\n}\nfunction invalidReexport(decl, rawExpr, isStandalone) {\n  let message = `Can't be exported from this NgModule, as `;\n  if (isStandalone) {\n    message += \"it must be imported first\";\n  } else if (decl.node.getSourceFile().isDeclarationFile) {\n    message += \"it must be imported via its NgModule first\";\n  } else {\n    message += \"it must be either declared by this NgModule, or imported here via its NgModule first\";\n  }\n  return makeDiagnostic(ErrorCode.NGMODULE_INVALID_REEXPORT, getDiagnosticNode(decl, rawExpr), message);\n}\nfunction reexportCollision(module, refA, refB) {\n  const childMessageText = `This directive/pipe is part of the exports of '${module.name.text}' and shares the same name as another exported directive/pipe.`;\n  return makeDiagnostic(ErrorCode.NGMODULE_REEXPORT_NAME_COLLISION, module.name, `\n    There was a name collision between two classes named '${refA.node.name.text}', which are both part of the exports of '${module.name.text}'.\n\n    Angular generates re-exports of an NgModule's exported directives/pipes from the module's source file in certain cases, using the declared name of the class. If two classes of the same name are exported, this automatic naming does not work.\n\n    To fix this problem please re-export one or both classes directly from this file.\n  `.trim(), [\n    makeRelatedInformation(refA.node.name, childMessageText),\n    makeRelatedInformation(refB.node.name, childMessageText)\n  ]);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/typecheck.mjs\nimport { CssSelector, SelectorMatcher } from \"@angular/compiler\";\nimport ts13 from \"typescript\";\nvar TypeCheckScopeRegistry = class {\n  constructor(scopeReader, metaReader, hostDirectivesResolver) {\n    this.scopeReader = scopeReader;\n    this.metaReader = metaReader;\n    this.hostDirectivesResolver = hostDirectivesResolver;\n    this.flattenedDirectiveMetaCache = /* @__PURE__ */ new Map();\n    this.scopeCache = /* @__PURE__ */ new Map();\n  }\n  getTypeCheckScope(node) {\n    const matcher = new SelectorMatcher();\n    const directives = [];\n    const pipes = /* @__PURE__ */ new Map();\n    const scope = this.scopeReader.getScopeForComponent(node);\n    if (scope === null) {\n      return {\n        matcher,\n        directives,\n        pipes,\n        schemas: [],\n        isPoisoned: false\n      };\n    }\n    const cacheKey = scope.kind === ComponentScopeKind.NgModule ? scope.ngModule : scope.component;\n    const dependencies = scope.kind === ComponentScopeKind.NgModule ? scope.compilation.dependencies : scope.dependencies;\n    if (this.scopeCache.has(cacheKey)) {\n      return this.scopeCache.get(cacheKey);\n    }\n    for (const meta of dependencies) {\n      if (meta.kind === MetaKind.Directive && meta.selector !== null) {\n        const extMeta = this.getTypeCheckDirectiveMetadata(meta.ref);\n        if (extMeta === null) {\n          continue;\n        }\n        matcher.addSelectables(CssSelector.parse(meta.selector), [...this.hostDirectivesResolver.resolve(extMeta), extMeta]);\n        directives.push(extMeta);\n      } else if (meta.kind === MetaKind.Pipe) {\n        if (!ts13.isClassDeclaration(meta.ref.node)) {\n          throw new Error(`Unexpected non-class declaration ${ts13.SyntaxKind[meta.ref.node.kind]} for pipe ${meta.ref.debugName}`);\n        }\n        pipes.set(meta.name, meta.ref);\n      }\n    }\n    const typeCheckScope = {\n      matcher,\n      directives,\n      pipes,\n      schemas: scope.schemas,\n      isPoisoned: scope.kind === ComponentScopeKind.NgModule ? scope.compilation.isPoisoned || scope.exported.isPoisoned : scope.isPoisoned\n    };\n    this.scopeCache.set(cacheKey, typeCheckScope);\n    return typeCheckScope;\n  }\n  getTypeCheckDirectiveMetadata(ref) {\n    const clazz = ref.node;\n    if (this.flattenedDirectiveMetaCache.has(clazz)) {\n      return this.flattenedDirectiveMetaCache.get(clazz);\n    }\n    const meta = flattenInheritedDirectiveMetadata(this.metaReader, ref);\n    if (meta === null) {\n      return null;\n    }\n    this.flattenedDirectiveMetaCache.set(clazz, meta);\n    return meta;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/api.mjs\nvar CompilationMode;\n(function(CompilationMode2) {\n  CompilationMode2[CompilationMode2[\"FULL\"] = 0] = \"FULL\";\n  CompilationMode2[CompilationMode2[\"PARTIAL\"] = 1] = \"PARTIAL\";\n  CompilationMode2[CompilationMode2[\"LOCAL\"] = 2] = \"LOCAL\";\n})(CompilationMode || (CompilationMode = {}));\nvar HandlerPrecedence;\n(function(HandlerPrecedence2) {\n  HandlerPrecedence2[HandlerPrecedence2[\"PRIMARY\"] = 0] = \"PRIMARY\";\n  HandlerPrecedence2[HandlerPrecedence2[\"SHARED\"] = 1] = \"SHARED\";\n  HandlerPrecedence2[HandlerPrecedence2[\"WEAK\"] = 2] = \"WEAK\";\n})(HandlerPrecedence || (HandlerPrecedence = {}));\nvar HandlerFlags;\n(function(HandlerFlags2) {\n  HandlerFlags2[HandlerFlags2[\"NONE\"] = 0] = \"NONE\";\n  HandlerFlags2[HandlerFlags2[\"FULL_INHERITANCE\"] = 1] = \"FULL_INHERITANCE\";\n})(HandlerFlags || (HandlerFlags = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/alias.mjs\nimport ts14 from \"typescript\";\nfunction aliasTransformFactory(exportStatements) {\n  return () => {\n    return (file) => {\n      if (ts14.isBundle(file) || !exportStatements.has(file.fileName)) {\n        return file;\n      }\n      const statements = [...file.statements];\n      exportStatements.get(file.fileName).forEach(([moduleName, symbolName], aliasName) => {\n        const stmt = ts14.factory.createExportDeclaration(\n          void 0,\n          false,\n          ts14.factory.createNamedExports([ts14.factory.createExportSpecifier(false, symbolName, aliasName)]),\n          ts14.factory.createStringLiteral(moduleName)\n        );\n        statements.push(stmt);\n      });\n      return ts14.factory.updateSourceFile(file, statements);\n    };\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/compilation.mjs\nimport ts15 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/trait.mjs\nvar TraitState;\n(function(TraitState2) {\n  TraitState2[TraitState2[\"Pending\"] = 0] = \"Pending\";\n  TraitState2[TraitState2[\"Analyzed\"] = 1] = \"Analyzed\";\n  TraitState2[TraitState2[\"Resolved\"] = 2] = \"Resolved\";\n  TraitState2[TraitState2[\"Skipped\"] = 3] = \"Skipped\";\n})(TraitState || (TraitState = {}));\nvar Trait = {\n  pending: (handler, detected) => TraitImpl.pending(handler, detected)\n};\nvar TraitImpl = class {\n  constructor(handler, detected) {\n    this.state = TraitState.Pending;\n    this.analysis = null;\n    this.symbol = null;\n    this.resolution = null;\n    this.analysisDiagnostics = null;\n    this.resolveDiagnostics = null;\n    this.typeCheckDiagnostics = null;\n    this.handler = handler;\n    this.detected = detected;\n  }\n  toAnalyzed(analysis, diagnostics, symbol) {\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);\n    this.analysis = analysis;\n    this.analysisDiagnostics = diagnostics;\n    this.symbol = symbol;\n    this.state = TraitState.Analyzed;\n    return this;\n  }\n  toResolved(resolution, diagnostics) {\n    this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);\n    if (this.analysis === null) {\n      throw new Error(`Cannot transition an Analyzed trait with a null analysis to Resolved`);\n    }\n    this.resolution = resolution;\n    this.state = TraitState.Resolved;\n    this.resolveDiagnostics = diagnostics;\n    this.typeCheckDiagnostics = null;\n    return this;\n  }\n  toSkipped() {\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);\n    this.state = TraitState.Skipped;\n    return this;\n  }\n  assertTransitionLegal(allowedState, transitionTo) {\n    if (!(this.state === allowedState)) {\n      throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${TraitState[transitionTo]}.`);\n    }\n  }\n  static pending(handler, detected) {\n    return new TraitImpl(handler, detected);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/compilation.mjs\nvar TraitCompiler = class {\n  constructor(handlers, reflector, perf, incrementalBuild, compileNonExportedClasses, compilationMode, dtsTransforms, semanticDepGraphUpdater, sourceFileTypeIdentifier) {\n    this.handlers = handlers;\n    this.reflector = reflector;\n    this.perf = perf;\n    this.incrementalBuild = incrementalBuild;\n    this.compileNonExportedClasses = compileNonExportedClasses;\n    this.compilationMode = compilationMode;\n    this.dtsTransforms = dtsTransforms;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.sourceFileTypeIdentifier = sourceFileTypeIdentifier;\n    this.classes = /* @__PURE__ */ new Map();\n    this.fileToClasses = /* @__PURE__ */ new Map();\n    this.filesWithoutTraits = /* @__PURE__ */ new Set();\n    this.reexportMap = /* @__PURE__ */ new Map();\n    this.handlersByName = /* @__PURE__ */ new Map();\n    for (const handler of handlers) {\n      this.handlersByName.set(handler.name, handler);\n    }\n  }\n  analyzeSync(sf) {\n    this.analyze(sf, false);\n  }\n  analyzeAsync(sf) {\n    return this.analyze(sf, true);\n  }\n  analyze(sf, preanalyze) {\n    if (sf.isDeclarationFile || this.sourceFileTypeIdentifier.isShim(sf) || this.sourceFileTypeIdentifier.isResource(sf)) {\n      return void 0;\n    }\n    const promises = [];\n    const priorWork = this.incrementalBuild.priorAnalysisFor(sf);\n    if (priorWork !== null) {\n      this.perf.eventCount(PerfEvent.SourceFileReuseAnalysis);\n      if (priorWork.length > 0) {\n        for (const priorRecord of priorWork) {\n          this.adopt(priorRecord);\n        }\n        this.perf.eventCount(PerfEvent.TraitReuseAnalysis, priorWork.length);\n      } else {\n        this.filesWithoutTraits.add(sf);\n      }\n      return;\n    }\n    const visit2 = (node) => {\n      if (this.reflector.isClass(node)) {\n        this.analyzeClass(node, preanalyze ? promises : null);\n      }\n      ts15.forEachChild(node, visit2);\n    };\n    visit2(sf);\n    if (!this.fileToClasses.has(sf)) {\n      this.filesWithoutTraits.add(sf);\n    }\n    if (preanalyze && promises.length > 0) {\n      return Promise.all(promises).then(() => void 0);\n    } else {\n      return void 0;\n    }\n  }\n  recordFor(clazz) {\n    if (this.classes.has(clazz)) {\n      return this.classes.get(clazz);\n    } else {\n      return null;\n    }\n  }\n  getAnalyzedRecords() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [sf, classes] of this.fileToClasses) {\n      const records = [];\n      for (const clazz of classes) {\n        records.push(this.classes.get(clazz));\n      }\n      result.set(sf, records);\n    }\n    for (const sf of this.filesWithoutTraits) {\n      result.set(sf, []);\n    }\n    return result;\n  }\n  adopt(priorRecord) {\n    const record = {\n      hasPrimaryHandler: priorRecord.hasPrimaryHandler,\n      hasWeakHandlers: priorRecord.hasWeakHandlers,\n      metaDiagnostics: priorRecord.metaDiagnostics,\n      node: priorRecord.node,\n      traits: []\n    };\n    for (const priorTrait of priorRecord.traits) {\n      const handler = this.handlersByName.get(priorTrait.handler.name);\n      let trait = Trait.pending(handler, priorTrait.detected);\n      if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {\n        const symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);\n        trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);\n        if (trait.analysis !== null && trait.handler.register !== void 0) {\n          trait.handler.register(record.node, trait.analysis);\n        }\n      } else if (priorTrait.state === TraitState.Skipped) {\n        trait = trait.toSkipped();\n      }\n      record.traits.push(trait);\n    }\n    this.classes.set(record.node, record);\n    const sf = record.node.getSourceFile();\n    if (!this.fileToClasses.has(sf)) {\n      this.fileToClasses.set(sf, /* @__PURE__ */ new Set());\n    }\n    this.fileToClasses.get(sf).add(record.node);\n  }\n  scanClassForTraits(clazz) {\n    if (!this.compileNonExportedClasses && !this.reflector.isStaticallyExported(clazz)) {\n      return null;\n    }\n    const decorators = this.reflector.getDecoratorsOfDeclaration(clazz);\n    return this.detectTraits(clazz, decorators);\n  }\n  detectTraits(clazz, decorators) {\n    let record = this.recordFor(clazz);\n    let foundTraits = [];\n    for (const handler of this.handlers) {\n      const result = handler.detect(clazz, decorators);\n      if (result === void 0) {\n        continue;\n      }\n      const isPrimaryHandler = handler.precedence === HandlerPrecedence.PRIMARY;\n      const isWeakHandler = handler.precedence === HandlerPrecedence.WEAK;\n      const trait = Trait.pending(handler, result);\n      foundTraits.push(trait);\n      if (record === null) {\n        record = {\n          node: clazz,\n          traits: [trait],\n          metaDiagnostics: null,\n          hasPrimaryHandler: isPrimaryHandler,\n          hasWeakHandlers: isWeakHandler\n        };\n        this.classes.set(clazz, record);\n        const sf = clazz.getSourceFile();\n        if (!this.fileToClasses.has(sf)) {\n          this.fileToClasses.set(sf, /* @__PURE__ */ new Set());\n        }\n        this.fileToClasses.get(sf).add(clazz);\n      } else {\n        if (!isWeakHandler && record.hasWeakHandlers) {\n          record.traits = record.traits.filter((field) => field.handler.precedence !== HandlerPrecedence.WEAK);\n          record.hasWeakHandlers = false;\n        } else if (isWeakHandler && !record.hasWeakHandlers) {\n          continue;\n        }\n        if (isPrimaryHandler && record.hasPrimaryHandler) {\n          record.metaDiagnostics = [{\n            category: ts15.DiagnosticCategory.Error,\n            code: Number(\"-99\" + ErrorCode.DECORATOR_COLLISION),\n            file: getSourceFile(clazz),\n            start: clazz.getStart(void 0, false),\n            length: clazz.getWidth(),\n            messageText: \"Two incompatible decorators on class\"\n          }];\n          record.traits = foundTraits = [];\n          break;\n        }\n        record.traits.push(trait);\n        record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;\n      }\n    }\n    return foundTraits.length > 0 ? foundTraits : null;\n  }\n  makeSymbolForTrait(handler, decl, analysis) {\n    if (analysis === null) {\n      return null;\n    }\n    const symbol = handler.symbol(decl, analysis);\n    if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n      const isPrimary = handler.precedence === HandlerPrecedence.PRIMARY;\n      if (!isPrimary) {\n        throw new Error(`AssertionError: ${handler.name} returned a symbol but is not a primary handler.`);\n      }\n      this.semanticDepGraphUpdater.registerSymbol(symbol);\n    }\n    return symbol;\n  }\n  analyzeClass(clazz, preanalyzeQueue) {\n    const traits = this.scanClassForTraits(clazz);\n    if (traits === null) {\n      return;\n    }\n    for (const trait of traits) {\n      const analyze = () => this.analyzeTrait(clazz, trait);\n      let preanalysis = null;\n      if (preanalyzeQueue !== null && trait.handler.preanalyze !== void 0) {\n        try {\n          preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait.toAnalyzed(null, [err.toDiagnostic()], null);\n            return;\n          } else {\n            throw err;\n          }\n        }\n      }\n      if (preanalysis !== null) {\n        preanalyzeQueue.push(preanalysis.then(analyze));\n      } else {\n        analyze();\n      }\n    }\n  }\n  analyzeTrait(clazz, trait, flags) {\n    var _a, _b, _c;\n    if (trait.state !== TraitState.Pending) {\n      throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${TraitState[trait.state]} (expected DETECTED)`);\n    }\n    this.perf.eventCount(PerfEvent.TraitAnalyze);\n    let result;\n    try {\n      result = trait.handler.analyze(clazz, trait.detected.metadata, flags);\n    } catch (err) {\n      if (err instanceof FatalDiagnosticError) {\n        trait.toAnalyzed(null, [err.toDiagnostic()], null);\n        return;\n      } else {\n        throw err;\n      }\n    }\n    const symbol = this.makeSymbolForTrait(trait.handler, clazz, (_a = result.analysis) != null ? _a : null);\n    if (result.analysis !== void 0 && trait.handler.register !== void 0) {\n      trait.handler.register(clazz, result.analysis);\n    }\n    trait = trait.toAnalyzed((_b = result.analysis) != null ? _b : null, (_c = result.diagnostics) != null ? _c : null, symbol);\n  }\n  resolve() {\n    var _a, _b;\n    const classes = this.classes.keys();\n    for (const clazz of classes) {\n      const record = this.classes.get(clazz);\n      for (let trait of record.traits) {\n        const handler = trait.handler;\n        switch (trait.state) {\n          case TraitState.Skipped:\n            continue;\n          case TraitState.Pending:\n            throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${trait.handler.name}`);\n          case TraitState.Resolved:\n            throw new Error(`Resolving an already resolved trait`);\n        }\n        if (trait.analysis === null) {\n          continue;\n        }\n        if (handler.resolve === void 0) {\n          trait = trait.toResolved(null, null);\n          continue;\n        }\n        let result;\n        try {\n          result = handler.resolve(clazz, trait.analysis, trait.symbol);\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait = trait.toResolved(null, [err.toDiagnostic()]);\n            continue;\n          } else {\n            throw err;\n          }\n        }\n        trait = trait.toResolved((_a = result.data) != null ? _a : null, (_b = result.diagnostics) != null ? _b : null);\n        if (result.reexports !== void 0) {\n          const fileName = clazz.getSourceFile().fileName;\n          if (!this.reexportMap.has(fileName)) {\n            this.reexportMap.set(fileName, /* @__PURE__ */ new Map());\n          }\n          const fileReexports = this.reexportMap.get(fileName);\n          for (const reexport of result.reexports) {\n            fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);\n          }\n        }\n      }\n    }\n  }\n  typeCheck(sf, ctx) {\n    if (!this.fileToClasses.has(sf)) {\n      return;\n    }\n    for (const clazz of this.fileToClasses.get(sf)) {\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.typeCheck === void 0) {\n          continue;\n        }\n        if (trait.resolution !== null) {\n          trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n  extendedTemplateCheck(sf, extendedTemplateChecker) {\n    const classes = this.fileToClasses.get(sf);\n    if (classes === void 0) {\n      return [];\n    }\n    const diagnostics = [];\n    for (const clazz of classes) {\n      if (!isNamedClassDeclaration(clazz)) {\n        continue;\n      }\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.handler.extendedTemplateCheck === void 0) {\n          continue;\n        }\n        diagnostics.push(...trait.handler.extendedTemplateCheck(clazz, extendedTemplateChecker));\n      }\n    }\n    return diagnostics;\n  }\n  index(ctx) {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.index === void 0) {\n          continue;\n        }\n        if (trait.resolution !== null) {\n          trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n  xi18n(bundle) {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Analyzed && trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.xi18n === void 0) {\n          continue;\n        }\n        if (trait.analysis !== null) {\n          trait.handler.xi18n(bundle, clazz, trait.analysis);\n        }\n      }\n    }\n  }\n  updateResources(clazz) {\n    if (!this.reflector.isClass(clazz) || !this.classes.has(clazz)) {\n      return;\n    }\n    const record = this.classes.get(clazz);\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || trait.handler.updateResources === void 0) {\n        continue;\n      }\n      trait.handler.updateResources(clazz, trait.analysis, trait.resolution);\n    }\n  }\n  compile(clazz, constantPool) {\n    const original = ts15.getOriginalNode(clazz);\n    if (!this.reflector.isClass(clazz) || !this.reflector.isClass(original) || !this.classes.has(original)) {\n      return null;\n    }\n    const record = this.classes.get(original);\n    let res = [];\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || containsErrors(trait.analysisDiagnostics) || containsErrors(trait.resolveDiagnostics)) {\n        continue;\n      }\n      let compileRes;\n      if (this.compilationMode === CompilationMode.PARTIAL && trait.handler.compilePartial !== void 0) {\n        compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution);\n      } else {\n        compileRes = trait.handler.compileFull(clazz, trait.analysis, trait.resolution, constantPool);\n      }\n      const compileMatchRes = compileRes;\n      if (Array.isArray(compileMatchRes)) {\n        for (const result of compileMatchRes) {\n          if (!res.some((r) => r.name === result.name)) {\n            res.push(result);\n          }\n        }\n      } else if (!res.some((result) => result.name === compileMatchRes.name)) {\n        res.push(compileMatchRes);\n      }\n    }\n    this.dtsTransforms.getIvyDeclarationTransform(original.getSourceFile()).addFields(original, res);\n    return res.length > 0 ? res : null;\n  }\n  decoratorsFor(node) {\n    const original = ts15.getOriginalNode(node);\n    if (!this.reflector.isClass(original) || !this.classes.has(original)) {\n      return [];\n    }\n    const record = this.classes.get(original);\n    const decorators = [];\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved) {\n        continue;\n      }\n      if (trait.detected.trigger !== null && ts15.isDecorator(trait.detected.trigger)) {\n        decorators.push(trait.detected.trigger);\n      }\n    }\n    return decorators;\n  }\n  get diagnostics() {\n    var _a;\n    const diagnostics = [];\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n      if (record.metaDiagnostics !== null) {\n        diagnostics.push(...record.metaDiagnostics);\n      }\n      for (const trait of record.traits) {\n        if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) && trait.analysisDiagnostics !== null) {\n          diagnostics.push(...trait.analysisDiagnostics);\n        }\n        if (trait.state === TraitState.Resolved) {\n          diagnostics.push(...(_a = trait.resolveDiagnostics) != null ? _a : []);\n        }\n      }\n    }\n    return diagnostics;\n  }\n  get exportStatements() {\n    return this.reexportMap;\n  }\n};\nfunction containsErrors(diagnostics) {\n  return diagnostics !== null && diagnostics.some((diag) => diag.category === ts15.DiagnosticCategory.Error);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/declaration.mjs\nimport ts17 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/utils.mjs\nimport ts16 from \"typescript\";\nfunction addImports(importManager, sf, extraStatements = []) {\n  const addedImports = importManager.getAllImports(sf.fileName).map((i) => {\n    const qualifier = ts16.factory.createIdentifier(i.qualifier.text);\n    const importClause = ts16.factory.createImportClause(\n      false,\n      void 0,\n      ts16.factory.createNamespaceImport(qualifier)\n    );\n    const decl = ts16.factory.createImportDeclaration(\n      void 0,\n      importClause,\n      ts16.factory.createStringLiteral(i.specifier)\n    );\n    ts16.setOriginalNode(i.qualifier, decl);\n    return decl;\n  });\n  const existingImports = sf.statements.filter((stmt) => isImportStatement(stmt));\n  const body = sf.statements.filter((stmt) => !isImportStatement(stmt));\n  if (addedImports.length > 0) {\n    const fileoverviewAnchorStmt = ts16.factory.createNotEmittedStatement(sf);\n    return ts16.factory.updateSourceFile(sf, ts16.factory.createNodeArray([\n      fileoverviewAnchorStmt,\n      ...existingImports,\n      ...addedImports,\n      ...extraStatements,\n      ...body\n    ]));\n  }\n  return sf;\n}\nfunction isImportStatement(stmt) {\n  return ts16.isImportDeclaration(stmt) || ts16.isImportEqualsDeclaration(stmt) || ts16.isNamespaceImport(stmt);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/declaration.mjs\nvar DtsTransformRegistry = class {\n  constructor() {\n    this.ivyDeclarationTransforms = /* @__PURE__ */ new Map();\n  }\n  getIvyDeclarationTransform(sf) {\n    if (!this.ivyDeclarationTransforms.has(sf)) {\n      this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());\n    }\n    return this.ivyDeclarationTransforms.get(sf);\n  }\n  getAllTransforms(sf) {\n    if (!sf.isDeclarationFile) {\n      return null;\n    }\n    const originalSf = ts17.getOriginalNode(sf);\n    let transforms = null;\n    if (this.ivyDeclarationTransforms.has(originalSf)) {\n      transforms = [];\n      transforms.push(this.ivyDeclarationTransforms.get(originalSf));\n    }\n    return transforms;\n  }\n};\nfunction declarationTransformFactory(transformRegistry, reflector, refEmitter, importRewriter, importPrefix) {\n  return (context) => {\n    const transformer = new DtsTransformer(context, reflector, refEmitter, importRewriter, importPrefix);\n    return (fileOrBundle) => {\n      if (ts17.isBundle(fileOrBundle)) {\n        return fileOrBundle;\n      }\n      const transforms = transformRegistry.getAllTransforms(fileOrBundle);\n      if (transforms === null) {\n        return fileOrBundle;\n      }\n      return transformer.transform(fileOrBundle, transforms);\n    };\n  };\n}\nvar DtsTransformer = class {\n  constructor(ctx, reflector, refEmitter, importRewriter, importPrefix) {\n    this.ctx = ctx;\n    this.reflector = reflector;\n    this.refEmitter = refEmitter;\n    this.importRewriter = importRewriter;\n    this.importPrefix = importPrefix;\n  }\n  transform(sf, transforms) {\n    const imports = new ImportManager(this.importRewriter, this.importPrefix);\n    const visitor = (node) => {\n      if (ts17.isClassDeclaration(node)) {\n        return this.transformClassDeclaration(node, transforms, imports);\n      } else if (ts17.isFunctionDeclaration(node)) {\n        return this.transformFunctionDeclaration(node, transforms, imports);\n      } else {\n        return ts17.visitEachChild(node, visitor, this.ctx);\n      }\n    };\n    sf = ts17.visitNode(sf, visitor, ts17.isSourceFile) || sf;\n    return addImports(imports, sf);\n  }\n  transformClassDeclaration(clazz, transforms, imports) {\n    let elements = clazz.members;\n    let elementsChanged = false;\n    for (const transform of transforms) {\n      if (transform.transformClassElement !== void 0) {\n        for (let i = 0; i < elements.length; i++) {\n          const res = transform.transformClassElement(elements[i], imports);\n          if (res !== elements[i]) {\n            if (!elementsChanged) {\n              elements = [...elements];\n              elementsChanged = true;\n            }\n            elements[i] = res;\n          }\n        }\n      }\n    }\n    let newClazz = clazz;\n    for (const transform of transforms) {\n      if (transform.transformClass !== void 0) {\n        const inputMembers = clazz === newClazz ? elements : newClazz.members;\n        newClazz = transform.transformClass(newClazz, inputMembers, this.reflector, this.refEmitter, imports);\n      }\n    }\n    if (elementsChanged && clazz === newClazz) {\n      newClazz = ts17.factory.updateClassDeclaration(\n        clazz,\n        clazz.modifiers,\n        clazz.name,\n        clazz.typeParameters,\n        clazz.heritageClauses,\n        elements\n      );\n    }\n    return newClazz;\n  }\n  transformFunctionDeclaration(declaration, transforms, imports) {\n    let newDecl = declaration;\n    for (const transform of transforms) {\n      if (transform.transformFunctionDeclaration !== void 0) {\n        newDecl = transform.transformFunctionDeclaration(newDecl, imports);\n      }\n    }\n    return newDecl;\n  }\n};\nvar IvyDeclarationDtsTransform = class {\n  constructor() {\n    this.declarationFields = /* @__PURE__ */ new Map();\n  }\n  addFields(decl, fields) {\n    this.declarationFields.set(decl, fields);\n  }\n  transformClass(clazz, members, reflector, refEmitter, imports) {\n    const original = ts17.getOriginalNode(clazz);\n    if (!this.declarationFields.has(original)) {\n      return clazz;\n    }\n    const fields = this.declarationFields.get(original);\n    const newMembers = fields.map((decl) => {\n      const modifiers = [ts17.factory.createModifier(ts17.SyntaxKind.StaticKeyword)];\n      const typeRef = translateType(decl.type, original.getSourceFile(), reflector, refEmitter, imports);\n      markForEmitAsSingleLine(typeRef);\n      return ts17.factory.createPropertyDeclaration(\n        modifiers,\n        decl.name,\n        void 0,\n        typeRef,\n        void 0\n      );\n    });\n    return ts17.factory.updateClassDeclaration(\n      clazz,\n      clazz.modifiers,\n      clazz.name,\n      clazz.typeParameters,\n      clazz.heritageClauses,\n      [...members, ...newMembers]\n    );\n  }\n};\nfunction markForEmitAsSingleLine(node) {\n  ts17.setEmitFlags(node, ts17.EmitFlags.SingleLine);\n  ts17.forEachChild(node, markForEmitAsSingleLine);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/transform.mjs\nimport { ConstantPool } from \"@angular/compiler\";\nimport ts19 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/util/src/visitor.mjs\nimport ts18 from \"typescript\";\nfunction visit(node, visitor, context) {\n  return visitor._visit(node, context);\n}\nvar Visitor = class {\n  constructor() {\n    this._before = /* @__PURE__ */ new Map();\n    this._after = /* @__PURE__ */ new Map();\n  }\n  _visitListEntryNode(node, visitor) {\n    const result = visitor(node);\n    if (result.before !== void 0) {\n      this._before.set(result.node, result.before);\n    }\n    if (result.after !== void 0) {\n      this._after.set(result.node, result.after);\n    }\n    return result.node;\n  }\n  visitOtherNode(node) {\n    return node;\n  }\n  _visit(node, context) {\n    let visitedNode = null;\n    node = ts18.visitEachChild(node, (child) => this._visit(child, context), context);\n    if (ts18.isClassDeclaration(node)) {\n      visitedNode = this._visitListEntryNode(node, (node2) => this.visitClassDeclaration(node2));\n    } else {\n      visitedNode = this.visitOtherNode(node);\n    }\n    if (ts18.isBlock(visitedNode) || ts18.isSourceFile(visitedNode)) {\n      visitedNode = this._maybeProcessStatements(visitedNode);\n    }\n    return visitedNode;\n  }\n  _maybeProcessStatements(node) {\n    if (node.statements.every((stmt) => !this._before.has(stmt) && !this._after.has(stmt))) {\n      return node;\n    }\n    const newStatements = [];\n    node.statements.forEach((stmt) => {\n      if (this._before.has(stmt)) {\n        newStatements.push(...this._before.get(stmt));\n        this._before.delete(stmt);\n      }\n      newStatements.push(stmt);\n      if (this._after.has(stmt)) {\n        newStatements.push(...this._after.get(stmt));\n        this._after.delete(stmt);\n      }\n    });\n    const statementsArray = ts18.factory.createNodeArray(newStatements, node.statements.hasTrailingComma);\n    if (ts18.isBlock(node)) {\n      return ts18.factory.updateBlock(node, statementsArray);\n    } else {\n      return ts18.factory.updateSourceFile(node, statementsArray, node.isDeclarationFile, node.referencedFiles, node.typeReferenceDirectives, node.hasNoDefaultLib, node.libReferenceDirectives);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/transform.mjs\nvar NO_DECORATORS = /* @__PURE__ */ new Set();\nvar CLOSURE_FILE_OVERVIEW_REGEXP = /\\s+@fileoverview\\s+/i;\nfunction ivyTransformFactory(compilation, reflector, importRewriter, defaultImportTracker, perf, isCore, isClosureCompilerEnabled) {\n  const recordWrappedNode = createRecorderFn(defaultImportTracker);\n  return (context) => {\n    return (file) => {\n      return perf.inPhase(PerfPhase.Compile, () => transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode));\n    };\n  };\n}\nvar IvyCompilationVisitor = class extends Visitor {\n  constructor(compilation, constantPool) {\n    super();\n    this.compilation = compilation;\n    this.constantPool = constantPool;\n    this.classCompilationMap = /* @__PURE__ */ new Map();\n  }\n  visitClassDeclaration(node) {\n    const result = this.compilation.compile(node, this.constantPool);\n    if (result !== null) {\n      this.classCompilationMap.set(node, result);\n    }\n    return { node };\n  }\n};\nvar IvyTransformationVisitor = class extends Visitor {\n  constructor(compilation, classCompilationMap, reflector, importManager, recordWrappedNodeExpr, isClosureCompilerEnabled, isCore) {\n    super();\n    this.compilation = compilation;\n    this.classCompilationMap = classCompilationMap;\n    this.reflector = reflector;\n    this.importManager = importManager;\n    this.recordWrappedNodeExpr = recordWrappedNodeExpr;\n    this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n    this.isCore = isCore;\n  }\n  visitClassDeclaration(node) {\n    if (!this.classCompilationMap.has(node)) {\n      return { node };\n    }\n    const translateOptions = {\n      recordWrappedNode: this.recordWrappedNodeExpr,\n      annotateForClosureCompiler: this.isClosureCompilerEnabled\n    };\n    const statements = [];\n    const members = [...node.members];\n    for (const field of this.classCompilationMap.get(node)) {\n      if (field.initializer === null) {\n        continue;\n      }\n      const exprNode = translateExpression(field.initializer, this.importManager, translateOptions);\n      const property = ts19.factory.createPropertyDeclaration([ts19.factory.createToken(ts19.SyntaxKind.StaticKeyword)], field.name, void 0, void 0, exprNode);\n      if (this.isClosureCompilerEnabled) {\n        ts19.addSyntheticLeadingComment(\n          property,\n          ts19.SyntaxKind.MultiLineCommentTrivia,\n          \"* @nocollapse \",\n          false\n        );\n      }\n      field.statements.map((stmt) => translateStatement(stmt, this.importManager, translateOptions)).forEach((stmt) => statements.push(stmt));\n      members.push(property);\n    }\n    const filteredDecorators = maybeFilterDecorator(ts19.getDecorators(node), this.compilation.decoratorsFor(node));\n    const nodeModifiers = ts19.getModifiers(node);\n    let updatedModifiers;\n    if ((filteredDecorators == null ? void 0 : filteredDecorators.length) || (nodeModifiers == null ? void 0 : nodeModifiers.length)) {\n      updatedModifiers = [...filteredDecorators || [], ...nodeModifiers || []];\n    }\n    node = ts19.factory.updateClassDeclaration(\n      node,\n      updatedModifiers,\n      node.name,\n      node.typeParameters,\n      node.heritageClauses || [],\n      members.map((member) => this._stripAngularDecorators(member))\n    );\n    return { node, after: statements };\n  }\n  _angularCoreDecorators(decl) {\n    const decorators = this.reflector.getDecoratorsOfDeclaration(decl);\n    if (decorators === null) {\n      return NO_DECORATORS;\n    }\n    const coreDecorators = decorators.filter((dec) => this.isCore || isFromAngularCore(dec)).map((dec) => dec.node);\n    if (coreDecorators.length > 0) {\n      return new Set(coreDecorators);\n    } else {\n      return NO_DECORATORS;\n    }\n  }\n  _nonCoreDecoratorsOnly(node) {\n    const decorators = ts19.getDecorators(node);\n    if (decorators === void 0) {\n      return void 0;\n    }\n    const coreDecorators = this._angularCoreDecorators(node);\n    if (coreDecorators.size === decorators.length) {\n      return void 0;\n    } else if (coreDecorators.size === 0) {\n      return nodeArrayFromDecoratorsArray(decorators);\n    }\n    const filtered = decorators.filter((dec) => !coreDecorators.has(dec));\n    if (filtered.length === 0) {\n      return void 0;\n    }\n    return nodeArrayFromDecoratorsArray(filtered);\n  }\n  _stripAngularDecorators(node) {\n    const modifiers = ts19.canHaveModifiers(node) ? ts19.getModifiers(node) : void 0;\n    const nonCoreDecorators = ts19.canHaveDecorators(node) ? this._nonCoreDecoratorsOnly(node) : void 0;\n    const combinedModifiers = [...nonCoreDecorators || [], ...modifiers || []];\n    if (ts19.isParameter(node)) {\n      node = ts19.factory.updateParameterDeclaration(node, combinedModifiers, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer);\n    } else if (ts19.isMethodDeclaration(node)) {\n      node = ts19.factory.updateMethodDeclaration(node, combinedModifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);\n    } else if (ts19.isPropertyDeclaration(node)) {\n      node = ts19.factory.updatePropertyDeclaration(node, combinedModifiers, node.name, node.questionToken, node.type, node.initializer);\n    } else if (ts19.isGetAccessor(node)) {\n      node = ts19.factory.updateGetAccessorDeclaration(node, combinedModifiers, node.name, node.parameters, node.type, node.body);\n    } else if (ts19.isSetAccessor(node)) {\n      node = ts19.factory.updateSetAccessorDeclaration(node, combinedModifiers, node.name, node.parameters, node.body);\n    } else if (ts19.isConstructorDeclaration(node)) {\n      const parameters = node.parameters.map((param) => this._stripAngularDecorators(param));\n      node = ts19.factory.updateConstructorDeclaration(node, modifiers, parameters, node.body);\n    }\n    return node;\n  }\n};\nfunction transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode) {\n  const constantPool = new ConstantPool(isClosureCompilerEnabled);\n  const importManager = new ImportManager(importRewriter);\n  const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);\n  visit(file, compilationVisitor, context);\n  const transformationVisitor = new IvyTransformationVisitor(compilation, compilationVisitor.classCompilationMap, reflector, importManager, recordWrappedNode, isClosureCompilerEnabled, isCore);\n  let sf = visit(file, transformationVisitor, context);\n  const downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts19.ScriptTarget.ES2015;\n  const constants = constantPool.statements.map((stmt) => translateStatement(stmt, importManager, {\n    recordWrappedNode,\n    downlevelTaggedTemplates: downlevelTranslatedCode,\n    downlevelVariableDeclarations: downlevelTranslatedCode,\n    annotateForClosureCompiler: isClosureCompilerEnabled\n  }));\n  const fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null;\n  sf = addImports(importManager, sf, constants);\n  if (fileOverviewMeta !== null) {\n    setFileOverviewComment(sf, fileOverviewMeta);\n  }\n  return sf;\n}\nfunction getLocalizeCompileTarget(context) {\n  const target = context.getCompilerOptions().target || ts19.ScriptTarget.ES2015;\n  return target !== ts19.ScriptTarget.JSON ? target : ts19.ScriptTarget.ES2015;\n}\nfunction getFileOverviewComment(statements) {\n  if (statements.length > 0) {\n    const host = statements[0];\n    let trailing = false;\n    let comments = ts19.getSyntheticLeadingComments(host);\n    if (!comments || comments.length === 0) {\n      trailing = true;\n      comments = ts19.getSyntheticTrailingComments(host);\n    }\n    if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {\n      return { comments, host, trailing };\n    }\n  }\n  return null;\n}\nfunction setFileOverviewComment(sf, fileoverview) {\n  const { comments, host, trailing } = fileoverview;\n  if (sf.statements.length > 0 && host !== sf.statements[0]) {\n    if (trailing) {\n      ts19.setSyntheticTrailingComments(host, void 0);\n    } else {\n      ts19.setSyntheticLeadingComments(host, void 0);\n    }\n    ts19.setSyntheticLeadingComments(sf.statements[0], comments);\n  }\n}\nfunction maybeFilterDecorator(decorators, toRemove) {\n  if (decorators === void 0) {\n    return void 0;\n  }\n  const filtered = decorators.filter((dec) => toRemove.find((decToRemove) => ts19.getOriginalNode(dec) === decToRemove) === void 0);\n  if (filtered.length === 0) {\n    return void 0;\n  }\n  return ts19.factory.createNodeArray(filtered);\n}\nfunction isFromAngularCore(decorator) {\n  return decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\nfunction createRecorderFn(defaultImportTracker) {\n  return (node) => {\n    const importDecl = getDefaultImportDeclaration(node);\n    if (importDecl !== null) {\n      defaultImportTracker.recordUsedImport(importDecl);\n    }\n  };\n}\nfunction nodeArrayFromDecoratorsArray(decorators) {\n  const array = ts19.factory.createNodeArray(decorators);\n  if (array.length > 0) {\n    array.pos = decorators[0].pos;\n    array.end = decorators[decorators.length - 1].end;\n  }\n  return array;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/directive/src/handler.mjs\nimport { compileClassMetadata, compileDeclareClassMetadata, compileDeclareDirectiveFromMetadata, compileDirectiveFromMetadata, FactoryTarget, makeBindingParser, WrappedNodeExpr as WrappedNodeExpr5 } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/directive/src/shared.mjs\nimport { createMayBeForwardRefExpression, emitDistinctChangesOnlyDefaultValue, ExternalExpr as ExternalExpr4, getSafePropertyAccessString, parseHostBindings, verifyHostBindings, WrappedNodeExpr as WrappedNodeExpr4 } from \"@angular/compiler\";\nimport ts20 from \"typescript\";\nvar EMPTY_OBJECT = {};\nvar QUERY_TYPES = /* @__PURE__ */ new Set([\n  \"ContentChild\",\n  \"ContentChildren\",\n  \"ViewChild\",\n  \"ViewChildren\"\n]);\nfunction extractDirectiveMetadata(clazz, decorator, reflector, evaluator, refEmitter, referencesRegistry, isCore, flags, annotateForClosureCompiler, defaultSelector = null) {\n  let directive;\n  if (decorator === null || decorator.args === null || decorator.args.length === 0) {\n    directive = /* @__PURE__ */ new Map();\n  } else if (decorator.args.length !== 1) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @${decorator.name} decorator`);\n  } else {\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts20.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `@${decorator.name} argument must be an object literal`);\n    }\n    directive = reflectObjectLiteral(meta);\n  }\n  if (directive.has(\"jit\")) {\n    return void 0;\n  }\n  const members = reflector.getMembersOfClass(clazz);\n  const decoratedElements = members.filter((member) => !member.isStatic && member.decorators !== null);\n  const coreModule = isCore ? void 0 : \"@angular/core\";\n  const inputsFromMeta = parseInputsArray(clazz, directive, evaluator, reflector, refEmitter);\n  const inputsFromFields = parseInputFields(clazz, filterToMembersWithDecorator(decoratedElements, \"Input\", coreModule), evaluator, reflector, refEmitter);\n  const inputs = ClassPropertyMapping.fromMappedObject({ ...inputsFromMeta, ...inputsFromFields });\n  const outputsFromMeta = parseOutputsArray(directive, evaluator);\n  const outputsFromFields = parseOutputFields(filterToMembersWithDecorator(decoratedElements, \"Output\", coreModule), evaluator);\n  const outputs = ClassPropertyMapping.fromMappedObject({ ...outputsFromMeta, ...outputsFromFields });\n  const contentChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ContentChild\", coreModule), reflector, evaluator);\n  const contentChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ContentChildren\", coreModule), reflector, evaluator);\n  const queries = [...contentChildFromFields, ...contentChildrenFromFields];\n  const viewChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ViewChild\", coreModule), reflector, evaluator);\n  const viewChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ViewChildren\", coreModule), reflector, evaluator);\n  const viewQueries = [...viewChildFromFields, ...viewChildrenFromFields];\n  if (directive.has(\"queries\")) {\n    const queriesFromDecorator = extractQueriesFromDecorator(directive.get(\"queries\"), reflector, evaluator, isCore);\n    queries.push(...queriesFromDecorator.content);\n    viewQueries.push(...queriesFromDecorator.view);\n  }\n  let selector = defaultSelector;\n  if (directive.has(\"selector\")) {\n    const expr = directive.get(\"selector\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"string\") {\n      throw createValueHasWrongTypeError(expr, resolved, `selector must be a string`);\n    }\n    selector = resolved === \"\" ? defaultSelector : resolved;\n    if (!selector) {\n      throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr, `Directive ${clazz.name.text} has no selector, please add it!`);\n    }\n  }\n  const host = extractHostBindings(decoratedElements, evaluator, coreModule, directive);\n  const providers = directive.has(\"providers\") ? new WrappedNodeExpr4(annotateForClosureCompiler ? wrapFunctionExpressionsInParens(directive.get(\"providers\")) : directive.get(\"providers\")) : null;\n  const usesOnChanges = members.some((member) => !member.isStatic && member.kind === ClassMemberKind.Method && member.name === \"ngOnChanges\");\n  let exportAs = null;\n  if (directive.has(\"exportAs\")) {\n    const expr = directive.get(\"exportAs\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"string\") {\n      throw createValueHasWrongTypeError(expr, resolved, `exportAs must be a string`);\n    }\n    exportAs = resolved.split(\",\").map((part) => part.trim());\n  }\n  const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n  const ctorDeps = selector !== null ? validateConstructorDependencies(clazz, rawCtorDeps) : unwrapConstructorDependencies(rawCtorDeps);\n  const isStructural = ctorDeps !== null && ctorDeps !== \"invalid\" && ctorDeps.some((dep) => dep.token instanceof ExternalExpr4 && dep.token.value.moduleName === \"@angular/core\" && dep.token.value.name === \"TemplateRef\");\n  let isStandalone = false;\n  if (directive.has(\"standalone\")) {\n    const expr = directive.get(\"standalone\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"boolean\") {\n      throw createValueHasWrongTypeError(expr, resolved, `standalone flag must be a boolean`);\n    }\n    isStandalone = resolved;\n  }\n  let isSignal = false;\n  if (directive.has(\"signals\")) {\n    const expr = directive.get(\"signals\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"boolean\") {\n      throw createValueHasWrongTypeError(expr, resolved, `signals flag must be a boolean`);\n    }\n    isSignal = resolved;\n  }\n  const usesInheritance = reflector.hasBaseClass(clazz);\n  const sourceFile = clazz.getSourceFile();\n  const type = wrapTypeReference(reflector, clazz);\n  const rawHostDirectives = directive.get(\"hostDirectives\") || null;\n  const hostDirectives = rawHostDirectives === null ? null : extractHostDirectives(rawHostDirectives, evaluator);\n  if (hostDirectives !== null) {\n    referencesRegistry.add(clazz, ...hostDirectives.map((hostDir) => hostDir.directive));\n  }\n  const metadata = {\n    name: clazz.name.text,\n    deps: ctorDeps,\n    host,\n    lifecycle: {\n      usesOnChanges\n    },\n    inputs: inputs.toJointMappedObject(toR3InputMetadata),\n    outputs: outputs.toDirectMappedObject(),\n    queries,\n    viewQueries,\n    selector,\n    fullInheritance: !!(flags & HandlerFlags.FULL_INHERITANCE),\n    type,\n    typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,\n    typeSourceSpan: createSourceSpan(clazz.name),\n    usesInheritance,\n    exportAs,\n    providers,\n    isStandalone,\n    isSignal,\n    hostDirectives: (hostDirectives == null ? void 0 : hostDirectives.map((hostDir) => toHostDirectiveMetadata(hostDir, sourceFile, refEmitter))) || null\n  };\n  return {\n    decorator: directive,\n    metadata,\n    inputs,\n    outputs,\n    isStructural,\n    hostDirectives,\n    rawHostDirectives\n  };\n}\nfunction extractQueryMetadata(exprNode, name, args, propertyName, reflector, evaluator) {\n  if (args.length === 0) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, exprNode, `@${name} must have arguments`);\n  }\n  const first = name === \"ViewChild\" || name === \"ContentChild\";\n  const forwardReferenceTarget = tryUnwrapForwardRef(args[0], reflector);\n  const node = forwardReferenceTarget != null ? forwardReferenceTarget : args[0];\n  const arg = evaluator.evaluate(node);\n  let isStatic = false;\n  let predicate = null;\n  if (arg instanceof Reference || arg instanceof DynamicValue) {\n    predicate = createMayBeForwardRefExpression(new WrappedNodeExpr4(node), forwardReferenceTarget !== null ? 2 : 0);\n  } else if (typeof arg === \"string\") {\n    predicate = [arg];\n  } else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {\n    predicate = arg;\n  } else {\n    throw createValueHasWrongTypeError(node, arg, `@${name} predicate cannot be interpreted`);\n  }\n  let read = null;\n  let descendants = name !== \"ContentChildren\";\n  let emitDistinctChangesOnly = emitDistinctChangesOnlyDefaultValue;\n  if (args.length === 2) {\n    const optionsExpr = unwrapExpression(args[1]);\n    if (!ts20.isObjectLiteralExpression(optionsExpr)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr, `@${name} options must be an object literal`);\n    }\n    const options = reflectObjectLiteral(optionsExpr);\n    if (options.has(\"read\")) {\n      read = new WrappedNodeExpr4(options.get(\"read\"));\n    }\n    if (options.has(\"descendants\")) {\n      const descendantsExpr = options.get(\"descendants\");\n      const descendantsValue = evaluator.evaluate(descendantsExpr);\n      if (typeof descendantsValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(descendantsExpr, descendantsValue, `@${name} options.descendants must be a boolean`);\n      }\n      descendants = descendantsValue;\n    }\n    if (options.has(\"emitDistinctChangesOnly\")) {\n      const emitDistinctChangesOnlyExpr = options.get(\"emitDistinctChangesOnly\");\n      const emitDistinctChangesOnlyValue = evaluator.evaluate(emitDistinctChangesOnlyExpr);\n      if (typeof emitDistinctChangesOnlyValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(emitDistinctChangesOnlyExpr, emitDistinctChangesOnlyValue, `@${name} options.emitDistinctChangesOnly must be a boolean`);\n      }\n      emitDistinctChangesOnly = emitDistinctChangesOnlyValue;\n    }\n    if (options.has(\"static\")) {\n      const staticValue = evaluator.evaluate(options.get(\"static\"));\n      if (typeof staticValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(node, staticValue, `@${name} options.static must be a boolean`);\n      }\n      isStatic = staticValue;\n    }\n  } else if (args.length > 2) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, node, `@${name} has too many arguments`);\n  }\n  return {\n    propertyName,\n    predicate,\n    first,\n    descendants,\n    read,\n    static: isStatic,\n    emitDistinctChangesOnly\n  };\n}\nfunction extractHostBindings(members, evaluator, coreModule, metadata) {\n  let bindings;\n  if (metadata && metadata.has(\"host\")) {\n    bindings = evaluateHostExpressionBindings(metadata.get(\"host\"), evaluator);\n  } else {\n    bindings = parseHostBindings({});\n  }\n  filterToMembersWithDecorator(members, \"HostBinding\", coreModule).forEach(({ member, decorators }) => {\n    decorators.forEach((decorator) => {\n      let hostPropertyName = member.name;\n      if (decorator.args !== null && decorator.args.length > 0) {\n        if (decorator.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `@HostBinding can have at most one argument, got ${decorator.args.length} argument(s)`);\n        }\n        const resolved = evaluator.evaluate(decorator.args[0]);\n        if (typeof resolved !== \"string\") {\n          throw createValueHasWrongTypeError(decorator.node, resolved, `@HostBinding's argument must be a string`);\n        }\n        hostPropertyName = resolved;\n      }\n      bindings.properties[hostPropertyName] = getSafePropertyAccessString(\"this\", member.name);\n    });\n  });\n  filterToMembersWithDecorator(members, \"HostListener\", coreModule).forEach(({ member, decorators }) => {\n    decorators.forEach((decorator) => {\n      let eventName = member.name;\n      let args = [];\n      if (decorator.args !== null && decorator.args.length > 0) {\n        if (decorator.args.length > 2) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], `@HostListener can have at most two arguments`);\n        }\n        const resolved = evaluator.evaluate(decorator.args[0]);\n        if (typeof resolved !== \"string\") {\n          throw createValueHasWrongTypeError(decorator.args[0], resolved, `@HostListener's event name argument must be a string`);\n        }\n        eventName = resolved;\n        if (decorator.args.length === 2) {\n          const expression = decorator.args[1];\n          const resolvedArgs = evaluator.evaluate(decorator.args[1]);\n          if (!isStringArrayOrDie(resolvedArgs, \"@HostListener.args\", expression)) {\n            throw createValueHasWrongTypeError(decorator.args[1], resolvedArgs, `@HostListener's second argument must be a string array`);\n          }\n          args = resolvedArgs;\n        }\n      }\n      bindings.listeners[eventName] = `${member.name}(${args.join(\",\")})`;\n    });\n  });\n  return bindings;\n}\nfunction extractQueriesFromDecorator(queryData, reflector, evaluator, isCore) {\n  const content = [], view = [];\n  if (!ts20.isObjectLiteralExpression(queryData)) {\n    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator queries metadata must be an object literal\");\n  }\n  reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {\n    queryExpr = unwrapExpression(queryExpr);\n    if (!ts20.isNewExpression(queryExpr)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n    const queryType = ts20.isPropertyAccessExpression(queryExpr.expression) ? queryExpr.expression.name : queryExpr.expression;\n    if (!ts20.isIdentifier(queryType)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n    const type = reflector.getImportOfIdentifier(queryType);\n    if (type === null || !isCore && type.from !== \"@angular/core\" || !QUERY_TYPES.has(type.name)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n    const query = extractQueryMetadata(queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);\n    if (type.name.startsWith(\"Content\")) {\n      content.push(query);\n    } else {\n      view.push(query);\n    }\n  });\n  return { content, view };\n}\nfunction parseFieldStringArrayValue(directive, field, evaluator) {\n  if (!directive.has(field)) {\n    return null;\n  }\n  const expression = directive.get(field);\n  const value = evaluator.evaluate(expression);\n  if (!isStringArrayOrDie(value, field, expression)) {\n    throw createValueHasWrongTypeError(expression, value, `Failed to resolve @Directive.${field} to a string array`);\n  }\n  return value;\n}\nfunction isStringArrayOrDie(value, name, node) {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  for (let i = 0; i < value.length; i++) {\n    if (typeof value[i] !== \"string\") {\n      throw createValueHasWrongTypeError(node, value[i], `Failed to resolve ${name} at position ${i} to a string`);\n    }\n  }\n  return true;\n}\nfunction queriesFromFields(fields, reflector, evaluator) {\n  return fields.map(({ member, decorators }) => {\n    const decorator = decorators[0];\n    const node = member.node || decorator.node;\n    if (member.decorators.some((v) => v.name === \"Input\")) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, \"Cannot combine @Input decorators with query decorators\");\n    }\n    if (decorators.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, \"Cannot have multiple query decorators on the same class member\");\n    } else if (!isPropertyTypeMember(member)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, node, \"Query decorator must go on a property-type member\");\n    }\n    return extractQueryMetadata(node, decorator.name, decorator.args || [], member.name, reflector, evaluator);\n  });\n}\nfunction isPropertyTypeMember(member) {\n  return member.kind === ClassMemberKind.Getter || member.kind === ClassMemberKind.Setter || member.kind === ClassMemberKind.Property;\n}\nfunction parseMappingStringArray(values) {\n  return values.reduce((results, value) => {\n    if (typeof value !== \"string\") {\n      throw new Error(\"Mapping value must be a string\");\n    }\n    const [bindingPropertyName, fieldName] = parseMappingString(value);\n    results[fieldName] = bindingPropertyName;\n    return results;\n  }, {});\n}\nfunction parseMappingString(value) {\n  const [fieldName, bindingPropertyName] = value.split(\":\", 2).map((str) => str.trim());\n  return [bindingPropertyName != null ? bindingPropertyName : fieldName, fieldName];\n}\nfunction parseDecoratedFields(fields, evaluator, callback) {\n  for (const field of fields) {\n    const fieldName = field.member.name;\n    for (const decorator of field.decorators) {\n      if (decorator.args != null && decorator.args.length > 1) {\n        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `@${decorator.name} can have at most one argument, got ${decorator.args.length} argument(s)`);\n      }\n      const value = decorator.args != null && decorator.args.length > 0 ? evaluator.evaluate(decorator.args[0]) : null;\n      callback(fieldName, value, decorator);\n    }\n  }\n}\nfunction parseInputsArray(clazz, decoratorMetadata, evaluator, reflector, refEmitter) {\n  const inputsField = decoratorMetadata.get(\"inputs\");\n  if (inputsField === void 0) {\n    return {};\n  }\n  const inputs = {};\n  const inputsArray = evaluator.evaluate(inputsField);\n  if (!Array.isArray(inputsArray)) {\n    throw createValueHasWrongTypeError(inputsField, inputsArray, `Failed to resolve @Directive.inputs to an array`);\n  }\n  for (let i = 0; i < inputsArray.length; i++) {\n    const value = inputsArray[i];\n    if (typeof value === \"string\") {\n      const [bindingPropertyName, classPropertyName] = parseMappingString(value);\n      inputs[classPropertyName] = {\n        bindingPropertyName,\n        classPropertyName,\n        required: false,\n        transform: null\n      };\n    } else if (value instanceof Map) {\n      const name = value.get(\"name\");\n      const alias = value.get(\"alias\");\n      const required = value.get(\"required\");\n      let transform = null;\n      if (typeof name !== \"string\") {\n        throw createValueHasWrongTypeError(inputsField, name, `Value at position ${i} of @Directive.inputs array must have a \"name\" property`);\n      }\n      if (value.has(\"transform\")) {\n        const transformValue = value.get(\"transform\");\n        if (!(transformValue instanceof DynamicValue) && !(transformValue instanceof Reference)) {\n          throw createValueHasWrongTypeError(inputsField, transformValue, `Transform of value at position ${i} of @Directive.inputs array must be a function`);\n        }\n        transform = parseInputTransformFunction(clazz, name, transformValue, reflector, refEmitter);\n      }\n      inputs[name] = {\n        classPropertyName: name,\n        bindingPropertyName: typeof alias === \"string\" ? alias : name,\n        required: required === true,\n        transform\n      };\n    } else {\n      throw createValueHasWrongTypeError(inputsField, value, `@Directive.inputs array can only contain strings or object literals`);\n    }\n  }\n  return inputs;\n}\nfunction parseInputFields(clazz, inputMembers, evaluator, reflector, refEmitter) {\n  const inputs = {};\n  parseDecoratedFields(inputMembers, evaluator, (classPropertyName, options, decorator) => {\n    let bindingPropertyName;\n    let required = false;\n    let transform = null;\n    if (options === null) {\n      bindingPropertyName = classPropertyName;\n    } else if (typeof options === \"string\") {\n      bindingPropertyName = options;\n    } else if (options instanceof Map) {\n      const aliasInConfig = options.get(\"alias\");\n      bindingPropertyName = typeof aliasInConfig === \"string\" ? aliasInConfig : classPropertyName;\n      required = options.get(\"required\") === true;\n      if (options.has(\"transform\")) {\n        const transformValue = options.get(\"transform\");\n        if (!(transformValue instanceof DynamicValue) && !(transformValue instanceof Reference)) {\n          throw createValueHasWrongTypeError(decorator.node, transformValue, `Input transform must be a function`);\n        }\n        transform = parseInputTransformFunction(clazz, classPropertyName, transformValue, reflector, refEmitter);\n      }\n    } else {\n      throw createValueHasWrongTypeError(decorator.node, options, `@${decorator.name} decorator argument must resolve to a string or an object literal`);\n    }\n    inputs[classPropertyName] = { bindingPropertyName, classPropertyName, required, transform };\n  });\n  return inputs;\n}\nfunction parseInputTransformFunction(clazz, classPropertyName, value, reflector, refEmitter) {\n  var _a;\n  const definition = reflector.getDefinitionOfFunction(value.node);\n  if (definition === null) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform must be a function\");\n  }\n  if (definition.typeParameters !== null && definition.typeParameters.length > 0) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function cannot be generic\");\n  }\n  if (definition.signatureCount > 1) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function cannot have multiple signatures\");\n  }\n  const members = reflector.getMembersOfClass(clazz);\n  for (const member of members) {\n    const conflictingName = `ngAcceptInputType_${classPropertyName}`;\n    if (member.name === conflictingName && member.isStatic) {\n      throw new FatalDiagnosticError(ErrorCode.CONFLICTING_INPUT_TRANSFORM, value.node, `Class cannot have both a transform function on Input ${classPropertyName} and a static member called ${conflictingName}`);\n    }\n  }\n  const node = value instanceof Reference ? value.getIdentityIn(clazz.getSourceFile()) : value.node;\n  if (node === null) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function could not be referenced\");\n  }\n  const firstParam = ((_a = definition.parameters[0]) == null ? void 0 : _a.name) === \"this\" ? definition.parameters[1] : definition.parameters[0];\n  if (!firstParam) {\n    return { node, type: ts20.factory.createKeywordTypeNode(ts20.SyntaxKind.UnknownKeyword) };\n  }\n  if (!firstParam.type) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function first parameter must have a type\");\n  }\n  if (firstParam.node.dotDotDotToken) {\n    throw createValueHasWrongTypeError(value.node, value, \"Input transform function first parameter cannot be a spread parameter\");\n  }\n  assertEmittableInputType(firstParam.type, clazz.getSourceFile(), reflector, refEmitter);\n  return { node, type: firstParam.type };\n}\nfunction assertEmittableInputType(type, contextFile, reflector, refEmitter) {\n  (function walk(node) {\n    if (ts20.isTypeReferenceNode(node) && ts20.isIdentifier(node.typeName)) {\n      const declaration = reflector.getDeclarationOfIdentifier(node.typeName);\n      if (declaration !== null) {\n        if (declaration.node.getSourceFile() !== contextFile) {\n          const emittedType = refEmitter.emit(new Reference(declaration.node), contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports);\n          assertSuccessfulReferenceEmit(emittedType, node, \"type\");\n        } else if (!reflector.isStaticallyExported(declaration.node)) {\n          throw new FatalDiagnosticError(ErrorCode.SYMBOL_NOT_EXPORTED, type, `Symbol must be exported in order to be used as the type of an Input transform function`, [makeRelatedInformation(declaration.node, `The symbol is declared here.`)]);\n        }\n      }\n    }\n    node.forEachChild(walk);\n  })(type);\n}\nfunction parseOutputsArray(directive, evaluator) {\n  const metaValues = parseFieldStringArrayValue(directive, \"outputs\", evaluator);\n  return metaValues ? parseMappingStringArray(metaValues) : EMPTY_OBJECT;\n}\nfunction parseOutputFields(outputMembers, evaluator) {\n  const outputs = {};\n  parseDecoratedFields(outputMembers, evaluator, (fieldName, bindingPropertyName, decorator) => {\n    if (bindingPropertyName != null && typeof bindingPropertyName !== \"string\") {\n      throw createValueHasWrongTypeError(decorator.node, bindingPropertyName, `@${decorator.name} decorator argument must resolve to a string`);\n    }\n    outputs[fieldName] = bindingPropertyName != null ? bindingPropertyName : fieldName;\n  });\n  return outputs;\n}\nfunction evaluateHostExpressionBindings(hostExpr, evaluator) {\n  const hostMetaMap = evaluator.evaluate(hostExpr);\n  if (!(hostMetaMap instanceof Map)) {\n    throw createValueHasWrongTypeError(hostExpr, hostMetaMap, `Decorator host metadata must be an object`);\n  }\n  const hostMetadata = {};\n  hostMetaMap.forEach((value, key) => {\n    if (value instanceof EnumValue) {\n      value = value.resolved;\n    }\n    if (typeof key !== \"string\") {\n      throw createValueHasWrongTypeError(hostExpr, key, `Decorator host metadata must be a string -> string object, but found unparseable key`);\n    }\n    if (typeof value == \"string\") {\n      hostMetadata[key] = value;\n    } else if (value instanceof DynamicValue) {\n      hostMetadata[key] = new WrappedNodeExpr4(value.node);\n    } else {\n      throw createValueHasWrongTypeError(hostExpr, value, `Decorator host metadata must be a string -> string object, but found unparseable value`);\n    }\n  });\n  const bindings = parseHostBindings(hostMetadata);\n  const errors = verifyHostBindings(bindings, createSourceSpan(hostExpr));\n  if (errors.length > 0) {\n    throw new FatalDiagnosticError(\n      ErrorCode.HOST_BINDING_PARSE_ERROR,\n      hostExpr,\n      errors.map((error) => error.msg).join(\"\\n\")\n    );\n  }\n  return bindings;\n}\nfunction extractHostDirectives(rawHostDirectives, evaluator) {\n  const resolved = evaluator.evaluate(rawHostDirectives, forwardRefResolver);\n  if (!Array.isArray(resolved)) {\n    throw createValueHasWrongTypeError(rawHostDirectives, resolved, \"hostDirectives must be an array\");\n  }\n  return resolved.map((value) => {\n    const hostReference = value instanceof Map ? value.get(\"directive\") : value;\n    if (!(hostReference instanceof Reference)) {\n      throw createValueHasWrongTypeError(rawHostDirectives, hostReference, \"Host directive must be a reference\");\n    }\n    if (!isNamedClassDeclaration(hostReference.node)) {\n      throw createValueHasWrongTypeError(rawHostDirectives, hostReference, \"Host directive reference must be a class\");\n    }\n    const meta = {\n      directive: hostReference,\n      isForwardReference: hostReference.synthetic,\n      inputs: parseHostDirectivesMapping(\"inputs\", value, hostReference.node, rawHostDirectives),\n      outputs: parseHostDirectivesMapping(\"outputs\", value, hostReference.node, rawHostDirectives)\n    };\n    return meta;\n  });\n}\nfunction parseHostDirectivesMapping(field, resolvedValue, classReference, sourceExpression) {\n  if (resolvedValue instanceof Map && resolvedValue.has(field)) {\n    const nameForErrors = `@Directive.hostDirectives.${classReference.name.text}.${field}`;\n    const rawInputs = resolvedValue.get(field);\n    if (isStringArrayOrDie(rawInputs, nameForErrors, sourceExpression)) {\n      return parseMappingStringArray(rawInputs);\n    }\n  }\n  return null;\n}\nfunction toHostDirectiveMetadata(hostDirective, context, refEmitter) {\n  return {\n    directive: toR3Reference(hostDirective.directive.node, hostDirective.directive, context, refEmitter),\n    isForwardReference: hostDirective.isForwardReference,\n    inputs: hostDirective.inputs || null,\n    outputs: hostDirective.outputs || null\n  };\n}\nfunction toR3InputMetadata(mapping) {\n  return {\n    classPropertyName: mapping.classPropertyName,\n    bindingPropertyName: mapping.bindingPropertyName,\n    required: mapping.required,\n    transformFunction: mapping.transform !== null ? new WrappedNodeExpr4(mapping.transform.node) : null\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/directive/src/symbol.mjs\nvar DirectiveSymbol = class extends SemanticSymbol {\n  constructor(decl, selector, inputs, outputs, exportAs, typeCheckMeta, typeParameters) {\n    super(decl);\n    this.selector = selector;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.exportAs = exportAs;\n    this.typeCheckMeta = typeCheckMeta;\n    this.typeParameters = typeParameters;\n    this.baseClass = null;\n  }\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n    return this.selector !== previousSymbol.selector || !isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) || !isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) || !isArrayEqual(this.exportAs, previousSymbol.exportAs);\n  }\n  isTypeCheckApiAffected(previousSymbol) {\n    if (this.isPublicApiAffected(previousSymbol)) {\n      return true;\n    }\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n    if (!isArrayEqual(Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) || !isArrayEqual(Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputOrOutputEqual)) {\n      return true;\n    }\n    if (!areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {\n      return true;\n    }\n    if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {\n      return true;\n    }\n    if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {\n      return true;\n    }\n    return false;\n  }\n};\nfunction isInputMappingEqual(current, previous) {\n  return isInputOrOutputEqual(current, previous) && current.required === previous.required;\n}\nfunction isInputOrOutputEqual(current, previous) {\n  return current.classPropertyName === previous.classPropertyName && current.bindingPropertyName === previous.bindingPropertyName;\n}\nfunction isTypeCheckMetaEqual(current, previous) {\n  if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {\n    return false;\n  }\n  if (current.isGeneric !== previous.isGeneric) {\n    return false;\n  }\n  if (!isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {\n    return false;\n  }\n  if (!isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {\n    return false;\n  }\n  return true;\n}\nfunction isTemplateGuardEqual(current, previous) {\n  return current.inputName === previous.inputName && current.type === previous.type;\n}\nfunction isBaseClassEqual(current, previous) {\n  if (current === null || previous === null) {\n    return current === previous;\n  }\n  return isSymbolEqual(current, previous);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/directive/src/handler.mjs\nvar FIELD_DECORATORS = [\n  \"Input\",\n  \"Output\",\n  \"ViewChild\",\n  \"ViewChildren\",\n  \"ContentChild\",\n  \"ContentChildren\",\n  \"HostBinding\",\n  \"HostListener\"\n];\nvar LIFECYCLE_HOOKS = /* @__PURE__ */ new Set([\n  \"ngOnChanges\",\n  \"ngOnInit\",\n  \"ngOnDestroy\",\n  \"ngDoCheck\",\n  \"ngAfterViewInit\",\n  \"ngAfterViewChecked\",\n  \"ngAfterContentInit\",\n  \"ngAfterContentChecked\"\n]);\nvar DirectiveDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, injectableRegistry, refEmitter, referencesRegistry, isCore, strictCtorDeps, semanticDepGraphUpdater, annotateForClosureCompiler, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.metaReader = metaReader;\n    this.injectableRegistry = injectableRegistry;\n    this.refEmitter = refEmitter;\n    this.referencesRegistry = referencesRegistry;\n    this.isCore = isCore;\n    this.strictCtorDeps = strictCtorDeps;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = \"DirectiveDecoratorHandler\";\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      const angularField = this.findClassFieldWithAngularFeatures(node);\n      return angularField ? { trigger: angularField.node, decorator: null, metadata: null } : void 0;\n    } else {\n      const decorator = findAngularDecorator(decorators, \"Directive\", this.isCore);\n      return decorator ? { trigger: decorator.node, decorator, metadata: decorator } : void 0;\n    }\n  }\n  analyze(node, decorator, flags = HandlerFlags.NONE) {\n    var _a;\n    if (decorator === null) {\n      if (this.isCore) {\n        return {};\n      }\n      return { diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)] };\n    }\n    this.perf.eventCount(PerfEvent.AnalyzeDirective);\n    const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.refEmitter, this.referencesRegistry, this.isCore, flags, this.annotateForClosureCompiler);\n    if (directiveResult === void 0) {\n      return {};\n    }\n    const analysis = directiveResult.metadata;\n    let providersRequiringFactory = null;\n    if (directiveResult !== void 0 && directiveResult.decorator.has(\"providers\")) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(directiveResult.decorator.get(\"providers\"), this.reflector, this.evaluator);\n    }\n    return {\n      analysis: {\n        inputs: directiveResult.inputs,\n        outputs: directiveResult.outputs,\n        meta: analysis,\n        hostDirectives: directiveResult.hostDirectives,\n        rawHostDirectives: directiveResult.rawHostDirectives,\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),\n        providersRequiringFactory,\n        isPoisoned: false,\n        isStructural: directiveResult.isStructural,\n        decorator: (_a = decorator == null ? void 0 : decorator.node) != null ? _a : null\n      }\n    };\n  }\n  symbol(node, analysis) {\n    const typeParameters = extractSemanticTypeParameters(node);\n    return new DirectiveSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n  }\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata({\n      kind: MetaKind.Directive,\n      matchSource: MatchSource.Selector,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map((query) => query.propertyName),\n      isComponent: false,\n      baseClass: analysis.baseClass,\n      hostDirectives: analysis.hostDirectives,\n      ...analysis.typeCheckMeta,\n      isPoisoned: analysis.isPoisoned,\n      isStructural: analysis.isStructural,\n      animationTriggerNames: null,\n      isStandalone: analysis.meta.isStandalone,\n      isSignal: analysis.meta.isSignal,\n      imports: null,\n      schemas: null,\n      decorator: analysis.decorator,\n      assumedToExportProviders: false\n    });\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.meta.deps\n    });\n  }\n  resolve(node, analysis, symbol) {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n    const diagnostics = [];\n    if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof WrappedNodeExpr5) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n    const directiveDiagnostics = getDirectiveDiagnostics(node, this.injectableRegistry, this.evaluator, this.reflector, this.scopeRegistry, this.strictCtorDeps, \"Directive\");\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n    const hostDirectivesDiagnotics = analysis.hostDirectives && analysis.rawHostDirectives ? validateHostDirectives(analysis.rawHostDirectives, analysis.hostDirectives, this.metaReader) : null;\n    if (hostDirectivesDiagnotics !== null) {\n      diagnostics.push(...hostDirectivesDiagnotics);\n    }\n    return { diagnostics: diagnostics.length > 0 ? diagnostics : void 0 };\n  }\n  compileFull(node, analysis, resolution, pool) {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDirectiveFromMetadata(analysis.meta, pool, makeBindingParser());\n    const inputTransformFields = compileInputTransformFields(analysis.inputs);\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275dir\", inputTransformFields);\n  }\n  compilePartial(node, analysis, resolution) {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDeclareDirectiveFromMetadata(analysis.meta);\n    const inputTransformFields = compileInputTransformFields(analysis.inputs);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275dir\", inputTransformFields);\n  }\n  findClassFieldWithAngularFeatures(node) {\n    return this.reflector.getMembersOfClass(node).find((member) => {\n      if (!member.isStatic && member.kind === ClassMemberKind.Method && LIFECYCLE_HOOKS.has(member.name)) {\n        return true;\n      }\n      if (member.decorators) {\n        return member.decorators.some((decorator) => FIELD_DECORATORS.some((decoratorName) => isAngularDecorator(decorator, decoratorName, this.isCore)));\n      }\n      return false;\n    });\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/ng_module/src/handler.mjs\nimport { compileClassMetadata as compileClassMetadata2, compileDeclareClassMetadata as compileDeclareClassMetadata2, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileInjector, compileNgModule, ExternalExpr as ExternalExpr5, FactoryTarget as FactoryTarget2, FunctionExpr as FunctionExpr2, InvokeFunctionExpr, LiteralArrayExpr as LiteralArrayExpr2, R3Identifiers, R3SelectorScopeMode, ReturnStatement as ReturnStatement2, WrappedNodeExpr as WrappedNodeExpr6 } from \"@angular/compiler\";\nimport ts22 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/ng_module/src/module_with_providers.mjs\nimport ts21 from \"typescript\";\nfunction createModuleWithProvidersResolver(reflector, isCore) {\n  function _reflectModuleFromTypeParam(type, node) {\n    if (!ts21.isTypeReferenceNode(type)) {\n      return null;\n    }\n    const typeName = type && (ts21.isIdentifier(type.typeName) && type.typeName || ts21.isQualifiedName(type.typeName) && type.typeName.right) || null;\n    if (typeName === null) {\n      return null;\n    }\n    const id = reflector.getImportOfIdentifier(typeName);\n    if (id === null || id.name !== \"ModuleWithProviders\") {\n      return null;\n    }\n    if (!isCore && id.from !== \"@angular/core\") {\n      return null;\n    }\n    if (type.typeArguments === void 0 || type.typeArguments.length !== 1) {\n      const parent = ts21.isMethodDeclaration(node) && ts21.isClassDeclaration(node.parent) ? node.parent : null;\n      const symbolName = (parent && parent.name ? parent.name.getText() + \".\" : \"\") + (node.name ? node.name.getText() : \"anonymous\");\n      throw new FatalDiagnosticError(ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type, `${symbolName} returns a ModuleWithProviders type without a generic type argument. Please add a generic type argument to the ModuleWithProviders type. If this occurrence is in library code you don't control, please contact the library authors.`);\n    }\n    const arg = type.typeArguments[0];\n    return typeNodeToValueExpr(arg);\n  }\n  function _reflectModuleFromLiteralType(type) {\n    if (!ts21.isIntersectionTypeNode(type)) {\n      return null;\n    }\n    for (const t of type.types) {\n      if (ts21.isTypeLiteralNode(t)) {\n        for (const m of t.members) {\n          const ngModuleType = ts21.isPropertySignature(m) && ts21.isIdentifier(m.name) && m.name.text === \"ngModule\" && m.type || null;\n          const ngModuleExpression = ngModuleType && typeNodeToValueExpr(ngModuleType);\n          if (ngModuleExpression) {\n            return ngModuleExpression;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  return (fn, callExpr, resolve, unresolvable) => {\n    var _a;\n    const rawType = fn.node.type;\n    if (rawType === void 0) {\n      return unresolvable;\n    }\n    const type = (_a = _reflectModuleFromTypeParam(rawType, fn.node)) != null ? _a : _reflectModuleFromLiteralType(rawType);\n    if (type === null) {\n      return unresolvable;\n    }\n    const ngModule = resolve(type);\n    if (!(ngModule instanceof Reference) || !isNamedClassDeclaration(ngModule.node)) {\n      return unresolvable;\n    }\n    return new SyntheticValue({\n      ngModule,\n      mwpCall: callExpr\n    });\n  };\n}\nfunction isResolvedModuleWithProviders(sv) {\n  return typeof sv.value === \"object\" && sv.value != null && sv.value.hasOwnProperty(\"ngModule\") && sv.value.hasOwnProperty(\"mwpCall\");\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/ng_module/src/handler.mjs\nvar NgModuleSymbol = class extends SemanticSymbol {\n  constructor(decl, hasProviders) {\n    super(decl);\n    this.hasProviders = hasProviders;\n    this.remotelyScopedComponents = [];\n    this.transitiveImportsFromStandaloneComponents = /* @__PURE__ */ new Set();\n  }\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n    if (previousSymbol.hasProviders !== this.hasProviders) {\n      return true;\n    }\n    return false;\n  }\n  isEmitAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n    if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {\n      return true;\n    }\n    for (const currEntry of this.remotelyScopedComponents) {\n      const prevEntry = previousSymbol.remotelyScopedComponents.find((prevEntry2) => {\n        return isSymbolEqual(prevEntry2.component, currEntry.component);\n      });\n      if (prevEntry === void 0) {\n        return true;\n      }\n      if (!isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, isReferenceEqual)) {\n        return true;\n      }\n      if (!isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, isReferenceEqual)) {\n        return true;\n      }\n    }\n    if (previousSymbol.transitiveImportsFromStandaloneComponents.size !== this.transitiveImportsFromStandaloneComponents.size) {\n      return true;\n    }\n    const previousImports = Array.from(previousSymbol.transitiveImportsFromStandaloneComponents);\n    for (const transitiveImport of this.transitiveImportsFromStandaloneComponents) {\n      const prevEntry = previousImports.find((prevEntry2) => isSymbolEqual(prevEntry2, transitiveImport));\n      if (prevEntry === void 0) {\n        return true;\n      }\n      if (transitiveImport.isPublicApiAffected(prevEntry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isTypeCheckApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n    return false;\n  }\n  addRemotelyScopedComponent(component, usedDirectives, usedPipes) {\n    this.remotelyScopedComponents.push({ component, usedDirectives, usedPipes });\n  }\n  addTransitiveImportFromStandaloneComponent(importedSymbol) {\n    this.transitiveImportsFromStandaloneComponents.add(importedSymbol);\n  }\n};\nvar NgModuleDecoratorHandler = class {\n  constructor(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, exportedProviderStatusResolver, semanticDepGraphUpdater, isCore, refEmitter, annotateForClosureCompiler, onlyPublishPublicTypings, injectableRegistry, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaReader = metaReader;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.referencesRegistry = referencesRegistry;\n    this.exportedProviderStatusResolver = exportedProviderStatusResolver;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.isCore = isCore;\n    this.refEmitter = refEmitter;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.onlyPublishPublicTypings = onlyPublishPublicTypings;\n    this.injectableRegistry = injectableRegistry;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = \"NgModuleDecoratorHandler\";\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"NgModule\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  analyze(node, decorator) {\n    var _a;\n    this.perf.eventCount(PerfEvent.AnalyzeNgModule);\n    const name = node.name.text;\n    if (decorator.args === null || decorator.args.length > 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @NgModule decorator`);\n    }\n    const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) : ts22.factory.createObjectLiteralExpression([]);\n    if (!ts22.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"@NgModule argument must be an object literal\");\n    }\n    const ngModule = reflectObjectLiteral(meta);\n    if (ngModule.has(\"jit\")) {\n      return {};\n    }\n    const moduleResolvers = combineResolvers([\n      createModuleWithProvidersResolver(this.reflector, this.isCore),\n      forwardRefResolver\n    ]);\n    const diagnostics = [];\n    let declarationRefs = [];\n    let rawDeclarations = null;\n    if (ngModule.has(\"declarations\")) {\n      rawDeclarations = ngModule.get(\"declarations\");\n      const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver);\n      declarationRefs = this.resolveTypeList(rawDeclarations, declarationMeta, name, \"declarations\", 0).references;\n      for (const ref of declarationRefs) {\n        if (ref.node.getSourceFile().isDeclarationFile) {\n          const errorNode = ref.getOriginForDiagnostics(rawDeclarations);\n          diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `Cannot declare '${ref.node.name.text}' in an NgModule as it's not a part of the current compilation.`, [makeRelatedInformation(ref.node.name, `'${ref.node.name.text}' is declared here.`)]));\n        }\n      }\n    }\n    if (diagnostics.length > 0) {\n      return { diagnostics };\n    }\n    let importRefs = [];\n    let rawImports = null;\n    if (ngModule.has(\"imports\")) {\n      rawImports = ngModule.get(\"imports\");\n      const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);\n      importRefs = this.resolveTypeList(rawImports, importsMeta, name, \"imports\", 0).references;\n    }\n    let exportRefs = [];\n    let rawExports = null;\n    if (ngModule.has(\"exports\")) {\n      rawExports = ngModule.get(\"exports\");\n      const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);\n      exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, \"exports\", 0).references;\n      this.referencesRegistry.add(node, ...exportRefs);\n    }\n    let bootstrapRefs = [];\n    if (ngModule.has(\"bootstrap\")) {\n      const expr = ngModule.get(\"bootstrap\");\n      const bootstrapMeta = this.evaluator.evaluate(expr, forwardRefResolver);\n      bootstrapRefs = this.resolveTypeList(expr, bootstrapMeta, name, \"bootstrap\", 0).references;\n      for (const ref of bootstrapRefs) {\n        const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n        if (dirMeta == null ? void 0 : dirMeta.isStandalone) {\n          diagnostics.push(makeStandaloneBootstrapDiagnostic(node, ref, expr));\n        }\n      }\n    }\n    const schemas = ngModule.has(\"schemas\") ? extractSchemas(ngModule.get(\"schemas\"), this.evaluator, \"NgModule\") : [];\n    let id = null;\n    if (ngModule.has(\"id\")) {\n      const idExpr = ngModule.get(\"id\");\n      if (!isModuleIdExpression(idExpr)) {\n        id = new WrappedNodeExpr6(idExpr);\n      } else {\n        const diag = makeDiagnostic(ErrorCode.WARN_NGMODULE_ID_UNNECESSARY, idExpr, `Using 'module.id' for NgModule.id is a common anti-pattern that is ignored by the Angular compiler.`);\n        diag.category = ts22.DiagnosticCategory.Warning;\n        diagnostics.push(diag);\n      }\n    }\n    const valueContext = node.getSourceFile();\n    const exportedNodes = new Set(exportRefs.map((ref) => ref.node));\n    const declarations = [];\n    const exportedDeclarations = [];\n    const bootstrap = bootstrapRefs.map((bootstrap2) => this._toR3Reference(bootstrap2.getOriginForDiagnostics(meta, node.name), bootstrap2, valueContext));\n    for (const ref of declarationRefs) {\n      const decl = this._toR3Reference(ref.getOriginForDiagnostics(meta, node.name), ref, valueContext);\n      declarations.push(decl);\n      if (exportedNodes.has(ref.node)) {\n        exportedDeclarations.push(decl.type);\n      }\n    }\n    const imports = importRefs.map((imp) => this._toR3Reference(imp.getOriginForDiagnostics(meta, node.name), imp, valueContext));\n    const exports = exportRefs.map((exp) => this._toR3Reference(exp.getOriginForDiagnostics(meta, node.name), exp, valueContext));\n    const isForwardReference = (ref) => isExpressionForwardReference(ref.value, node.name, valueContext);\n    const containsForwardDecls = bootstrap.some(isForwardReference) || declarations.some(isForwardReference) || imports.some(isForwardReference) || exports.some(isForwardReference);\n    const type = wrapTypeReference(this.reflector, node);\n    const ngModuleMetadata = {\n      type,\n      bootstrap,\n      declarations,\n      publicDeclarationTypes: this.onlyPublishPublicTypings ? exportedDeclarations : null,\n      exports,\n      imports,\n      includeImportTypes: !this.onlyPublishPublicTypings,\n      containsForwardDecls,\n      id,\n      selectorScopeMode: R3SelectorScopeMode.SideEffect,\n      schemas: []\n    };\n    const rawProviders = ngModule.has(\"providers\") ? ngModule.get(\"providers\") : null;\n    let wrappedProviders = null;\n    if (rawProviders !== null && (!ts22.isArrayLiteralExpression(rawProviders) || rawProviders.elements.length > 0)) {\n      wrappedProviders = new WrappedNodeExpr6(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(rawProviders) : rawProviders);\n    }\n    const topLevelImports = [];\n    if (ngModule.has(\"imports\")) {\n      const rawImports2 = unwrapExpression(ngModule.get(\"imports\"));\n      let topLevelExpressions = [];\n      if (ts22.isArrayLiteralExpression(rawImports2)) {\n        for (const element of rawImports2.elements) {\n          if (ts22.isSpreadElement(element)) {\n            topLevelExpressions.push(element.expression);\n            continue;\n          }\n          topLevelExpressions.push(element);\n        }\n      } else {\n        topLevelExpressions.push(rawImports2);\n      }\n      let absoluteIndex = 0;\n      for (const importExpr of topLevelExpressions) {\n        const resolved = this.evaluator.evaluate(importExpr, moduleResolvers);\n        const { references, hasModuleWithProviders } = this.resolveTypeList(importExpr, [resolved], node.name.text, \"imports\", absoluteIndex);\n        absoluteIndex += references.length;\n        topLevelImports.push({\n          expression: importExpr,\n          resolvedReferences: references,\n          hasModuleWithProviders\n        });\n      }\n    }\n    const injectorMetadata = {\n      name,\n      type,\n      providers: wrappedProviders\n    };\n    const factoryMetadata = {\n      name,\n      type,\n      typeArgumentCount: 0,\n      deps: getValidConstructorDependencies(node, this.reflector, this.isCore),\n      target: FactoryTarget2.NgModule\n    };\n    const remoteScopesMayRequireCycleProtection = declarationRefs.some(isSyntheticReference) || importRefs.some(isSyntheticReference);\n    return {\n      diagnostics: diagnostics.length > 0 ? diagnostics : void 0,\n      analysis: {\n        id,\n        schemas,\n        mod: ngModuleMetadata,\n        inj: injectorMetadata,\n        fac: factoryMetadata,\n        declarations: declarationRefs,\n        rawDeclarations,\n        imports: topLevelImports,\n        rawImports,\n        importRefs,\n        exports: exportRefs,\n        rawExports,\n        providers: rawProviders,\n        providersRequiringFactory: rawProviders ? resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator) : null,\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        factorySymbolName: node.name.text,\n        remoteScopesMayRequireCycleProtection,\n        decorator: (_a = decorator == null ? void 0 : decorator.node) != null ? _a : null\n      }\n    };\n  }\n  symbol(node, analysis) {\n    return new NgModuleSymbol(node, analysis.providers !== null);\n  }\n  register(node, analysis) {\n    this.metaRegistry.registerNgModuleMetadata({\n      kind: MetaKind.NgModule,\n      ref: new Reference(node),\n      schemas: analysis.schemas,\n      declarations: analysis.declarations,\n      imports: analysis.importRefs,\n      exports: analysis.exports,\n      rawDeclarations: analysis.rawDeclarations,\n      rawImports: analysis.rawImports,\n      rawExports: analysis.rawExports,\n      decorator: analysis.decorator,\n      mayDeclareProviders: analysis.providers !== null\n    });\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.fac.deps\n    });\n  }\n  resolve(node, analysis) {\n    const scope = this.scopeRegistry.getScopeOfModule(node);\n    const diagnostics = [];\n    const scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);\n    if (scopeDiagnostics !== null) {\n      diagnostics.push(...scopeDiagnostics);\n    }\n    if (analysis.providersRequiringFactory !== null) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.providers, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n    const data = {\n      injectorImports: []\n    };\n    for (const topLevelImport of analysis.imports) {\n      if (topLevelImport.hasModuleWithProviders) {\n        data.injectorImports.push(new WrappedNodeExpr6(topLevelImport.expression));\n        continue;\n      }\n      const refsToEmit = [];\n      let symbol = null;\n      if (this.semanticDepGraphUpdater !== null) {\n        const sym = this.semanticDepGraphUpdater.getSymbol(node);\n        if (sym instanceof NgModuleSymbol) {\n          symbol = sym;\n        }\n      }\n      for (const ref of topLevelImport.resolvedReferences) {\n        const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n        if (dirMeta !== null) {\n          if (!dirMeta.isComponent) {\n            continue;\n          }\n          const mayExportProviders = this.exportedProviderStatusResolver.mayExportProviders(dirMeta.ref, (importRef) => {\n            if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n              const importSymbol = this.semanticDepGraphUpdater.getSymbol(importRef.node);\n              symbol.addTransitiveImportFromStandaloneComponent(importSymbol);\n            }\n          });\n          if (!mayExportProviders) {\n            continue;\n          }\n        }\n        const pipeMeta = dirMeta === null ? this.metaReader.getPipeMetadata(ref) : null;\n        if (pipeMeta !== null) {\n          continue;\n        }\n        refsToEmit.push(ref);\n      }\n      if (refsToEmit.length === topLevelImport.resolvedReferences.length) {\n        data.injectorImports.push(new WrappedNodeExpr6(topLevelImport.expression));\n      } else {\n        const context = node.getSourceFile();\n        for (const ref of refsToEmit) {\n          const emittedRef = this.refEmitter.emit(ref, context);\n          assertSuccessfulReferenceEmit(emittedRef, topLevelImport.expression, \"class\");\n          data.injectorImports.push(emittedRef.expression);\n        }\n      }\n    }\n    if (scope !== null && !scope.compilation.isPoisoned) {\n      const context = getSourceFile(node);\n      for (const exportRef of analysis.exports) {\n        if (isNgModule(exportRef.node, scope.compilation)) {\n          const type = this.refEmitter.emit(exportRef, context);\n          assertSuccessfulReferenceEmit(type, node, \"NgModule\");\n          data.injectorImports.push(type.expression);\n        }\n      }\n      for (const decl of analysis.declarations) {\n        const dirMeta = this.metaReader.getDirectiveMetadata(decl);\n        if (dirMeta !== null) {\n          const refType = dirMeta.isComponent ? \"Component\" : \"Directive\";\n          if (dirMeta.selector === null) {\n            throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node, `${refType} ${decl.node.name.text} has no selector, please add it!`);\n          }\n          continue;\n        }\n      }\n    }\n    if (diagnostics.length > 0) {\n      return { diagnostics };\n    }\n    if (scope === null || scope.compilation.isPoisoned || scope.exported.isPoisoned || scope.reexports === null) {\n      return { data };\n    } else {\n      return {\n        data,\n        reexports: scope.reexports\n      };\n    }\n  }\n  compileFull(node, { inj, mod, fac, classMetadata, declarations, remoteScopesMayRequireCycleProtection }, { injectorImports }) {\n    const factoryFn = compileNgFactoryDefField(fac);\n    const ngInjectorDef = compileInjector({\n      ...inj,\n      imports: injectorImports\n    });\n    const ngModuleDef = compileNgModule(mod);\n    const statements = ngModuleDef.statements;\n    const metadata = classMetadata !== null ? compileClassMetadata2(classMetadata) : null;\n    this.insertMetadataStatement(statements, metadata);\n    this.appendRemoteScopingStatements(statements, node, declarations, remoteScopesMayRequireCycleProtection);\n    return this.compileNgModule(factoryFn, ngInjectorDef, ngModuleDef);\n  }\n  compilePartial(node, { inj, fac, mod, classMetadata }, { injectorImports }) {\n    const factoryFn = compileDeclareFactory(fac);\n    const injectorDef = compileDeclareInjectorFromMetadata({\n      ...inj,\n      imports: injectorImports\n    });\n    const ngModuleDef = compileDeclareNgModuleFromMetadata(mod);\n    const metadata = classMetadata !== null ? compileDeclareClassMetadata2(classMetadata) : null;\n    this.insertMetadataStatement(ngModuleDef.statements, metadata);\n    return this.compileNgModule(factoryFn, injectorDef, ngModuleDef);\n  }\n  insertMetadataStatement(ngModuleStatements, metadata) {\n    if (metadata !== null) {\n      ngModuleStatements.unshift(metadata.toStmt());\n    }\n  }\n  appendRemoteScopingStatements(ngModuleStatements, node, declarations, remoteScopesMayRequireCycleProtection) {\n    const context = getSourceFile(node);\n    for (const decl of declarations) {\n      const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);\n      if (remoteScope !== null) {\n        const directives = remoteScope.directives.map((directive) => {\n          const type = this.refEmitter.emit(directive, context);\n          assertSuccessfulReferenceEmit(type, node, \"directive\");\n          return type.expression;\n        });\n        const pipes = remoteScope.pipes.map((pipe) => {\n          const type = this.refEmitter.emit(pipe, context);\n          assertSuccessfulReferenceEmit(type, node, \"pipe\");\n          return type.expression;\n        });\n        const directiveArray = new LiteralArrayExpr2(directives);\n        const pipesArray = new LiteralArrayExpr2(pipes);\n        const directiveExpr = remoteScopesMayRequireCycleProtection && directives.length > 0 ? new FunctionExpr2([], [new ReturnStatement2(directiveArray)]) : directiveArray;\n        const pipesExpr = remoteScopesMayRequireCycleProtection && pipes.length > 0 ? new FunctionExpr2([], [new ReturnStatement2(pipesArray)]) : pipesArray;\n        const componentType = this.refEmitter.emit(decl, context);\n        assertSuccessfulReferenceEmit(componentType, node, \"component\");\n        const declExpr = componentType.expression;\n        const setComponentScope = new ExternalExpr5(R3Identifiers.setComponentScope);\n        const callExpr = new InvokeFunctionExpr(setComponentScope, [declExpr, directiveExpr, pipesExpr]);\n        ngModuleStatements.push(callExpr.toStmt());\n      }\n    }\n  }\n  compileNgModule(factoryFn, injectorDef, ngModuleDef) {\n    const res = [\n      factoryFn,\n      {\n        name: \"\\u0275mod\",\n        initializer: ngModuleDef.expression,\n        statements: ngModuleDef.statements,\n        type: ngModuleDef.type\n      },\n      {\n        name: \"\\u0275inj\",\n        initializer: injectorDef.expression,\n        statements: injectorDef.statements,\n        type: injectorDef.type\n      }\n    ];\n    return res;\n  }\n  _toR3Reference(origin, valueRef, valueContext) {\n    if (valueRef.hasOwningModuleGuess) {\n      return toR3Reference(origin, valueRef, valueContext, this.refEmitter);\n    } else {\n      return toR3Reference(origin, valueRef, valueContext, this.refEmitter);\n    }\n  }\n  isClassDeclarationReference(ref) {\n    return this.reflector.isClass(ref.node);\n  }\n  resolveTypeList(expr, resolvedList, className, arrayName, absoluteIndex) {\n    let hasModuleWithProviders = false;\n    const refList = [];\n    if (!Array.isArray(resolvedList)) {\n      throw createValueHasWrongTypeError(expr, resolvedList, `Expected array when reading the NgModule.${arrayName} of ${className}`);\n    }\n    for (let idx = 0; idx < resolvedList.length; idx++) {\n      let entry = resolvedList[idx];\n      if (entry instanceof SyntheticValue && isResolvedModuleWithProviders(entry)) {\n        entry = entry.value.ngModule;\n        hasModuleWithProviders = true;\n      } else if (entry instanceof Map && entry.has(\"ngModule\")) {\n        entry = entry.get(\"ngModule\");\n        hasModuleWithProviders = true;\n      }\n      if (Array.isArray(entry)) {\n        const recursiveResult = this.resolveTypeList(expr, entry, className, arrayName, absoluteIndex);\n        refList.push(...recursiveResult.references);\n        absoluteIndex += recursiveResult.references.length;\n        hasModuleWithProviders = hasModuleWithProviders || recursiveResult.hasModuleWithProviders;\n      } else if (entry instanceof Reference) {\n        if (!this.isClassDeclarationReference(entry)) {\n          throw createValueHasWrongTypeError(entry.node, entry, `Value at position ${absoluteIndex} in the NgModule.${arrayName} of ${className} is not a class`);\n        }\n        refList.push(entry);\n        absoluteIndex += 1;\n      } else {\n        throw createValueHasWrongTypeError(expr, entry, `Value at position ${absoluteIndex} in the NgModule.${arrayName} of ${className} is not a reference`);\n      }\n    }\n    return {\n      references: refList,\n      hasModuleWithProviders\n    };\n  }\n};\nfunction isNgModule(node, compilation) {\n  return !compilation.dependencies.some((dep) => dep.ref.node === node);\n}\nfunction isModuleIdExpression(expr) {\n  return ts22.isPropertyAccessExpression(expr) && ts22.isIdentifier(expr.expression) && expr.expression.text === \"module\" && expr.name.text === \"id\";\n}\nfunction makeStandaloneBootstrapDiagnostic(ngModuleClass, bootstrappedClassRef, rawBootstrapExpr) {\n  const componentClassName = bootstrappedClassRef.node.name.text;\n  const message = `The \\`${componentClassName}\\` class is a standalone component, which can not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` function for bootstrap instead.`;\n  const relatedInformation = [makeRelatedInformation(ngModuleClass, `The 'bootstrap' array is present on this NgModule.`)];\n  return makeDiagnostic(ErrorCode.NGMODULE_BOOTSTRAP_IS_STANDALONE, getDiagnosticNode(bootstrappedClassRef, rawBootstrapExpr), message, relatedInformation);\n}\nfunction isSyntheticReference(ref) {\n  return ref.synthetic;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/diagnostics.mjs\nfunction makeCyclicImportInfo(ref, type, cycle) {\n  const name = ref.debugName || \"(unknown)\";\n  const path = cycle.getPath().map((sf) => sf.fileName).join(\" -> \");\n  const message = `The ${type} '${name}' is used in the template but importing it would create a cycle: `;\n  return makeRelatedInformation(ref.node, message + path);\n}\nfunction checkCustomElementSelectorForErrors(selector) {\n  if (selector.includes(\".\") || selector.includes(\"[\") && selector.includes(\"]\")) {\n    return null;\n  }\n  if (!/^[a-z]/.test(selector)) {\n    return \"Selector of a ShadowDom-encapsulated component must start with a lower case letter.\";\n  }\n  if (/[A-Z]/.test(selector)) {\n    return \"Selector of a ShadowDom-encapsulated component must all be in lower case.\";\n  }\n  if (!selector.includes(\"-\")) {\n    return \"Selector of a component that uses ViewEncapsulation.ShadowDom must contain a hyphen.\";\n  }\n  return null;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/resources.mjs\nimport { DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig, ParseSourceFile as ParseSourceFile2, parseTemplate } from \"@angular/compiler\";\nimport ts23 from \"typescript\";\nfunction getTemplateDeclarationNodeForError(declaration) {\n  return declaration.isInline ? declaration.expression : declaration.templateUrlExpression;\n}\nfunction extractTemplate(node, template, evaluator, depTracker, resourceLoader, options) {\n  if (template.isInline) {\n    let sourceStr;\n    let sourceParseRange = null;\n    let templateContent;\n    let sourceMapping;\n    let escapedString = false;\n    let sourceMapUrl;\n    if (ts23.isStringLiteral(template.expression) || ts23.isNoSubstitutionTemplateLiteral(template.expression)) {\n      sourceParseRange = getTemplateRange(template.expression);\n      sourceStr = template.expression.getSourceFile().text;\n      templateContent = template.expression.text;\n      escapedString = true;\n      sourceMapping = {\n        type: \"direct\",\n        node: template.expression\n      };\n      sourceMapUrl = template.resolvedTemplateUrl;\n    } else {\n      const resolvedTemplate = evaluator.evaluate(template.expression);\n      if (typeof resolvedTemplate !== \"string\") {\n        throw createValueHasWrongTypeError(template.expression, resolvedTemplate, \"template must be a string\");\n      }\n      sourceStr = resolvedTemplate;\n      templateContent = resolvedTemplate;\n      sourceMapping = {\n        type: \"indirect\",\n        node: template.expression,\n        componentClass: node,\n        template: templateContent\n      };\n      sourceMapUrl = null;\n    }\n    return {\n      ...parseExtractedTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl, options),\n      content: templateContent,\n      sourceMapping,\n      declaration: template\n    };\n  } else {\n    const templateContent = resourceLoader.load(template.resolvedTemplateUrl);\n    if (depTracker !== null) {\n      depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));\n    }\n    return {\n      ...parseExtractedTemplate(\n        template,\n        templateContent,\n        null,\n        false,\n        template.resolvedTemplateUrl,\n        options\n      ),\n      content: templateContent,\n      sourceMapping: {\n        type: \"external\",\n        componentClass: node,\n        node: template.templateUrlExpression,\n        template: templateContent,\n        templateUrl: template.resolvedTemplateUrl\n      },\n      declaration: template\n    };\n  }\n}\nfunction parseExtractedTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl, options) {\n  const i18nNormalizeLineEndingsInICUs = escapedString || options.i18nNormalizeLineEndingsInICUs;\n  const parsedTemplate = parseTemplate(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\", {\n    preserveWhitespaces: template.preserveWhitespaces,\n    interpolationConfig: template.interpolationConfig,\n    range: sourceParseRange != null ? sourceParseRange : void 0,\n    escapedString,\n    enableI18nLegacyMessageIdFormat: options.enableI18nLegacyMessageIdFormat,\n    i18nNormalizeLineEndingsInICUs,\n    alwaysAttemptHtmlToR3AstConversion: options.usePoisonedData\n  });\n  const { nodes: diagNodes } = parseTemplate(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\", {\n    preserveWhitespaces: true,\n    preserveLineEndings: true,\n    interpolationConfig: template.interpolationConfig,\n    range: sourceParseRange != null ? sourceParseRange : void 0,\n    escapedString,\n    enableI18nLegacyMessageIdFormat: options.enableI18nLegacyMessageIdFormat,\n    i18nNormalizeLineEndingsInICUs,\n    leadingTriviaChars: [],\n    alwaysAttemptHtmlToR3AstConversion: options.usePoisonedData\n  });\n  return {\n    ...parsedTemplate,\n    diagNodes,\n    file: new ParseSourceFile2(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\")\n  };\n}\nfunction parseTemplateDeclaration(node, decorator, component, containingFile, evaluator, depTracker, resourceLoader, defaultPreserveWhitespaces) {\n  let preserveWhitespaces = defaultPreserveWhitespaces;\n  if (component.has(\"preserveWhitespaces\")) {\n    const expr = component.get(\"preserveWhitespaces\");\n    const value = evaluator.evaluate(expr);\n    if (typeof value !== \"boolean\") {\n      throw createValueHasWrongTypeError(expr, value, \"preserveWhitespaces must be a boolean\");\n    }\n    preserveWhitespaces = value;\n  }\n  let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n  if (component.has(\"interpolation\")) {\n    const expr = component.get(\"interpolation\");\n    const value = evaluator.evaluate(expr);\n    if (!Array.isArray(value) || value.length !== 2 || !value.every((element) => typeof element === \"string\")) {\n      throw createValueHasWrongTypeError(expr, value, \"interpolation must be an array with 2 elements of string type\");\n    }\n    interpolationConfig = InterpolationConfig.fromArray(value);\n  }\n  if (component.has(\"templateUrl\")) {\n    const templateUrlExpr = component.get(\"templateUrl\");\n    const templateUrl = evaluator.evaluate(templateUrlExpr);\n    if (typeof templateUrl !== \"string\") {\n      throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, \"templateUrl must be a string\");\n    }\n    try {\n      const resourceUrl = resourceLoader.resolve(templateUrl, containingFile);\n      return {\n        isInline: false,\n        interpolationConfig,\n        preserveWhitespaces,\n        templateUrl,\n        templateUrlExpression: templateUrlExpr,\n        resolvedTemplateUrl: resourceUrl\n      };\n    } catch (e) {\n      if (depTracker !== null) {\n        depTracker.recordDependencyAnalysisFailure(node.getSourceFile());\n      }\n      throw makeResourceNotFoundError(templateUrl, templateUrlExpr, 0);\n    }\n  } else if (component.has(\"template\")) {\n    return {\n      isInline: true,\n      interpolationConfig,\n      preserveWhitespaces,\n      expression: component.get(\"template\"),\n      templateUrl: containingFile,\n      resolvedTemplateUrl: containingFile\n    };\n  } else {\n    throw new FatalDiagnosticError(ErrorCode.COMPONENT_MISSING_TEMPLATE, decorator.node, \"component is missing a template\");\n  }\n}\nfunction preloadAndParseTemplate(evaluator, resourceLoader, depTracker, preanalyzeTemplateCache, node, decorator, component, containingFile, defaultPreserveWhitespaces, options) {\n  if (component.has(\"templateUrl\")) {\n    const templateUrlExpr = component.get(\"templateUrl\");\n    const templateUrl = evaluator.evaluate(templateUrlExpr);\n    if (typeof templateUrl !== \"string\") {\n      throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, \"templateUrl must be a string\");\n    }\n    try {\n      const resourceUrl = resourceLoader.resolve(templateUrl, containingFile);\n      const templatePromise = resourceLoader.preload(resourceUrl, { type: \"template\", containingFile });\n      if (templatePromise !== void 0) {\n        return templatePromise.then(() => {\n          const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, evaluator, depTracker, resourceLoader, defaultPreserveWhitespaces);\n          const template = extractTemplate(node, templateDecl, evaluator, depTracker, resourceLoader, options);\n          preanalyzeTemplateCache.set(node, template);\n          return template;\n        });\n      } else {\n        return Promise.resolve(null);\n      }\n    } catch (e) {\n      if (depTracker !== null) {\n        depTracker.recordDependencyAnalysisFailure(node.getSourceFile());\n      }\n      throw makeResourceNotFoundError(templateUrl, templateUrlExpr, 0);\n    }\n  } else {\n    const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, evaluator, depTracker, resourceLoader, defaultPreserveWhitespaces);\n    const template = extractTemplate(node, templateDecl, evaluator, depTracker, resourceLoader, options);\n    preanalyzeTemplateCache.set(node, template);\n    return Promise.resolve(template);\n  }\n}\nfunction getTemplateRange(templateExpr) {\n  const startPos = templateExpr.getStart() + 1;\n  const { line, character } = ts23.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos);\n  return {\n    startPos,\n    startLine: line,\n    startCol: character,\n    endPos: templateExpr.getEnd() - 1\n  };\n}\nfunction makeResourceNotFoundError(file, nodeForError, resourceType) {\n  let errorText;\n  switch (resourceType) {\n    case 0:\n      errorText = `Could not find template file '${file}'.`;\n      break;\n    case 1:\n      errorText = `Could not find stylesheet file '${file}' linked from the template.`;\n      break;\n    case 2:\n      errorText = `Could not find stylesheet file '${file}'.`;\n      break;\n  }\n  return new FatalDiagnosticError(ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n}\nfunction transformDecoratorResources(dec, component, styles, template) {\n  if (dec.name !== \"Component\") {\n    return dec;\n  }\n  if (!component.has(\"templateUrl\") && !component.has(\"styleUrls\") && !component.has(\"styles\")) {\n    return dec;\n  }\n  const metadata = new Map(component);\n  if (metadata.has(\"templateUrl\")) {\n    metadata.delete(\"templateUrl\");\n    metadata.set(\"template\", ts23.factory.createStringLiteral(template.content));\n  }\n  if (metadata.has(\"styleUrls\") || metadata.has(\"styles\")) {\n    metadata.delete(\"styles\");\n    metadata.delete(\"styleUrls\");\n    if (styles.length > 0) {\n      const styleNodes = styles.reduce((result, style) => {\n        if (style.trim().length > 0) {\n          result.push(ts23.factory.createStringLiteral(style));\n        }\n        return result;\n      }, []);\n      if (styleNodes.length > 0) {\n        metadata.set(\"styles\", ts23.factory.createArrayLiteralExpression(styleNodes));\n      }\n    }\n  }\n  const newMetadataFields = [];\n  for (const [name, value] of metadata.entries()) {\n    newMetadataFields.push(ts23.factory.createPropertyAssignment(name, value));\n  }\n  return { ...dec, args: [ts23.factory.createObjectLiteralExpression(newMetadataFields)] };\n}\nfunction extractComponentStyleUrls(evaluator, component) {\n  if (!component.has(\"styleUrls\")) {\n    return [];\n  }\n  return extractStyleUrlsFromExpression(evaluator, component.get(\"styleUrls\"));\n}\nfunction extractStyleUrlsFromExpression(evaluator, styleUrlsExpr) {\n  const styleUrls = [];\n  if (ts23.isArrayLiteralExpression(styleUrlsExpr)) {\n    for (const styleUrlExpr of styleUrlsExpr.elements) {\n      if (ts23.isSpreadElement(styleUrlExpr)) {\n        styleUrls.push(...extractStyleUrlsFromExpression(evaluator, styleUrlExpr.expression));\n      } else {\n        const styleUrl = evaluator.evaluate(styleUrlExpr);\n        if (typeof styleUrl !== \"string\") {\n          throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, \"styleUrl must be a string\");\n        }\n        styleUrls.push({\n          url: styleUrl,\n          source: 2,\n          nodeForError: styleUrlExpr\n        });\n      }\n    }\n  } else {\n    const evaluatedStyleUrls = evaluator.evaluate(styleUrlsExpr);\n    if (!isStringArray(evaluatedStyleUrls)) {\n      throw createValueHasWrongTypeError(styleUrlsExpr, evaluatedStyleUrls, \"styleUrls must be an array of strings\");\n    }\n    for (const styleUrl of evaluatedStyleUrls) {\n      styleUrls.push({\n        url: styleUrl,\n        source: 2,\n        nodeForError: styleUrlsExpr\n      });\n    }\n  }\n  return styleUrls;\n}\nfunction extractStyleResources(resourceLoader, component, containingFile) {\n  const styles = /* @__PURE__ */ new Set();\n  function stringLiteralElements(array) {\n    return array.elements.filter((e) => ts23.isStringLiteralLike(e));\n  }\n  const styleUrlsExpr = component.get(\"styleUrls\");\n  if (styleUrlsExpr !== void 0 && ts23.isArrayLiteralExpression(styleUrlsExpr)) {\n    for (const expression of stringLiteralElements(styleUrlsExpr)) {\n      try {\n        const resourceUrl = resourceLoader.resolve(expression.text, containingFile);\n        styles.add({ path: absoluteFrom(resourceUrl), expression });\n      } catch {\n      }\n    }\n  }\n  const stylesExpr = component.get(\"styles\");\n  if (stylesExpr !== void 0 && ts23.isArrayLiteralExpression(stylesExpr)) {\n    for (const expression of stringLiteralElements(stylesExpr)) {\n      styles.add({ path: null, expression });\n    }\n  }\n  return styles;\n}\nfunction _extractTemplateStyleUrls(template) {\n  if (template.styleUrls === null) {\n    return [];\n  }\n  const nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n  return template.styleUrls.map((url) => ({ url, source: 1, nodeForError }));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/symbol.mjs\nvar ComponentSymbol = class extends DirectiveSymbol {\n  constructor() {\n    super(...arguments);\n    this.usedDirectives = [];\n    this.usedPipes = [];\n    this.isRemotelyScoped = false;\n  }\n  isEmitAffected(previousSymbol, publicApiAffected) {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n    const isSymbolUnaffected = (current, previous) => isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);\n    return this.isRemotelyScoped !== previousSymbol.isRemotelyScoped || !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) || !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected);\n  }\n  isTypeCheckBlockAffected(previousSymbol, typeCheckApiAffected) {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n    const isInheritanceChainAffected = (symbol) => {\n      let currentSymbol = symbol;\n      while (currentSymbol instanceof DirectiveSymbol) {\n        if (typeCheckApiAffected.has(currentSymbol)) {\n          return true;\n        }\n        currentSymbol = currentSymbol.baseClass;\n      }\n      return false;\n    };\n    const isDirectiveUnaffected = (current, previous) => isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);\n    const isPipeUnaffected = (current, previous) => isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);\n    return !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) || !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/util.mjs\nfunction collectAnimationNames(value, animationTriggerNames) {\n  if (value instanceof Map) {\n    const name = value.get(\"name\");\n    if (typeof name === \"string\") {\n      animationTriggerNames.staticTriggerNames.push(name);\n    } else {\n      animationTriggerNames.includesDynamicAnimations = true;\n    }\n  } else if (Array.isArray(value)) {\n    for (const resolvedValue of value) {\n      collectAnimationNames(resolvedValue, animationTriggerNames);\n    }\n  } else {\n    animationTriggerNames.includesDynamicAnimations = true;\n  }\n}\nfunction isAngularAnimationsReference(reference, symbolName) {\n  return reference.ownedByModuleGuess === \"@angular/animations\" && reference.debugName === symbolName;\n}\nvar animationTriggerResolver = (fn, node, resolve, unresolvable) => {\n  const animationTriggerMethodName = \"trigger\";\n  if (!isAngularAnimationsReference(fn, animationTriggerMethodName)) {\n    return unresolvable;\n  }\n  const triggerNameExpression = node.arguments[0];\n  if (!triggerNameExpression) {\n    return unresolvable;\n  }\n  const res = /* @__PURE__ */ new Map();\n  res.set(\"name\", resolve(triggerNameExpression));\n  return res;\n};\nfunction validateAndFlattenComponentImports(imports, expr) {\n  const flattened = [];\n  if (!Array.isArray(imports)) {\n    const error = createValueHasWrongTypeError(expr, imports, `'imports' must be an array of components, directives, pipes, or NgModules.`).toDiagnostic();\n    return {\n      imports: [],\n      diagnostics: [error]\n    };\n  }\n  const diagnostics = [];\n  for (const ref of imports) {\n    if (Array.isArray(ref)) {\n      const { imports: childImports, diagnostics: childDiagnostics } = validateAndFlattenComponentImports(ref, expr);\n      flattened.push(...childImports);\n      diagnostics.push(...childDiagnostics);\n    } else if (ref instanceof Reference) {\n      if (isNamedClassDeclaration(ref.node)) {\n        flattened.push(ref);\n      } else {\n        diagnostics.push(createValueHasWrongTypeError(ref.getOriginForDiagnostics(expr), ref, `'imports' must be an array of components, directives, pipes, or NgModules.`).toDiagnostic());\n      }\n    } else if (isLikelyModuleWithProviders(ref)) {\n      let origin = expr;\n      if (ref instanceof SyntheticValue) {\n        origin = getOriginNodeForDiagnostics(ref.value.mwpCall, expr);\n      }\n      diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_UNKNOWN_IMPORT, origin, `'imports' contains a ModuleWithProviders value, likely the result of a 'Module.forRoot()'-style call. These calls are not used to configure components and are not valid in standalone component imports - consider importing them in the application bootstrap instead.`));\n    } else {\n      diagnostics.push(createValueHasWrongTypeError(expr, imports, `'imports' must be an array of components, directives, pipes, or NgModules.`).toDiagnostic());\n    }\n  }\n  return { imports: flattened, diagnostics };\n}\nfunction isLikelyModuleWithProviders(value) {\n  if (value instanceof SyntheticValue && isResolvedModuleWithProviders(value)) {\n    return true;\n  }\n  if (value instanceof Map && value.has(\"ngModule\")) {\n    return true;\n  }\n  return false;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/component/src/handler.mjs\nvar EMPTY_ARRAY2 = [];\nvar ComponentDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, metaReader, scopeReader, dtsScopeReader, scopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, strictCtorDeps, resourceLoader, rootDirs, defaultPreserveWhitespaces, i18nUseExternalIds, enableI18nLegacyMessageIdFormat, usePoisonedData, i18nNormalizeLineEndingsInICUs, moduleResolver, cycleAnalyzer, cycleHandlingStrategy, refEmitter, referencesRegistry, depTracker, injectableRegistry, semanticDepGraphUpdater, annotateForClosureCompiler, perf, hostDirectivesResolver) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.metaReader = metaReader;\n    this.scopeReader = scopeReader;\n    this.dtsScopeReader = dtsScopeReader;\n    this.scopeRegistry = scopeRegistry;\n    this.typeCheckScopeRegistry = typeCheckScopeRegistry;\n    this.resourceRegistry = resourceRegistry;\n    this.isCore = isCore;\n    this.strictCtorDeps = strictCtorDeps;\n    this.resourceLoader = resourceLoader;\n    this.rootDirs = rootDirs;\n    this.defaultPreserveWhitespaces = defaultPreserveWhitespaces;\n    this.i18nUseExternalIds = i18nUseExternalIds;\n    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n    this.usePoisonedData = usePoisonedData;\n    this.i18nNormalizeLineEndingsInICUs = i18nNormalizeLineEndingsInICUs;\n    this.moduleResolver = moduleResolver;\n    this.cycleAnalyzer = cycleAnalyzer;\n    this.cycleHandlingStrategy = cycleHandlingStrategy;\n    this.refEmitter = refEmitter;\n    this.referencesRegistry = referencesRegistry;\n    this.depTracker = depTracker;\n    this.injectableRegistry = injectableRegistry;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.perf = perf;\n    this.hostDirectivesResolver = hostDirectivesResolver;\n    this.literalCache = /* @__PURE__ */ new Map();\n    this.elementSchemaRegistry = new DomElementSchemaRegistry();\n    this.preanalyzeTemplateCache = /* @__PURE__ */ new Map();\n    this.preanalyzeStylesCache = /* @__PURE__ */ new Map();\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = \"ComponentDecoratorHandler\";\n    this.extractTemplateOptions = {\n      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n      i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,\n      usePoisonedData: this.usePoisonedData\n    };\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"Component\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  preanalyze(node, decorator) {\n    if (!this.resourceLoader.canPreload) {\n      return void 0;\n    }\n    const meta = resolveLiteral(decorator, this.literalCache);\n    const component = reflectObjectLiteral(meta);\n    const containingFile = node.getSourceFile().fileName;\n    const resolveStyleUrl = (styleUrl) => {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n        return this.resourceLoader.preload(resourceUrl, { type: \"style\", containingFile });\n      } catch {\n        return void 0;\n      }\n    };\n    const templateAndTemplateStyleResources = preloadAndParseTemplate(this.evaluator, this.resourceLoader, this.depTracker, this.preanalyzeTemplateCache, node, decorator, component, containingFile, this.defaultPreserveWhitespaces, this.extractTemplateOptions).then((template) => {\n      if (template === null) {\n        return void 0;\n      }\n      return Promise.all(template.styleUrls.map((styleUrl) => resolveStyleUrl(styleUrl))).then(() => void 0);\n    });\n    const componentStyleUrls = extractComponentStyleUrls(this.evaluator, component);\n    let inlineStyles;\n    if (component.has(\"styles\")) {\n      const litStyles = parseFieldStringArrayValue(component, \"styles\", this.evaluator);\n      if (litStyles === null) {\n        this.preanalyzeStylesCache.set(node, null);\n      } else {\n        inlineStyles = Promise.all(litStyles.map((style) => this.resourceLoader.preprocessInline(style, { type: \"style\", containingFile }))).then((styles) => {\n          this.preanalyzeStylesCache.set(node, styles);\n        });\n      }\n    } else {\n      this.preanalyzeStylesCache.set(node, null);\n    }\n    return Promise.all([\n      templateAndTemplateStyleResources,\n      inlineStyles,\n      ...componentStyleUrls.map((styleUrl) => resolveStyleUrl(styleUrl.url))\n    ]).then(() => void 0);\n  }\n  analyze(node, decorator, flags = HandlerFlags.NONE) {\n    var _a, _b, _c;\n    this.perf.eventCount(PerfEvent.AnalyzeComponent);\n    const containingFile = node.getSourceFile().fileName;\n    this.literalCache.delete(decorator);\n    let diagnostics;\n    let isPoisoned = false;\n    const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.refEmitter, this.referencesRegistry, this.isCore, flags, this.annotateForClosureCompiler, this.elementSchemaRegistry.getDefaultComponentElementName());\n    if (directiveResult === void 0) {\n      return {};\n    }\n    const { decorator: component, metadata, inputs, outputs, hostDirectives, rawHostDirectives } = directiveResult;\n    const encapsulation = (_a = resolveEnumValue(this.evaluator, component, \"encapsulation\", \"ViewEncapsulation\")) != null ? _a : ViewEncapsulation.Emulated;\n    const changeDetection = resolveEnumValue(this.evaluator, component, \"changeDetection\", \"ChangeDetectionStrategy\");\n    let animations = null;\n    let animationTriggerNames = null;\n    if (component.has(\"animations\")) {\n      const animationExpression = component.get(\"animations\");\n      animations = new WrappedNodeExpr7(animationExpression);\n      const animationsValue = this.evaluator.evaluate(animationExpression, animationTriggerResolver);\n      animationTriggerNames = { includesDynamicAnimations: false, staticTriggerNames: [] };\n      collectAnimationNames(animationsValue, animationTriggerNames);\n    }\n    const relativeContextFilePath = this.rootDirs.reduce((previous, rootDir) => {\n      const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));\n      if (previous === void 0 || candidate.length < previous.length) {\n        return candidate;\n      } else {\n        return previous;\n      }\n    }, void 0);\n    let viewProvidersRequiringFactory = null;\n    let providersRequiringFactory = null;\n    let wrappedViewProviders = null;\n    if (component.has(\"viewProviders\")) {\n      const viewProviders = component.get(\"viewProviders\");\n      viewProvidersRequiringFactory = resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);\n      wrappedViewProviders = new WrappedNodeExpr7(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(viewProviders) : viewProviders);\n    }\n    if (component.has(\"providers\")) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(component.get(\"providers\"), this.reflector, this.evaluator);\n    }\n    let resolvedImports = null;\n    let rawImports = null;\n    if (component.has(\"imports\") && !metadata.isStandalone) {\n      if (diagnostics === void 0) {\n        diagnostics = [];\n      }\n      diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_NOT_STANDALONE, component.get(\"imports\"), `'imports' is only valid on a component that is standalone.`, [makeRelatedInformation(node.name, `Did you forget to add 'standalone: true' to this @Component?`)]));\n      isPoisoned = true;\n    } else if (component.has(\"imports\")) {\n      const expr = component.get(\"imports\");\n      const importResolvers = combineResolvers([\n        createModuleWithProvidersResolver(this.reflector, this.isCore),\n        forwardRefResolver\n      ]);\n      const imported = this.evaluator.evaluate(expr, importResolvers);\n      const { imports: flattened, diagnostics: importDiagnostics } = validateAndFlattenComponentImports(imported, expr);\n      resolvedImports = flattened;\n      rawImports = expr;\n      if (importDiagnostics.length > 0) {\n        isPoisoned = true;\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n        diagnostics.push(...importDiagnostics);\n      }\n    }\n    let schemas = null;\n    if (component.has(\"schemas\") && !metadata.isStandalone) {\n      if (diagnostics === void 0) {\n        diagnostics = [];\n      }\n      diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_NOT_STANDALONE, component.get(\"schemas\"), `'schemas' is only valid on a component that is standalone.`));\n    } else if (component.has(\"schemas\")) {\n      schemas = extractSchemas(component.get(\"schemas\"), this.evaluator, \"Component\");\n    } else if (metadata.isStandalone) {\n      schemas = [];\n    }\n    let template;\n    if (this.preanalyzeTemplateCache.has(node)) {\n      const preanalyzed = this.preanalyzeTemplateCache.get(node);\n      this.preanalyzeTemplateCache.delete(node);\n      template = preanalyzed;\n    } else {\n      const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, this.evaluator, this.depTracker, this.resourceLoader, this.defaultPreserveWhitespaces);\n      template = extractTemplate(node, templateDecl, this.evaluator, this.depTracker, this.resourceLoader, {\n        enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n        i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,\n        usePoisonedData: this.usePoisonedData\n      });\n    }\n    const templateResource = template.declaration.isInline ? { path: null, expression: component.get(\"template\") } : {\n      path: absoluteFrom(template.declaration.resolvedTemplateUrl),\n      expression: template.sourceMapping.node\n    };\n    let styles = [];\n    const styleResources = extractStyleResources(this.resourceLoader, component, containingFile);\n    const styleUrls = [\n      ...extractComponentStyleUrls(this.evaluator, component),\n      ..._extractTemplateStyleUrls(template)\n    ];\n    for (const styleUrl of styleUrls) {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n        const resourceStr = this.resourceLoader.load(resourceUrl);\n        styles.push(resourceStr);\n        if (this.depTracker !== null) {\n          this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n        }\n      } catch {\n        if (this.depTracker !== null) {\n          this.depTracker.recordDependencyAnalysisFailure(node.getSourceFile());\n        }\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n        const resourceType = styleUrl.source === 2 ? 2 : 1;\n        diagnostics.push(makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType).toDiagnostic());\n      }\n    }\n    if (encapsulation === ViewEncapsulation.ShadowDom && metadata.selector !== null) {\n      const selectorError = checkCustomElementSelectorForErrors(metadata.selector);\n      if (selectorError !== null) {\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n        diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR, component.get(\"selector\"), selectorError));\n      }\n    }\n    let inlineStyles = null;\n    if (this.preanalyzeStylesCache.has(node)) {\n      inlineStyles = this.preanalyzeStylesCache.get(node);\n      this.preanalyzeStylesCache.delete(node);\n      if (inlineStyles !== null) {\n        styles.push(...inlineStyles);\n      }\n    } else {\n      if (this.resourceLoader.canPreprocess) {\n        throw new Error(\"Inline resource processing requires asynchronous preanalyze.\");\n      }\n      if (component.has(\"styles\")) {\n        const litStyles = parseFieldStringArrayValue(component, \"styles\", this.evaluator);\n        if (litStyles !== null) {\n          inlineStyles = [...litStyles];\n          styles.push(...litStyles);\n        }\n      }\n    }\n    if (template.styles.length > 0) {\n      styles.push(...template.styles);\n    }\n    const output = {\n      analysis: {\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        inputs,\n        outputs,\n        hostDirectives,\n        rawHostDirectives,\n        meta: {\n          ...metadata,\n          template: {\n            nodes: template.nodes,\n            ngContentSelectors: template.ngContentSelectors\n          },\n          encapsulation,\n          interpolation: (_b = template.interpolationConfig) != null ? _b : DEFAULT_INTERPOLATION_CONFIG2,\n          styles,\n          animations,\n          viewProviders: wrappedViewProviders,\n          i18nUseExternalIds: this.i18nUseExternalIds,\n          relativeContextFilePath\n        },\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, inputs, this.reflector),\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler, (dec) => transformDecoratorResources(dec, component, styles, template)),\n        template,\n        providersRequiringFactory,\n        viewProvidersRequiringFactory,\n        inlineStyles,\n        styleUrls,\n        resources: {\n          styles: styleResources,\n          template: templateResource\n        },\n        isPoisoned,\n        animationTriggerNames,\n        rawImports,\n        resolvedImports,\n        schemas,\n        decorator: (_c = decorator == null ? void 0 : decorator.node) != null ? _c : null\n      },\n      diagnostics\n    };\n    if (changeDetection !== null) {\n      output.analysis.meta.changeDetection = changeDetection;\n    }\n    return output;\n  }\n  symbol(node, analysis) {\n    const typeParameters = extractSemanticTypeParameters(node);\n    return new ComponentSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n  }\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata({\n      kind: MetaKind.Directive,\n      matchSource: MatchSource.Selector,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map((query) => query.propertyName),\n      isComponent: true,\n      baseClass: analysis.baseClass,\n      hostDirectives: analysis.hostDirectives,\n      ...analysis.typeCheckMeta,\n      isPoisoned: analysis.isPoisoned,\n      isStructural: false,\n      isStandalone: analysis.meta.isStandalone,\n      isSignal: analysis.meta.isSignal,\n      imports: analysis.resolvedImports,\n      animationTriggerNames: analysis.animationTriggerNames,\n      schemas: analysis.schemas,\n      decorator: analysis.decorator,\n      assumedToExportProviders: false\n    });\n    this.resourceRegistry.registerResources(analysis.resources, node);\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.meta.deps\n    });\n  }\n  index(context, node, analysis) {\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return null;\n    }\n    const scope = this.scopeReader.getScopeForComponent(node);\n    const selector = analysis.meta.selector;\n    const matcher = new SelectorMatcher2();\n    if (scope !== null) {\n      let { dependencies, isPoisoned } = scope.kind === ComponentScopeKind.NgModule ? scope.compilation : scope;\n      if ((isPoisoned || scope.kind === ComponentScopeKind.NgModule && scope.exported.isPoisoned) && !this.usePoisonedData) {\n        return null;\n      }\n      for (const dep of dependencies) {\n        if (dep.kind === MetaKind.Directive && dep.selector !== null) {\n          matcher.addSelectables(CssSelector2.parse(dep.selector), [...this.hostDirectivesResolver.resolve(dep), dep]);\n        }\n      }\n    }\n    const binder = new R3TargetBinder(matcher);\n    const boundTemplate = binder.bind({ template: analysis.template.diagNodes });\n    context.addComponent({\n      declaration: node,\n      selector,\n      boundTemplate,\n      templateMeta: {\n        isInline: analysis.template.declaration.isInline,\n        file: analysis.template.file\n      }\n    });\n  }\n  typeCheck(ctx, node, meta) {\n    if (this.typeCheckScopeRegistry === null || !ts24.isClassDeclaration(node)) {\n      return;\n    }\n    if (meta.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n    const scope = this.typeCheckScopeRegistry.getTypeCheckScope(node);\n    if (scope.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n    const binder = new R3TargetBinder(scope.matcher);\n    ctx.addTemplate(new Reference(node), binder, meta.template.diagNodes, scope.pipes, scope.schemas, meta.template.sourceMapping, meta.template.file, meta.template.errors, meta.meta.isStandalone);\n  }\n  extendedTemplateCheck(component, extendedTemplateChecker) {\n    return extendedTemplateChecker.getDiagnosticsForComponent(component);\n  }\n  resolve(node, analysis, symbol) {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return {};\n    }\n    const context = getSourceFile(node);\n    const metadata = analysis.meta;\n    const data = {\n      declarations: EMPTY_ARRAY2,\n      declarationListEmitMode: 0\n    };\n    const diagnostics = [];\n    const scope = this.scopeReader.getScopeForComponent(node);\n    if (scope !== null) {\n      const matcher = new SelectorMatcher2();\n      const pipes = /* @__PURE__ */ new Map();\n      const dependencies = scope.kind === ComponentScopeKind.NgModule ? scope.compilation.dependencies : scope.dependencies;\n      for (const dep of dependencies) {\n        if (dep.kind === MetaKind.Directive && dep.selector !== null) {\n          matcher.addSelectables(CssSelector2.parse(dep.selector), [dep]);\n        } else if (dep.kind === MetaKind.Pipe) {\n          pipes.set(dep.name, dep);\n        }\n      }\n      const binder = new R3TargetBinder(matcher);\n      const bound = binder.bind({ template: metadata.template.nodes });\n      const used = /* @__PURE__ */ new Set();\n      for (const dir of bound.getUsedDirectives()) {\n        used.add(dir.ref.node);\n      }\n      for (const name of bound.getUsedPipes()) {\n        if (!pipes.has(name)) {\n          continue;\n        }\n        used.add(pipes.get(name).ref.node);\n      }\n      const declarations = [];\n      const seen = /* @__PURE__ */ new Set();\n      for (const dep of dependencies) {\n        if (seen.has(dep.ref.node)) {\n          continue;\n        }\n        seen.add(dep.ref.node);\n        switch (dep.kind) {\n          case MetaKind.Directive:\n            if (!used.has(dep.ref.node) || dep.matchSource !== MatchSource.Selector) {\n              continue;\n            }\n            const dirType = this.refEmitter.emit(dep.ref, context);\n            assertSuccessfulReferenceEmit(dirType, node.name, dep.isComponent ? \"component\" : \"directive\");\n            declarations.push({\n              kind: R3TemplateDependencyKind.Directive,\n              ref: dep.ref,\n              type: dirType.expression,\n              importedFile: dirType.importedFile,\n              selector: dep.selector,\n              inputs: dep.inputs.propertyNames,\n              outputs: dep.outputs.propertyNames,\n              exportAs: dep.exportAs,\n              isComponent: dep.isComponent\n            });\n            break;\n          case MetaKind.Pipe:\n            if (!used.has(dep.ref.node)) {\n              continue;\n            }\n            const pipeType = this.refEmitter.emit(dep.ref, context);\n            assertSuccessfulReferenceEmit(pipeType, node.name, \"pipe\");\n            declarations.push({\n              kind: R3TemplateDependencyKind.Pipe,\n              type: pipeType.expression,\n              name: dep.name,\n              ref: dep.ref,\n              importedFile: pipeType.importedFile\n            });\n            break;\n          case MetaKind.NgModule:\n            const ngModuleType = this.refEmitter.emit(dep.ref, context);\n            assertSuccessfulReferenceEmit(ngModuleType, node.name, \"NgModule\");\n            declarations.push({\n              kind: R3TemplateDependencyKind.NgModule,\n              type: ngModuleType.expression,\n              importedFile: ngModuleType.importedFile\n            });\n            break;\n        }\n      }\n      const isUsedDirective = (decl) => decl.kind === R3TemplateDependencyKind.Directive;\n      const isUsedPipe = (decl) => decl.kind === R3TemplateDependencyKind.Pipe;\n      const getSemanticReference = (decl) => this.semanticDepGraphUpdater.getSemanticReference(decl.ref.node, decl.type);\n      if (this.semanticDepGraphUpdater !== null) {\n        symbol.usedDirectives = declarations.filter(isUsedDirective).map(getSemanticReference);\n        symbol.usedPipes = declarations.filter(isUsedPipe).map(getSemanticReference);\n      }\n      const cyclesFromDirectives = /* @__PURE__ */ new Map();\n      const cyclesFromPipes = /* @__PURE__ */ new Map();\n      if (!metadata.isStandalone) {\n        for (const usedDep of declarations) {\n          const cycle = this._checkForCyclicImport(usedDep.importedFile, usedDep.type, context);\n          if (cycle !== null) {\n            switch (usedDep.kind) {\n              case R3TemplateDependencyKind.Directive:\n                cyclesFromDirectives.set(usedDep, cycle);\n                break;\n              case R3TemplateDependencyKind.Pipe:\n                cyclesFromPipes.set(usedDep, cycle);\n                break;\n            }\n          }\n        }\n      }\n      const standaloneImportMayBeForwardDeclared = analysis.resolvedImports !== null && analysis.resolvedImports.some((ref) => ref.synthetic);\n      const cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;\n      if (!cycleDetected) {\n        for (const { type, importedFile } of declarations) {\n          this.maybeRecordSyntheticImport(importedFile, type, context);\n        }\n        const declarationIsForwardDeclared = declarations.some((decl) => isExpressionForwardReference(decl.type, node.name, context));\n        const wrapDirectivesAndPipesInClosure = declarationIsForwardDeclared || standaloneImportMayBeForwardDeclared;\n        data.declarations = declarations;\n        data.declarationListEmitMode = wrapDirectivesAndPipesInClosure ? 1 : 0;\n      } else {\n        if (this.cycleHandlingStrategy === 0) {\n          this.scopeRegistry.setComponentRemoteScope(node, declarations.filter(isUsedDirective).map((dir) => dir.ref), declarations.filter(isUsedPipe).map((pipe) => pipe.ref));\n          symbol.isRemotelyScoped = true;\n          if (this.semanticDepGraphUpdater !== null && scope.kind === ComponentScopeKind.NgModule && scope.ngModule !== null) {\n            const moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);\n            if (!(moduleSymbol instanceof NgModuleSymbol)) {\n              throw new Error(`AssertionError: Expected ${scope.ngModule.name} to be an NgModuleSymbol.`);\n            }\n            moduleSymbol.addRemotelyScopedComponent(symbol, symbol.usedDirectives, symbol.usedPipes);\n          }\n        } else {\n          const relatedMessages = [];\n          for (const [dir, cycle] of cyclesFromDirectives) {\n            relatedMessages.push(makeCyclicImportInfo(dir.ref, dir.isComponent ? \"component\" : \"directive\", cycle));\n          }\n          for (const [pipe, cycle] of cyclesFromPipes) {\n            relatedMessages.push(makeCyclicImportInfo(pipe.ref, \"pipe\", cycle));\n          }\n          throw new FatalDiagnosticError(ErrorCode.IMPORT_CYCLE_DETECTED, node, \"One or more import cycles would need to be created to compile this component, which is not supported by the current compiler configuration.\", relatedMessages);\n        }\n      }\n    }\n    if (analysis.resolvedImports !== null && analysis.rawImports !== null) {\n      const standaloneDiagnostics = validateStandaloneImports(analysis.resolvedImports, analysis.rawImports, this.metaReader, this.scopeReader);\n      diagnostics.push(...standaloneDiagnostics);\n    }\n    if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof WrappedNodeExpr7) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n    if (analysis.viewProvidersRequiringFactory !== null && analysis.meta.viewProviders instanceof WrappedNodeExpr7) {\n      const viewProviderDiagnostics = getProviderDiagnostics(analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders.node, this.injectableRegistry);\n      diagnostics.push(...viewProviderDiagnostics);\n    }\n    const directiveDiagnostics = getDirectiveDiagnostics(node, this.injectableRegistry, this.evaluator, this.reflector, this.scopeRegistry, this.strictCtorDeps, \"Component\");\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n    const hostDirectivesDiagnotics = analysis.hostDirectives && analysis.rawHostDirectives ? validateHostDirectives(analysis.rawHostDirectives, analysis.hostDirectives, this.metaReader) : null;\n    if (hostDirectivesDiagnotics !== null) {\n      diagnostics.push(...hostDirectivesDiagnotics);\n    }\n    if (diagnostics.length > 0) {\n      return { diagnostics };\n    }\n    return { data };\n  }\n  xi18n(ctx, node, analysis) {\n    var _a;\n    ctx.updateFromTemplate(analysis.template.content, analysis.template.declaration.resolvedTemplateUrl, (_a = analysis.template.interpolationConfig) != null ? _a : DEFAULT_INTERPOLATION_CONFIG2);\n  }\n  updateResources(node, analysis) {\n    const containingFile = node.getSourceFile().fileName;\n    const templateDecl = analysis.template.declaration;\n    if (!templateDecl.isInline) {\n      analysis.template = extractTemplate(node, templateDecl, this.evaluator, this.depTracker, this.resourceLoader, this.extractTemplateOptions);\n    }\n    let styles = [];\n    if (analysis.styleUrls !== null) {\n      for (const styleUrl of analysis.styleUrls) {\n        try {\n          const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n          const styleText = this.resourceLoader.load(resolvedStyleUrl);\n          styles.push(styleText);\n        } catch (e) {\n        }\n      }\n    }\n    if (analysis.inlineStyles !== null) {\n      for (const styleText of analysis.inlineStyles) {\n        styles.push(styleText);\n      }\n    }\n    for (const styleText of analysis.template.styles) {\n      styles.push(styleText);\n    }\n    analysis.meta.styles = styles.filter((s) => s.trim().length > 0);\n  }\n  compileFull(node, analysis, resolution, pool) {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const meta = { ...analysis.meta, ...resolution };\n    const fac = compileNgFactoryDefField(toFactoryMetadata(meta, FactoryTarget3.Component));\n    const def = compileComponentFromMetadata(meta, pool, makeBindingParser2());\n    const inputTransformFields = compileInputTransformFields(analysis.inputs);\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata3(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275cmp\", inputTransformFields);\n  }\n  compilePartial(node, analysis, resolution) {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const templateInfo = {\n      content: analysis.template.content,\n      sourceUrl: analysis.template.declaration.resolvedTemplateUrl,\n      isInline: analysis.template.declaration.isInline,\n      inlineTemplateLiteralExpression: analysis.template.sourceMapping.type === \"direct\" ? new WrappedNodeExpr7(analysis.template.sourceMapping.node) : null\n    };\n    const meta = { ...analysis.meta, ...resolution };\n    const fac = compileDeclareFactory(toFactoryMetadata(meta, FactoryTarget3.Component));\n    const inputTransformFields = compileInputTransformFields(analysis.inputs);\n    const def = compileDeclareComponentFromMetadata(meta, analysis.template, templateInfo);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata3(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275cmp\", inputTransformFields);\n  }\n  _checkForCyclicImport(importedFile, expr, origin) {\n    const imported = resolveImportedFile(this.moduleResolver, importedFile, expr, origin);\n    if (imported === null) {\n      return null;\n    }\n    return this.cycleAnalyzer.wouldCreateCycle(origin, imported);\n  }\n  maybeRecordSyntheticImport(importedFile, expr, origin) {\n    const imported = resolveImportedFile(this.moduleResolver, importedFile, expr, origin);\n    if (imported === null) {\n      return;\n    }\n    this.cycleAnalyzer.recordSyntheticImport(origin, imported);\n  }\n};\nfunction validateStandaloneImports(importRefs, importExpr, metaReader, scopeReader) {\n  const diagnostics = [];\n  for (const ref of importRefs) {\n    const dirMeta = metaReader.getDirectiveMetadata(ref);\n    if (dirMeta !== null) {\n      if (!dirMeta.isStandalone) {\n        diagnostics.push(makeNotStandaloneDiagnostic(scopeReader, ref, importExpr, dirMeta.isComponent ? \"component\" : \"directive\"));\n      }\n      continue;\n    }\n    const pipeMeta = metaReader.getPipeMetadata(ref);\n    if (pipeMeta !== null) {\n      if (!pipeMeta.isStandalone) {\n        diagnostics.push(makeNotStandaloneDiagnostic(scopeReader, ref, importExpr, \"pipe\"));\n      }\n      continue;\n    }\n    const ngModuleMeta = metaReader.getNgModuleMetadata(ref);\n    if (ngModuleMeta !== null) {\n      continue;\n    }\n    diagnostics.push(makeUnknownComponentImportDiagnostic(ref, importExpr));\n  }\n  return diagnostics;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/injectable.mjs\nimport { compileClassMetadata as compileClassMetadata4, compileDeclareClassMetadata as compileDeclareClassMetadata4, compileDeclareInjectableFromMetadata, compileInjectable, createMayBeForwardRefExpression as createMayBeForwardRefExpression2, FactoryTarget as FactoryTarget4, LiteralExpr as LiteralExpr3, WrappedNodeExpr as WrappedNodeExpr8 } from \"@angular/compiler\";\nimport ts25 from \"typescript\";\nvar InjectableDecoratorHandler = class {\n  constructor(reflector, evaluator, isCore, strictCtorDeps, injectableRegistry, perf, errorOnDuplicateProv = true) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.isCore = isCore;\n    this.strictCtorDeps = strictCtorDeps;\n    this.injectableRegistry = injectableRegistry;\n    this.perf = perf;\n    this.errorOnDuplicateProv = errorOnDuplicateProv;\n    this.precedence = HandlerPrecedence.SHARED;\n    this.name = \"InjectableDecoratorHandler\";\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"Injectable\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  analyze(node, decorator) {\n    this.perf.eventCount(PerfEvent.AnalyzeInjectable);\n    const meta = extractInjectableMetadata(node, decorator, this.reflector);\n    const decorators = this.reflector.getDecoratorsOfDeclaration(node);\n    return {\n      analysis: {\n        meta,\n        ctorDeps: extractInjectableCtorDeps(node, meta, decorator, this.reflector, this.isCore, this.strictCtorDeps),\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore),\n        needsFactory: !decorators || decorators.every((current) => !isAngularCore(current) || current.name === \"Injectable\")\n      }\n    };\n  }\n  symbol() {\n    return null;\n  }\n  register(node, analysis) {\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.ctorDeps\n    });\n  }\n  resolve(node, analysis, symbol) {\n    if (requiresValidCtor(analysis.meta)) {\n      const diagnostic = checkInheritanceOfInjectable(node, this.injectableRegistry, this.reflector, this.evaluator, this.strictCtorDeps, \"Injectable\");\n      if (diagnostic !== null) {\n        return {\n          diagnostics: [diagnostic]\n        };\n      }\n    }\n    return {};\n  }\n  compileFull(node, analysis) {\n    return this.compile(compileNgFactoryDefField, (meta) => compileInjectable(meta, false), compileClassMetadata4, node, analysis);\n  }\n  compilePartial(node, analysis) {\n    return this.compile(compileDeclareFactory, compileDeclareInjectableFromMetadata, compileDeclareClassMetadata4, node, analysis);\n  }\n  compile(compileFactoryFn, compileInjectableFn, compileClassMetadataFn, node, analysis) {\n    const results = [];\n    if (analysis.needsFactory) {\n      const meta = analysis.meta;\n      const factoryRes = compileFactoryFn(toFactoryMetadata({ ...meta, deps: analysis.ctorDeps }, FactoryTarget4.Injectable));\n      if (analysis.classMetadata !== null) {\n        factoryRes.statements.push(compileClassMetadataFn(analysis.classMetadata).toStmt());\n      }\n      results.push(factoryRes);\n    }\n    const \\u0275prov = this.reflector.getMembersOfClass(node).find((member) => member.name === \"\\u0275prov\");\n    if (\\u0275prov !== void 0 && this.errorOnDuplicateProv) {\n      throw new FatalDiagnosticError(ErrorCode.INJECTABLE_DUPLICATE_PROV, \\u0275prov.nameNode || \\u0275prov.node || node, \"Injectables cannot contain a static \\u0275prov property, because the compiler is going to generate one.\");\n    }\n    if (\\u0275prov === void 0) {\n      const res = compileInjectableFn(analysis.meta);\n      results.push({ name: \"\\u0275prov\", initializer: res.expression, statements: res.statements, type: res.type });\n    }\n    return results;\n  }\n};\nfunction extractInjectableMetadata(clazz, decorator, reflector) {\n  const name = clazz.name.text;\n  const type = wrapTypeReference(reflector, clazz);\n  const typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, decorator.node, \"@Injectable must be called\");\n  }\n  if (decorator.args.length === 0) {\n    return {\n      name,\n      type,\n      typeArgumentCount,\n      providedIn: createMayBeForwardRefExpression2(new LiteralExpr3(null), 0)\n    };\n  } else if (decorator.args.length === 1) {\n    const metaNode = decorator.args[0];\n    if (!ts25.isObjectLiteralExpression(metaNode)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode, `@Injectable argument must be an object literal`);\n    }\n    const meta = reflectObjectLiteral(metaNode);\n    const providedIn = meta.has(\"providedIn\") ? getProviderExpression(meta.get(\"providedIn\"), reflector) : createMayBeForwardRefExpression2(new LiteralExpr3(null), 0);\n    let deps = void 0;\n    if ((meta.has(\"useClass\") || meta.has(\"useFactory\")) && meta.has(\"deps\")) {\n      const depsExpr = meta.get(\"deps\");\n      if (!ts25.isArrayLiteralExpression(depsExpr)) {\n        throw new FatalDiagnosticError(ErrorCode.VALUE_NOT_LITERAL, depsExpr, `@Injectable deps metadata must be an inline array`);\n      }\n      deps = depsExpr.elements.map((dep) => getDep(dep, reflector));\n    }\n    const result = { name, type, typeArgumentCount, providedIn };\n    if (meta.has(\"useValue\")) {\n      result.useValue = getProviderExpression(meta.get(\"useValue\"), reflector);\n    } else if (meta.has(\"useExisting\")) {\n      result.useExisting = getProviderExpression(meta.get(\"useExisting\"), reflector);\n    } else if (meta.has(\"useClass\")) {\n      result.useClass = getProviderExpression(meta.get(\"useClass\"), reflector);\n      result.deps = deps;\n    } else if (meta.has(\"useFactory\")) {\n      result.useFactory = new WrappedNodeExpr8(meta.get(\"useFactory\"));\n      result.deps = deps;\n    }\n    return result;\n  } else {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], \"Too many arguments to @Injectable\");\n  }\n}\nfunction getProviderExpression(expression, reflector) {\n  const forwardRefValue = tryUnwrapForwardRef(expression, reflector);\n  return createMayBeForwardRefExpression2(new WrappedNodeExpr8(forwardRefValue != null ? forwardRefValue : expression), forwardRefValue !== null ? 2 : 0);\n}\nfunction extractInjectableCtorDeps(clazz, meta, decorator, reflector, isCore, strictCtorDeps) {\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, decorator.node, \"@Injectable must be called\");\n  }\n  let ctorDeps = null;\n  if (decorator.args.length === 0) {\n    if (strictCtorDeps && !isAbstractClassDeclaration(clazz)) {\n      ctorDeps = getValidConstructorDependencies(clazz, reflector, isCore);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(getConstructorDependencies(clazz, reflector, isCore));\n    }\n    return ctorDeps;\n  } else if (decorator.args.length === 1) {\n    const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n    if (strictCtorDeps && !isAbstractClassDeclaration(clazz) && requiresValidCtor(meta)) {\n      ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(rawCtorDeps);\n    }\n  }\n  return ctorDeps;\n}\nfunction requiresValidCtor(meta) {\n  return meta.useValue === void 0 && meta.useExisting === void 0 && meta.useClass === void 0 && meta.useFactory === void 0;\n}\nfunction getDep(dep, reflector) {\n  const meta = {\n    token: new WrappedNodeExpr8(dep),\n    attributeNameType: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false\n  };\n  function maybeUpdateDecorator(dec, reflector2, token) {\n    const source = reflector2.getImportOfIdentifier(dec);\n    if (source === null || source.from !== \"@angular/core\") {\n      return false;\n    }\n    switch (source.name) {\n      case \"Inject\":\n        if (token !== void 0) {\n          meta.token = new WrappedNodeExpr8(token);\n        }\n        break;\n      case \"Optional\":\n        meta.optional = true;\n        break;\n      case \"SkipSelf\":\n        meta.skipSelf = true;\n        break;\n      case \"Self\":\n        meta.self = true;\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n  if (ts25.isArrayLiteralExpression(dep)) {\n    dep.elements.forEach((el) => {\n      let isDecorator = false;\n      if (ts25.isIdentifier(el)) {\n        isDecorator = maybeUpdateDecorator(el, reflector);\n      } else if (ts25.isNewExpression(el) && ts25.isIdentifier(el.expression)) {\n        const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || void 0;\n        isDecorator = maybeUpdateDecorator(el.expression, reflector, token);\n      }\n      if (!isDecorator) {\n        meta.token = new WrappedNodeExpr8(el);\n      }\n    });\n  }\n  return meta;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/pipe.mjs\nimport { compileClassMetadata as compileClassMetadata5, compileDeclareClassMetadata as compileDeclareClassMetadata5, compileDeclarePipeFromMetadata, compilePipeFromMetadata, FactoryTarget as FactoryTarget5 } from \"@angular/compiler\";\nimport ts26 from \"typescript\";\nvar PipeSymbol = class extends SemanticSymbol {\n  constructor(decl, name) {\n    super(decl);\n    this.name = name;\n  }\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof PipeSymbol)) {\n      return true;\n    }\n    return this.name !== previousSymbol.name;\n  }\n  isTypeCheckApiAffected(previousSymbol) {\n    return this.isPublicApiAffected(previousSymbol);\n  }\n};\nvar PipeDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.injectableRegistry = injectableRegistry;\n    this.isCore = isCore;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = \"PipeDecoratorHandler\";\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"Pipe\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  analyze(clazz, decorator) {\n    var _a;\n    this.perf.eventCount(PerfEvent.AnalyzePipe);\n    const name = clazz.name.text;\n    const type = wrapTypeReference(this.reflector, clazz);\n    if (decorator.args === null) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, decorator.node, `@Pipe must be called`);\n    }\n    if (decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, \"@Pipe must have exactly one argument\");\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts26.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"@Pipe must have a literal argument\");\n    }\n    const pipe = reflectObjectLiteral(meta);\n    if (!pipe.has(\"name\")) {\n      throw new FatalDiagnosticError(ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);\n    }\n    const pipeNameExpr = pipe.get(\"name\");\n    const pipeName = this.evaluator.evaluate(pipeNameExpr);\n    if (typeof pipeName !== \"string\") {\n      throw createValueHasWrongTypeError(pipeNameExpr, pipeName, `@Pipe.name must be a string`);\n    }\n    let pure = true;\n    if (pipe.has(\"pure\")) {\n      const expr = pipe.get(\"pure\");\n      const pureValue = this.evaluator.evaluate(expr);\n      if (typeof pureValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(expr, pureValue, `@Pipe.pure must be a boolean`);\n      }\n      pure = pureValue;\n    }\n    let isStandalone = false;\n    if (pipe.has(\"standalone\")) {\n      const expr = pipe.get(\"standalone\");\n      const resolved = this.evaluator.evaluate(expr);\n      if (typeof resolved !== \"boolean\") {\n        throw createValueHasWrongTypeError(expr, resolved, `standalone flag must be a boolean`);\n      }\n      isStandalone = resolved;\n    }\n    return {\n      analysis: {\n        meta: {\n          name,\n          type,\n          typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,\n          pipeName,\n          deps: getValidConstructorDependencies(clazz, this.reflector, this.isCore),\n          pure,\n          isStandalone\n        },\n        classMetadata: extractClassMetadata(clazz, this.reflector, this.isCore),\n        pipeNameExpr,\n        decorator: (_a = decorator == null ? void 0 : decorator.node) != null ? _a : null\n      }\n    };\n  }\n  symbol(node, analysis) {\n    return new PipeSymbol(node, analysis.meta.pipeName);\n  }\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerPipeMetadata({\n      kind: MetaKind.Pipe,\n      ref,\n      name: analysis.meta.pipeName,\n      nameExpr: analysis.pipeNameExpr,\n      isStandalone: analysis.meta.isStandalone,\n      decorator: analysis.decorator\n    });\n    this.injectableRegistry.registerInjectable(node, {\n      ctorDeps: analysis.meta.deps\n    });\n  }\n  resolve(node) {\n    const duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);\n    if (duplicateDeclData !== null) {\n      return {\n        diagnostics: [makeDuplicateDeclarationError(node, duplicateDeclData, \"Pipe\")]\n      };\n    }\n    return {};\n  }\n  compileFull(node, analysis) {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget5.Pipe));\n    const def = compilePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata5(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275pipe\", null);\n  }\n  compilePartial(node, analysis) {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget5.Pipe));\n    const def = compileDeclarePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata5(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275pipe\", null);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/api/checker.mjs\nvar OptimizeFor;\n(function(OptimizeFor2) {\n  OptimizeFor2[OptimizeFor2[\"SingleFile\"] = 0] = \"SingleFile\";\n  OptimizeFor2[OptimizeFor2[\"WholeProgram\"] = 1] = \"WholeProgram\";\n})(OptimizeFor || (OptimizeFor = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/api/scope.mjs\nvar PotentialImportKind;\n(function(PotentialImportKind2) {\n  PotentialImportKind2[PotentialImportKind2[\"NgModule\"] = 0] = \"NgModule\";\n  PotentialImportKind2[PotentialImportKind2[\"Standalone\"] = 1] = \"Standalone\";\n})(PotentialImportKind || (PotentialImportKind = {}));\nvar PotentialImportMode;\n(function(PotentialImportMode2) {\n  PotentialImportMode2[PotentialImportMode2[\"Normal\"] = 0] = \"Normal\";\n  PotentialImportMode2[PotentialImportMode2[\"ForceDirect\"] = 1] = \"ForceDirect\";\n})(PotentialImportMode || (PotentialImportMode = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/api/completion.mjs\nvar CompletionKind;\n(function(CompletionKind2) {\n  CompletionKind2[CompletionKind2[\"Reference\"] = 0] = \"Reference\";\n  CompletionKind2[CompletionKind2[\"Variable\"] = 1] = \"Variable\";\n})(CompletionKind || (CompletionKind = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/api/symbols.mjs\nvar SymbolKind;\n(function(SymbolKind2) {\n  SymbolKind2[SymbolKind2[\"Input\"] = 0] = \"Input\";\n  SymbolKind2[SymbolKind2[\"Output\"] = 1] = \"Output\";\n  SymbolKind2[SymbolKind2[\"Binding\"] = 2] = \"Binding\";\n  SymbolKind2[SymbolKind2[\"Reference\"] = 3] = \"Reference\";\n  SymbolKind2[SymbolKind2[\"Variable\"] = 4] = \"Variable\";\n  SymbolKind2[SymbolKind2[\"Directive\"] = 5] = \"Directive\";\n  SymbolKind2[SymbolKind2[\"Element\"] = 6] = \"Element\";\n  SymbolKind2[SymbolKind2[\"Template\"] = 7] = \"Template\";\n  SymbolKind2[SymbolKind2[\"Expression\"] = 8] = \"Expression\";\n  SymbolKind2[SymbolKind2[\"DomBinding\"] = 9] = \"DomBinding\";\n  SymbolKind2[SymbolKind2[\"Pipe\"] = 10] = \"Pipe\";\n})(SymbolKind || (SymbolKind = {}));\n\nexport {\n  forwardRefResolver,\n  MetaKind,\n  CompoundMetadataReader,\n  DtsMetadataReader,\n  LocalMetadataRegistry,\n  CompoundMetadataRegistry,\n  ResourceRegistry,\n  ExportedProviderStatusResolver,\n  HostDirectivesResolver,\n  DynamicValue,\n  StaticInterpreter,\n  PartialEvaluator,\n  InjectableClassRegistry,\n  NoopReferencesRegistry,\n  SemanticDepGraphUpdater,\n  ComponentScopeKind,\n  CompoundComponentScopeReader,\n  MetadataDtsModuleScopeResolver,\n  LocalModuleScopeRegistry,\n  TypeCheckScopeRegistry,\n  CompilationMode,\n  aliasTransformFactory,\n  TraitCompiler,\n  DtsTransformRegistry,\n  declarationTransformFactory,\n  ivyTransformFactory,\n  DirectiveDecoratorHandler,\n  NgModuleDecoratorHandler,\n  ComponentDecoratorHandler,\n  InjectableDecoratorHandler,\n  PipeDecoratorHandler,\n  OptimizeFor,\n  CompletionKind,\n  PotentialImportKind,\n  PotentialImportMode,\n  SymbolKind\n};\n/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}