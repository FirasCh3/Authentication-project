{"ast":null,"code":"import { createRequire as __cjsCompatRequire } from 'module';\nconst require = __cjsCompatRequire(import.meta.url);\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/typescript.mjs\nimport ts4 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/host.mjs\nimport ts from \"typescript\";\nfunction isDecoratorIdentifier(exp) {\n  return ts.isIdentifier(exp) || ts.isPropertyAccessExpression(exp) && ts.isIdentifier(exp.expression) && ts.isIdentifier(exp.name);\n}\nvar ClassMemberKind;\n(function (ClassMemberKind2) {\n  ClassMemberKind2[ClassMemberKind2[\"Constructor\"] = 0] = \"Constructor\";\n  ClassMemberKind2[ClassMemberKind2[\"Getter\"] = 1] = \"Getter\";\n  ClassMemberKind2[ClassMemberKind2[\"Setter\"] = 2] = \"Setter\";\n  ClassMemberKind2[ClassMemberKind2[\"Property\"] = 3] = \"Property\";\n  ClassMemberKind2[ClassMemberKind2[\"Method\"] = 4] = \"Method\";\n})(ClassMemberKind || (ClassMemberKind = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/type_to_value.mjs\nimport ts2 from \"typescript\";\nfunction typeToValue(typeNode, checker) {\n  if (typeNode === null) {\n    return missingType();\n  }\n  if (!ts2.isTypeReferenceNode(typeNode)) {\n    return unsupportedType(typeNode);\n  }\n  const symbols = resolveTypeSymbols(typeNode, checker);\n  if (symbols === null) {\n    return unknownReference(typeNode);\n  }\n  const {\n    local,\n    decl\n  } = symbols;\n  if (decl.valueDeclaration === void 0 || decl.flags & ts2.SymbolFlags.ConstEnum) {\n    let typeOnlyDecl = null;\n    if (decl.declarations !== void 0 && decl.declarations.length > 0) {\n      typeOnlyDecl = decl.declarations[0];\n    }\n    return noValueDeclaration(typeNode, typeOnlyDecl);\n  }\n  const firstDecl = local.declarations && local.declarations[0];\n  if (firstDecl !== void 0) {\n    if (ts2.isImportClause(firstDecl) && firstDecl.name !== void 0) {\n      if (firstDecl.isTypeOnly) {\n        return typeOnlyImport(typeNode, firstDecl);\n      }\n      return {\n        kind: 0,\n        expression: firstDecl.name,\n        defaultImportStatement: firstDecl.parent\n      };\n    } else if (ts2.isImportSpecifier(firstDecl)) {\n      if (firstDecl.isTypeOnly) {\n        return typeOnlyImport(typeNode, firstDecl);\n      }\n      if (firstDecl.parent.parent.isTypeOnly) {\n        return typeOnlyImport(typeNode, firstDecl.parent.parent);\n      }\n      const importedName = (firstDecl.propertyName || firstDecl.name).text;\n      const [_localName, ...nestedPath] = symbols.symbolNames;\n      const moduleName = extractModuleName(firstDecl.parent.parent.parent);\n      return {\n        kind: 1,\n        valueDeclaration: decl.valueDeclaration,\n        moduleName,\n        importedName,\n        nestedPath\n      };\n    } else if (ts2.isNamespaceImport(firstDecl)) {\n      if (firstDecl.parent.isTypeOnly) {\n        return typeOnlyImport(typeNode, firstDecl.parent);\n      }\n      if (symbols.symbolNames.length === 1) {\n        return namespaceImport(typeNode, firstDecl.parent);\n      }\n      const [_ns, importedName, ...nestedPath] = symbols.symbolNames;\n      const moduleName = extractModuleName(firstDecl.parent.parent);\n      return {\n        kind: 1,\n        valueDeclaration: decl.valueDeclaration,\n        moduleName,\n        importedName,\n        nestedPath\n      };\n    }\n  }\n  const expression = typeNodeToValueExpr(typeNode);\n  if (expression !== null) {\n    return {\n      kind: 0,\n      expression,\n      defaultImportStatement: null\n    };\n  } else {\n    return unsupportedType(typeNode);\n  }\n}\nfunction unsupportedType(typeNode) {\n  return {\n    kind: 2,\n    reason: {\n      kind: 5,\n      typeNode\n    }\n  };\n}\nfunction noValueDeclaration(typeNode, decl) {\n  return {\n    kind: 2,\n    reason: {\n      kind: 1,\n      typeNode,\n      decl\n    }\n  };\n}\nfunction typeOnlyImport(typeNode, node) {\n  return {\n    kind: 2,\n    reason: {\n      kind: 2,\n      typeNode,\n      node\n    }\n  };\n}\nfunction unknownReference(typeNode) {\n  return {\n    kind: 2,\n    reason: {\n      kind: 3,\n      typeNode\n    }\n  };\n}\nfunction namespaceImport(typeNode, importClause) {\n  return {\n    kind: 2,\n    reason: {\n      kind: 4,\n      typeNode,\n      importClause\n    }\n  };\n}\nfunction missingType() {\n  return {\n    kind: 2,\n    reason: {\n      kind: 0\n    }\n  };\n}\nfunction typeNodeToValueExpr(node) {\n  if (ts2.isTypeReferenceNode(node)) {\n    return entityNameToValue(node.typeName);\n  } else {\n    return null;\n  }\n}\nfunction resolveTypeSymbols(typeRef, checker) {\n  const typeName = typeRef.typeName;\n  const typeRefSymbol = checker.getSymbolAtLocation(typeName);\n  if (typeRefSymbol === void 0) {\n    return null;\n  }\n  let local = typeRefSymbol;\n  let leftMost = typeName;\n  const symbolNames = [];\n  while (ts2.isQualifiedName(leftMost)) {\n    symbolNames.unshift(leftMost.right.text);\n    leftMost = leftMost.left;\n  }\n  symbolNames.unshift(leftMost.text);\n  if (leftMost !== typeName) {\n    const localTmp = checker.getSymbolAtLocation(leftMost);\n    if (localTmp !== void 0) {\n      local = localTmp;\n    }\n  }\n  let decl = typeRefSymbol;\n  if (typeRefSymbol.flags & ts2.SymbolFlags.Alias) {\n    decl = checker.getAliasedSymbol(typeRefSymbol);\n  }\n  return {\n    local,\n    decl,\n    symbolNames\n  };\n}\nfunction entityNameToValue(node) {\n  if (ts2.isQualifiedName(node)) {\n    const left = entityNameToValue(node.left);\n    return left !== null ? ts2.factory.createPropertyAccessExpression(left, node.right) : null;\n  } else if (ts2.isIdentifier(node)) {\n    const clone = ts2.setOriginalNode(ts2.factory.createIdentifier(node.text), node);\n    clone.parent = node.parent;\n    return clone;\n  } else {\n    return null;\n  }\n}\nfunction extractModuleName(node) {\n  if (!ts2.isStringLiteral(node.moduleSpecifier)) {\n    throw new Error(\"not a module specifier\");\n  }\n  return node.moduleSpecifier.text;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/util.mjs\nimport ts3 from \"typescript\";\nfunction isNamedClassDeclaration(node) {\n  return ts3.isClassDeclaration(node) && isIdentifier(node.name);\n}\nfunction isIdentifier(node) {\n  return node !== void 0 && ts3.isIdentifier(node);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/typescript.mjs\nvar TypeScriptReflectionHost = class {\n  constructor(checker) {\n    this.checker = checker;\n  }\n  getDecoratorsOfDeclaration(declaration) {\n    const decorators = ts4.canHaveDecorators(declaration) ? ts4.getDecorators(declaration) : void 0;\n    return decorators !== void 0 && decorators.length ? decorators.map(decorator => this._reflectDecorator(decorator)).filter(dec => dec !== null) : null;\n  }\n  getMembersOfClass(clazz) {\n    const tsClazz = castDeclarationToClassOrDie(clazz);\n    return tsClazz.members.map(member => this._reflectMember(member)).filter(member => member !== null);\n  }\n  getConstructorParameters(clazz) {\n    const tsClazz = castDeclarationToClassOrDie(clazz);\n    const isDeclaration = tsClazz.getSourceFile().isDeclarationFile;\n    const ctor = tsClazz.members.find(member => ts4.isConstructorDeclaration(member) && (isDeclaration || member.body !== void 0));\n    if (ctor === void 0) {\n      return null;\n    }\n    return ctor.parameters.map(node => {\n      const name = parameterName(node.name);\n      const decorators = this.getDecoratorsOfDeclaration(node);\n      let originalTypeNode = node.type || null;\n      let typeNode = originalTypeNode;\n      if (typeNode && ts4.isUnionTypeNode(typeNode)) {\n        let childTypeNodes = typeNode.types.filter(childTypeNode => !(ts4.isLiteralTypeNode(childTypeNode) && childTypeNode.literal.kind === ts4.SyntaxKind.NullKeyword));\n        if (childTypeNodes.length === 1) {\n          typeNode = childTypeNodes[0];\n        }\n      }\n      const typeValueReference = typeToValue(typeNode, this.checker);\n      return {\n        name,\n        nameNode: node.name,\n        typeValueReference,\n        typeNode: originalTypeNode,\n        decorators\n      };\n    });\n  }\n  getImportOfIdentifier(id) {\n    const directImport = this.getDirectImportOfIdentifier(id);\n    if (directImport !== null) {\n      return directImport;\n    } else if (ts4.isQualifiedName(id.parent) && id.parent.right === id) {\n      return this.getImportOfNamespacedIdentifier(id, getQualifiedNameRoot(id.parent));\n    } else if (ts4.isPropertyAccessExpression(id.parent) && id.parent.name === id) {\n      return this.getImportOfNamespacedIdentifier(id, getFarLeftIdentifier(id.parent));\n    } else {\n      return null;\n    }\n  }\n  getExportsOfModule(node) {\n    if (!ts4.isSourceFile(node)) {\n      throw new Error(`getExportsOfModule() called on non-SourceFile in TS code`);\n    }\n    const symbol = this.checker.getSymbolAtLocation(node);\n    if (symbol === void 0) {\n      return null;\n    }\n    const map = /* @__PURE__ */new Map();\n    this.checker.getExportsOfModule(symbol).forEach(exportSymbol => {\n      const decl = this.getDeclarationOfSymbol(exportSymbol, null);\n      if (decl !== null) {\n        map.set(exportSymbol.name, decl);\n      }\n    });\n    return map;\n  }\n  isClass(node) {\n    return isNamedClassDeclaration(node);\n  }\n  hasBaseClass(clazz) {\n    return this.getBaseClassExpression(clazz) !== null;\n  }\n  getBaseClassExpression(clazz) {\n    if (!(ts4.isClassDeclaration(clazz) || ts4.isClassExpression(clazz)) || clazz.heritageClauses === void 0) {\n      return null;\n    }\n    const extendsClause = clazz.heritageClauses.find(clause => clause.token === ts4.SyntaxKind.ExtendsKeyword);\n    if (extendsClause === void 0) {\n      return null;\n    }\n    const extendsType = extendsClause.types[0];\n    if (extendsType === void 0) {\n      return null;\n    }\n    return extendsType.expression;\n  }\n  getDeclarationOfIdentifier(id) {\n    let symbol = this.checker.getSymbolAtLocation(id);\n    if (symbol === void 0) {\n      return null;\n    }\n    return this.getDeclarationOfSymbol(symbol, id);\n  }\n  getDefinitionOfFunction(node) {\n    if (!ts4.isFunctionDeclaration(node) && !ts4.isMethodDeclaration(node) && !ts4.isFunctionExpression(node) && !ts4.isArrowFunction(node)) {\n      return null;\n    }\n    let body = null;\n    if (node.body !== void 0) {\n      body = ts4.isBlock(node.body) ? Array.from(node.body.statements) : [ts4.factory.createReturnStatement(node.body)];\n    }\n    const type = this.checker.getTypeAtLocation(node);\n    const signatures = this.checker.getSignaturesOfType(type, ts4.SignatureKind.Call);\n    return {\n      node,\n      body,\n      signatureCount: signatures.length,\n      typeParameters: node.typeParameters === void 0 ? null : Array.from(node.typeParameters),\n      parameters: node.parameters.map(param => {\n        const name = parameterName(param.name);\n        const initializer = param.initializer || null;\n        return {\n          name,\n          node: param,\n          initializer,\n          type: param.type || null\n        };\n      })\n    };\n  }\n  getGenericArityOfClass(clazz) {\n    if (!ts4.isClassDeclaration(clazz)) {\n      return null;\n    }\n    return clazz.typeParameters !== void 0 ? clazz.typeParameters.length : 0;\n  }\n  getVariableValue(declaration) {\n    return declaration.initializer || null;\n  }\n  isStaticallyExported(decl) {\n    let topLevel = decl;\n    if (ts4.isVariableDeclaration(decl) && ts4.isVariableDeclarationList(decl.parent)) {\n      topLevel = decl.parent.parent;\n    }\n    const modifiers = ts4.canHaveModifiers(topLevel) ? ts4.getModifiers(topLevel) : void 0;\n    if (modifiers !== void 0 && modifiers.some(modifier => modifier.kind === ts4.SyntaxKind.ExportKeyword)) {\n      return true;\n    }\n    if (topLevel.parent === void 0 || !ts4.isSourceFile(topLevel.parent)) {\n      return false;\n    }\n    const localExports = this.getLocalExportedDeclarationsOfSourceFile(decl.getSourceFile());\n    return localExports.has(decl);\n  }\n  getDirectImportOfIdentifier(id) {\n    const symbol = this.checker.getSymbolAtLocation(id);\n    if (symbol === void 0 || symbol.declarations === void 0 || symbol.declarations.length !== 1) {\n      return null;\n    }\n    const decl = symbol.declarations[0];\n    const importDecl = getContainingImportDeclaration(decl);\n    if (importDecl === null) {\n      return null;\n    }\n    if (!ts4.isStringLiteral(importDecl.moduleSpecifier)) {\n      return null;\n    }\n    return {\n      from: importDecl.moduleSpecifier.text,\n      name: getExportedName(decl, id)\n    };\n  }\n  getImportOfNamespacedIdentifier(id, namespaceIdentifier) {\n    if (namespaceIdentifier === null) {\n      return null;\n    }\n    const namespaceSymbol = this.checker.getSymbolAtLocation(namespaceIdentifier);\n    if (!namespaceSymbol || namespaceSymbol.declarations === void 0) {\n      return null;\n    }\n    const declaration = namespaceSymbol.declarations.length === 1 ? namespaceSymbol.declarations[0] : null;\n    if (!declaration) {\n      return null;\n    }\n    const namespaceDeclaration = ts4.isNamespaceImport(declaration) ? declaration : null;\n    if (!namespaceDeclaration) {\n      return null;\n    }\n    const importDeclaration = namespaceDeclaration.parent.parent;\n    if (!ts4.isStringLiteral(importDeclaration.moduleSpecifier)) {\n      return null;\n    }\n    return {\n      from: importDeclaration.moduleSpecifier.text,\n      name: id.text\n    };\n  }\n  getDeclarationOfSymbol(symbol, originalId) {\n    let valueDeclaration = void 0;\n    if (symbol.valueDeclaration !== void 0) {\n      valueDeclaration = symbol.valueDeclaration;\n    } else if (symbol.declarations !== void 0 && symbol.declarations.length > 0) {\n      valueDeclaration = symbol.declarations[0];\n    }\n    if (valueDeclaration !== void 0 && ts4.isShorthandPropertyAssignment(valueDeclaration)) {\n      const shorthandSymbol = this.checker.getShorthandAssignmentValueSymbol(valueDeclaration);\n      if (shorthandSymbol === void 0) {\n        return null;\n      }\n      return this.getDeclarationOfSymbol(shorthandSymbol, originalId);\n    } else if (valueDeclaration !== void 0 && ts4.isExportSpecifier(valueDeclaration)) {\n      const targetSymbol = this.checker.getExportSpecifierLocalTargetSymbol(valueDeclaration);\n      if (targetSymbol === void 0) {\n        return null;\n      }\n      return this.getDeclarationOfSymbol(targetSymbol, originalId);\n    }\n    const importInfo = originalId && this.getImportOfIdentifier(originalId);\n    const viaModule = importInfo !== null && importInfo.from !== null && !importInfo.from.startsWith(\".\") ? importInfo.from : null;\n    while (symbol.flags & ts4.SymbolFlags.Alias) {\n      symbol = this.checker.getAliasedSymbol(symbol);\n    }\n    if (symbol.valueDeclaration !== void 0) {\n      return {\n        node: symbol.valueDeclaration,\n        viaModule\n      };\n    } else if (symbol.declarations !== void 0 && symbol.declarations.length > 0) {\n      return {\n        node: symbol.declarations[0],\n        viaModule\n      };\n    } else {\n      return null;\n    }\n  }\n  _reflectDecorator(node) {\n    let decoratorExpr = node.expression;\n    let args = null;\n    if (ts4.isCallExpression(decoratorExpr)) {\n      args = Array.from(decoratorExpr.arguments);\n      decoratorExpr = decoratorExpr.expression;\n    }\n    if (!isDecoratorIdentifier(decoratorExpr)) {\n      return null;\n    }\n    const decoratorIdentifier = ts4.isIdentifier(decoratorExpr) ? decoratorExpr : decoratorExpr.name;\n    const importDecl = this.getImportOfIdentifier(decoratorIdentifier);\n    return {\n      name: decoratorIdentifier.text,\n      identifier: decoratorExpr,\n      import: importDecl,\n      node,\n      args\n    };\n  }\n  _reflectMember(node) {\n    let kind = null;\n    let value = null;\n    let name = null;\n    let nameNode = null;\n    if (ts4.isPropertyDeclaration(node)) {\n      kind = ClassMemberKind.Property;\n      value = node.initializer || null;\n    } else if (ts4.isGetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Getter;\n    } else if (ts4.isSetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Setter;\n    } else if (ts4.isMethodDeclaration(node)) {\n      kind = ClassMemberKind.Method;\n    } else if (ts4.isConstructorDeclaration(node)) {\n      kind = ClassMemberKind.Constructor;\n    } else {\n      return null;\n    }\n    if (ts4.isConstructorDeclaration(node)) {\n      name = \"constructor\";\n    } else if (ts4.isIdentifier(node.name)) {\n      name = node.name.text;\n      nameNode = node.name;\n    } else if (ts4.isStringLiteral(node.name)) {\n      name = node.name.text;\n      nameNode = node.name;\n    } else {\n      return null;\n    }\n    const decorators = this.getDecoratorsOfDeclaration(node);\n    const modifiers = ts4.getModifiers(node);\n    const isStatic = modifiers !== void 0 && modifiers.some(mod => mod.kind === ts4.SyntaxKind.StaticKeyword);\n    return {\n      node,\n      implementation: node,\n      kind,\n      type: node.type || null,\n      name,\n      nameNode,\n      decorators,\n      value,\n      isStatic\n    };\n  }\n  getLocalExportedDeclarationsOfSourceFile(file) {\n    const cacheSf = file;\n    if (cacheSf[LocalExportedDeclarations] !== void 0) {\n      return cacheSf[LocalExportedDeclarations];\n    }\n    const exportSet = /* @__PURE__ */new Set();\n    cacheSf[LocalExportedDeclarations] = exportSet;\n    const sfSymbol = this.checker.getSymbolAtLocation(cacheSf);\n    if (sfSymbol === void 0 || sfSymbol.exports === void 0) {\n      return exportSet;\n    }\n    const iter = sfSymbol.exports.values();\n    let item = iter.next();\n    while (item.done !== true) {\n      let exportedSymbol = item.value;\n      if (exportedSymbol.flags & ts4.SymbolFlags.Alias) {\n        exportedSymbol = this.checker.getAliasedSymbol(exportedSymbol);\n      }\n      if (exportedSymbol.valueDeclaration !== void 0 && exportedSymbol.valueDeclaration.getSourceFile() === file) {\n        exportSet.add(exportedSymbol.valueDeclaration);\n      }\n      item = iter.next();\n    }\n    return exportSet;\n  }\n};\nfunction reflectTypeEntityToDeclaration(type, checker) {\n  let realSymbol = checker.getSymbolAtLocation(type);\n  if (realSymbol === void 0) {\n    throw new Error(`Cannot resolve type entity ${type.getText()} to symbol`);\n  }\n  while (realSymbol.flags & ts4.SymbolFlags.Alias) {\n    realSymbol = checker.getAliasedSymbol(realSymbol);\n  }\n  let node = null;\n  if (realSymbol.valueDeclaration !== void 0) {\n    node = realSymbol.valueDeclaration;\n  } else if (realSymbol.declarations !== void 0 && realSymbol.declarations.length === 1) {\n    node = realSymbol.declarations[0];\n  } else {\n    throw new Error(`Cannot resolve type entity symbol to declaration`);\n  }\n  if (ts4.isQualifiedName(type)) {\n    if (!ts4.isIdentifier(type.left)) {\n      throw new Error(`Cannot handle qualified name with non-identifier lhs`);\n    }\n    const symbol = checker.getSymbolAtLocation(type.left);\n    if (symbol === void 0 || symbol.declarations === void 0 || symbol.declarations.length !== 1) {\n      throw new Error(`Cannot resolve qualified type entity lhs to symbol`);\n    }\n    const decl = symbol.declarations[0];\n    if (ts4.isNamespaceImport(decl)) {\n      const clause = decl.parent;\n      const importDecl = clause.parent;\n      if (!ts4.isStringLiteral(importDecl.moduleSpecifier)) {\n        throw new Error(`Module specifier is not a string`);\n      }\n      return {\n        node,\n        from: importDecl.moduleSpecifier.text\n      };\n    } else if (ts4.isModuleDeclaration(decl)) {\n      return {\n        node,\n        from: null\n      };\n    } else {\n      throw new Error(`Unknown import type?`);\n    }\n  } else {\n    return {\n      node,\n      from: null\n    };\n  }\n}\nfunction filterToMembersWithDecorator(members, name, module) {\n  return members.filter(member => !member.isStatic).map(member => {\n    if (member.decorators === null) {\n      return null;\n    }\n    const decorators = member.decorators.filter(dec => {\n      if (dec.import !== null) {\n        return dec.import.name === name && (module === void 0 || dec.import.from === module);\n      } else {\n        return dec.name === name && module === void 0;\n      }\n    });\n    if (decorators.length === 0) {\n      return null;\n    }\n    return {\n      member,\n      decorators\n    };\n  }).filter(value => value !== null);\n}\nfunction reflectObjectLiteral(node) {\n  const map = /* @__PURE__ */new Map();\n  node.properties.forEach(prop => {\n    if (ts4.isPropertyAssignment(prop)) {\n      const name = propertyNameToString(prop.name);\n      if (name === null) {\n        return;\n      }\n      map.set(name, prop.initializer);\n    } else if (ts4.isShorthandPropertyAssignment(prop)) {\n      map.set(prop.name.text, prop.name);\n    } else {\n      return;\n    }\n  });\n  return map;\n}\nfunction castDeclarationToClassOrDie(declaration) {\n  if (!ts4.isClassDeclaration(declaration)) {\n    throw new Error(`Reflecting on a ${ts4.SyntaxKind[declaration.kind]} instead of a ClassDeclaration.`);\n  }\n  return declaration;\n}\nfunction parameterName(name) {\n  if (ts4.isIdentifier(name)) {\n    return name.text;\n  } else {\n    return null;\n  }\n}\nfunction propertyNameToString(node) {\n  if (ts4.isIdentifier(node) || ts4.isStringLiteral(node) || ts4.isNumericLiteral(node)) {\n    return node.text;\n  } else {\n    return null;\n  }\n}\nfunction getQualifiedNameRoot(qualifiedName) {\n  while (ts4.isQualifiedName(qualifiedName.left)) {\n    qualifiedName = qualifiedName.left;\n  }\n  return ts4.isIdentifier(qualifiedName.left) ? qualifiedName.left : null;\n}\nfunction getFarLeftIdentifier(propertyAccess) {\n  while (ts4.isPropertyAccessExpression(propertyAccess.expression)) {\n    propertyAccess = propertyAccess.expression;\n  }\n  return ts4.isIdentifier(propertyAccess.expression) ? propertyAccess.expression : null;\n}\nfunction getContainingImportDeclaration(node) {\n  return ts4.isImportSpecifier(node) ? node.parent.parent.parent : ts4.isNamespaceImport(node) ? node.parent.parent : null;\n}\nfunction getExportedName(decl, originalId) {\n  return ts4.isImportSpecifier(decl) ? (decl.propertyName !== void 0 ? decl.propertyName : decl.name).text : originalId.text;\n}\nvar LocalExportedDeclarations = Symbol(\"LocalExportedDeclarations\");\nexport { ClassMemberKind, typeNodeToValueExpr, isNamedClassDeclaration, TypeScriptReflectionHost, reflectTypeEntityToDeclaration, filterToMembersWithDecorator, reflectObjectLiteral };\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */","map":{"version":3,"names":["createRequire","__cjsCompatRequire","require","import","meta","url","ts4","ts","isDecoratorIdentifier","exp","isIdentifier","isPropertyAccessExpression","expression","name","ClassMemberKind","ClassMemberKind2","ts2","typeToValue","typeNode","checker","missingType","isTypeReferenceNode","unsupportedType","symbols","resolveTypeSymbols","unknownReference","local","decl","valueDeclaration","flags","SymbolFlags","ConstEnum","typeOnlyDecl","declarations","length","noValueDeclaration","firstDecl","isImportClause","isTypeOnly","typeOnlyImport","kind","defaultImportStatement","parent","isImportSpecifier","importedName","propertyName","text","_localName","nestedPath","symbolNames","moduleName","extractModuleName","isNamespaceImport","namespaceImport","_ns","typeNodeToValueExpr","reason","node","importClause","entityNameToValue","typeName","typeRef","typeRefSymbol","getSymbolAtLocation","leftMost","isQualifiedName","unshift","right","left","localTmp","Alias","getAliasedSymbol","factory","createPropertyAccessExpression","clone","setOriginalNode","createIdentifier","isStringLiteral","moduleSpecifier","Error","ts3","isNamedClassDeclaration","isClassDeclaration","TypeScriptReflectionHost","constructor","getDecoratorsOfDeclaration","declaration","decorators","canHaveDecorators","getDecorators","map","decorator","_reflectDecorator","filter","dec","getMembersOfClass","clazz","tsClazz","castDeclarationToClassOrDie","members","member","_reflectMember","getConstructorParameters","isDeclaration","getSourceFile","isDeclarationFile","ctor","find","isConstructorDeclaration","body","parameters","parameterName","originalTypeNode","type","isUnionTypeNode","childTypeNodes","types","childTypeNode","isLiteralTypeNode","literal","SyntaxKind","NullKeyword","typeValueReference","nameNode","getImportOfIdentifier","id","directImport","getDirectImportOfIdentifier","getImportOfNamespacedIdentifier","getQualifiedNameRoot","getFarLeftIdentifier","getExportsOfModule","isSourceFile","symbol","Map","forEach","exportSymbol","getDeclarationOfSymbol","set","isClass","hasBaseClass","getBaseClassExpression","isClassExpression","heritageClauses","extendsClause","clause","token","ExtendsKeyword","extendsType","getDeclarationOfIdentifier","getDefinitionOfFunction","isFunctionDeclaration","isMethodDeclaration","isFunctionExpression","isArrowFunction","isBlock","Array","from","statements","createReturnStatement","getTypeAtLocation","signatures","getSignaturesOfType","SignatureKind","Call","signatureCount","typeParameters","param","initializer","getGenericArityOfClass","getVariableValue","isStaticallyExported","topLevel","isVariableDeclaration","isVariableDeclarationList","modifiers","canHaveModifiers","getModifiers","some","modifier","ExportKeyword","localExports","getLocalExportedDeclarationsOfSourceFile","has","importDecl","getContainingImportDeclaration","getExportedName","namespaceIdentifier","namespaceSymbol","namespaceDeclaration","importDeclaration","originalId","isShorthandPropertyAssignment","shorthandSymbol","getShorthandAssignmentValueSymbol","isExportSpecifier","targetSymbol","getExportSpecifierLocalTargetSymbol","importInfo","viaModule","startsWith","decoratorExpr","args","isCallExpression","arguments","decoratorIdentifier","identifier","value","isPropertyDeclaration","Property","isGetAccessorDeclaration","Getter","isSetAccessorDeclaration","Setter","Method","Constructor","isStatic","mod","StaticKeyword","implementation","file","cacheSf","LocalExportedDeclarations","exportSet","Set","sfSymbol","exports","iter","values","item","next","done","exportedSymbol","add","reflectTypeEntityToDeclaration","realSymbol","getText","isModuleDeclaration","filterToMembersWithDecorator","module","reflectObjectLiteral","properties","prop","isPropertyAssignment","propertyNameToString","isNumericLiteral","qualifiedName","propertyAccess","Symbol"],"sources":["C:/Users/user/Desktop/SpringBootProject/src/main/resources/my-app/node_modules/@angular/compiler-cli/bundles/chunk-OIJPCKRW.js"],"sourcesContent":["\n      import {createRequire as __cjsCompatRequire} from 'module';\n      const require = __cjsCompatRequire(import.meta.url);\n    \n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/typescript.mjs\nimport ts4 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/host.mjs\nimport ts from \"typescript\";\nfunction isDecoratorIdentifier(exp) {\n  return ts.isIdentifier(exp) || ts.isPropertyAccessExpression(exp) && ts.isIdentifier(exp.expression) && ts.isIdentifier(exp.name);\n}\nvar ClassMemberKind;\n(function(ClassMemberKind2) {\n  ClassMemberKind2[ClassMemberKind2[\"Constructor\"] = 0] = \"Constructor\";\n  ClassMemberKind2[ClassMemberKind2[\"Getter\"] = 1] = \"Getter\";\n  ClassMemberKind2[ClassMemberKind2[\"Setter\"] = 2] = \"Setter\";\n  ClassMemberKind2[ClassMemberKind2[\"Property\"] = 3] = \"Property\";\n  ClassMemberKind2[ClassMemberKind2[\"Method\"] = 4] = \"Method\";\n})(ClassMemberKind || (ClassMemberKind = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/type_to_value.mjs\nimport ts2 from \"typescript\";\nfunction typeToValue(typeNode, checker) {\n  if (typeNode === null) {\n    return missingType();\n  }\n  if (!ts2.isTypeReferenceNode(typeNode)) {\n    return unsupportedType(typeNode);\n  }\n  const symbols = resolveTypeSymbols(typeNode, checker);\n  if (symbols === null) {\n    return unknownReference(typeNode);\n  }\n  const { local, decl } = symbols;\n  if (decl.valueDeclaration === void 0 || decl.flags & ts2.SymbolFlags.ConstEnum) {\n    let typeOnlyDecl = null;\n    if (decl.declarations !== void 0 && decl.declarations.length > 0) {\n      typeOnlyDecl = decl.declarations[0];\n    }\n    return noValueDeclaration(typeNode, typeOnlyDecl);\n  }\n  const firstDecl = local.declarations && local.declarations[0];\n  if (firstDecl !== void 0) {\n    if (ts2.isImportClause(firstDecl) && firstDecl.name !== void 0) {\n      if (firstDecl.isTypeOnly) {\n        return typeOnlyImport(typeNode, firstDecl);\n      }\n      return {\n        kind: 0,\n        expression: firstDecl.name,\n        defaultImportStatement: firstDecl.parent\n      };\n    } else if (ts2.isImportSpecifier(firstDecl)) {\n      if (firstDecl.isTypeOnly) {\n        return typeOnlyImport(typeNode, firstDecl);\n      }\n      if (firstDecl.parent.parent.isTypeOnly) {\n        return typeOnlyImport(typeNode, firstDecl.parent.parent);\n      }\n      const importedName = (firstDecl.propertyName || firstDecl.name).text;\n      const [_localName, ...nestedPath] = symbols.symbolNames;\n      const moduleName = extractModuleName(firstDecl.parent.parent.parent);\n      return {\n        kind: 1,\n        valueDeclaration: decl.valueDeclaration,\n        moduleName,\n        importedName,\n        nestedPath\n      };\n    } else if (ts2.isNamespaceImport(firstDecl)) {\n      if (firstDecl.parent.isTypeOnly) {\n        return typeOnlyImport(typeNode, firstDecl.parent);\n      }\n      if (symbols.symbolNames.length === 1) {\n        return namespaceImport(typeNode, firstDecl.parent);\n      }\n      const [_ns, importedName, ...nestedPath] = symbols.symbolNames;\n      const moduleName = extractModuleName(firstDecl.parent.parent);\n      return {\n        kind: 1,\n        valueDeclaration: decl.valueDeclaration,\n        moduleName,\n        importedName,\n        nestedPath\n      };\n    }\n  }\n  const expression = typeNodeToValueExpr(typeNode);\n  if (expression !== null) {\n    return {\n      kind: 0,\n      expression,\n      defaultImportStatement: null\n    };\n  } else {\n    return unsupportedType(typeNode);\n  }\n}\nfunction unsupportedType(typeNode) {\n  return {\n    kind: 2,\n    reason: { kind: 5, typeNode }\n  };\n}\nfunction noValueDeclaration(typeNode, decl) {\n  return {\n    kind: 2,\n    reason: { kind: 1, typeNode, decl }\n  };\n}\nfunction typeOnlyImport(typeNode, node) {\n  return {\n    kind: 2,\n    reason: { kind: 2, typeNode, node }\n  };\n}\nfunction unknownReference(typeNode) {\n  return {\n    kind: 2,\n    reason: { kind: 3, typeNode }\n  };\n}\nfunction namespaceImport(typeNode, importClause) {\n  return {\n    kind: 2,\n    reason: { kind: 4, typeNode, importClause }\n  };\n}\nfunction missingType() {\n  return {\n    kind: 2,\n    reason: { kind: 0 }\n  };\n}\nfunction typeNodeToValueExpr(node) {\n  if (ts2.isTypeReferenceNode(node)) {\n    return entityNameToValue(node.typeName);\n  } else {\n    return null;\n  }\n}\nfunction resolveTypeSymbols(typeRef, checker) {\n  const typeName = typeRef.typeName;\n  const typeRefSymbol = checker.getSymbolAtLocation(typeName);\n  if (typeRefSymbol === void 0) {\n    return null;\n  }\n  let local = typeRefSymbol;\n  let leftMost = typeName;\n  const symbolNames = [];\n  while (ts2.isQualifiedName(leftMost)) {\n    symbolNames.unshift(leftMost.right.text);\n    leftMost = leftMost.left;\n  }\n  symbolNames.unshift(leftMost.text);\n  if (leftMost !== typeName) {\n    const localTmp = checker.getSymbolAtLocation(leftMost);\n    if (localTmp !== void 0) {\n      local = localTmp;\n    }\n  }\n  let decl = typeRefSymbol;\n  if (typeRefSymbol.flags & ts2.SymbolFlags.Alias) {\n    decl = checker.getAliasedSymbol(typeRefSymbol);\n  }\n  return { local, decl, symbolNames };\n}\nfunction entityNameToValue(node) {\n  if (ts2.isQualifiedName(node)) {\n    const left = entityNameToValue(node.left);\n    return left !== null ? ts2.factory.createPropertyAccessExpression(left, node.right) : null;\n  } else if (ts2.isIdentifier(node)) {\n    const clone = ts2.setOriginalNode(ts2.factory.createIdentifier(node.text), node);\n    clone.parent = node.parent;\n    return clone;\n  } else {\n    return null;\n  }\n}\nfunction extractModuleName(node) {\n  if (!ts2.isStringLiteral(node.moduleSpecifier)) {\n    throw new Error(\"not a module specifier\");\n  }\n  return node.moduleSpecifier.text;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/util.mjs\nimport ts3 from \"typescript\";\nfunction isNamedClassDeclaration(node) {\n  return ts3.isClassDeclaration(node) && isIdentifier(node.name);\n}\nfunction isIdentifier(node) {\n  return node !== void 0 && ts3.isIdentifier(node);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/reflection/src/typescript.mjs\nvar TypeScriptReflectionHost = class {\n  constructor(checker) {\n    this.checker = checker;\n  }\n  getDecoratorsOfDeclaration(declaration) {\n    const decorators = ts4.canHaveDecorators(declaration) ? ts4.getDecorators(declaration) : void 0;\n    return decorators !== void 0 && decorators.length ? decorators.map((decorator) => this._reflectDecorator(decorator)).filter((dec) => dec !== null) : null;\n  }\n  getMembersOfClass(clazz) {\n    const tsClazz = castDeclarationToClassOrDie(clazz);\n    return tsClazz.members.map((member) => this._reflectMember(member)).filter((member) => member !== null);\n  }\n  getConstructorParameters(clazz) {\n    const tsClazz = castDeclarationToClassOrDie(clazz);\n    const isDeclaration = tsClazz.getSourceFile().isDeclarationFile;\n    const ctor = tsClazz.members.find((member) => ts4.isConstructorDeclaration(member) && (isDeclaration || member.body !== void 0));\n    if (ctor === void 0) {\n      return null;\n    }\n    return ctor.parameters.map((node) => {\n      const name = parameterName(node.name);\n      const decorators = this.getDecoratorsOfDeclaration(node);\n      let originalTypeNode = node.type || null;\n      let typeNode = originalTypeNode;\n      if (typeNode && ts4.isUnionTypeNode(typeNode)) {\n        let childTypeNodes = typeNode.types.filter((childTypeNode) => !(ts4.isLiteralTypeNode(childTypeNode) && childTypeNode.literal.kind === ts4.SyntaxKind.NullKeyword));\n        if (childTypeNodes.length === 1) {\n          typeNode = childTypeNodes[0];\n        }\n      }\n      const typeValueReference = typeToValue(typeNode, this.checker);\n      return {\n        name,\n        nameNode: node.name,\n        typeValueReference,\n        typeNode: originalTypeNode,\n        decorators\n      };\n    });\n  }\n  getImportOfIdentifier(id) {\n    const directImport = this.getDirectImportOfIdentifier(id);\n    if (directImport !== null) {\n      return directImport;\n    } else if (ts4.isQualifiedName(id.parent) && id.parent.right === id) {\n      return this.getImportOfNamespacedIdentifier(id, getQualifiedNameRoot(id.parent));\n    } else if (ts4.isPropertyAccessExpression(id.parent) && id.parent.name === id) {\n      return this.getImportOfNamespacedIdentifier(id, getFarLeftIdentifier(id.parent));\n    } else {\n      return null;\n    }\n  }\n  getExportsOfModule(node) {\n    if (!ts4.isSourceFile(node)) {\n      throw new Error(`getExportsOfModule() called on non-SourceFile in TS code`);\n    }\n    const symbol = this.checker.getSymbolAtLocation(node);\n    if (symbol === void 0) {\n      return null;\n    }\n    const map = /* @__PURE__ */ new Map();\n    this.checker.getExportsOfModule(symbol).forEach((exportSymbol) => {\n      const decl = this.getDeclarationOfSymbol(exportSymbol, null);\n      if (decl !== null) {\n        map.set(exportSymbol.name, decl);\n      }\n    });\n    return map;\n  }\n  isClass(node) {\n    return isNamedClassDeclaration(node);\n  }\n  hasBaseClass(clazz) {\n    return this.getBaseClassExpression(clazz) !== null;\n  }\n  getBaseClassExpression(clazz) {\n    if (!(ts4.isClassDeclaration(clazz) || ts4.isClassExpression(clazz)) || clazz.heritageClauses === void 0) {\n      return null;\n    }\n    const extendsClause = clazz.heritageClauses.find((clause) => clause.token === ts4.SyntaxKind.ExtendsKeyword);\n    if (extendsClause === void 0) {\n      return null;\n    }\n    const extendsType = extendsClause.types[0];\n    if (extendsType === void 0) {\n      return null;\n    }\n    return extendsType.expression;\n  }\n  getDeclarationOfIdentifier(id) {\n    let symbol = this.checker.getSymbolAtLocation(id);\n    if (symbol === void 0) {\n      return null;\n    }\n    return this.getDeclarationOfSymbol(symbol, id);\n  }\n  getDefinitionOfFunction(node) {\n    if (!ts4.isFunctionDeclaration(node) && !ts4.isMethodDeclaration(node) && !ts4.isFunctionExpression(node) && !ts4.isArrowFunction(node)) {\n      return null;\n    }\n    let body = null;\n    if (node.body !== void 0) {\n      body = ts4.isBlock(node.body) ? Array.from(node.body.statements) : [ts4.factory.createReturnStatement(node.body)];\n    }\n    const type = this.checker.getTypeAtLocation(node);\n    const signatures = this.checker.getSignaturesOfType(type, ts4.SignatureKind.Call);\n    return {\n      node,\n      body,\n      signatureCount: signatures.length,\n      typeParameters: node.typeParameters === void 0 ? null : Array.from(node.typeParameters),\n      parameters: node.parameters.map((param) => {\n        const name = parameterName(param.name);\n        const initializer = param.initializer || null;\n        return { name, node: param, initializer, type: param.type || null };\n      })\n    };\n  }\n  getGenericArityOfClass(clazz) {\n    if (!ts4.isClassDeclaration(clazz)) {\n      return null;\n    }\n    return clazz.typeParameters !== void 0 ? clazz.typeParameters.length : 0;\n  }\n  getVariableValue(declaration) {\n    return declaration.initializer || null;\n  }\n  isStaticallyExported(decl) {\n    let topLevel = decl;\n    if (ts4.isVariableDeclaration(decl) && ts4.isVariableDeclarationList(decl.parent)) {\n      topLevel = decl.parent.parent;\n    }\n    const modifiers = ts4.canHaveModifiers(topLevel) ? ts4.getModifiers(topLevel) : void 0;\n    if (modifiers !== void 0 && modifiers.some((modifier) => modifier.kind === ts4.SyntaxKind.ExportKeyword)) {\n      return true;\n    }\n    if (topLevel.parent === void 0 || !ts4.isSourceFile(topLevel.parent)) {\n      return false;\n    }\n    const localExports = this.getLocalExportedDeclarationsOfSourceFile(decl.getSourceFile());\n    return localExports.has(decl);\n  }\n  getDirectImportOfIdentifier(id) {\n    const symbol = this.checker.getSymbolAtLocation(id);\n    if (symbol === void 0 || symbol.declarations === void 0 || symbol.declarations.length !== 1) {\n      return null;\n    }\n    const decl = symbol.declarations[0];\n    const importDecl = getContainingImportDeclaration(decl);\n    if (importDecl === null) {\n      return null;\n    }\n    if (!ts4.isStringLiteral(importDecl.moduleSpecifier)) {\n      return null;\n    }\n    return { from: importDecl.moduleSpecifier.text, name: getExportedName(decl, id) };\n  }\n  getImportOfNamespacedIdentifier(id, namespaceIdentifier) {\n    if (namespaceIdentifier === null) {\n      return null;\n    }\n    const namespaceSymbol = this.checker.getSymbolAtLocation(namespaceIdentifier);\n    if (!namespaceSymbol || namespaceSymbol.declarations === void 0) {\n      return null;\n    }\n    const declaration = namespaceSymbol.declarations.length === 1 ? namespaceSymbol.declarations[0] : null;\n    if (!declaration) {\n      return null;\n    }\n    const namespaceDeclaration = ts4.isNamespaceImport(declaration) ? declaration : null;\n    if (!namespaceDeclaration) {\n      return null;\n    }\n    const importDeclaration = namespaceDeclaration.parent.parent;\n    if (!ts4.isStringLiteral(importDeclaration.moduleSpecifier)) {\n      return null;\n    }\n    return {\n      from: importDeclaration.moduleSpecifier.text,\n      name: id.text\n    };\n  }\n  getDeclarationOfSymbol(symbol, originalId) {\n    let valueDeclaration = void 0;\n    if (symbol.valueDeclaration !== void 0) {\n      valueDeclaration = symbol.valueDeclaration;\n    } else if (symbol.declarations !== void 0 && symbol.declarations.length > 0) {\n      valueDeclaration = symbol.declarations[0];\n    }\n    if (valueDeclaration !== void 0 && ts4.isShorthandPropertyAssignment(valueDeclaration)) {\n      const shorthandSymbol = this.checker.getShorthandAssignmentValueSymbol(valueDeclaration);\n      if (shorthandSymbol === void 0) {\n        return null;\n      }\n      return this.getDeclarationOfSymbol(shorthandSymbol, originalId);\n    } else if (valueDeclaration !== void 0 && ts4.isExportSpecifier(valueDeclaration)) {\n      const targetSymbol = this.checker.getExportSpecifierLocalTargetSymbol(valueDeclaration);\n      if (targetSymbol === void 0) {\n        return null;\n      }\n      return this.getDeclarationOfSymbol(targetSymbol, originalId);\n    }\n    const importInfo = originalId && this.getImportOfIdentifier(originalId);\n    const viaModule = importInfo !== null && importInfo.from !== null && !importInfo.from.startsWith(\".\") ? importInfo.from : null;\n    while (symbol.flags & ts4.SymbolFlags.Alias) {\n      symbol = this.checker.getAliasedSymbol(symbol);\n    }\n    if (symbol.valueDeclaration !== void 0) {\n      return {\n        node: symbol.valueDeclaration,\n        viaModule\n      };\n    } else if (symbol.declarations !== void 0 && symbol.declarations.length > 0) {\n      return {\n        node: symbol.declarations[0],\n        viaModule\n      };\n    } else {\n      return null;\n    }\n  }\n  _reflectDecorator(node) {\n    let decoratorExpr = node.expression;\n    let args = null;\n    if (ts4.isCallExpression(decoratorExpr)) {\n      args = Array.from(decoratorExpr.arguments);\n      decoratorExpr = decoratorExpr.expression;\n    }\n    if (!isDecoratorIdentifier(decoratorExpr)) {\n      return null;\n    }\n    const decoratorIdentifier = ts4.isIdentifier(decoratorExpr) ? decoratorExpr : decoratorExpr.name;\n    const importDecl = this.getImportOfIdentifier(decoratorIdentifier);\n    return {\n      name: decoratorIdentifier.text,\n      identifier: decoratorExpr,\n      import: importDecl,\n      node,\n      args\n    };\n  }\n  _reflectMember(node) {\n    let kind = null;\n    let value = null;\n    let name = null;\n    let nameNode = null;\n    if (ts4.isPropertyDeclaration(node)) {\n      kind = ClassMemberKind.Property;\n      value = node.initializer || null;\n    } else if (ts4.isGetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Getter;\n    } else if (ts4.isSetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Setter;\n    } else if (ts4.isMethodDeclaration(node)) {\n      kind = ClassMemberKind.Method;\n    } else if (ts4.isConstructorDeclaration(node)) {\n      kind = ClassMemberKind.Constructor;\n    } else {\n      return null;\n    }\n    if (ts4.isConstructorDeclaration(node)) {\n      name = \"constructor\";\n    } else if (ts4.isIdentifier(node.name)) {\n      name = node.name.text;\n      nameNode = node.name;\n    } else if (ts4.isStringLiteral(node.name)) {\n      name = node.name.text;\n      nameNode = node.name;\n    } else {\n      return null;\n    }\n    const decorators = this.getDecoratorsOfDeclaration(node);\n    const modifiers = ts4.getModifiers(node);\n    const isStatic = modifiers !== void 0 && modifiers.some((mod) => mod.kind === ts4.SyntaxKind.StaticKeyword);\n    return {\n      node,\n      implementation: node,\n      kind,\n      type: node.type || null,\n      name,\n      nameNode,\n      decorators,\n      value,\n      isStatic\n    };\n  }\n  getLocalExportedDeclarationsOfSourceFile(file) {\n    const cacheSf = file;\n    if (cacheSf[LocalExportedDeclarations] !== void 0) {\n      return cacheSf[LocalExportedDeclarations];\n    }\n    const exportSet = /* @__PURE__ */ new Set();\n    cacheSf[LocalExportedDeclarations] = exportSet;\n    const sfSymbol = this.checker.getSymbolAtLocation(cacheSf);\n    if (sfSymbol === void 0 || sfSymbol.exports === void 0) {\n      return exportSet;\n    }\n    const iter = sfSymbol.exports.values();\n    let item = iter.next();\n    while (item.done !== true) {\n      let exportedSymbol = item.value;\n      if (exportedSymbol.flags & ts4.SymbolFlags.Alias) {\n        exportedSymbol = this.checker.getAliasedSymbol(exportedSymbol);\n      }\n      if (exportedSymbol.valueDeclaration !== void 0 && exportedSymbol.valueDeclaration.getSourceFile() === file) {\n        exportSet.add(exportedSymbol.valueDeclaration);\n      }\n      item = iter.next();\n    }\n    return exportSet;\n  }\n};\nfunction reflectTypeEntityToDeclaration(type, checker) {\n  let realSymbol = checker.getSymbolAtLocation(type);\n  if (realSymbol === void 0) {\n    throw new Error(`Cannot resolve type entity ${type.getText()} to symbol`);\n  }\n  while (realSymbol.flags & ts4.SymbolFlags.Alias) {\n    realSymbol = checker.getAliasedSymbol(realSymbol);\n  }\n  let node = null;\n  if (realSymbol.valueDeclaration !== void 0) {\n    node = realSymbol.valueDeclaration;\n  } else if (realSymbol.declarations !== void 0 && realSymbol.declarations.length === 1) {\n    node = realSymbol.declarations[0];\n  } else {\n    throw new Error(`Cannot resolve type entity symbol to declaration`);\n  }\n  if (ts4.isQualifiedName(type)) {\n    if (!ts4.isIdentifier(type.left)) {\n      throw new Error(`Cannot handle qualified name with non-identifier lhs`);\n    }\n    const symbol = checker.getSymbolAtLocation(type.left);\n    if (symbol === void 0 || symbol.declarations === void 0 || symbol.declarations.length !== 1) {\n      throw new Error(`Cannot resolve qualified type entity lhs to symbol`);\n    }\n    const decl = symbol.declarations[0];\n    if (ts4.isNamespaceImport(decl)) {\n      const clause = decl.parent;\n      const importDecl = clause.parent;\n      if (!ts4.isStringLiteral(importDecl.moduleSpecifier)) {\n        throw new Error(`Module specifier is not a string`);\n      }\n      return { node, from: importDecl.moduleSpecifier.text };\n    } else if (ts4.isModuleDeclaration(decl)) {\n      return { node, from: null };\n    } else {\n      throw new Error(`Unknown import type?`);\n    }\n  } else {\n    return { node, from: null };\n  }\n}\nfunction filterToMembersWithDecorator(members, name, module) {\n  return members.filter((member) => !member.isStatic).map((member) => {\n    if (member.decorators === null) {\n      return null;\n    }\n    const decorators = member.decorators.filter((dec) => {\n      if (dec.import !== null) {\n        return dec.import.name === name && (module === void 0 || dec.import.from === module);\n      } else {\n        return dec.name === name && module === void 0;\n      }\n    });\n    if (decorators.length === 0) {\n      return null;\n    }\n    return { member, decorators };\n  }).filter((value) => value !== null);\n}\nfunction reflectObjectLiteral(node) {\n  const map = /* @__PURE__ */ new Map();\n  node.properties.forEach((prop) => {\n    if (ts4.isPropertyAssignment(prop)) {\n      const name = propertyNameToString(prop.name);\n      if (name === null) {\n        return;\n      }\n      map.set(name, prop.initializer);\n    } else if (ts4.isShorthandPropertyAssignment(prop)) {\n      map.set(prop.name.text, prop.name);\n    } else {\n      return;\n    }\n  });\n  return map;\n}\nfunction castDeclarationToClassOrDie(declaration) {\n  if (!ts4.isClassDeclaration(declaration)) {\n    throw new Error(`Reflecting on a ${ts4.SyntaxKind[declaration.kind]} instead of a ClassDeclaration.`);\n  }\n  return declaration;\n}\nfunction parameterName(name) {\n  if (ts4.isIdentifier(name)) {\n    return name.text;\n  } else {\n    return null;\n  }\n}\nfunction propertyNameToString(node) {\n  if (ts4.isIdentifier(node) || ts4.isStringLiteral(node) || ts4.isNumericLiteral(node)) {\n    return node.text;\n  } else {\n    return null;\n  }\n}\nfunction getQualifiedNameRoot(qualifiedName) {\n  while (ts4.isQualifiedName(qualifiedName.left)) {\n    qualifiedName = qualifiedName.left;\n  }\n  return ts4.isIdentifier(qualifiedName.left) ? qualifiedName.left : null;\n}\nfunction getFarLeftIdentifier(propertyAccess) {\n  while (ts4.isPropertyAccessExpression(propertyAccess.expression)) {\n    propertyAccess = propertyAccess.expression;\n  }\n  return ts4.isIdentifier(propertyAccess.expression) ? propertyAccess.expression : null;\n}\nfunction getContainingImportDeclaration(node) {\n  return ts4.isImportSpecifier(node) ? node.parent.parent.parent : ts4.isNamespaceImport(node) ? node.parent.parent : null;\n}\nfunction getExportedName(decl, originalId) {\n  return ts4.isImportSpecifier(decl) ? (decl.propertyName !== void 0 ? decl.propertyName : decl.name).text : originalId.text;\n}\nvar LocalExportedDeclarations = Symbol(\"LocalExportedDeclarations\");\n\nexport {\n  ClassMemberKind,\n  typeNodeToValueExpr,\n  isNamedClassDeclaration,\n  TypeScriptReflectionHost,\n  reflectTypeEntityToDeclaration,\n  filterToMembersWithDecorator,\n  reflectObjectLiteral\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}