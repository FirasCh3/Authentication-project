{"ast":null,"code":"import { createRequire as __cjsCompatRequire } from 'module';\nconst require = __cjsCompatRequire(import.meta.url);\nimport { ImportFlags, NoopImportRewriter, Reference, assertSuccessfulReferenceEmit } from \"./chunk-KPIJL3UY.js\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/context.mjs\nvar Context = class {\n  constructor(isStatement) {\n    this.isStatement = isStatement;\n  }\n  get withExpressionMode() {\n    return this.isStatement ? new Context(false) : this;\n  }\n  get withStatementMode() {\n    return !this.isStatement ? new Context(true) : this;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/translator.mjs\nimport * as o from \"@angular/compiler\";\nvar UNARY_OPERATORS = /* @__PURE__ */new Map([[o.UnaryOperator.Minus, \"-\"], [o.UnaryOperator.Plus, \"+\"]]);\nvar BINARY_OPERATORS = /* @__PURE__ */new Map([[o.BinaryOperator.And, \"&&\"], [o.BinaryOperator.Bigger, \">\"], [o.BinaryOperator.BiggerEquals, \">=\"], [o.BinaryOperator.BitwiseAnd, \"&\"], [o.BinaryOperator.Divide, \"/\"], [o.BinaryOperator.Equals, \"==\"], [o.BinaryOperator.Identical, \"===\"], [o.BinaryOperator.Lower, \"<\"], [o.BinaryOperator.LowerEquals, \"<=\"], [o.BinaryOperator.Minus, \"-\"], [o.BinaryOperator.Modulo, \"%\"], [o.BinaryOperator.Multiply, \"*\"], [o.BinaryOperator.NotEquals, \"!=\"], [o.BinaryOperator.NotIdentical, \"!==\"], [o.BinaryOperator.Or, \"||\"], [o.BinaryOperator.Plus, \"+\"], [o.BinaryOperator.NullishCoalesce, \"??\"]]);\nvar ExpressionTranslatorVisitor = class {\n  constructor(factory, imports, options) {\n    this.factory = factory;\n    this.imports = imports;\n    this.downlevelTaggedTemplates = options.downlevelTaggedTemplates === true;\n    this.downlevelVariableDeclarations = options.downlevelVariableDeclarations === true;\n    this.recordWrappedNode = options.recordWrappedNode || (() => {});\n  }\n  visitDeclareVarStmt(stmt, context) {\n    var _a;\n    const varType = this.downlevelVariableDeclarations ? \"var\" : stmt.hasModifier(o.StmtModifier.Final) ? \"const\" : \"let\";\n    return this.attachComments(this.factory.createVariableDeclaration(stmt.name, (_a = stmt.value) == null ? void 0 : _a.visitExpression(this, context.withExpressionMode), varType), stmt.leadingComments);\n  }\n  visitDeclareFunctionStmt(stmt, context) {\n    return this.attachComments(this.factory.createFunctionDeclaration(stmt.name, stmt.params.map(param => param.name), this.factory.createBlock(this.visitStatements(stmt.statements, context.withStatementMode))), stmt.leadingComments);\n  }\n  visitExpressionStmt(stmt, context) {\n    return this.attachComments(this.factory.createExpressionStatement(stmt.expr.visitExpression(this, context.withStatementMode)), stmt.leadingComments);\n  }\n  visitReturnStmt(stmt, context) {\n    return this.attachComments(this.factory.createReturnStatement(stmt.value.visitExpression(this, context.withExpressionMode)), stmt.leadingComments);\n  }\n  visitIfStmt(stmt, context) {\n    return this.attachComments(this.factory.createIfStatement(stmt.condition.visitExpression(this, context), this.factory.createBlock(this.visitStatements(stmt.trueCase, context.withStatementMode)), stmt.falseCase.length > 0 ? this.factory.createBlock(this.visitStatements(stmt.falseCase, context.withStatementMode)) : null), stmt.leadingComments);\n  }\n  visitReadVarExpr(ast, _context) {\n    const identifier = this.factory.createIdentifier(ast.name);\n    this.setSourceMapRange(identifier, ast.sourceSpan);\n    return identifier;\n  }\n  visitWriteVarExpr(expr, context) {\n    const assignment = this.factory.createAssignment(this.setSourceMapRange(this.factory.createIdentifier(expr.name), expr.sourceSpan), expr.value.visitExpression(this, context));\n    return context.isStatement ? assignment : this.factory.createParenthesizedExpression(assignment);\n  }\n  visitWriteKeyExpr(expr, context) {\n    const exprContext = context.withExpressionMode;\n    const target = this.factory.createElementAccess(expr.receiver.visitExpression(this, exprContext), expr.index.visitExpression(this, exprContext));\n    const assignment = this.factory.createAssignment(target, expr.value.visitExpression(this, exprContext));\n    return context.isStatement ? assignment : this.factory.createParenthesizedExpression(assignment);\n  }\n  visitWritePropExpr(expr, context) {\n    const target = this.factory.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name);\n    return this.factory.createAssignment(target, expr.value.visitExpression(this, context));\n  }\n  visitInvokeFunctionExpr(ast, context) {\n    return this.setSourceMapRange(this.factory.createCallExpression(ast.fn.visitExpression(this, context), ast.args.map(arg => arg.visitExpression(this, context)), ast.pure), ast.sourceSpan);\n  }\n  visitTaggedTemplateExpr(ast, context) {\n    return this.setSourceMapRange(this.createTaggedTemplateExpression(ast.tag.visitExpression(this, context), {\n      elements: ast.template.elements.map(e => {\n        var _a;\n        return createTemplateElement({\n          cooked: e.text,\n          raw: e.rawText,\n          range: (_a = e.sourceSpan) != null ? _a : ast.sourceSpan\n        });\n      }),\n      expressions: ast.template.expressions.map(e => e.visitExpression(this, context))\n    }), ast.sourceSpan);\n  }\n  visitInstantiateExpr(ast, context) {\n    return this.factory.createNewExpression(ast.classExpr.visitExpression(this, context), ast.args.map(arg => arg.visitExpression(this, context)));\n  }\n  visitLiteralExpr(ast, _context) {\n    return this.setSourceMapRange(this.factory.createLiteral(ast.value), ast.sourceSpan);\n  }\n  visitLocalizedString(ast, context) {\n    const elements = [createTemplateElement(ast.serializeI18nHead())];\n    const expressions = [];\n    for (let i = 0; i < ast.expressions.length; i++) {\n      const placeholder = this.setSourceMapRange(ast.expressions[i].visitExpression(this, context), ast.getPlaceholderSourceSpan(i));\n      expressions.push(placeholder);\n      elements.push(createTemplateElement(ast.serializeI18nTemplatePart(i + 1)));\n    }\n    const localizeTag = this.factory.createIdentifier(\"$localize\");\n    return this.setSourceMapRange(this.createTaggedTemplateExpression(localizeTag, {\n      elements,\n      expressions\n    }), ast.sourceSpan);\n  }\n  createTaggedTemplateExpression(tag, template) {\n    return this.downlevelTaggedTemplates ? this.createES5TaggedTemplateFunctionCall(tag, template) : this.factory.createTaggedTemplate(tag, template);\n  }\n  createES5TaggedTemplateFunctionCall(tagHandler, {\n    elements,\n    expressions\n  }) {\n    const {\n      moduleImport,\n      symbol\n    } = this.imports.generateNamedImport(\"tslib\", \"__makeTemplateObject\");\n    const __makeTemplateObjectHelper = moduleImport === null ? this.factory.createIdentifier(symbol) : this.factory.createPropertyAccess(moduleImport, symbol);\n    const cooked = [];\n    const raw = [];\n    for (const element of elements) {\n      cooked.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.cooked), element.range));\n      raw.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.raw), element.range));\n    }\n    const templateHelperCall = this.factory.createCallExpression(__makeTemplateObjectHelper, [this.factory.createArrayLiteral(cooked), this.factory.createArrayLiteral(raw)], false);\n    return this.factory.createCallExpression(tagHandler, [templateHelperCall, ...expressions], false);\n  }\n  visitExternalExpr(ast, _context) {\n    if (ast.value.name === null) {\n      if (ast.value.moduleName === null) {\n        throw new Error(\"Invalid import without name nor moduleName\");\n      }\n      return this.imports.generateNamespaceImport(ast.value.moduleName);\n    }\n    if (ast.value.moduleName !== null) {\n      const {\n        moduleImport,\n        symbol\n      } = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n      if (moduleImport === null) {\n        return this.factory.createIdentifier(symbol);\n      } else {\n        return this.factory.createPropertyAccess(moduleImport, symbol);\n      }\n    } else {\n      return this.factory.createIdentifier(ast.value.name);\n    }\n  }\n  visitConditionalExpr(ast, context) {\n    let cond = ast.condition.visitExpression(this, context);\n    if (ast.condition instanceof o.ConditionalExpr) {\n      cond = this.factory.createParenthesizedExpression(cond);\n    }\n    return this.factory.createConditional(cond, ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));\n  }\n  visitNotExpr(ast, context) {\n    return this.factory.createUnaryExpression(\"!\", ast.condition.visitExpression(this, context));\n  }\n  visitFunctionExpr(ast, context) {\n    var _a;\n    return this.factory.createFunctionExpression((_a = ast.name) != null ? _a : null, ast.params.map(param => param.name), this.factory.createBlock(this.visitStatements(ast.statements, context)));\n  }\n  visitBinaryOperatorExpr(ast, context) {\n    if (!BINARY_OPERATORS.has(ast.operator)) {\n      throw new Error(`Unknown binary operator: ${o.BinaryOperator[ast.operator]}`);\n    }\n    return this.factory.createBinaryExpression(ast.lhs.visitExpression(this, context), BINARY_OPERATORS.get(ast.operator), ast.rhs.visitExpression(this, context));\n  }\n  visitReadPropExpr(ast, context) {\n    return this.factory.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);\n  }\n  visitReadKeyExpr(ast, context) {\n    return this.factory.createElementAccess(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));\n  }\n  visitLiteralArrayExpr(ast, context) {\n    return this.factory.createArrayLiteral(ast.entries.map(expr => this.setSourceMapRange(expr.visitExpression(this, context), ast.sourceSpan)));\n  }\n  visitLiteralMapExpr(ast, context) {\n    const properties = ast.entries.map(entry => {\n      return {\n        propertyName: entry.key,\n        quoted: entry.quoted,\n        value: entry.value.visitExpression(this, context)\n      };\n    });\n    return this.setSourceMapRange(this.factory.createObjectLiteral(properties), ast.sourceSpan);\n  }\n  visitCommaExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitWrappedNodeExpr(ast, _context) {\n    this.recordWrappedNode(ast);\n    return ast.node;\n  }\n  visitTypeofExpr(ast, context) {\n    return this.factory.createTypeOfExpression(ast.expr.visitExpression(this, context));\n  }\n  visitUnaryOperatorExpr(ast, context) {\n    if (!UNARY_OPERATORS.has(ast.operator)) {\n      throw new Error(`Unknown unary operator: ${o.UnaryOperator[ast.operator]}`);\n    }\n    return this.factory.createUnaryExpression(UNARY_OPERATORS.get(ast.operator), ast.expr.visitExpression(this, context));\n  }\n  visitStatements(statements, context) {\n    return statements.map(stmt => stmt.visitStatement(this, context)).filter(stmt => stmt !== void 0);\n  }\n  setSourceMapRange(ast, span) {\n    return this.factory.setSourceMapRange(ast, createRange(span));\n  }\n  attachComments(statement, leadingComments) {\n    if (leadingComments !== void 0) {\n      this.factory.attachComments(statement, leadingComments);\n    }\n    return statement;\n  }\n};\nfunction createTemplateElement({\n  cooked,\n  raw,\n  range\n}) {\n  return {\n    cooked,\n    raw,\n    range: createRange(range)\n  };\n}\nfunction createRange(span) {\n  if (span === null) {\n    return null;\n  }\n  const {\n    start,\n    end\n  } = span;\n  const {\n    url,\n    content\n  } = start.file;\n  if (!url) {\n    return null;\n  }\n  return {\n    url,\n    content,\n    start: {\n      offset: start.offset,\n      line: start.line,\n      column: start.col\n    },\n    end: {\n      offset: end.offset,\n      line: end.line,\n      column: end.col\n    }\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/import_manager.mjs\nimport ts from \"typescript\";\nvar ImportManager = class {\n  constructor(rewriter = new NoopImportRewriter(), prefix = \"i\") {\n    this.rewriter = rewriter;\n    this.prefix = prefix;\n    this.specifierToIdentifier = /* @__PURE__ */new Map();\n    this.nextIndex = 0;\n  }\n  generateNamespaceImport(moduleName) {\n    if (!this.specifierToIdentifier.has(moduleName)) {\n      this.specifierToIdentifier.set(moduleName, ts.factory.createIdentifier(`${this.prefix}${this.nextIndex++}`));\n    }\n    return this.specifierToIdentifier.get(moduleName);\n  }\n  generateNamedImport(moduleName, originalSymbol) {\n    const symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName);\n    if (!this.rewriter.shouldImportSymbol(symbol, moduleName)) {\n      return {\n        moduleImport: null,\n        symbol\n      };\n    }\n    const moduleImport = this.generateNamespaceImport(moduleName);\n    return {\n      moduleImport,\n      symbol\n    };\n  }\n  getAllImports(contextPath) {\n    const imports = [];\n    for (const [originalSpecifier, qualifier] of this.specifierToIdentifier) {\n      const specifier = this.rewriter.rewriteSpecifier(originalSpecifier, contextPath);\n      imports.push({\n        specifier,\n        qualifier\n      });\n    }\n    return imports;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/type_translator.mjs\nimport * as o2 from \"@angular/compiler\";\nimport ts2 from \"typescript\";\nfunction translateType(type, contextFile, reflector, refEmitter, imports) {\n  return type.visitType(new TypeTranslatorVisitor(imports, contextFile, reflector, refEmitter), new Context(false));\n}\nvar TypeTranslatorVisitor = class {\n  constructor(imports, contextFile, reflector, refEmitter) {\n    this.imports = imports;\n    this.contextFile = contextFile;\n    this.reflector = reflector;\n    this.refEmitter = refEmitter;\n  }\n  visitBuiltinType(type, context) {\n    switch (type.name) {\n      case o2.BuiltinTypeName.Bool:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.BooleanKeyword);\n      case o2.BuiltinTypeName.Dynamic:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.AnyKeyword);\n      case o2.BuiltinTypeName.Int:\n      case o2.BuiltinTypeName.Number:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.NumberKeyword);\n      case o2.BuiltinTypeName.String:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.StringKeyword);\n      case o2.BuiltinTypeName.None:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.NeverKeyword);\n      default:\n        throw new Error(`Unsupported builtin type: ${o2.BuiltinTypeName[type.name]}`);\n    }\n  }\n  visitExpressionType(type, context) {\n    const typeNode = this.translateExpression(type.value, context);\n    if (type.typeParams === null) {\n      return typeNode;\n    }\n    if (!ts2.isTypeReferenceNode(typeNode)) {\n      throw new Error(\"An ExpressionType with type arguments must translate into a TypeReferenceNode\");\n    } else if (typeNode.typeArguments !== void 0) {\n      throw new Error(`An ExpressionType with type arguments cannot have multiple levels of type arguments`);\n    }\n    const typeArgs = type.typeParams.map(param => this.translateType(param, context));\n    return ts2.factory.createTypeReferenceNode(typeNode.typeName, typeArgs);\n  }\n  visitArrayType(type, context) {\n    return ts2.factory.createArrayTypeNode(this.translateType(type.of, context));\n  }\n  visitMapType(type, context) {\n    const parameter = ts2.factory.createParameterDeclaration(void 0, void 0, \"key\", void 0, ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.StringKeyword));\n    const typeArgs = type.valueType !== null ? this.translateType(type.valueType, context) : ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.UnknownKeyword);\n    const indexSignature = ts2.factory.createIndexSignature(void 0, [parameter], typeArgs);\n    return ts2.factory.createTypeLiteralNode([indexSignature]);\n  }\n  visitTransplantedType(ast, context) {\n    if (!ts2.isTypeNode(ast.type)) {\n      throw new Error(`A TransplantedType must wrap a TypeNode`);\n    }\n    return this.translateTransplantedTypeNode(ast.type, context);\n  }\n  visitReadVarExpr(ast, context) {\n    if (ast.name === null) {\n      throw new Error(`ReadVarExpr with no variable name in type`);\n    }\n    return ts2.factory.createTypeQueryNode(ts2.factory.createIdentifier(ast.name));\n  }\n  visitWriteVarExpr(expr, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitWriteKeyExpr(expr, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitWritePropExpr(expr, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitInvokeFunctionExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitTaggedTemplateExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitInstantiateExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitLiteralExpr(ast, context) {\n    if (ast.value === null) {\n      return ts2.factory.createLiteralTypeNode(ts2.factory.createNull());\n    } else if (ast.value === void 0) {\n      return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.UndefinedKeyword);\n    } else if (typeof ast.value === \"boolean\") {\n      return ts2.factory.createLiteralTypeNode(ast.value ? ts2.factory.createTrue() : ts2.factory.createFalse());\n    } else if (typeof ast.value === \"number\") {\n      return ts2.factory.createLiteralTypeNode(ts2.factory.createNumericLiteral(ast.value));\n    } else {\n      return ts2.factory.createLiteralTypeNode(ts2.factory.createStringLiteral(ast.value));\n    }\n  }\n  visitLocalizedString(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitExternalExpr(ast, context) {\n    if (ast.value.moduleName === null || ast.value.name === null) {\n      throw new Error(`Import unknown module or symbol`);\n    }\n    const {\n      moduleImport,\n      symbol\n    } = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n    const symbolIdentifier = ts2.factory.createIdentifier(symbol);\n    const typeName = moduleImport ? ts2.factory.createQualifiedName(moduleImport, symbolIdentifier) : symbolIdentifier;\n    const typeArguments = ast.typeParams !== null ? ast.typeParams.map(type => this.translateType(type, context)) : void 0;\n    return ts2.factory.createTypeReferenceNode(typeName, typeArguments);\n  }\n  visitConditionalExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitNotExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitFunctionExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitUnaryOperatorExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitBinaryOperatorExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitReadPropExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitReadKeyExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitLiteralArrayExpr(ast, context) {\n    const values = ast.entries.map(expr => this.translateExpression(expr, context));\n    return ts2.factory.createTupleTypeNode(values);\n  }\n  visitLiteralMapExpr(ast, context) {\n    const entries = ast.entries.map(entry => {\n      const {\n        key,\n        quoted\n      } = entry;\n      const type = this.translateExpression(entry.value, context);\n      return ts2.factory.createPropertySignature(void 0, quoted ? ts2.factory.createStringLiteral(key) : key, void 0, type);\n    });\n    return ts2.factory.createTypeLiteralNode(entries);\n  }\n  visitCommaExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitWrappedNodeExpr(ast, context) {\n    const node = ast.node;\n    if (ts2.isEntityName(node)) {\n      return ts2.factory.createTypeReferenceNode(node, void 0);\n    } else if (ts2.isTypeNode(node)) {\n      return node;\n    } else if (ts2.isLiteralExpression(node)) {\n      return ts2.factory.createLiteralTypeNode(node);\n    } else {\n      throw new Error(`Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts2.SyntaxKind[node.kind]}`);\n    }\n  }\n  visitTypeofExpr(ast, context) {\n    const typeNode = this.translateExpression(ast.expr, context);\n    if (!ts2.isTypeReferenceNode(typeNode)) {\n      throw new Error(`The target of a typeof expression must be a type reference, but it was\n          ${ts2.SyntaxKind[typeNode.kind]}`);\n    }\n    return ts2.factory.createTypeQueryNode(typeNode.typeName);\n  }\n  translateType(type, context) {\n    const typeNode = type.visitType(this, context);\n    if (!ts2.isTypeNode(typeNode)) {\n      throw new Error(`A Type must translate to a TypeNode, but was ${ts2.SyntaxKind[typeNode.kind]}`);\n    }\n    return typeNode;\n  }\n  translateExpression(expr, context) {\n    const typeNode = expr.visitExpression(this, context);\n    if (!ts2.isTypeNode(typeNode)) {\n      throw new Error(`An Expression must translate to a TypeNode, but was ${ts2.SyntaxKind[typeNode.kind]}`);\n    }\n    return typeNode;\n  }\n  translateTransplantedTypeReferenceNode(node, context) {\n    const declaration = this.reflector.getDeclarationOfIdentifier(node.typeName);\n    if (declaration === null) {\n      throw new Error(`Unable to statically determine the declaration file of type node ${node.typeName.text}`);\n    }\n    const emittedType = this.refEmitter.emit(new Reference(declaration.node), this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports);\n    assertSuccessfulReferenceEmit(emittedType, node, \"type\");\n    const result = emittedType.expression.visitExpression(this, context);\n    if (!ts2.isTypeReferenceNode(result)) {\n      throw new Error(`Expected TypeReferenceNode when referencing the type for ${node.typeName.text}, but received ${ts2.SyntaxKind[result.kind]}`);\n    }\n    if (node.typeArguments === void 0 || node.typeArguments.length === 0) {\n      return result;\n    }\n    const translatedArgs = node.typeArguments.map(arg => this.translateTransplantedTypeNode(arg, context));\n    return ts2.factory.updateTypeReferenceNode(result, result.typeName, ts2.factory.createNodeArray(translatedArgs));\n  }\n  translateTransplantedTypeNode(rootNode, context) {\n    const factory = transformContext => root => {\n      const walk = node => {\n        if (ts2.isTypeReferenceNode(node) && ts2.isIdentifier(node.typeName)) {\n          const translated = this.translateTransplantedTypeReferenceNode(node, context);\n          if (translated !== node) {\n            return translated;\n          }\n        }\n        return ts2.visitEachChild(node, walk, transformContext);\n      };\n      return ts2.visitNode(root, walk);\n    };\n    return ts2.transform(rootNode, [factory]).transformed[0];\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/typescript_ast_factory.mjs\nimport ts3 from \"typescript\";\nvar PureAnnotation;\n(function (PureAnnotation2) {\n  PureAnnotation2[\"CLOSURE\"] = \"* @pureOrBreakMyCode \";\n  PureAnnotation2[\"TERSER\"] = \"@__PURE__\";\n})(PureAnnotation || (PureAnnotation = {}));\nvar UNARY_OPERATORS2 = {\n  \"+\": ts3.SyntaxKind.PlusToken,\n  \"-\": ts3.SyntaxKind.MinusToken,\n  \"!\": ts3.SyntaxKind.ExclamationToken\n};\nvar BINARY_OPERATORS2 = {\n  \"&&\": ts3.SyntaxKind.AmpersandAmpersandToken,\n  \">\": ts3.SyntaxKind.GreaterThanToken,\n  \">=\": ts3.SyntaxKind.GreaterThanEqualsToken,\n  \"&\": ts3.SyntaxKind.AmpersandToken,\n  \"/\": ts3.SyntaxKind.SlashToken,\n  \"==\": ts3.SyntaxKind.EqualsEqualsToken,\n  \"===\": ts3.SyntaxKind.EqualsEqualsEqualsToken,\n  \"<\": ts3.SyntaxKind.LessThanToken,\n  \"<=\": ts3.SyntaxKind.LessThanEqualsToken,\n  \"-\": ts3.SyntaxKind.MinusToken,\n  \"%\": ts3.SyntaxKind.PercentToken,\n  \"*\": ts3.SyntaxKind.AsteriskToken,\n  \"!=\": ts3.SyntaxKind.ExclamationEqualsToken,\n  \"!==\": ts3.SyntaxKind.ExclamationEqualsEqualsToken,\n  \"||\": ts3.SyntaxKind.BarBarToken,\n  \"+\": ts3.SyntaxKind.PlusToken,\n  \"??\": ts3.SyntaxKind.QuestionQuestionToken\n};\nvar VAR_TYPES = {\n  \"const\": ts3.NodeFlags.Const,\n  \"let\": ts3.NodeFlags.Let,\n  \"var\": ts3.NodeFlags.None\n};\nvar TypeScriptAstFactory = class {\n  constructor(annotateForClosureCompiler) {\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.externalSourceFiles = /* @__PURE__ */new Map();\n    this.attachComments = attachComments;\n    this.createArrayLiteral = ts3.factory.createArrayLiteralExpression;\n    this.createElementAccess = ts3.factory.createElementAccessExpression;\n    this.createExpressionStatement = ts3.factory.createExpressionStatement;\n    this.createIdentifier = ts3.factory.createIdentifier;\n    this.createParenthesizedExpression = ts3.factory.createParenthesizedExpression;\n    this.createPropertyAccess = ts3.factory.createPropertyAccessExpression;\n    this.createThrowStatement = ts3.factory.createThrowStatement;\n    this.createTypeOfExpression = ts3.factory.createTypeOfExpression;\n  }\n  createAssignment(target, value) {\n    return ts3.factory.createBinaryExpression(target, ts3.SyntaxKind.EqualsToken, value);\n  }\n  createBinaryExpression(leftOperand, operator, rightOperand) {\n    return ts3.factory.createBinaryExpression(leftOperand, BINARY_OPERATORS2[operator], rightOperand);\n  }\n  createBlock(body) {\n    return ts3.factory.createBlock(body);\n  }\n  createCallExpression(callee, args, pure) {\n    const call = ts3.factory.createCallExpression(callee, void 0, args);\n    if (pure) {\n      ts3.addSyntheticLeadingComment(call, ts3.SyntaxKind.MultiLineCommentTrivia, this.annotateForClosureCompiler ? PureAnnotation.CLOSURE : PureAnnotation.TERSER, false);\n    }\n    return call;\n  }\n  createConditional(condition, whenTrue, whenFalse) {\n    return ts3.factory.createConditionalExpression(condition, void 0, whenTrue, void 0, whenFalse);\n  }\n  createFunctionDeclaration(functionName, parameters, body) {\n    if (!ts3.isBlock(body)) {\n      throw new Error(`Invalid syntax, expected a block, but got ${ts3.SyntaxKind[body.kind]}.`);\n    }\n    return ts3.factory.createFunctionDeclaration(void 0, void 0, functionName, void 0, parameters.map(param => ts3.factory.createParameterDeclaration(void 0, void 0, param)), void 0, body);\n  }\n  createFunctionExpression(functionName, parameters, body) {\n    if (!ts3.isBlock(body)) {\n      throw new Error(`Invalid syntax, expected a block, but got ${ts3.SyntaxKind[body.kind]}.`);\n    }\n    return ts3.factory.createFunctionExpression(void 0, void 0, functionName != null ? functionName : void 0, void 0, parameters.map(param => ts3.factory.createParameterDeclaration(void 0, void 0, param)), void 0, body);\n  }\n  createIfStatement(condition, thenStatement, elseStatement) {\n    return ts3.factory.createIfStatement(condition, thenStatement, elseStatement != null ? elseStatement : void 0);\n  }\n  createLiteral(value) {\n    if (value === void 0) {\n      return ts3.factory.createIdentifier(\"undefined\");\n    } else if (value === null) {\n      return ts3.factory.createNull();\n    } else if (typeof value === \"boolean\") {\n      return value ? ts3.factory.createTrue() : ts3.factory.createFalse();\n    } else if (typeof value === \"number\") {\n      return ts3.factory.createNumericLiteral(value);\n    } else {\n      return ts3.factory.createStringLiteral(value);\n    }\n  }\n  createNewExpression(expression, args) {\n    return ts3.factory.createNewExpression(expression, void 0, args);\n  }\n  createObjectLiteral(properties) {\n    return ts3.factory.createObjectLiteralExpression(properties.map(prop => ts3.factory.createPropertyAssignment(prop.quoted ? ts3.factory.createStringLiteral(prop.propertyName) : ts3.factory.createIdentifier(prop.propertyName), prop.value)));\n  }\n  createReturnStatement(expression) {\n    return ts3.factory.createReturnStatement(expression != null ? expression : void 0);\n  }\n  createTaggedTemplate(tag, template) {\n    let templateLiteral;\n    const length = template.elements.length;\n    const head = template.elements[0];\n    if (length === 1) {\n      templateLiteral = ts3.factory.createNoSubstitutionTemplateLiteral(head.cooked, head.raw);\n    } else {\n      const spans = [];\n      for (let i = 1; i < length - 1; i++) {\n        const {\n          cooked,\n          raw,\n          range\n        } = template.elements[i];\n        const middle = createTemplateMiddle(cooked, raw);\n        if (range !== null) {\n          this.setSourceMapRange(middle, range);\n        }\n        spans.push(ts3.factory.createTemplateSpan(template.expressions[i - 1], middle));\n      }\n      const resolvedExpression = template.expressions[length - 2];\n      const templatePart = template.elements[length - 1];\n      const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);\n      if (templatePart.range !== null) {\n        this.setSourceMapRange(templateTail, templatePart.range);\n      }\n      spans.push(ts3.factory.createTemplateSpan(resolvedExpression, templateTail));\n      templateLiteral = ts3.factory.createTemplateExpression(ts3.factory.createTemplateHead(head.cooked, head.raw), spans);\n    }\n    if (head.range !== null) {\n      this.setSourceMapRange(templateLiteral, head.range);\n    }\n    return ts3.factory.createTaggedTemplateExpression(tag, void 0, templateLiteral);\n  }\n  createUnaryExpression(operator, operand) {\n    return ts3.factory.createPrefixUnaryExpression(UNARY_OPERATORS2[operator], operand);\n  }\n  createVariableDeclaration(variableName, initializer, type) {\n    return ts3.factory.createVariableStatement(void 0, ts3.factory.createVariableDeclarationList([ts3.factory.createVariableDeclaration(variableName, void 0, void 0, initializer != null ? initializer : void 0)], VAR_TYPES[type]));\n  }\n  setSourceMapRange(node, sourceMapRange) {\n    if (sourceMapRange === null) {\n      return node;\n    }\n    const url = sourceMapRange.url;\n    if (!this.externalSourceFiles.has(url)) {\n      this.externalSourceFiles.set(url, ts3.createSourceMapSource(url, sourceMapRange.content, pos => pos));\n    }\n    const source = this.externalSourceFiles.get(url);\n    ts3.setSourceMapRange(node, {\n      pos: sourceMapRange.start.offset,\n      end: sourceMapRange.end.offset,\n      source\n    });\n    return node;\n  }\n};\nfunction createTemplateMiddle(cooked, raw) {\n  const node = ts3.factory.createTemplateHead(cooked, raw);\n  node.kind = ts3.SyntaxKind.TemplateMiddle;\n  return node;\n}\nfunction createTemplateTail(cooked, raw) {\n  const node = ts3.factory.createTemplateHead(cooked, raw);\n  node.kind = ts3.SyntaxKind.TemplateTail;\n  return node;\n}\nfunction attachComments(statement, leadingComments) {\n  for (const comment of leadingComments) {\n    const commentKind = comment.multiline ? ts3.SyntaxKind.MultiLineCommentTrivia : ts3.SyntaxKind.SingleLineCommentTrivia;\n    if (comment.multiline) {\n      ts3.addSyntheticLeadingComment(statement, commentKind, comment.toString(), comment.trailingNewline);\n    } else {\n      for (const line of comment.toString().split(\"\\n\")) {\n        ts3.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);\n      }\n    }\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/typescript_translator.mjs\nfunction translateExpression(expression, imports, options = {}) {\n  return expression.visitExpression(new ExpressionTranslatorVisitor(new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, options), new Context(false));\n}\nfunction translateStatement(statement, imports, options = {}) {\n  return statement.visitStatement(new ExpressionTranslatorVisitor(new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, options), new Context(true));\n}\nexport { Context, ImportManager, ExpressionTranslatorVisitor, translateType, translateExpression, translateStatement };\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */","map":{"version":3,"names":["createRequire","__cjsCompatRequire","require","import","meta","url","ImportFlags","NoopImportRewriter","Reference","assertSuccessfulReferenceEmit","Context","constructor","isStatement","withExpressionMode","withStatementMode","o","UNARY_OPERATORS","Map","UnaryOperator","Minus","Plus","BINARY_OPERATORS","BinaryOperator","And","Bigger","BiggerEquals","BitwiseAnd","Divide","Equals","Identical","Lower","LowerEquals","Modulo","Multiply","NotEquals","NotIdentical","Or","NullishCoalesce","ExpressionTranslatorVisitor","factory","imports","options","downlevelTaggedTemplates","downlevelVariableDeclarations","recordWrappedNode","visitDeclareVarStmt","stmt","context","_a","varType","hasModifier","StmtModifier","Final","attachComments","createVariableDeclaration","name","value","visitExpression","leadingComments","visitDeclareFunctionStmt","createFunctionDeclaration","params","map","param","createBlock","visitStatements","statements","visitExpressionStmt","createExpressionStatement","expr","visitReturnStmt","createReturnStatement","visitIfStmt","createIfStatement","condition","trueCase","falseCase","length","visitReadVarExpr","ast","_context","identifier","createIdentifier","setSourceMapRange","sourceSpan","visitWriteVarExpr","assignment","createAssignment","createParenthesizedExpression","visitWriteKeyExpr","exprContext","target","createElementAccess","receiver","index","visitWritePropExpr","createPropertyAccess","visitInvokeFunctionExpr","createCallExpression","fn","args","arg","pure","visitTaggedTemplateExpr","createTaggedTemplateExpression","tag","elements","template","e","createTemplateElement","cooked","text","raw","rawText","range","expressions","visitInstantiateExpr","createNewExpression","classExpr","visitLiteralExpr","createLiteral","visitLocalizedString","serializeI18nHead","i","placeholder","getPlaceholderSourceSpan","push","serializeI18nTemplatePart","localizeTag","createES5TaggedTemplateFunctionCall","createTaggedTemplate","tagHandler","moduleImport","symbol","generateNamedImport","__makeTemplateObjectHelper","element","templateHelperCall","createArrayLiteral","visitExternalExpr","moduleName","Error","generateNamespaceImport","visitConditionalExpr","cond","ConditionalExpr","createConditional","visitNotExpr","createUnaryExpression","visitFunctionExpr","createFunctionExpression","visitBinaryOperatorExpr","has","operator","createBinaryExpression","lhs","get","rhs","visitReadPropExpr","visitReadKeyExpr","visitLiteralArrayExpr","entries","visitLiteralMapExpr","properties","entry","propertyName","key","quoted","createObjectLiteral","visitCommaExpr","visitWrappedNodeExpr","node","visitTypeofExpr","createTypeOfExpression","visitUnaryOperatorExpr","visitStatement","filter","span","createRange","statement","start","end","content","file","offset","line","column","col","ts","ImportManager","rewriter","prefix","specifierToIdentifier","nextIndex","set","originalSymbol","rewriteSymbol","shouldImportSymbol","getAllImports","contextPath","originalSpecifier","qualifier","specifier","rewriteSpecifier","o2","ts2","translateType","type","contextFile","reflector","refEmitter","visitType","TypeTranslatorVisitor","visitBuiltinType","BuiltinTypeName","Bool","createKeywordTypeNode","SyntaxKind","BooleanKeyword","Dynamic","AnyKeyword","Int","Number","NumberKeyword","String","StringKeyword","None","NeverKeyword","visitExpressionType","typeNode","translateExpression","typeParams","isTypeReferenceNode","typeArguments","typeArgs","createTypeReferenceNode","typeName","visitArrayType","createArrayTypeNode","of","visitMapType","parameter","createParameterDeclaration","valueType","UnknownKeyword","indexSignature","createIndexSignature","createTypeLiteralNode","visitTransplantedType","isTypeNode","translateTransplantedTypeNode","createTypeQueryNode","createLiteralTypeNode","createNull","UndefinedKeyword","createTrue","createFalse","createNumericLiteral","createStringLiteral","symbolIdentifier","createQualifiedName","values","createTupleTypeNode","createPropertySignature","isEntityName","isLiteralExpression","kind","translateTransplantedTypeReferenceNode","declaration","getDeclarationOfIdentifier","emittedType","emit","NoAliasing","AllowTypeImports","AllowRelativeDtsImports","result","expression","translatedArgs","updateTypeReferenceNode","createNodeArray","rootNode","transformContext","root","walk","isIdentifier","translated","visitEachChild","visitNode","transform","transformed","ts3","PureAnnotation","PureAnnotation2","UNARY_OPERATORS2","PlusToken","MinusToken","ExclamationToken","BINARY_OPERATORS2","AmpersandAmpersandToken","GreaterThanToken","GreaterThanEqualsToken","AmpersandToken","SlashToken","EqualsEqualsToken","EqualsEqualsEqualsToken","LessThanToken","LessThanEqualsToken","PercentToken","AsteriskToken","ExclamationEqualsToken","ExclamationEqualsEqualsToken","BarBarToken","QuestionQuestionToken","VAR_TYPES","NodeFlags","Const","Let","TypeScriptAstFactory","annotateForClosureCompiler","externalSourceFiles","createArrayLiteralExpression","createElementAccessExpression","createPropertyAccessExpression","createThrowStatement","EqualsToken","leftOperand","rightOperand","body","callee","call","addSyntheticLeadingComment","MultiLineCommentTrivia","CLOSURE","TERSER","whenTrue","whenFalse","createConditionalExpression","functionName","parameters","isBlock","thenStatement","elseStatement","createObjectLiteralExpression","prop","createPropertyAssignment","templateLiteral","head","createNoSubstitutionTemplateLiteral","spans","middle","createTemplateMiddle","createTemplateSpan","resolvedExpression","templatePart","templateTail","createTemplateTail","createTemplateExpression","createTemplateHead","operand","createPrefixUnaryExpression","variableName","initializer","createVariableStatement","createVariableDeclarationList","sourceMapRange","createSourceMapSource","pos","source","TemplateMiddle","TemplateTail","comment","commentKind","multiline","SingleLineCommentTrivia","toString","trailingNewline","split","translateStatement"],"sources":["C:/Users/user/Desktop/SpringBootProject/src/main/resources/my-app/node_modules/@angular/compiler-cli/bundles/chunk-AAX4HKH5.js"],"sourcesContent":["\n      import {createRequire as __cjsCompatRequire} from 'module';\n      const require = __cjsCompatRequire(import.meta.url);\n    \nimport {\n  ImportFlags,\n  NoopImportRewriter,\n  Reference,\n  assertSuccessfulReferenceEmit\n} from \"./chunk-KPIJL3UY.js\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/context.mjs\nvar Context = class {\n  constructor(isStatement) {\n    this.isStatement = isStatement;\n  }\n  get withExpressionMode() {\n    return this.isStatement ? new Context(false) : this;\n  }\n  get withStatementMode() {\n    return !this.isStatement ? new Context(true) : this;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/translator.mjs\nimport * as o from \"@angular/compiler\";\nvar UNARY_OPERATORS = /* @__PURE__ */ new Map([\n  [o.UnaryOperator.Minus, \"-\"],\n  [o.UnaryOperator.Plus, \"+\"]\n]);\nvar BINARY_OPERATORS = /* @__PURE__ */ new Map([\n  [o.BinaryOperator.And, \"&&\"],\n  [o.BinaryOperator.Bigger, \">\"],\n  [o.BinaryOperator.BiggerEquals, \">=\"],\n  [o.BinaryOperator.BitwiseAnd, \"&\"],\n  [o.BinaryOperator.Divide, \"/\"],\n  [o.BinaryOperator.Equals, \"==\"],\n  [o.BinaryOperator.Identical, \"===\"],\n  [o.BinaryOperator.Lower, \"<\"],\n  [o.BinaryOperator.LowerEquals, \"<=\"],\n  [o.BinaryOperator.Minus, \"-\"],\n  [o.BinaryOperator.Modulo, \"%\"],\n  [o.BinaryOperator.Multiply, \"*\"],\n  [o.BinaryOperator.NotEquals, \"!=\"],\n  [o.BinaryOperator.NotIdentical, \"!==\"],\n  [o.BinaryOperator.Or, \"||\"],\n  [o.BinaryOperator.Plus, \"+\"],\n  [o.BinaryOperator.NullishCoalesce, \"??\"]\n]);\nvar ExpressionTranslatorVisitor = class {\n  constructor(factory, imports, options) {\n    this.factory = factory;\n    this.imports = imports;\n    this.downlevelTaggedTemplates = options.downlevelTaggedTemplates === true;\n    this.downlevelVariableDeclarations = options.downlevelVariableDeclarations === true;\n    this.recordWrappedNode = options.recordWrappedNode || (() => {\n    });\n  }\n  visitDeclareVarStmt(stmt, context) {\n    var _a;\n    const varType = this.downlevelVariableDeclarations ? \"var\" : stmt.hasModifier(o.StmtModifier.Final) ? \"const\" : \"let\";\n    return this.attachComments(this.factory.createVariableDeclaration(stmt.name, (_a = stmt.value) == null ? void 0 : _a.visitExpression(this, context.withExpressionMode), varType), stmt.leadingComments);\n  }\n  visitDeclareFunctionStmt(stmt, context) {\n    return this.attachComments(this.factory.createFunctionDeclaration(stmt.name, stmt.params.map((param) => param.name), this.factory.createBlock(this.visitStatements(stmt.statements, context.withStatementMode))), stmt.leadingComments);\n  }\n  visitExpressionStmt(stmt, context) {\n    return this.attachComments(this.factory.createExpressionStatement(stmt.expr.visitExpression(this, context.withStatementMode)), stmt.leadingComments);\n  }\n  visitReturnStmt(stmt, context) {\n    return this.attachComments(this.factory.createReturnStatement(stmt.value.visitExpression(this, context.withExpressionMode)), stmt.leadingComments);\n  }\n  visitIfStmt(stmt, context) {\n    return this.attachComments(this.factory.createIfStatement(stmt.condition.visitExpression(this, context), this.factory.createBlock(this.visitStatements(stmt.trueCase, context.withStatementMode)), stmt.falseCase.length > 0 ? this.factory.createBlock(this.visitStatements(stmt.falseCase, context.withStatementMode)) : null), stmt.leadingComments);\n  }\n  visitReadVarExpr(ast, _context) {\n    const identifier = this.factory.createIdentifier(ast.name);\n    this.setSourceMapRange(identifier, ast.sourceSpan);\n    return identifier;\n  }\n  visitWriteVarExpr(expr, context) {\n    const assignment = this.factory.createAssignment(this.setSourceMapRange(this.factory.createIdentifier(expr.name), expr.sourceSpan), expr.value.visitExpression(this, context));\n    return context.isStatement ? assignment : this.factory.createParenthesizedExpression(assignment);\n  }\n  visitWriteKeyExpr(expr, context) {\n    const exprContext = context.withExpressionMode;\n    const target = this.factory.createElementAccess(expr.receiver.visitExpression(this, exprContext), expr.index.visitExpression(this, exprContext));\n    const assignment = this.factory.createAssignment(target, expr.value.visitExpression(this, exprContext));\n    return context.isStatement ? assignment : this.factory.createParenthesizedExpression(assignment);\n  }\n  visitWritePropExpr(expr, context) {\n    const target = this.factory.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name);\n    return this.factory.createAssignment(target, expr.value.visitExpression(this, context));\n  }\n  visitInvokeFunctionExpr(ast, context) {\n    return this.setSourceMapRange(this.factory.createCallExpression(ast.fn.visitExpression(this, context), ast.args.map((arg) => arg.visitExpression(this, context)), ast.pure), ast.sourceSpan);\n  }\n  visitTaggedTemplateExpr(ast, context) {\n    return this.setSourceMapRange(this.createTaggedTemplateExpression(ast.tag.visitExpression(this, context), {\n      elements: ast.template.elements.map((e) => {\n        var _a;\n        return createTemplateElement({\n          cooked: e.text,\n          raw: e.rawText,\n          range: (_a = e.sourceSpan) != null ? _a : ast.sourceSpan\n        });\n      }),\n      expressions: ast.template.expressions.map((e) => e.visitExpression(this, context))\n    }), ast.sourceSpan);\n  }\n  visitInstantiateExpr(ast, context) {\n    return this.factory.createNewExpression(ast.classExpr.visitExpression(this, context), ast.args.map((arg) => arg.visitExpression(this, context)));\n  }\n  visitLiteralExpr(ast, _context) {\n    return this.setSourceMapRange(this.factory.createLiteral(ast.value), ast.sourceSpan);\n  }\n  visitLocalizedString(ast, context) {\n    const elements = [createTemplateElement(ast.serializeI18nHead())];\n    const expressions = [];\n    for (let i = 0; i < ast.expressions.length; i++) {\n      const placeholder = this.setSourceMapRange(ast.expressions[i].visitExpression(this, context), ast.getPlaceholderSourceSpan(i));\n      expressions.push(placeholder);\n      elements.push(createTemplateElement(ast.serializeI18nTemplatePart(i + 1)));\n    }\n    const localizeTag = this.factory.createIdentifier(\"$localize\");\n    return this.setSourceMapRange(this.createTaggedTemplateExpression(localizeTag, { elements, expressions }), ast.sourceSpan);\n  }\n  createTaggedTemplateExpression(tag, template) {\n    return this.downlevelTaggedTemplates ? this.createES5TaggedTemplateFunctionCall(tag, template) : this.factory.createTaggedTemplate(tag, template);\n  }\n  createES5TaggedTemplateFunctionCall(tagHandler, { elements, expressions }) {\n    const { moduleImport, symbol } = this.imports.generateNamedImport(\"tslib\", \"__makeTemplateObject\");\n    const __makeTemplateObjectHelper = moduleImport === null ? this.factory.createIdentifier(symbol) : this.factory.createPropertyAccess(moduleImport, symbol);\n    const cooked = [];\n    const raw = [];\n    for (const element of elements) {\n      cooked.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.cooked), element.range));\n      raw.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.raw), element.range));\n    }\n    const templateHelperCall = this.factory.createCallExpression(\n      __makeTemplateObjectHelper,\n      [this.factory.createArrayLiteral(cooked), this.factory.createArrayLiteral(raw)],\n      false\n    );\n    return this.factory.createCallExpression(\n      tagHandler,\n      [templateHelperCall, ...expressions],\n      false\n    );\n  }\n  visitExternalExpr(ast, _context) {\n    if (ast.value.name === null) {\n      if (ast.value.moduleName === null) {\n        throw new Error(\"Invalid import without name nor moduleName\");\n      }\n      return this.imports.generateNamespaceImport(ast.value.moduleName);\n    }\n    if (ast.value.moduleName !== null) {\n      const { moduleImport, symbol } = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n      if (moduleImport === null) {\n        return this.factory.createIdentifier(symbol);\n      } else {\n        return this.factory.createPropertyAccess(moduleImport, symbol);\n      }\n    } else {\n      return this.factory.createIdentifier(ast.value.name);\n    }\n  }\n  visitConditionalExpr(ast, context) {\n    let cond = ast.condition.visitExpression(this, context);\n    if (ast.condition instanceof o.ConditionalExpr) {\n      cond = this.factory.createParenthesizedExpression(cond);\n    }\n    return this.factory.createConditional(cond, ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));\n  }\n  visitNotExpr(ast, context) {\n    return this.factory.createUnaryExpression(\"!\", ast.condition.visitExpression(this, context));\n  }\n  visitFunctionExpr(ast, context) {\n    var _a;\n    return this.factory.createFunctionExpression((_a = ast.name) != null ? _a : null, ast.params.map((param) => param.name), this.factory.createBlock(this.visitStatements(ast.statements, context)));\n  }\n  visitBinaryOperatorExpr(ast, context) {\n    if (!BINARY_OPERATORS.has(ast.operator)) {\n      throw new Error(`Unknown binary operator: ${o.BinaryOperator[ast.operator]}`);\n    }\n    return this.factory.createBinaryExpression(ast.lhs.visitExpression(this, context), BINARY_OPERATORS.get(ast.operator), ast.rhs.visitExpression(this, context));\n  }\n  visitReadPropExpr(ast, context) {\n    return this.factory.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);\n  }\n  visitReadKeyExpr(ast, context) {\n    return this.factory.createElementAccess(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));\n  }\n  visitLiteralArrayExpr(ast, context) {\n    return this.factory.createArrayLiteral(ast.entries.map((expr) => this.setSourceMapRange(expr.visitExpression(this, context), ast.sourceSpan)));\n  }\n  visitLiteralMapExpr(ast, context) {\n    const properties = ast.entries.map((entry) => {\n      return {\n        propertyName: entry.key,\n        quoted: entry.quoted,\n        value: entry.value.visitExpression(this, context)\n      };\n    });\n    return this.setSourceMapRange(this.factory.createObjectLiteral(properties), ast.sourceSpan);\n  }\n  visitCommaExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitWrappedNodeExpr(ast, _context) {\n    this.recordWrappedNode(ast);\n    return ast.node;\n  }\n  visitTypeofExpr(ast, context) {\n    return this.factory.createTypeOfExpression(ast.expr.visitExpression(this, context));\n  }\n  visitUnaryOperatorExpr(ast, context) {\n    if (!UNARY_OPERATORS.has(ast.operator)) {\n      throw new Error(`Unknown unary operator: ${o.UnaryOperator[ast.operator]}`);\n    }\n    return this.factory.createUnaryExpression(UNARY_OPERATORS.get(ast.operator), ast.expr.visitExpression(this, context));\n  }\n  visitStatements(statements, context) {\n    return statements.map((stmt) => stmt.visitStatement(this, context)).filter((stmt) => stmt !== void 0);\n  }\n  setSourceMapRange(ast, span) {\n    return this.factory.setSourceMapRange(ast, createRange(span));\n  }\n  attachComments(statement, leadingComments) {\n    if (leadingComments !== void 0) {\n      this.factory.attachComments(statement, leadingComments);\n    }\n    return statement;\n  }\n};\nfunction createTemplateElement({ cooked, raw, range }) {\n  return { cooked, raw, range: createRange(range) };\n}\nfunction createRange(span) {\n  if (span === null) {\n    return null;\n  }\n  const { start, end } = span;\n  const { url, content } = start.file;\n  if (!url) {\n    return null;\n  }\n  return {\n    url,\n    content,\n    start: { offset: start.offset, line: start.line, column: start.col },\n    end: { offset: end.offset, line: end.line, column: end.col }\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/import_manager.mjs\nimport ts from \"typescript\";\nvar ImportManager = class {\n  constructor(rewriter = new NoopImportRewriter(), prefix = \"i\") {\n    this.rewriter = rewriter;\n    this.prefix = prefix;\n    this.specifierToIdentifier = /* @__PURE__ */ new Map();\n    this.nextIndex = 0;\n  }\n  generateNamespaceImport(moduleName) {\n    if (!this.specifierToIdentifier.has(moduleName)) {\n      this.specifierToIdentifier.set(moduleName, ts.factory.createIdentifier(`${this.prefix}${this.nextIndex++}`));\n    }\n    return this.specifierToIdentifier.get(moduleName);\n  }\n  generateNamedImport(moduleName, originalSymbol) {\n    const symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName);\n    if (!this.rewriter.shouldImportSymbol(symbol, moduleName)) {\n      return { moduleImport: null, symbol };\n    }\n    const moduleImport = this.generateNamespaceImport(moduleName);\n    return { moduleImport, symbol };\n  }\n  getAllImports(contextPath) {\n    const imports = [];\n    for (const [originalSpecifier, qualifier] of this.specifierToIdentifier) {\n      const specifier = this.rewriter.rewriteSpecifier(originalSpecifier, contextPath);\n      imports.push({\n        specifier,\n        qualifier\n      });\n    }\n    return imports;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/type_translator.mjs\nimport * as o2 from \"@angular/compiler\";\nimport ts2 from \"typescript\";\nfunction translateType(type, contextFile, reflector, refEmitter, imports) {\n  return type.visitType(new TypeTranslatorVisitor(imports, contextFile, reflector, refEmitter), new Context(false));\n}\nvar TypeTranslatorVisitor = class {\n  constructor(imports, contextFile, reflector, refEmitter) {\n    this.imports = imports;\n    this.contextFile = contextFile;\n    this.reflector = reflector;\n    this.refEmitter = refEmitter;\n  }\n  visitBuiltinType(type, context) {\n    switch (type.name) {\n      case o2.BuiltinTypeName.Bool:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.BooleanKeyword);\n      case o2.BuiltinTypeName.Dynamic:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.AnyKeyword);\n      case o2.BuiltinTypeName.Int:\n      case o2.BuiltinTypeName.Number:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.NumberKeyword);\n      case o2.BuiltinTypeName.String:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.StringKeyword);\n      case o2.BuiltinTypeName.None:\n        return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.NeverKeyword);\n      default:\n        throw new Error(`Unsupported builtin type: ${o2.BuiltinTypeName[type.name]}`);\n    }\n  }\n  visitExpressionType(type, context) {\n    const typeNode = this.translateExpression(type.value, context);\n    if (type.typeParams === null) {\n      return typeNode;\n    }\n    if (!ts2.isTypeReferenceNode(typeNode)) {\n      throw new Error(\"An ExpressionType with type arguments must translate into a TypeReferenceNode\");\n    } else if (typeNode.typeArguments !== void 0) {\n      throw new Error(`An ExpressionType with type arguments cannot have multiple levels of type arguments`);\n    }\n    const typeArgs = type.typeParams.map((param) => this.translateType(param, context));\n    return ts2.factory.createTypeReferenceNode(typeNode.typeName, typeArgs);\n  }\n  visitArrayType(type, context) {\n    return ts2.factory.createArrayTypeNode(this.translateType(type.of, context));\n  }\n  visitMapType(type, context) {\n    const parameter = ts2.factory.createParameterDeclaration(void 0, void 0, \"key\", void 0, ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.StringKeyword));\n    const typeArgs = type.valueType !== null ? this.translateType(type.valueType, context) : ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.UnknownKeyword);\n    const indexSignature = ts2.factory.createIndexSignature(void 0, [parameter], typeArgs);\n    return ts2.factory.createTypeLiteralNode([indexSignature]);\n  }\n  visitTransplantedType(ast, context) {\n    if (!ts2.isTypeNode(ast.type)) {\n      throw new Error(`A TransplantedType must wrap a TypeNode`);\n    }\n    return this.translateTransplantedTypeNode(ast.type, context);\n  }\n  visitReadVarExpr(ast, context) {\n    if (ast.name === null) {\n      throw new Error(`ReadVarExpr with no variable name in type`);\n    }\n    return ts2.factory.createTypeQueryNode(ts2.factory.createIdentifier(ast.name));\n  }\n  visitWriteVarExpr(expr, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitWriteKeyExpr(expr, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitWritePropExpr(expr, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitInvokeFunctionExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitTaggedTemplateExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitInstantiateExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitLiteralExpr(ast, context) {\n    if (ast.value === null) {\n      return ts2.factory.createLiteralTypeNode(ts2.factory.createNull());\n    } else if (ast.value === void 0) {\n      return ts2.factory.createKeywordTypeNode(ts2.SyntaxKind.UndefinedKeyword);\n    } else if (typeof ast.value === \"boolean\") {\n      return ts2.factory.createLiteralTypeNode(ast.value ? ts2.factory.createTrue() : ts2.factory.createFalse());\n    } else if (typeof ast.value === \"number\") {\n      return ts2.factory.createLiteralTypeNode(ts2.factory.createNumericLiteral(ast.value));\n    } else {\n      return ts2.factory.createLiteralTypeNode(ts2.factory.createStringLiteral(ast.value));\n    }\n  }\n  visitLocalizedString(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitExternalExpr(ast, context) {\n    if (ast.value.moduleName === null || ast.value.name === null) {\n      throw new Error(`Import unknown module or symbol`);\n    }\n    const { moduleImport, symbol } = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n    const symbolIdentifier = ts2.factory.createIdentifier(symbol);\n    const typeName = moduleImport ? ts2.factory.createQualifiedName(moduleImport, symbolIdentifier) : symbolIdentifier;\n    const typeArguments = ast.typeParams !== null ? ast.typeParams.map((type) => this.translateType(type, context)) : void 0;\n    return ts2.factory.createTypeReferenceNode(typeName, typeArguments);\n  }\n  visitConditionalExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitNotExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitFunctionExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitUnaryOperatorExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitBinaryOperatorExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitReadPropExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitReadKeyExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitLiteralArrayExpr(ast, context) {\n    const values = ast.entries.map((expr) => this.translateExpression(expr, context));\n    return ts2.factory.createTupleTypeNode(values);\n  }\n  visitLiteralMapExpr(ast, context) {\n    const entries = ast.entries.map((entry) => {\n      const { key, quoted } = entry;\n      const type = this.translateExpression(entry.value, context);\n      return ts2.factory.createPropertySignature(\n        void 0,\n        quoted ? ts2.factory.createStringLiteral(key) : key,\n        void 0,\n        type\n      );\n    });\n    return ts2.factory.createTypeLiteralNode(entries);\n  }\n  visitCommaExpr(ast, context) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitWrappedNodeExpr(ast, context) {\n    const node = ast.node;\n    if (ts2.isEntityName(node)) {\n      return ts2.factory.createTypeReferenceNode(node, void 0);\n    } else if (ts2.isTypeNode(node)) {\n      return node;\n    } else if (ts2.isLiteralExpression(node)) {\n      return ts2.factory.createLiteralTypeNode(node);\n    } else {\n      throw new Error(`Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts2.SyntaxKind[node.kind]}`);\n    }\n  }\n  visitTypeofExpr(ast, context) {\n    const typeNode = this.translateExpression(ast.expr, context);\n    if (!ts2.isTypeReferenceNode(typeNode)) {\n      throw new Error(`The target of a typeof expression must be a type reference, but it was\n          ${ts2.SyntaxKind[typeNode.kind]}`);\n    }\n    return ts2.factory.createTypeQueryNode(typeNode.typeName);\n  }\n  translateType(type, context) {\n    const typeNode = type.visitType(this, context);\n    if (!ts2.isTypeNode(typeNode)) {\n      throw new Error(`A Type must translate to a TypeNode, but was ${ts2.SyntaxKind[typeNode.kind]}`);\n    }\n    return typeNode;\n  }\n  translateExpression(expr, context) {\n    const typeNode = expr.visitExpression(this, context);\n    if (!ts2.isTypeNode(typeNode)) {\n      throw new Error(`An Expression must translate to a TypeNode, but was ${ts2.SyntaxKind[typeNode.kind]}`);\n    }\n    return typeNode;\n  }\n  translateTransplantedTypeReferenceNode(node, context) {\n    const declaration = this.reflector.getDeclarationOfIdentifier(node.typeName);\n    if (declaration === null) {\n      throw new Error(`Unable to statically determine the declaration file of type node ${node.typeName.text}`);\n    }\n    const emittedType = this.refEmitter.emit(new Reference(declaration.node), this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports);\n    assertSuccessfulReferenceEmit(emittedType, node, \"type\");\n    const result = emittedType.expression.visitExpression(this, context);\n    if (!ts2.isTypeReferenceNode(result)) {\n      throw new Error(`Expected TypeReferenceNode when referencing the type for ${node.typeName.text}, but received ${ts2.SyntaxKind[result.kind]}`);\n    }\n    if (node.typeArguments === void 0 || node.typeArguments.length === 0) {\n      return result;\n    }\n    const translatedArgs = node.typeArguments.map((arg) => this.translateTransplantedTypeNode(arg, context));\n    return ts2.factory.updateTypeReferenceNode(result, result.typeName, ts2.factory.createNodeArray(translatedArgs));\n  }\n  translateTransplantedTypeNode(rootNode, context) {\n    const factory = (transformContext) => (root) => {\n      const walk = (node) => {\n        if (ts2.isTypeReferenceNode(node) && ts2.isIdentifier(node.typeName)) {\n          const translated = this.translateTransplantedTypeReferenceNode(node, context);\n          if (translated !== node) {\n            return translated;\n          }\n        }\n        return ts2.visitEachChild(node, walk, transformContext);\n      };\n      return ts2.visitNode(root, walk);\n    };\n    return ts2.transform(rootNode, [factory]).transformed[0];\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/typescript_ast_factory.mjs\nimport ts3 from \"typescript\";\nvar PureAnnotation;\n(function(PureAnnotation2) {\n  PureAnnotation2[\"CLOSURE\"] = \"* @pureOrBreakMyCode \";\n  PureAnnotation2[\"TERSER\"] = \"@__PURE__\";\n})(PureAnnotation || (PureAnnotation = {}));\nvar UNARY_OPERATORS2 = {\n  \"+\": ts3.SyntaxKind.PlusToken,\n  \"-\": ts3.SyntaxKind.MinusToken,\n  \"!\": ts3.SyntaxKind.ExclamationToken\n};\nvar BINARY_OPERATORS2 = {\n  \"&&\": ts3.SyntaxKind.AmpersandAmpersandToken,\n  \">\": ts3.SyntaxKind.GreaterThanToken,\n  \">=\": ts3.SyntaxKind.GreaterThanEqualsToken,\n  \"&\": ts3.SyntaxKind.AmpersandToken,\n  \"/\": ts3.SyntaxKind.SlashToken,\n  \"==\": ts3.SyntaxKind.EqualsEqualsToken,\n  \"===\": ts3.SyntaxKind.EqualsEqualsEqualsToken,\n  \"<\": ts3.SyntaxKind.LessThanToken,\n  \"<=\": ts3.SyntaxKind.LessThanEqualsToken,\n  \"-\": ts3.SyntaxKind.MinusToken,\n  \"%\": ts3.SyntaxKind.PercentToken,\n  \"*\": ts3.SyntaxKind.AsteriskToken,\n  \"!=\": ts3.SyntaxKind.ExclamationEqualsToken,\n  \"!==\": ts3.SyntaxKind.ExclamationEqualsEqualsToken,\n  \"||\": ts3.SyntaxKind.BarBarToken,\n  \"+\": ts3.SyntaxKind.PlusToken,\n  \"??\": ts3.SyntaxKind.QuestionQuestionToken\n};\nvar VAR_TYPES = {\n  \"const\": ts3.NodeFlags.Const,\n  \"let\": ts3.NodeFlags.Let,\n  \"var\": ts3.NodeFlags.None\n};\nvar TypeScriptAstFactory = class {\n  constructor(annotateForClosureCompiler) {\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.externalSourceFiles = /* @__PURE__ */ new Map();\n    this.attachComments = attachComments;\n    this.createArrayLiteral = ts3.factory.createArrayLiteralExpression;\n    this.createElementAccess = ts3.factory.createElementAccessExpression;\n    this.createExpressionStatement = ts3.factory.createExpressionStatement;\n    this.createIdentifier = ts3.factory.createIdentifier;\n    this.createParenthesizedExpression = ts3.factory.createParenthesizedExpression;\n    this.createPropertyAccess = ts3.factory.createPropertyAccessExpression;\n    this.createThrowStatement = ts3.factory.createThrowStatement;\n    this.createTypeOfExpression = ts3.factory.createTypeOfExpression;\n  }\n  createAssignment(target, value) {\n    return ts3.factory.createBinaryExpression(target, ts3.SyntaxKind.EqualsToken, value);\n  }\n  createBinaryExpression(leftOperand, operator, rightOperand) {\n    return ts3.factory.createBinaryExpression(leftOperand, BINARY_OPERATORS2[operator], rightOperand);\n  }\n  createBlock(body) {\n    return ts3.factory.createBlock(body);\n  }\n  createCallExpression(callee, args, pure) {\n    const call = ts3.factory.createCallExpression(callee, void 0, args);\n    if (pure) {\n      ts3.addSyntheticLeadingComment(\n        call,\n        ts3.SyntaxKind.MultiLineCommentTrivia,\n        this.annotateForClosureCompiler ? PureAnnotation.CLOSURE : PureAnnotation.TERSER,\n        false\n      );\n    }\n    return call;\n  }\n  createConditional(condition, whenTrue, whenFalse) {\n    return ts3.factory.createConditionalExpression(condition, void 0, whenTrue, void 0, whenFalse);\n  }\n  createFunctionDeclaration(functionName, parameters, body) {\n    if (!ts3.isBlock(body)) {\n      throw new Error(`Invalid syntax, expected a block, but got ${ts3.SyntaxKind[body.kind]}.`);\n    }\n    return ts3.factory.createFunctionDeclaration(void 0, void 0, functionName, void 0, parameters.map((param) => ts3.factory.createParameterDeclaration(void 0, void 0, param)), void 0, body);\n  }\n  createFunctionExpression(functionName, parameters, body) {\n    if (!ts3.isBlock(body)) {\n      throw new Error(`Invalid syntax, expected a block, but got ${ts3.SyntaxKind[body.kind]}.`);\n    }\n    return ts3.factory.createFunctionExpression(void 0, void 0, functionName != null ? functionName : void 0, void 0, parameters.map((param) => ts3.factory.createParameterDeclaration(void 0, void 0, param)), void 0, body);\n  }\n  createIfStatement(condition, thenStatement, elseStatement) {\n    return ts3.factory.createIfStatement(condition, thenStatement, elseStatement != null ? elseStatement : void 0);\n  }\n  createLiteral(value) {\n    if (value === void 0) {\n      return ts3.factory.createIdentifier(\"undefined\");\n    } else if (value === null) {\n      return ts3.factory.createNull();\n    } else if (typeof value === \"boolean\") {\n      return value ? ts3.factory.createTrue() : ts3.factory.createFalse();\n    } else if (typeof value === \"number\") {\n      return ts3.factory.createNumericLiteral(value);\n    } else {\n      return ts3.factory.createStringLiteral(value);\n    }\n  }\n  createNewExpression(expression, args) {\n    return ts3.factory.createNewExpression(expression, void 0, args);\n  }\n  createObjectLiteral(properties) {\n    return ts3.factory.createObjectLiteralExpression(properties.map((prop) => ts3.factory.createPropertyAssignment(prop.quoted ? ts3.factory.createStringLiteral(prop.propertyName) : ts3.factory.createIdentifier(prop.propertyName), prop.value)));\n  }\n  createReturnStatement(expression) {\n    return ts3.factory.createReturnStatement(expression != null ? expression : void 0);\n  }\n  createTaggedTemplate(tag, template) {\n    let templateLiteral;\n    const length = template.elements.length;\n    const head = template.elements[0];\n    if (length === 1) {\n      templateLiteral = ts3.factory.createNoSubstitutionTemplateLiteral(head.cooked, head.raw);\n    } else {\n      const spans = [];\n      for (let i = 1; i < length - 1; i++) {\n        const { cooked, raw, range } = template.elements[i];\n        const middle = createTemplateMiddle(cooked, raw);\n        if (range !== null) {\n          this.setSourceMapRange(middle, range);\n        }\n        spans.push(ts3.factory.createTemplateSpan(template.expressions[i - 1], middle));\n      }\n      const resolvedExpression = template.expressions[length - 2];\n      const templatePart = template.elements[length - 1];\n      const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);\n      if (templatePart.range !== null) {\n        this.setSourceMapRange(templateTail, templatePart.range);\n      }\n      spans.push(ts3.factory.createTemplateSpan(resolvedExpression, templateTail));\n      templateLiteral = ts3.factory.createTemplateExpression(ts3.factory.createTemplateHead(head.cooked, head.raw), spans);\n    }\n    if (head.range !== null) {\n      this.setSourceMapRange(templateLiteral, head.range);\n    }\n    return ts3.factory.createTaggedTemplateExpression(tag, void 0, templateLiteral);\n  }\n  createUnaryExpression(operator, operand) {\n    return ts3.factory.createPrefixUnaryExpression(UNARY_OPERATORS2[operator], operand);\n  }\n  createVariableDeclaration(variableName, initializer, type) {\n    return ts3.factory.createVariableStatement(void 0, ts3.factory.createVariableDeclarationList([ts3.factory.createVariableDeclaration(variableName, void 0, void 0, initializer != null ? initializer : void 0)], VAR_TYPES[type]));\n  }\n  setSourceMapRange(node, sourceMapRange) {\n    if (sourceMapRange === null) {\n      return node;\n    }\n    const url = sourceMapRange.url;\n    if (!this.externalSourceFiles.has(url)) {\n      this.externalSourceFiles.set(url, ts3.createSourceMapSource(url, sourceMapRange.content, (pos) => pos));\n    }\n    const source = this.externalSourceFiles.get(url);\n    ts3.setSourceMapRange(node, { pos: sourceMapRange.start.offset, end: sourceMapRange.end.offset, source });\n    return node;\n  }\n};\nfunction createTemplateMiddle(cooked, raw) {\n  const node = ts3.factory.createTemplateHead(cooked, raw);\n  node.kind = ts3.SyntaxKind.TemplateMiddle;\n  return node;\n}\nfunction createTemplateTail(cooked, raw) {\n  const node = ts3.factory.createTemplateHead(cooked, raw);\n  node.kind = ts3.SyntaxKind.TemplateTail;\n  return node;\n}\nfunction attachComments(statement, leadingComments) {\n  for (const comment of leadingComments) {\n    const commentKind = comment.multiline ? ts3.SyntaxKind.MultiLineCommentTrivia : ts3.SyntaxKind.SingleLineCommentTrivia;\n    if (comment.multiline) {\n      ts3.addSyntheticLeadingComment(statement, commentKind, comment.toString(), comment.trailingNewline);\n    } else {\n      for (const line of comment.toString().split(\"\\n\")) {\n        ts3.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);\n      }\n    }\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/translator/src/typescript_translator.mjs\nfunction translateExpression(expression, imports, options = {}) {\n  return expression.visitExpression(new ExpressionTranslatorVisitor(new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, options), new Context(false));\n}\nfunction translateStatement(statement, imports, options = {}) {\n  return statement.visitStatement(new ExpressionTranslatorVisitor(new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, options), new Context(true));\n}\n\nexport {\n  Context,\n  ImportManager,\n  ExpressionTranslatorVisitor,\n  translateType,\n  translateExpression,\n  translateStatement\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}