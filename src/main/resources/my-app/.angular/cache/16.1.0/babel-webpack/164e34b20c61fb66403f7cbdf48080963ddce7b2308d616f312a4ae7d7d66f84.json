{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/user/Desktop/SpringBootProject/src/main/resources/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { createRequire as __cjsCompatRequire } from 'module';\nconst require = __cjsCompatRequire(import.meta.url);\nimport { CompilationMode, CompletionKind, ComponentDecoratorHandler, ComponentScopeKind, CompoundComponentScopeReader, CompoundMetadataReader, CompoundMetadataRegistry, DirectiveDecoratorHandler, DtsMetadataReader, DtsTransformRegistry, ExportedProviderStatusResolver, HostDirectivesResolver, InjectableClassRegistry, InjectableDecoratorHandler, LocalMetadataRegistry, LocalModuleScopeRegistry, MetaKind, MetadataDtsModuleScopeResolver, NgModuleDecoratorHandler, NoopReferencesRegistry, OptimizeFor, PartialEvaluator, PipeDecoratorHandler, PotentialImportKind, PotentialImportMode, ResourceRegistry, SemanticDepGraphUpdater, SymbolKind, TraitCompiler, TypeCheckScopeRegistry, aliasTransformFactory, declarationTransformFactory, ivyTransformFactory } from \"./chunk-JXL4GN5W.js\";\nimport { TypeScriptReflectionHost, isNamedClassDeclaration } from \"./chunk-OIJPCKRW.js\";\nimport { ImportManager, translateExpression, translateType } from \"./chunk-AAX4HKH5.js\";\nimport { AbsoluteModuleStrategy, AliasStrategy, COMPILER_ERRORS_WITH_GUIDES, DefaultImportTracker, ERROR_DETAILS_PAGE_BASE_URL, ErrorCode, ExtendedTemplateDiagnosticName, FatalDiagnosticError, ImportFlags, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, NoopImportRewriter, PrivateExportAliasingHost, R3SymbolsImportRewriter, Reference, ReferenceEmitter, RelativePathStrategy, UnifiedModulesAliasingHost, UnifiedModulesStrategy, addDiagnosticChain, assertSuccessfulReferenceEmit, getRootDirs, getSourceFileOrNull, getTokenAtPosition, isAssignment, isDtsPath, isNonDeclarationTsPath, isSymbolWithValueDeclaration, makeDiagnostic, makeDiagnosticChain, makeRelatedInformation, ngErrorCode, normalizeSeparators, relativePathBetween, replaceTsWithNgInErrors, toUnredirectedSourceFile } from \"./chunk-KPIJL3UY.js\";\nimport { ActivePerfRecorder, DelegatingPerfRecorder, PerfCheckpoint, PerfEvent, PerfPhase } from \"./chunk-HJOPJLIM.js\";\nimport { LogicalFileSystem, absoluteFrom, absoluteFromSourceFile, dirname, getFileSystem, getSourceFileOrError, join, resolve } from \"./chunk-EC5K6QPP.js\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/api.mjs\nvar DEFAULT_ERROR_CODE = 100;\nvar UNKNOWN_ERROR_CODE = 500;\nvar SOURCE = \"angular\";\nfunction isTsDiagnostic(diagnostic) {\n  return diagnostic != null && diagnostic.source !== \"angular\";\n}\nvar EmitFlags;\n(function (EmitFlags2) {\n  EmitFlags2[EmitFlags2[\"DTS\"] = 1] = \"DTS\";\n  EmitFlags2[EmitFlags2[\"JS\"] = 2] = \"JS\";\n  EmitFlags2[EmitFlags2[\"Metadata\"] = 4] = \"Metadata\";\n  EmitFlags2[EmitFlags2[\"I18nBundle\"] = 8] = \"I18nBundle\";\n  EmitFlags2[EmitFlags2[\"Codegen\"] = 16] = \"Codegen\";\n  EmitFlags2[EmitFlags2[\"Default\"] = 19] = \"Default\";\n  EmitFlags2[EmitFlags2[\"All\"] = 31] = \"All\";\n})(EmitFlags || (EmitFlags = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/compiler_host.mjs\nimport ts from \"typescript\";\nvar wrapHostForTest = null;\nfunction createCompilerHost({\n  options,\n  tsHost = ts.createCompilerHost(options, true)\n}) {\n  if (wrapHostForTest !== null) {\n    tsHost = wrapHostForTest(tsHost);\n  }\n  return tsHost;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program.mjs\nimport { HtmlParser, MessageBundle } from \"@angular/compiler\";\nimport ts32 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/i18n.mjs\nimport { Xliff, Xliff2, Xmb } from \"@angular/compiler\";\nimport * as path from \"path\";\nfunction i18nGetExtension(formatName) {\n  const format = formatName.toLowerCase();\n  switch (format) {\n    case \"xmb\":\n      return \"xmb\";\n    case \"xlf\":\n    case \"xlif\":\n    case \"xliff\":\n    case \"xlf2\":\n    case \"xliff2\":\n      return \"xlf\";\n  }\n  throw new Error(`Unsupported format \"${formatName}\"`);\n}\nfunction i18nExtract(formatName, outFile, host, options, bundle, pathResolve = path.resolve) {\n  formatName = formatName || \"xlf\";\n  const ext = i18nGetExtension(formatName);\n  const content = i18nSerialize(bundle, formatName, options);\n  const dstFile = outFile || `messages.${ext}`;\n  const dstPath = pathResolve(options.outDir || options.basePath, dstFile);\n  host.writeFile(dstPath, content, false, void 0, []);\n  return [dstPath];\n}\nfunction i18nSerialize(bundle, formatName, options) {\n  const format = formatName.toLowerCase();\n  let serializer;\n  switch (format) {\n    case \"xmb\":\n      serializer = new Xmb();\n      break;\n    case \"xliff2\":\n    case \"xlf2\":\n      serializer = new Xliff2();\n      break;\n    case \"xlf\":\n    case \"xliff\":\n    default:\n      serializer = new Xliff();\n  }\n  return bundle.write(serializer, getPathNormalizer(options.basePath));\n}\nfunction getPathNormalizer(basePath) {\n  return sourcePath => {\n    sourcePath = basePath ? path.relative(basePath, sourcePath) : sourcePath;\n    return sourcePath.split(path.sep).join(\"/\");\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/typescript_support.mjs\nimport ts2 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/version_helpers.mjs\nfunction toNumbers(value) {\n  const suffixIndex = value.lastIndexOf(\"-\");\n  return value.slice(0, suffixIndex === -1 ? value.length : suffixIndex).split(\".\").map(segment => {\n    const parsed = parseInt(segment, 10);\n    if (isNaN(parsed)) {\n      throw Error(`Unable to parse version string ${value}.`);\n    }\n    return parsed;\n  });\n}\nfunction compareNumbers(a, b) {\n  const max = Math.max(a.length, b.length);\n  const min = Math.min(a.length, b.length);\n  for (let i = 0; i < min; i++) {\n    if (a[i] > b[i]) return 1;\n    if (a[i] < b[i]) return -1;\n  }\n  if (min !== max) {\n    const longestArray = a.length === max ? a : b;\n    const comparisonResult = a.length === max ? 1 : -1;\n    for (let i = min; i < max; i++) {\n      if (longestArray[i] > 0) {\n        return comparisonResult;\n      }\n    }\n  }\n  return 0;\n}\nfunction compareVersions(v1, v2) {\n  return compareNumbers(toNumbers(v1), toNumbers(v2));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/typescript_support.mjs\nvar MIN_TS_VERSION = \"4.9.3\";\nvar MAX_TS_VERSION = \"5.2.0\";\nvar tsVersion = ts2.version;\nfunction checkVersion(version, minVersion, maxVersion) {\n  if (compareVersions(version, minVersion) < 0 || compareVersions(version, maxVersion) >= 0) {\n    throw new Error(`The Angular Compiler requires TypeScript >=${minVersion} and <${maxVersion} but ${version} was found instead.`);\n  }\n}\nfunction verifySupportedTypeScriptVersion() {\n  checkVersion(tsVersion, MIN_TS_VERSION, MAX_TS_VERSION);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/core/src/compiler.mjs\nimport ts30 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/cycles/src/analyzer.mjs\nvar CycleAnalyzer = class {\n  constructor(importGraph) {\n    this.importGraph = importGraph;\n    this.cachedResults = null;\n  }\n  wouldCreateCycle(from, to) {\n    if (this.cachedResults === null || this.cachedResults.from !== from) {\n      this.cachedResults = new CycleResults(from, this.importGraph);\n    }\n    return this.cachedResults.wouldBeCyclic(to) ? new Cycle(this.importGraph, from, to) : null;\n  }\n  recordSyntheticImport(from, to) {\n    this.cachedResults = null;\n    this.importGraph.addSyntheticImport(from, to);\n  }\n};\nvar NgCyclicResult = Symbol(\"NgCyclicResult\");\nvar CycleResults = class {\n  constructor(from, importGraph) {\n    this.from = from;\n    this.importGraph = importGraph;\n    this.cyclic = {};\n    this.acyclic = {};\n  }\n  wouldBeCyclic(sf) {\n    const cached = this.getCachedResult(sf);\n    if (cached !== null) {\n      return cached;\n    }\n    if (sf === this.from) {\n      return true;\n    }\n    this.markAcyclic(sf);\n    const imports = this.importGraph.importsOf(sf);\n    for (const imported of imports) {\n      if (this.wouldBeCyclic(imported)) {\n        this.markCyclic(sf);\n        return true;\n      }\n    }\n    return false;\n  }\n  getCachedResult(sf) {\n    const result = sf[NgCyclicResult];\n    if (result === this.cyclic) {\n      return true;\n    } else if (result === this.acyclic) {\n      return false;\n    } else {\n      return null;\n    }\n  }\n  markCyclic(sf) {\n    sf[NgCyclicResult] = this.cyclic;\n  }\n  markAcyclic(sf) {\n    sf[NgCyclicResult] = this.acyclic;\n  }\n};\nvar Cycle = class {\n  constructor(importGraph, from, to) {\n    this.importGraph = importGraph;\n    this.from = from;\n    this.to = to;\n  }\n  getPath() {\n    return [this.from, ...this.importGraph.findPath(this.to, this.from)];\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/cycles/src/imports.mjs\nimport ts3 from \"typescript\";\nvar ImportGraph = class {\n  constructor(checker, perf) {\n    this.checker = checker;\n    this.perf = perf;\n    this.imports = /* @__PURE__ */new Map();\n  }\n  importsOf(sf) {\n    if (!this.imports.has(sf)) {\n      this.imports.set(sf, this.scanImports(sf));\n    }\n    return this.imports.get(sf);\n  }\n  findPath(start, end) {\n    if (start === end) {\n      return [start];\n    }\n    const found = /* @__PURE__ */new Set([start]);\n    const queue = [new Found(start, null)];\n    while (queue.length > 0) {\n      const current = queue.shift();\n      const imports = this.importsOf(current.sourceFile);\n      for (const importedFile of imports) {\n        if (!found.has(importedFile)) {\n          const next = new Found(importedFile, current);\n          if (next.sourceFile === end) {\n            return next.toPath();\n          }\n          found.add(importedFile);\n          queue.push(next);\n        }\n      }\n    }\n    return null;\n  }\n  addSyntheticImport(sf, imported) {\n    if (isLocalFile(imported)) {\n      this.importsOf(sf).add(imported);\n    }\n  }\n  scanImports(sf) {\n    return this.perf.inPhase(PerfPhase.CycleDetection, () => {\n      const imports = /* @__PURE__ */new Set();\n      for (const stmt of sf.statements) {\n        if (!ts3.isImportDeclaration(stmt) && !ts3.isExportDeclaration(stmt) || stmt.moduleSpecifier === void 0) {\n          continue;\n        }\n        if (ts3.isImportDeclaration(stmt) && stmt.importClause !== void 0 && isTypeOnlyImportClause(stmt.importClause)) {\n          continue;\n        }\n        const symbol = this.checker.getSymbolAtLocation(stmt.moduleSpecifier);\n        if (symbol === void 0 || symbol.valueDeclaration === void 0) {\n          continue;\n        }\n        const moduleFile = symbol.valueDeclaration;\n        if (ts3.isSourceFile(moduleFile) && isLocalFile(moduleFile)) {\n          imports.add(moduleFile);\n        }\n      }\n      return imports;\n    });\n  }\n};\nfunction isLocalFile(sf) {\n  return !sf.isDeclarationFile;\n}\nfunction isTypeOnlyImportClause(node) {\n  if (node.isTypeOnly) {\n    return true;\n  }\n  if (node.namedBindings !== void 0 && ts3.isNamedImports(node.namedBindings) && node.namedBindings.elements.every(specifier => specifier.isTypeOnly)) {\n    return true;\n  }\n  return false;\n}\nvar Found = class {\n  constructor(sourceFile, parent) {\n    this.sourceFile = sourceFile;\n    this.parent = parent;\n  }\n  toPath() {\n    const array = [];\n    let current = this;\n    while (current !== null) {\n      array.push(current.sourceFile);\n      current = current.parent;\n    }\n    return array.reverse();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/entry_point/src/generator.mjs\nimport ts4 from \"typescript\";\nvar FlatIndexGenerator = class {\n  constructor(entryPoint, relativeFlatIndexPath, moduleName) {\n    this.entryPoint = entryPoint;\n    this.moduleName = moduleName;\n    this.shouldEmit = true;\n    this.flatIndexPath = join(dirname(entryPoint), relativeFlatIndexPath).replace(/\\.js$/, \"\") + \".ts\";\n  }\n  makeTopLevelShim() {\n    const relativeEntryPoint = relativePathBetween(this.flatIndexPath, this.entryPoint);\n    const contents = `/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from '${relativeEntryPoint}';\n`;\n    const genFile = ts4.createSourceFile(this.flatIndexPath, contents, ts4.ScriptTarget.ES2015, true, ts4.ScriptKind.TS);\n    if (this.moduleName !== null) {\n      genFile.moduleName = this.moduleName;\n    }\n    return genFile;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/entry_point/src/logic.mjs\nfunction findFlatIndexEntryPoint(rootFiles) {\n  const tsFiles = rootFiles.filter(file => isNonDeclarationTsPath(file));\n  let resolvedEntryPoint = null;\n  if (tsFiles.length === 1) {\n    resolvedEntryPoint = tsFiles[0];\n  } else {\n    for (const tsFile of tsFiles) {\n      if (getFileSystem().basename(tsFile) === \"index.ts\" && (resolvedEntryPoint === null || tsFile.length <= resolvedEntryPoint.length)) {\n        resolvedEntryPoint = tsFile;\n      }\n    }\n  }\n  return resolvedEntryPoint;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/entry_point/src/private_export_checker.mjs\nimport ts5 from \"typescript\";\nfunction checkForPrivateExports(entryPoint, checker, refGraph) {\n  const diagnostics = [];\n  const topLevelExports = /* @__PURE__ */new Set();\n  const moduleSymbol = checker.getSymbolAtLocation(entryPoint);\n  if (moduleSymbol === void 0) {\n    throw new Error(`Internal error: failed to get symbol for entrypoint`);\n  }\n  const exportedSymbols = checker.getExportsOfModule(moduleSymbol);\n  exportedSymbols.forEach(symbol => {\n    if (symbol.flags & ts5.SymbolFlags.Alias) {\n      symbol = checker.getAliasedSymbol(symbol);\n    }\n    const decl = symbol.valueDeclaration;\n    if (decl !== void 0) {\n      topLevelExports.add(decl);\n    }\n  });\n  const checkedSet = /* @__PURE__ */new Set();\n  topLevelExports.forEach(mainExport => {\n    refGraph.transitiveReferencesOf(mainExport).forEach(transitiveReference => {\n      if (checkedSet.has(transitiveReference)) {\n        return;\n      }\n      checkedSet.add(transitiveReference);\n      if (!topLevelExports.has(transitiveReference)) {\n        const descriptor = getDescriptorOfDeclaration(transitiveReference);\n        const name = getNameOfDeclaration(transitiveReference);\n        let visibleVia = \"NgModule exports\";\n        const transitivePath = refGraph.pathFrom(mainExport, transitiveReference);\n        if (transitivePath !== null) {\n          visibleVia = transitivePath.map(seg => getNameOfDeclaration(seg)).join(\" -> \");\n        }\n        const diagnostic = {\n          category: ts5.DiagnosticCategory.Error,\n          code: ngErrorCode(ErrorCode.SYMBOL_NOT_EXPORTED),\n          file: transitiveReference.getSourceFile(),\n          ...getPosOfDeclaration(transitiveReference),\n          messageText: `Unsupported private ${descriptor} ${name}. This ${descriptor} is visible to consumers via ${visibleVia}, but is not exported from the top-level library entrypoint.`\n        };\n        diagnostics.push(diagnostic);\n      }\n    });\n  });\n  return diagnostics;\n}\nfunction getPosOfDeclaration(decl) {\n  const node = getIdentifierOfDeclaration(decl) || decl;\n  return {\n    start: node.getStart(),\n    length: node.getEnd() + 1 - node.getStart()\n  };\n}\nfunction getIdentifierOfDeclaration(decl) {\n  if ((ts5.isClassDeclaration(decl) || ts5.isVariableDeclaration(decl) || ts5.isFunctionDeclaration(decl)) && decl.name !== void 0 && ts5.isIdentifier(decl.name)) {\n    return decl.name;\n  } else {\n    return null;\n  }\n}\nfunction getNameOfDeclaration(decl) {\n  const id = getIdentifierOfDeclaration(decl);\n  return id !== null ? id.text : \"(unnamed)\";\n}\nfunction getDescriptorOfDeclaration(decl) {\n  switch (decl.kind) {\n    case ts5.SyntaxKind.ClassDeclaration:\n      return \"class\";\n    case ts5.SyntaxKind.FunctionDeclaration:\n      return \"function\";\n    case ts5.SyntaxKind.VariableDeclaration:\n      return \"variable\";\n    case ts5.SyntaxKind.EnumDeclaration:\n      return \"enum\";\n    default:\n      return \"declaration\";\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/entry_point/src/reference_graph.mjs\nvar ReferenceGraph = class {\n  constructor() {\n    this.references = /* @__PURE__ */new Map();\n  }\n  add(from, to) {\n    if (!this.references.has(from)) {\n      this.references.set(from, /* @__PURE__ */new Set());\n    }\n    this.references.get(from).add(to);\n  }\n  transitiveReferencesOf(target) {\n    const set = /* @__PURE__ */new Set();\n    this.collectTransitiveReferences(set, target);\n    return set;\n  }\n  pathFrom(source, target) {\n    return this.collectPathFrom(source, target, /* @__PURE__ */new Set());\n  }\n  collectPathFrom(source, target, seen) {\n    if (source === target) {\n      return [target];\n    } else if (seen.has(source)) {\n      return null;\n    }\n    seen.add(source);\n    if (!this.references.has(source)) {\n      return null;\n    } else {\n      let candidatePath = null;\n      this.references.get(source).forEach(edge => {\n        if (candidatePath !== null) {\n          return;\n        }\n        const partialPath = this.collectPathFrom(edge, target, seen);\n        if (partialPath !== null) {\n          candidatePath = [source, ...partialPath];\n        }\n      });\n      return candidatePath;\n    }\n  }\n  collectTransitiveReferences(set, decl) {\n    if (this.references.has(decl)) {\n      this.references.get(decl).forEach(ref => {\n        if (!set.has(ref)) {\n          set.add(ref);\n          this.collectTransitiveReferences(set, ref);\n        }\n      });\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program_driver/src/api.mjs\nvar NgOriginalFile = Symbol(\"NgOriginalFile\");\nvar UpdateMode;\n(function (UpdateMode2) {\n  UpdateMode2[UpdateMode2[\"Complete\"] = 0] = \"Complete\";\n  UpdateMode2[UpdateMode2[\"Incremental\"] = 1] = \"Incremental\";\n})(UpdateMode || (UpdateMode = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program_driver/src/ts_create_program_driver.mjs\nimport ts7 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/adapter.mjs\nimport ts6 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/expando.mjs\nvar NgExtension = Symbol(\"NgExtension\");\nfunction isExtended(sf) {\n  return sf[NgExtension] !== void 0;\n}\nfunction sfExtensionData(sf) {\n  const extSf = sf;\n  if (extSf[NgExtension] !== void 0) {\n    return extSf[NgExtension];\n  }\n  const extension = {\n    isTopLevelShim: false,\n    fileShim: null,\n    originalReferencedFiles: null,\n    taggedReferenceFiles: null\n  };\n  extSf[NgExtension] = extension;\n  return extension;\n}\nfunction isFileShimSourceFile(sf) {\n  return isExtended(sf) && sf[NgExtension].fileShim !== null;\n}\nfunction isShim(sf) {\n  return isExtended(sf) && (sf[NgExtension].fileShim !== null || sf[NgExtension].isTopLevelShim);\n}\nfunction copyFileShimData(from, to) {\n  if (!isFileShimSourceFile(from)) {\n    return;\n  }\n  sfExtensionData(to).fileShim = sfExtensionData(from).fileShim;\n}\nfunction untagAllTsFiles(program) {\n  for (const sf of program.getSourceFiles()) {\n    untagTsFile(sf);\n  }\n}\nfunction retagAllTsFiles(program) {\n  for (const sf of program.getSourceFiles()) {\n    retagTsFile(sf);\n  }\n}\nfunction untagTsFile(sf) {\n  if (sf.isDeclarationFile || !isExtended(sf)) {\n    return;\n  }\n  const ext = sfExtensionData(sf);\n  if (ext.originalReferencedFiles !== null) {\n    sf.referencedFiles = ext.originalReferencedFiles;\n  }\n}\nfunction retagTsFile(sf) {\n  if (sf.isDeclarationFile || !isExtended(sf)) {\n    return;\n  }\n  const ext = sfExtensionData(sf);\n  if (ext.taggedReferenceFiles !== null) {\n    sf.referencedFiles = ext.taggedReferenceFiles;\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/util.mjs\nvar TS_EXTENSIONS = /\\.tsx?$/i;\nfunction makeShimFileName(fileName, suffix) {\n  return absoluteFrom(fileName.replace(TS_EXTENSIONS, suffix));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/adapter.mjs\nvar ShimAdapter = class {\n  constructor(delegate, tsRootFiles, topLevelGenerators, perFileGenerators, oldProgram) {\n    this.delegate = delegate;\n    this.shims = /* @__PURE__ */new Map();\n    this.priorShims = /* @__PURE__ */new Map();\n    this.notShims = /* @__PURE__ */new Set();\n    this.generators = [];\n    this.ignoreForEmit = /* @__PURE__ */new Set();\n    this.extensionPrefixes = [];\n    for (const gen of perFileGenerators) {\n      const pattern = `^(.*)\\\\.${gen.extensionPrefix}\\\\.ts$`;\n      const regexp = new RegExp(pattern, \"i\");\n      this.generators.push({\n        generator: gen,\n        test: regexp,\n        suffix: `.${gen.extensionPrefix}.ts`\n      });\n      this.extensionPrefixes.push(gen.extensionPrefix);\n    }\n    const extraInputFiles = [];\n    for (const gen of topLevelGenerators) {\n      const sf = gen.makeTopLevelShim();\n      sfExtensionData(sf).isTopLevelShim = true;\n      if (!gen.shouldEmit) {\n        this.ignoreForEmit.add(sf);\n      }\n      const fileName = absoluteFromSourceFile(sf);\n      this.shims.set(fileName, sf);\n      extraInputFiles.push(fileName);\n    }\n    for (const rootFile of tsRootFiles) {\n      for (const gen of this.generators) {\n        extraInputFiles.push(makeShimFileName(rootFile, gen.suffix));\n      }\n    }\n    this.extraInputFiles = extraInputFiles;\n    if (oldProgram !== null) {\n      for (const oldSf of oldProgram.getSourceFiles()) {\n        if (oldSf.isDeclarationFile || !isFileShimSourceFile(oldSf)) {\n          continue;\n        }\n        this.priorShims.set(absoluteFromSourceFile(oldSf), oldSf);\n      }\n    }\n  }\n  maybeGenerate(fileName) {\n    if (this.notShims.has(fileName)) {\n      return null;\n    } else if (this.shims.has(fileName)) {\n      return this.shims.get(fileName);\n    }\n    if (isDtsPath(fileName)) {\n      this.notShims.add(fileName);\n      return null;\n    }\n    for (const record of this.generators) {\n      const match = record.test.exec(fileName);\n      if (match === null) {\n        continue;\n      }\n      const prefix = match[1];\n      let baseFileName = absoluteFrom(prefix + \".ts\");\n      let inputFile = this.delegate.getSourceFile(baseFileName, ts6.ScriptTarget.Latest);\n      if (inputFile === void 0) {\n        baseFileName = absoluteFrom(prefix + \".tsx\");\n        inputFile = this.delegate.getSourceFile(baseFileName, ts6.ScriptTarget.Latest);\n      }\n      if (inputFile === void 0 || isShim(inputFile)) {\n        return void 0;\n      }\n      return this.generateSpecific(fileName, record.generator, inputFile);\n    }\n    this.notShims.add(fileName);\n    return null;\n  }\n  generateSpecific(fileName, generator, inputFile) {\n    let priorShimSf = null;\n    if (this.priorShims.has(fileName)) {\n      priorShimSf = this.priorShims.get(fileName);\n      this.priorShims.delete(fileName);\n    }\n    const shimSf = generator.generateShimForFile(inputFile, fileName, priorShimSf);\n    sfExtensionData(shimSf).fileShim = {\n      extension: generator.extensionPrefix,\n      generatedFrom: absoluteFromSourceFile(inputFile)\n    };\n    if (!generator.shouldEmit) {\n      this.ignoreForEmit.add(shimSf);\n    }\n    this.shims.set(fileName, shimSf);\n    return shimSf;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/reference_tagger.mjs\nvar ShimReferenceTagger = class {\n  constructor(shimExtensions) {\n    this.tagged = /* @__PURE__ */new Set();\n    this.enabled = true;\n    this.suffixes = shimExtensions.map(extension => `.${extension}.ts`);\n  }\n  tag(sf) {\n    if (!this.enabled || sf.isDeclarationFile || isShim(sf) || this.tagged.has(sf) || !isNonDeclarationTsPath(sf.fileName)) {\n      return;\n    }\n    const ext = sfExtensionData(sf);\n    if (ext.originalReferencedFiles === null) {\n      ext.originalReferencedFiles = sf.referencedFiles;\n    }\n    const referencedFiles = [...ext.originalReferencedFiles];\n    const sfPath = absoluteFromSourceFile(sf);\n    for (const suffix of this.suffixes) {\n      referencedFiles.push({\n        fileName: makeShimFileName(sfPath, suffix),\n        pos: 0,\n        end: 0\n      });\n    }\n    ext.taggedReferenceFiles = referencedFiles;\n    sf.referencedFiles = referencedFiles;\n    this.tagged.add(sf);\n  }\n  finalize() {\n    this.enabled = false;\n    this.tagged.clear();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program_driver/src/ts_create_program_driver.mjs\nvar DelegatingCompilerHost = class {\n  constructor(delegate) {\n    this.delegate = delegate;\n    this.createHash = this.delegateMethod(\"createHash\");\n    this.directoryExists = this.delegateMethod(\"directoryExists\");\n    this.getCancellationToken = this.delegateMethod(\"getCancellationToken\");\n    this.getCanonicalFileName = this.delegateMethod(\"getCanonicalFileName\");\n    this.getCurrentDirectory = this.delegateMethod(\"getCurrentDirectory\");\n    this.getDefaultLibFileName = this.delegateMethod(\"getDefaultLibFileName\");\n    this.getDefaultLibLocation = this.delegateMethod(\"getDefaultLibLocation\");\n    this.getDirectories = this.delegateMethod(\"getDirectories\");\n    this.getEnvironmentVariable = this.delegateMethod(\"getEnvironmentVariable\");\n    this.getNewLine = this.delegateMethod(\"getNewLine\");\n    this.getParsedCommandLine = this.delegateMethod(\"getParsedCommandLine\");\n    this.getSourceFileByPath = this.delegateMethod(\"getSourceFileByPath\");\n    this.readDirectory = this.delegateMethod(\"readDirectory\");\n    this.readFile = this.delegateMethod(\"readFile\");\n    this.realpath = this.delegateMethod(\"realpath\");\n    this.resolveModuleNames = this.delegateMethod(\"resolveModuleNames\");\n    this.resolveTypeReferenceDirectives = this.delegateMethod(\"resolveTypeReferenceDirectives\");\n    this.trace = this.delegateMethod(\"trace\");\n    this.useCaseSensitiveFileNames = this.delegateMethod(\"useCaseSensitiveFileNames\");\n    this.getModuleResolutionCache = this.delegateMethod(\"getModuleResolutionCache\");\n    this.hasInvalidatedResolutions = this.delegateMethod(\"hasInvalidatedResolutions\");\n    this.resolveModuleNameLiterals = this.delegateMethod(\"resolveModuleNameLiterals\");\n    this.resolveTypeReferenceDirectiveReferences = this.delegateMethod(\"resolveTypeReferenceDirectiveReferences\");\n  }\n  delegateMethod(name) {\n    return this.delegate[name] !== void 0 ? this.delegate[name].bind(this.delegate) : void 0;\n  }\n};\nvar UpdatedProgramHost = class extends DelegatingCompilerHost {\n  constructor(sfMap, originalProgram, delegate, shimExtensionPrefixes) {\n    super(delegate);\n    this.originalProgram = originalProgram;\n    this.shimExtensionPrefixes = shimExtensionPrefixes;\n    this.shimTagger = new ShimReferenceTagger(this.shimExtensionPrefixes);\n    this.sfMap = sfMap;\n  }\n  getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile) {\n    let delegateSf = this.originalProgram.getSourceFile(fileName);\n    if (delegateSf === void 0) {\n      delegateSf = this.delegate.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);\n    }\n    if (delegateSf === void 0) {\n      return void 0;\n    }\n    let sf;\n    if (this.sfMap.has(fileName)) {\n      sf = this.sfMap.get(fileName);\n      copyFileShimData(delegateSf, sf);\n    } else {\n      sf = delegateSf;\n    }\n    sf = toUnredirectedSourceFile(sf);\n    this.shimTagger.tag(sf);\n    return sf;\n  }\n  postProgramCreationCleanup() {\n    this.shimTagger.finalize();\n  }\n  writeFile() {\n    throw new Error(`TypeCheckProgramHost should never write files`);\n  }\n  fileExists(fileName) {\n    return this.sfMap.has(fileName) || this.delegate.fileExists(fileName);\n  }\n};\nvar TsCreateProgramDriver = class {\n  constructor(originalProgram, originalHost, options, shimExtensionPrefixes) {\n    this.originalProgram = originalProgram;\n    this.originalHost = originalHost;\n    this.options = options;\n    this.shimExtensionPrefixes = shimExtensionPrefixes;\n    this.sfMap = /* @__PURE__ */new Map();\n    this.supportsInlineOperations = true;\n    this.program = this.originalProgram;\n  }\n  getProgram() {\n    return this.program;\n  }\n  updateFiles(contents, updateMode) {\n    if (contents.size === 0) {\n      if (updateMode !== UpdateMode.Complete || this.sfMap.size === 0) {\n        return;\n      }\n    }\n    if (updateMode === UpdateMode.Complete) {\n      this.sfMap.clear();\n    }\n    for (const [filePath, {\n      newText,\n      originalFile\n    }] of contents.entries()) {\n      const sf = ts7.createSourceFile(filePath, newText, ts7.ScriptTarget.Latest, true);\n      if (originalFile !== null) {\n        sf[NgOriginalFile] = originalFile;\n      }\n      this.sfMap.set(filePath, sf);\n    }\n    const host = new UpdatedProgramHost(this.sfMap, this.originalProgram, this.originalHost, this.shimExtensionPrefixes);\n    const oldProgram = this.program;\n    retagAllTsFiles(oldProgram);\n    this.program = ts7.createProgram({\n      host,\n      rootNames: this.program.getRootFileNames(),\n      options: this.options,\n      oldProgram\n    });\n    host.postProgramCreationCleanup();\n    untagAllTsFiles(this.program);\n    untagAllTsFiles(oldProgram);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/src/dependency_tracking.mjs\nvar FileDependencyGraph = class {\n  constructor() {\n    this.nodes = /* @__PURE__ */new Map();\n  }\n  addDependency(from, on) {\n    this.nodeFor(from).dependsOn.add(absoluteFromSourceFile(on));\n  }\n  addResourceDependency(from, resource) {\n    this.nodeFor(from).usesResources.add(resource);\n  }\n  recordDependencyAnalysisFailure(file) {\n    this.nodeFor(file).failedAnalysis = true;\n  }\n  getResourceDependencies(from) {\n    const node = this.nodes.get(from);\n    return node ? [...node.usesResources] : [];\n  }\n  updateWithPhysicalChanges(previous, changedTsPaths, deletedTsPaths, changedResources) {\n    const logicallyChanged = /* @__PURE__ */new Set();\n    for (const sf of previous.nodes.keys()) {\n      const sfPath = absoluteFromSourceFile(sf);\n      const node = previous.nodeFor(sf);\n      if (isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources)) {\n        logicallyChanged.add(sfPath);\n      } else if (!deletedTsPaths.has(sfPath)) {\n        this.nodes.set(sf, {\n          dependsOn: new Set(node.dependsOn),\n          usesResources: new Set(node.usesResources),\n          failedAnalysis: false\n        });\n      }\n    }\n    return logicallyChanged;\n  }\n  nodeFor(sf) {\n    if (!this.nodes.has(sf)) {\n      this.nodes.set(sf, {\n        dependsOn: /* @__PURE__ */new Set(),\n        usesResources: /* @__PURE__ */new Set(),\n        failedAnalysis: false\n      });\n    }\n    return this.nodes.get(sf);\n  }\n};\nfunction isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources) {\n  if (node.failedAnalysis) {\n    return true;\n  }\n  const sfPath = absoluteFromSourceFile(sf);\n  if (changedTsPaths.has(sfPath) || deletedTsPaths.has(sfPath)) {\n    return true;\n  }\n  for (const dep of node.dependsOn) {\n    if (changedTsPaths.has(dep) || deletedTsPaths.has(dep)) {\n      return true;\n    }\n  }\n  for (const dep of node.usesResources) {\n    if (changedResources.has(dep)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/src/state.mjs\nvar IncrementalStateKind;\n(function (IncrementalStateKind2) {\n  IncrementalStateKind2[IncrementalStateKind2[\"Fresh\"] = 0] = \"Fresh\";\n  IncrementalStateKind2[IncrementalStateKind2[\"Delta\"] = 1] = \"Delta\";\n  IncrementalStateKind2[IncrementalStateKind2[\"Analyzed\"] = 2] = \"Analyzed\";\n})(IncrementalStateKind || (IncrementalStateKind = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/src/incremental.mjs\nvar PhaseKind;\n(function (PhaseKind2) {\n  PhaseKind2[PhaseKind2[\"Analysis\"] = 0] = \"Analysis\";\n  PhaseKind2[PhaseKind2[\"TypeCheckAndEmit\"] = 1] = \"TypeCheckAndEmit\";\n})(PhaseKind || (PhaseKind = {}));\nvar IncrementalCompilation = class {\n  constructor(state, depGraph, versions, step) {\n    this.depGraph = depGraph;\n    this.versions = versions;\n    this.step = step;\n    this._state = state;\n    this.phase = {\n      kind: PhaseKind.Analysis,\n      semanticDepGraphUpdater: new SemanticDepGraphUpdater(step !== null ? step.priorState.semanticDepGraph : null)\n    };\n  }\n  static fresh(program, versions) {\n    const state = {\n      kind: IncrementalStateKind.Fresh\n    };\n    return new IncrementalCompilation(state, new FileDependencyGraph(), versions, null);\n  }\n  static incremental(program, newVersions, oldProgram, oldState, modifiedResourceFiles, perf) {\n    return perf.inPhase(PerfPhase.Reconciliation, () => {\n      const physicallyChangedTsFiles = /* @__PURE__ */new Set();\n      const changedResourceFiles = new Set(modifiedResourceFiles != null ? modifiedResourceFiles : []);\n      let priorAnalysis;\n      switch (oldState.kind) {\n        case IncrementalStateKind.Fresh:\n          return IncrementalCompilation.fresh(program, newVersions);\n        case IncrementalStateKind.Analyzed:\n          priorAnalysis = oldState;\n          break;\n        case IncrementalStateKind.Delta:\n          priorAnalysis = oldState.lastAnalyzedState;\n          for (const sfPath of oldState.physicallyChangedTsFiles) {\n            physicallyChangedTsFiles.add(sfPath);\n          }\n          for (const resourcePath of oldState.changedResourceFiles) {\n            changedResourceFiles.add(resourcePath);\n          }\n          break;\n      }\n      const oldVersions = priorAnalysis.versions;\n      const oldFilesArray = oldProgram.getSourceFiles().map(toOriginalSourceFile);\n      const oldFiles = new Set(oldFilesArray);\n      const deletedTsFiles = new Set(oldFilesArray.map(sf => absoluteFromSourceFile(sf)));\n      for (const possiblyRedirectedNewFile of program.getSourceFiles()) {\n        const sf = toOriginalSourceFile(possiblyRedirectedNewFile);\n        const sfPath = absoluteFromSourceFile(sf);\n        deletedTsFiles.delete(sfPath);\n        if (oldFiles.has(sf)) {\n          if (oldVersions === null || newVersions === null) {\n            continue;\n          }\n          if (oldVersions.has(sfPath) && newVersions.has(sfPath) && oldVersions.get(sfPath) === newVersions.get(sfPath)) {\n            continue;\n          }\n        }\n        if (sf.isDeclarationFile) {\n          return IncrementalCompilation.fresh(program, newVersions);\n        }\n        physicallyChangedTsFiles.add(sfPath);\n      }\n      for (const deletedFileName of deletedTsFiles) {\n        physicallyChangedTsFiles.delete(resolve(deletedFileName));\n      }\n      const depGraph = new FileDependencyGraph();\n      const logicallyChangedTsFiles = depGraph.updateWithPhysicalChanges(priorAnalysis.depGraph, physicallyChangedTsFiles, deletedTsFiles, changedResourceFiles);\n      for (const sfPath of physicallyChangedTsFiles) {\n        logicallyChangedTsFiles.add(sfPath);\n      }\n      const state = {\n        kind: IncrementalStateKind.Delta,\n        physicallyChangedTsFiles,\n        changedResourceFiles,\n        lastAnalyzedState: priorAnalysis\n      };\n      return new IncrementalCompilation(state, depGraph, newVersions, {\n        priorState: priorAnalysis,\n        logicallyChangedTsFiles\n      });\n    });\n  }\n  get state() {\n    return this._state;\n  }\n  get semanticDepGraphUpdater() {\n    if (this.phase.kind !== PhaseKind.Analysis) {\n      throw new Error(`AssertionError: Cannot update the SemanticDepGraph after analysis completes`);\n    }\n    return this.phase.semanticDepGraphUpdater;\n  }\n  recordSuccessfulAnalysis(traitCompiler) {\n    if (this.phase.kind !== PhaseKind.Analysis) {\n      throw new Error(`AssertionError: Incremental compilation in phase ${PhaseKind[this.phase.kind]}, expected Analysis`);\n    }\n    const {\n      needsEmit,\n      needsTypeCheckEmit,\n      newGraph\n    } = this.phase.semanticDepGraphUpdater.finalize();\n    let emitted;\n    if (this.step === null) {\n      emitted = /* @__PURE__ */new Set();\n    } else {\n      emitted = new Set(this.step.priorState.emitted);\n      for (const sfPath of this.step.logicallyChangedTsFiles) {\n        emitted.delete(sfPath);\n      }\n      for (const sfPath of needsEmit) {\n        emitted.delete(sfPath);\n      }\n    }\n    this._state = {\n      kind: IncrementalStateKind.Analyzed,\n      versions: this.versions,\n      depGraph: this.depGraph,\n      semanticDepGraph: newGraph,\n      priorAnalysis: traitCompiler.getAnalyzedRecords(),\n      typeCheckResults: null,\n      emitted\n    };\n    this.phase = {\n      kind: PhaseKind.TypeCheckAndEmit,\n      needsEmit,\n      needsTypeCheckEmit\n    };\n  }\n  recordSuccessfulTypeCheck(results) {\n    if (this._state.kind !== IncrementalStateKind.Analyzed) {\n      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n    } else if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n      throw new Error(`AssertionError: Incremental compilation in phase ${PhaseKind[this.phase.kind]}, expected TypeCheck`);\n    }\n    this._state.typeCheckResults = results;\n  }\n  recordSuccessfulEmit(sf) {\n    if (this._state.kind !== IncrementalStateKind.Analyzed) {\n      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n    }\n    this._state.emitted.add(absoluteFromSourceFile(sf));\n  }\n  priorAnalysisFor(sf) {\n    if (this.step === null) {\n      return null;\n    }\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.step.logicallyChangedTsFiles.has(sfPath)) {\n      return null;\n    }\n    const priorAnalysis = this.step.priorState.priorAnalysis;\n    if (!priorAnalysis.has(sf)) {\n      return null;\n    }\n    return priorAnalysis.get(sf);\n  }\n  priorTypeCheckingResultsFor(sf) {\n    if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n    }\n    if (this.step === null) {\n      return null;\n    }\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.step.logicallyChangedTsFiles.has(sfPath) || this.phase.needsTypeCheckEmit.has(sfPath)) {\n      return null;\n    }\n    if (this.step.priorState.typeCheckResults === null || !this.step.priorState.typeCheckResults.has(sfPath)) {\n      return null;\n    }\n    const priorResults = this.step.priorState.typeCheckResults.get(sfPath);\n    if (priorResults.hasInlines) {\n      return null;\n    }\n    return priorResults;\n  }\n  safeToSkipEmit(sf) {\n    if (this.step === null) {\n      return false;\n    }\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.step.logicallyChangedTsFiles.has(sfPath)) {\n      return false;\n    }\n    if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n      throw new Error(`AssertionError: Expected successful analysis before attempting to emit files`);\n    }\n    if (this.phase.needsEmit.has(sfPath)) {\n      return false;\n    }\n    return this.step.priorState.emitted.has(sfPath);\n  }\n};\nfunction toOriginalSourceFile(sf) {\n  const unredirectedSf = toUnredirectedSourceFile(sf);\n  const originalFile = unredirectedSf[NgOriginalFile];\n  if (originalFile !== void 0) {\n    return originalFile;\n  } else {\n    return unredirectedSf;\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/src/strategy.mjs\nvar TrackedIncrementalBuildStrategy = class {\n  constructor() {\n    this.state = null;\n    this.isSet = false;\n  }\n  getIncrementalState() {\n    return this.state;\n  }\n  setIncrementalState(state) {\n    this.state = state;\n    this.isSet = true;\n  }\n  toNextBuildStrategy() {\n    const strategy = new TrackedIncrementalBuildStrategy();\n    strategy.state = this.isSet ? this.state : null;\n    return strategy;\n  }\n};\nvar PatchedProgramIncrementalBuildStrategy = class {\n  getIncrementalState(program) {\n    const state = program[SYM_INCREMENTAL_STATE];\n    if (state === void 0) {\n      return null;\n    }\n    return state;\n  }\n  setIncrementalState(state, program) {\n    program[SYM_INCREMENTAL_STATE] = state;\n  }\n  toNextBuildStrategy() {\n    return this;\n  }\n};\nvar SYM_INCREMENTAL_STATE = Symbol(\"NgIncrementalState\");\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/api.mjs\nvar IdentifierKind;\n(function (IdentifierKind2) {\n  IdentifierKind2[IdentifierKind2[\"Property\"] = 0] = \"Property\";\n  IdentifierKind2[IdentifierKind2[\"Method\"] = 1] = \"Method\";\n  IdentifierKind2[IdentifierKind2[\"Element\"] = 2] = \"Element\";\n  IdentifierKind2[IdentifierKind2[\"Template\"] = 3] = \"Template\";\n  IdentifierKind2[IdentifierKind2[\"Attribute\"] = 4] = \"Attribute\";\n  IdentifierKind2[IdentifierKind2[\"Reference\"] = 5] = \"Reference\";\n  IdentifierKind2[IdentifierKind2[\"Variable\"] = 6] = \"Variable\";\n})(IdentifierKind || (IdentifierKind = {}));\nvar AbsoluteSourceSpan = class {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/context.mjs\nvar IndexingContext = class {\n  constructor() {\n    this.components = /* @__PURE__ */new Set();\n  }\n  addComponent(info) {\n    this.components.add(info);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/transform.mjs\nimport { ParseSourceFile } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/template.mjs\nimport { ASTWithSource, ImplicitReceiver, PropertyRead, PropertyWrite, RecursiveAstVisitor, TmplAstElement, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate } from \"@angular/compiler\";\nvar ExpressionVisitor = class extends RecursiveAstVisitor {\n  constructor(expressionStr, absoluteOffset, boundTemplate, targetToIdentifier) {\n    super();\n    this.expressionStr = expressionStr;\n    this.absoluteOffset = absoluteOffset;\n    this.boundTemplate = boundTemplate;\n    this.targetToIdentifier = targetToIdentifier;\n    this.identifiers = [];\n    this.errors = [];\n  }\n  static getIdentifiers(ast, source, absoluteOffset, boundTemplate, targetToIdentifier) {\n    const visitor = new ExpressionVisitor(source, absoluteOffset, boundTemplate, targetToIdentifier);\n    visitor.visit(ast);\n    return {\n      identifiers: visitor.identifiers,\n      errors: visitor.errors\n    };\n  }\n  visit(ast) {\n    ast.visit(this);\n  }\n  visitPropertyRead(ast, context) {\n    this.visitIdentifier(ast, IdentifierKind.Property);\n    super.visitPropertyRead(ast, context);\n  }\n  visitPropertyWrite(ast, context) {\n    this.visitIdentifier(ast, IdentifierKind.Property);\n    super.visitPropertyWrite(ast, context);\n  }\n  visitIdentifier(ast, kind) {\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n    let identifierStart = ast.sourceSpan.start - this.absoluteOffset;\n    if (ast instanceof PropertyRead || ast instanceof PropertyWrite) {\n      identifierStart = ast.nameSpan.start - this.absoluteOffset;\n    }\n    if (!this.expressionStr.substring(identifierStart).startsWith(ast.name)) {\n      this.errors.push(new Error(`Impossible state: \"${ast.name}\" not found in \"${this.expressionStr}\" at location ${identifierStart}`));\n      return;\n    }\n    const absoluteStart = this.absoluteOffset + identifierStart;\n    const span = new AbsoluteSourceSpan(absoluteStart, absoluteStart + ast.name.length);\n    const targetAst = this.boundTemplate.getExpressionTarget(ast);\n    const target = targetAst ? this.targetToIdentifier(targetAst) : null;\n    const identifier = {\n      name: ast.name,\n      span,\n      kind,\n      target\n    };\n    this.identifiers.push(identifier);\n  }\n};\nvar TemplateVisitor = class extends TmplAstRecursiveVisitor {\n  constructor(boundTemplate) {\n    super();\n    this.boundTemplate = boundTemplate;\n    this.identifiers = /* @__PURE__ */new Set();\n    this.errors = [];\n    this.targetIdentifierCache = /* @__PURE__ */new Map();\n    this.elementAndTemplateIdentifierCache = /* @__PURE__ */new Map();\n  }\n  visit(node) {\n    node.visit(this);\n  }\n  visitAll(nodes) {\n    nodes.forEach(node => this.visit(node));\n  }\n  visitElement(element) {\n    const elementIdentifier = this.elementOrTemplateToIdentifier(element);\n    if (elementIdentifier !== null) {\n      this.identifiers.add(elementIdentifier);\n    }\n    this.visitAll(element.references);\n    this.visitAll(element.inputs);\n    this.visitAll(element.attributes);\n    this.visitAll(element.children);\n    this.visitAll(element.outputs);\n  }\n  visitTemplate(template) {\n    const templateIdentifier = this.elementOrTemplateToIdentifier(template);\n    if (templateIdentifier !== null) {\n      this.identifiers.add(templateIdentifier);\n    }\n    this.visitAll(template.variables);\n    this.visitAll(template.attributes);\n    this.visitAll(template.templateAttrs);\n    this.visitAll(template.children);\n    this.visitAll(template.references);\n  }\n  visitBoundAttribute(attribute) {\n    if (attribute.valueSpan === void 0) {\n      return;\n    }\n    const {\n      identifiers,\n      errors\n    } = ExpressionVisitor.getIdentifiers(attribute.value, attribute.valueSpan.toString(), attribute.valueSpan.start.offset, this.boundTemplate, this.targetToIdentifier.bind(this));\n    identifiers.forEach(id => this.identifiers.add(id));\n    this.errors.push(...errors);\n  }\n  visitBoundEvent(attribute) {\n    this.visitExpression(attribute.handler);\n  }\n  visitBoundText(text) {\n    this.visitExpression(text.value);\n  }\n  visitReference(reference) {\n    const referenceIdentifier = this.targetToIdentifier(reference);\n    if (referenceIdentifier === null) {\n      return;\n    }\n    this.identifiers.add(referenceIdentifier);\n  }\n  visitVariable(variable) {\n    const variableIdentifier = this.targetToIdentifier(variable);\n    if (variableIdentifier === null) {\n      return;\n    }\n    this.identifiers.add(variableIdentifier);\n  }\n  elementOrTemplateToIdentifier(node) {\n    var _a;\n    if (this.elementAndTemplateIdentifierCache.has(node)) {\n      return this.elementAndTemplateIdentifierCache.get(node);\n    }\n    let name;\n    let kind;\n    if (node instanceof TmplAstTemplate) {\n      name = (_a = node.tagName) != null ? _a : \"ng-template\";\n      kind = IdentifierKind.Template;\n    } else {\n      name = node.name;\n      kind = IdentifierKind.Element;\n    }\n    if (name.startsWith(\":\")) {\n      name = name.split(\":\").pop();\n    }\n    const sourceSpan = node.startSourceSpan;\n    const start = this.getStartLocation(name, sourceSpan);\n    if (start === null) {\n      return null;\n    }\n    const absoluteSpan = new AbsoluteSourceSpan(start, start + name.length);\n    const attributes = node.attributes.map(({\n      name: name2,\n      sourceSpan: sourceSpan2\n    }) => {\n      return {\n        name: name2,\n        span: new AbsoluteSourceSpan(sourceSpan2.start.offset, sourceSpan2.end.offset),\n        kind: IdentifierKind.Attribute\n      };\n    });\n    const usedDirectives = this.boundTemplate.getDirectivesOfNode(node) || [];\n    const identifier = {\n      name,\n      span: absoluteSpan,\n      kind,\n      attributes: new Set(attributes),\n      usedDirectives: new Set(usedDirectives.map(dir => {\n        return {\n          node: dir.ref.node,\n          selector: dir.selector\n        };\n      }))\n    };\n    this.elementAndTemplateIdentifierCache.set(node, identifier);\n    return identifier;\n  }\n  targetToIdentifier(node) {\n    if (this.targetIdentifierCache.has(node)) {\n      return this.targetIdentifierCache.get(node);\n    }\n    const {\n      name,\n      sourceSpan\n    } = node;\n    const start = this.getStartLocation(name, sourceSpan);\n    if (start === null) {\n      return null;\n    }\n    const span = new AbsoluteSourceSpan(start, start + name.length);\n    let identifier;\n    if (node instanceof TmplAstReference) {\n      const refTarget = this.boundTemplate.getReferenceTarget(node);\n      let target = null;\n      if (refTarget) {\n        let node2 = null;\n        let directive = null;\n        if (refTarget instanceof TmplAstElement || refTarget instanceof TmplAstTemplate) {\n          node2 = this.elementOrTemplateToIdentifier(refTarget);\n        } else {\n          node2 = this.elementOrTemplateToIdentifier(refTarget.node);\n          directive = refTarget.directive.ref.node;\n        }\n        if (node2 === null) {\n          return null;\n        }\n        target = {\n          node: node2,\n          directive\n        };\n      }\n      identifier = {\n        name,\n        span,\n        kind: IdentifierKind.Reference,\n        target\n      };\n    } else {\n      identifier = {\n        name,\n        span,\n        kind: IdentifierKind.Variable\n      };\n    }\n    this.targetIdentifierCache.set(node, identifier);\n    return identifier;\n  }\n  getStartLocation(name, context) {\n    const localStr = context.toString();\n    if (!localStr.includes(name)) {\n      this.errors.push(new Error(`Impossible state: \"${name}\" not found in \"${localStr}\"`));\n      return null;\n    }\n    return context.start.offset + localStr.indexOf(name);\n  }\n  visitExpression(ast) {\n    if (ast instanceof ASTWithSource && ast.source !== null) {\n      const targetToIdentifier = this.targetToIdentifier.bind(this);\n      const absoluteOffset = ast.sourceSpan.start;\n      const {\n        identifiers,\n        errors\n      } = ExpressionVisitor.getIdentifiers(ast, ast.source, absoluteOffset, this.boundTemplate, targetToIdentifier);\n      identifiers.forEach(id => this.identifiers.add(id));\n      this.errors.push(...errors);\n    }\n  }\n};\nfunction getTemplateIdentifiers(boundTemplate) {\n  const visitor = new TemplateVisitor(boundTemplate);\n  if (boundTemplate.target.template !== void 0) {\n    visitor.visitAll(boundTemplate.target.template);\n  }\n  return {\n    identifiers: visitor.identifiers,\n    errors: visitor.errors\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/transform.mjs\nfunction generateAnalysis(context) {\n  const analysis = /* @__PURE__ */new Map();\n  context.components.forEach(({\n    declaration,\n    selector,\n    boundTemplate,\n    templateMeta\n  }) => {\n    const name = declaration.name.getText();\n    const usedComponents = /* @__PURE__ */new Set();\n    const usedDirs = boundTemplate.getUsedDirectives();\n    usedDirs.forEach(dir => {\n      if (dir.isComponent) {\n        usedComponents.add(dir.ref.node);\n      }\n    });\n    const componentFile = new ParseSourceFile(declaration.getSourceFile().getFullText(), declaration.getSourceFile().fileName);\n    let templateFile;\n    if (templateMeta.isInline) {\n      templateFile = componentFile;\n    } else {\n      templateFile = templateMeta.file;\n    }\n    const {\n      identifiers,\n      errors\n    } = getTemplateIdentifiers(boundTemplate);\n    analysis.set(declaration, {\n      name,\n      selector,\n      file: componentFile,\n      template: {\n        identifiers,\n        usedComponents,\n        isInline: templateMeta.isInline,\n        file: templateFile\n      },\n      errors\n    });\n  });\n  return analysis;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/ng_module_index.mjs\nvar NgModuleIndexImpl = class {\n  constructor(metaReader, localReader) {\n    this.metaReader = metaReader;\n    this.localReader = localReader;\n    this.ngModuleAuthoritativeReference = /* @__PURE__ */new Map();\n    this.typeToExportingModules = /* @__PURE__ */new Map();\n    this.indexed = false;\n  }\n  updateWith(cache, key, elem) {\n    if (cache.has(key)) {\n      cache.get(key).add(elem);\n    } else {\n      const set = /* @__PURE__ */new Set();\n      set.add(elem);\n      cache.set(key, set);\n    }\n  }\n  index() {\n    const seenTypesWithReexports = /* @__PURE__ */new Map();\n    const locallyDeclaredDirsAndNgModules = [...this.localReader.getKnown(MetaKind.NgModule), ...this.localReader.getKnown(MetaKind.Directive)];\n    for (const decl of locallyDeclaredDirsAndNgModules) {\n      this.indexTrait(new Reference(decl), seenTypesWithReexports);\n    }\n    this.indexed = true;\n  }\n  indexTrait(ref, seenTypesWithReexports) {\n    var _a, _b, _c;\n    if (seenTypesWithReexports.has(ref.node)) {\n      return;\n    }\n    seenTypesWithReexports.set(ref.node, /* @__PURE__ */new Set());\n    const meta = (_a = this.metaReader.getDirectiveMetadata(ref)) != null ? _a : this.metaReader.getNgModuleMetadata(ref);\n    if (meta === null) {\n      return;\n    }\n    if (meta.imports !== null) {\n      for (const childRef of meta.imports) {\n        this.indexTrait(childRef, seenTypesWithReexports);\n      }\n    }\n    if (meta.kind === MetaKind.NgModule) {\n      if (!this.ngModuleAuthoritativeReference.has(ref.node)) {\n        this.ngModuleAuthoritativeReference.set(ref.node, ref);\n      }\n      for (const childRef of meta.exports) {\n        this.indexTrait(childRef, seenTypesWithReexports);\n        const childMeta = (_c = (_b = this.metaReader.getDirectiveMetadata(childRef)) != null ? _b : this.metaReader.getPipeMetadata(childRef)) != null ? _c : this.metaReader.getNgModuleMetadata(childRef);\n        if (childMeta === null) {\n          continue;\n        }\n        switch (childMeta.kind) {\n          case MetaKind.Directive:\n          case MetaKind.Pipe:\n            this.updateWith(this.typeToExportingModules, childRef.node, ref.node);\n            this.updateWith(seenTypesWithReexports, ref.node, childRef.node);\n            break;\n          case MetaKind.NgModule:\n            if (seenTypesWithReexports.has(childRef.node)) {\n              for (const reexported of seenTypesWithReexports.get(childRef.node)) {\n                this.updateWith(this.typeToExportingModules, reexported, ref.node);\n                this.updateWith(seenTypesWithReexports, ref.node, reexported);\n              }\n            }\n            break;\n        }\n      }\n    }\n  }\n  getNgModulesExporting(directiveOrPipe) {\n    if (!this.indexed) {\n      this.index();\n    }\n    if (!this.typeToExportingModules.has(directiveOrPipe)) {\n      return [];\n    }\n    const refs = [];\n    for (const ngModule of this.typeToExportingModules.get(directiveOrPipe)) {\n      if (this.ngModuleAuthoritativeReference.has(ngModule)) {\n        refs.push(this.ngModuleAuthoritativeReference.get(ngModule));\n      }\n    }\n    return refs;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/resource/src/loader.mjs\nimport ts8 from \"typescript\";\nvar CSS_PREPROCESSOR_EXT = /(\\.scss|\\.sass|\\.less|\\.styl)$/;\nvar RESOURCE_MARKER = \".$ngresource$\";\nvar RESOURCE_MARKER_TS = RESOURCE_MARKER + \".ts\";\nvar AdapterResourceLoader = class {\n  constructor(adapter, options) {\n    this.adapter = adapter;\n    this.options = options;\n    this.cache = /* @__PURE__ */new Map();\n    this.fetching = /* @__PURE__ */new Map();\n    this.lookupResolutionHost = createLookupResolutionHost(this.adapter);\n    this.canPreload = !!this.adapter.readResource;\n    this.canPreprocess = !!this.adapter.transformResource;\n  }\n  resolve(url, fromFile) {\n    let resolvedUrl = null;\n    if (this.adapter.resourceNameToFileName) {\n      resolvedUrl = this.adapter.resourceNameToFileName(url, fromFile, (url2, fromFile2) => this.fallbackResolve(url2, fromFile2));\n    } else {\n      resolvedUrl = this.fallbackResolve(url, fromFile);\n    }\n    if (resolvedUrl === null) {\n      throw new Error(`HostResourceResolver: could not resolve ${url} in context of ${fromFile})`);\n    }\n    return resolvedUrl;\n  }\n  preload(resolvedUrl, context) {\n    var _this = this;\n    if (!this.adapter.readResource) {\n      throw new Error(\"HostResourceLoader: the CompilerHost provided does not support pre-loading resources.\");\n    }\n    if (this.cache.has(resolvedUrl)) {\n      return void 0;\n    } else if (this.fetching.has(resolvedUrl)) {\n      return this.fetching.get(resolvedUrl);\n    }\n    let result = this.adapter.readResource(resolvedUrl);\n    if (this.adapter.transformResource && context.type === \"style\") {\n      const resourceContext = {\n        type: \"style\",\n        containingFile: context.containingFile,\n        resourceFile: resolvedUrl\n      };\n      result = Promise.resolve(result).then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (str) {\n          const transformResult = yield _this.adapter.transformResource(str, resourceContext);\n          return transformResult === null ? str : transformResult.content;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n    if (typeof result === \"string\") {\n      this.cache.set(resolvedUrl, result);\n      return void 0;\n    } else {\n      const fetchCompletion = result.then(str => {\n        this.fetching.delete(resolvedUrl);\n        this.cache.set(resolvedUrl, str);\n      });\n      this.fetching.set(resolvedUrl, fetchCompletion);\n      return fetchCompletion;\n    }\n  }\n  preprocessInline(data, context) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.adapter.transformResource || context.type !== \"style\") {\n        return data;\n      }\n      const transformResult = yield _this2.adapter.transformResource(data, {\n        type: \"style\",\n        containingFile: context.containingFile,\n        resourceFile: null\n      });\n      if (transformResult === null) {\n        return data;\n      }\n      return transformResult.content;\n    })();\n  }\n  load(resolvedUrl) {\n    if (this.cache.has(resolvedUrl)) {\n      return this.cache.get(resolvedUrl);\n    }\n    const result = this.adapter.readResource ? this.adapter.readResource(resolvedUrl) : this.adapter.readFile(resolvedUrl);\n    if (typeof result !== \"string\") {\n      throw new Error(`HostResourceLoader: loader(${resolvedUrl}) returned a Promise`);\n    }\n    this.cache.set(resolvedUrl, result);\n    return result;\n  }\n  invalidate() {\n    this.cache.clear();\n  }\n  fallbackResolve(url, fromFile) {\n    let candidateLocations;\n    if (url.startsWith(\"/\")) {\n      candidateLocations = this.getRootedCandidateLocations(url);\n    } else {\n      if (!url.startsWith(\".\")) {\n        url = `./${url}`;\n      }\n      candidateLocations = this.getResolvedCandidateLocations(url, fromFile);\n    }\n    for (const candidate of candidateLocations) {\n      if (this.adapter.fileExists(candidate)) {\n        return candidate;\n      } else if (CSS_PREPROCESSOR_EXT.test(candidate)) {\n        const cssFallbackUrl = candidate.replace(CSS_PREPROCESSOR_EXT, \".css\");\n        if (this.adapter.fileExists(cssFallbackUrl)) {\n          return cssFallbackUrl;\n        }\n      }\n    }\n    return null;\n  }\n  getRootedCandidateLocations(url) {\n    const segment = \".\" + url;\n    return this.adapter.rootDirs.map(rootDir => join(rootDir, segment));\n  }\n  getResolvedCandidateLocations(url, fromFile) {\n    const failedLookup = ts8.resolveModuleName(url + RESOURCE_MARKER, fromFile, this.options, this.lookupResolutionHost);\n    if (failedLookup.failedLookupLocations === void 0) {\n      throw new Error(`Internal error: expected to find failedLookupLocations during resolution of resource '${url}' in context of ${fromFile}`);\n    }\n    return failedLookup.failedLookupLocations.filter(candidate => candidate.endsWith(RESOURCE_MARKER_TS)).map(candidate => candidate.slice(0, -RESOURCE_MARKER_TS.length));\n  }\n};\nfunction createLookupResolutionHost(adapter) {\n  var _a, _b, _c;\n  return {\n    directoryExists(directoryName) {\n      if (directoryName.includes(RESOURCE_MARKER)) {\n        return false;\n      } else if (adapter.directoryExists !== void 0) {\n        return adapter.directoryExists(directoryName);\n      } else {\n        return true;\n      }\n    },\n    fileExists(fileName) {\n      if (fileName.includes(RESOURCE_MARKER)) {\n        return false;\n      } else {\n        return adapter.fileExists(fileName);\n      }\n    },\n    readFile: adapter.readFile.bind(adapter),\n    getCurrentDirectory: adapter.getCurrentDirectory.bind(adapter),\n    getDirectories: (_a = adapter.getDirectories) == null ? void 0 : _a.bind(adapter),\n    realpath: (_b = adapter.realpath) == null ? void 0 : _b.bind(adapter),\n    trace: (_c = adapter.trace) == null ? void 0 : _c.bind(adapter),\n    useCaseSensitiveFileNames: typeof adapter.useCaseSensitiveFileNames === \"function\" ? adapter.useCaseSensitiveFileNames.bind(adapter) : adapter.useCaseSensitiveFileNames\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/standalone.mjs\nvar StandaloneComponentScopeReader = class {\n  constructor(metaReader, localModuleReader, dtsModuleReader) {\n    this.metaReader = metaReader;\n    this.localModuleReader = localModuleReader;\n    this.dtsModuleReader = dtsModuleReader;\n    this.cache = /* @__PURE__ */new Map();\n  }\n  getScopeForComponent(clazz) {\n    var _a;\n    if (!this.cache.has(clazz)) {\n      const clazzRef = new Reference(clazz);\n      const clazzMeta = this.metaReader.getDirectiveMetadata(clazzRef);\n      if (clazzMeta === null || !clazzMeta.isComponent || !clazzMeta.isStandalone) {\n        this.cache.set(clazz, null);\n        return null;\n      }\n      const dependencies = /* @__PURE__ */new Set([clazzMeta]);\n      const seen = /* @__PURE__ */new Set([clazz]);\n      let isPoisoned = clazzMeta.isPoisoned;\n      if (clazzMeta.imports !== null) {\n        for (const ref of clazzMeta.imports) {\n          if (seen.has(ref.node)) {\n            continue;\n          }\n          seen.add(ref.node);\n          const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n          if (dirMeta !== null) {\n            dependencies.add({\n              ...dirMeta,\n              ref\n            });\n            isPoisoned = isPoisoned || dirMeta.isPoisoned || !dirMeta.isStandalone;\n            continue;\n          }\n          const pipeMeta = this.metaReader.getPipeMetadata(ref);\n          if (pipeMeta !== null) {\n            dependencies.add({\n              ...pipeMeta,\n              ref\n            });\n            isPoisoned = isPoisoned || !pipeMeta.isStandalone;\n            continue;\n          }\n          const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);\n          if (ngModuleMeta !== null) {\n            dependencies.add({\n              ...ngModuleMeta,\n              ref\n            });\n            let ngModuleScope;\n            if (ref.node.getSourceFile().isDeclarationFile) {\n              ngModuleScope = this.dtsModuleReader.resolve(ref);\n            } else {\n              ngModuleScope = this.localModuleReader.getScopeOfModule(ref.node);\n            }\n            if (ngModuleScope === null) {\n              isPoisoned = true;\n              continue;\n            }\n            isPoisoned = isPoisoned || ngModuleScope.exported.isPoisoned;\n            for (const dep of ngModuleScope.exported.dependencies) {\n              if (!seen.has(dep.ref.node)) {\n                seen.add(dep.ref.node);\n                dependencies.add(dep);\n              }\n            }\n            continue;\n          }\n          isPoisoned = true;\n        }\n      }\n      this.cache.set(clazz, {\n        kind: ComponentScopeKind.Standalone,\n        component: clazz,\n        dependencies: Array.from(dependencies),\n        isPoisoned,\n        schemas: (_a = clazzMeta.schemas) != null ? _a : []\n      });\n    }\n    return this.cache.get(clazz);\n  }\n  getRemoteScope() {\n    return null;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/checker.mjs\nimport { CssSelector, DomElementSchemaRegistry as DomElementSchemaRegistry2, ExternalExpr as ExternalExpr2, WrappedNodeExpr } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/diagnostics/src/diagnostic.mjs\nimport ts9 from \"typescript\";\nfunction makeTemplateDiagnostic(templateId, mapping, span, category, code, messageText, relatedMessages) {\n  var _a;\n  if (mapping.type === \"direct\") {\n    let relatedInformation = void 0;\n    if (relatedMessages !== void 0) {\n      relatedInformation = [];\n      for (const relatedMessage of relatedMessages) {\n        relatedInformation.push({\n          category: ts9.DiagnosticCategory.Message,\n          code: 0,\n          file: relatedMessage.sourceFile,\n          start: relatedMessage.start,\n          length: relatedMessage.end - relatedMessage.start,\n          messageText: relatedMessage.text\n        });\n      }\n    }\n    return {\n      source: \"ngtsc\",\n      code,\n      category,\n      messageText,\n      file: mapping.node.getSourceFile(),\n      componentFile: mapping.node.getSourceFile(),\n      templateId,\n      start: span.start.offset,\n      length: span.end.offset - span.start.offset,\n      relatedInformation\n    };\n  } else if (mapping.type === \"indirect\" || mapping.type === \"external\") {\n    const componentSf = mapping.componentClass.getSourceFile();\n    const componentName = mapping.componentClass.name.text;\n    const fileName = mapping.type === \"indirect\" ? `${componentSf.fileName} (${componentName} template)` : mapping.templateUrl;\n    let relatedInformation = [];\n    if (relatedMessages !== void 0) {\n      for (const relatedMessage of relatedMessages) {\n        relatedInformation.push({\n          category: ts9.DiagnosticCategory.Message,\n          code: 0,\n          file: relatedMessage.sourceFile,\n          start: relatedMessage.start,\n          length: relatedMessage.end - relatedMessage.start,\n          messageText: relatedMessage.text\n        });\n      }\n    }\n    let sf;\n    try {\n      sf = getParsedTemplateSourceFile(fileName, mapping);\n    } catch (e) {\n      const failureChain = makeDiagnosticChain(`Failed to report an error in '${fileName}' at ${span.start.line + 1}:${span.start.col + 1}`, [makeDiagnosticChain((_a = e == null ? void 0 : e.stack) != null ? _a : `${e}`)]);\n      return {\n        source: \"ngtsc\",\n        category,\n        code,\n        messageText: addDiagnosticChain(messageText, [failureChain]),\n        file: componentSf,\n        componentFile: componentSf,\n        templateId,\n        start: mapping.node.getStart(),\n        length: mapping.node.getEnd() - mapping.node.getStart(),\n        relatedInformation\n      };\n    }\n    relatedInformation.push({\n      category: ts9.DiagnosticCategory.Message,\n      code: 0,\n      file: componentSf,\n      start: mapping.node.getStart(),\n      length: mapping.node.getEnd() - mapping.node.getStart(),\n      messageText: `Error occurs in the template of component ${componentName}.`\n    });\n    return {\n      source: \"ngtsc\",\n      category,\n      code,\n      messageText,\n      file: sf,\n      componentFile: componentSf,\n      templateId,\n      start: span.start.offset,\n      length: span.end.offset - span.start.offset,\n      relatedInformation\n    };\n  } else {\n    throw new Error(`Unexpected source mapping type: ${mapping.type}`);\n  }\n}\nvar TemplateSourceFile = Symbol(\"TemplateSourceFile\");\nfunction getParsedTemplateSourceFile(fileName, mapping) {\n  if (mapping[TemplateSourceFile] === void 0) {\n    mapping[TemplateSourceFile] = parseTemplateAsSourceFile(fileName, mapping.template);\n  }\n  return mapping[TemplateSourceFile];\n}\nvar parseTemplateAsSourceFileForTest = null;\nfunction parseTemplateAsSourceFile(fileName, template) {\n  if (parseTemplateAsSourceFileForTest !== null) {\n    return parseTemplateAsSourceFileForTest(fileName, template);\n  }\n  return ts9.createSourceFile(fileName, template, ts9.ScriptTarget.Latest, false, ts9.ScriptKind.JSX);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/diagnostics/src/id.mjs\nvar TEMPLATE_ID = Symbol(\"ngTemplateId\");\nvar NEXT_TEMPLATE_ID = Symbol(\"ngNextTemplateId\");\nfunction getTemplateId(clazz) {\n  const node = clazz;\n  if (node[TEMPLATE_ID] === void 0) {\n    node[TEMPLATE_ID] = allocateTemplateId(node.getSourceFile());\n  }\n  return node[TEMPLATE_ID];\n}\nfunction allocateTemplateId(sf) {\n  if (sf[NEXT_TEMPLATE_ID] === void 0) {\n    sf[NEXT_TEMPLATE_ID] = 1;\n  }\n  return `tcb${sf[NEXT_TEMPLATE_ID]++}`;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/completion.mjs\nimport { EmptyExpr, ImplicitReceiver as ImplicitReceiver2, PropertyRead as PropertyRead2, PropertyWrite as PropertyWrite2, SafePropertyRead, TmplAstReference as TmplAstReference2, TmplAstTextAttribute } from \"@angular/compiler\";\nimport ts11 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/comments.mjs\nimport { AbsoluteSourceSpan as AbsoluteSourceSpan2 } from \"@angular/compiler\";\nimport ts10 from \"typescript\";\nvar parseSpanComment = /^(\\d+),(\\d+)$/;\nfunction readSpanComment(node, sourceFile = node.getSourceFile()) {\n  return ts10.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts10.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    const match = commentText.match(parseSpanComment);\n    if (match === null) {\n      return null;\n    }\n    return new AbsoluteSourceSpan2(+match[1], +match[2]);\n  }) || null;\n}\nvar CommentTriviaType;\n(function (CommentTriviaType2) {\n  CommentTriviaType2[\"DIAGNOSTIC\"] = \"D\";\n  CommentTriviaType2[\"EXPRESSION_TYPE_IDENTIFIER\"] = \"T\";\n})(CommentTriviaType || (CommentTriviaType = {}));\nvar ExpressionIdentifier;\n(function (ExpressionIdentifier2) {\n  ExpressionIdentifier2[\"DIRECTIVE\"] = \"DIR\";\n  ExpressionIdentifier2[\"COMPONENT_COMPLETION\"] = \"COMPCOMP\";\n  ExpressionIdentifier2[\"EVENT_PARAMETER\"] = \"EP\";\n})(ExpressionIdentifier || (ExpressionIdentifier = {}));\nfunction addExpressionIdentifier(node, identifier) {\n  ts10.addSyntheticTrailingComment(node, ts10.SyntaxKind.MultiLineCommentTrivia, `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`, false);\n}\nvar IGNORE_FOR_DIAGNOSTICS_MARKER = `${CommentTriviaType.DIAGNOSTIC}:ignore`;\nfunction markIgnoreDiagnostics(node) {\n  ts10.addSyntheticTrailingComment(node, ts10.SyntaxKind.MultiLineCommentTrivia, IGNORE_FOR_DIAGNOSTICS_MARKER, false);\n}\nfunction hasIgnoreForDiagnosticsMarker(node, sourceFile) {\n  return ts10.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts10.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText === IGNORE_FOR_DIAGNOSTICS_MARKER;\n  }) === true;\n}\nfunction makeRecursiveVisitor(visitor) {\n  function recursiveVisitor(node) {\n    const res = visitor(node);\n    return res !== null ? res : node.forEachChild(recursiveVisitor);\n  }\n  return recursiveVisitor;\n}\nfunction getSpanFromOptions(opts) {\n  let withSpan = null;\n  if (opts.withSpan !== void 0) {\n    if (opts.withSpan instanceof AbsoluteSourceSpan2) {\n      withSpan = opts.withSpan;\n    } else {\n      withSpan = {\n        start: opts.withSpan.start.offset,\n        end: opts.withSpan.end.offset\n      };\n    }\n  }\n  return withSpan;\n}\nfunction findFirstMatchingNode(tcb, opts) {\n  var _a;\n  const withSpan = getSpanFromOptions(opts);\n  const withExpressionIdentifier = opts.withExpressionIdentifier;\n  const sf = tcb.getSourceFile();\n  const visitor = makeRecursiveVisitor(node => {\n    if (!opts.filter(node)) {\n      return null;\n    }\n    if (withSpan !== null) {\n      const comment = readSpanComment(node, sf);\n      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n        return null;\n      }\n    }\n    if (withExpressionIdentifier !== void 0 && !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n      return null;\n    }\n    return node;\n  });\n  return (_a = tcb.forEachChild(visitor)) != null ? _a : null;\n}\nfunction findAllMatchingNodes(tcb, opts) {\n  const withSpan = getSpanFromOptions(opts);\n  const withExpressionIdentifier = opts.withExpressionIdentifier;\n  const results = [];\n  const stack = [tcb];\n  const sf = tcb.getSourceFile();\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (!opts.filter(node)) {\n      stack.push(...node.getChildren());\n      continue;\n    }\n    if (withSpan !== null) {\n      const comment = readSpanComment(node, sf);\n      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n        stack.push(...node.getChildren());\n        continue;\n      }\n    }\n    if (withExpressionIdentifier !== void 0 && !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n      continue;\n    }\n    results.push(node);\n  }\n  return results;\n}\nfunction hasExpressionIdentifier(sourceFile, node, identifier) {\n  return ts10.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts10.SyntaxKind.MultiLineCommentTrivia) {\n      return false;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText === `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`;\n  }) || false;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/completion.mjs\nvar CompletionEngine = class {\n  constructor(tcb, data, tcbPath, tcbIsShim) {\n    this.tcb = tcb;\n    this.data = data;\n    this.tcbPath = tcbPath;\n    this.tcbIsShim = tcbIsShim;\n    this.templateContextCache = /* @__PURE__ */new Map();\n    this.expressionCompletionCache = /* @__PURE__ */new Map();\n    const globalRead = findFirstMatchingNode(this.tcb, {\n      filter: ts11.isPropertyAccessExpression,\n      withExpressionIdentifier: ExpressionIdentifier.COMPONENT_COMPLETION\n    });\n    if (globalRead !== null) {\n      this.componentContext = {\n        tcbPath: this.tcbPath,\n        isShimFile: this.tcbIsShim,\n        positionInFile: globalRead.name.getStart()\n      };\n    } else {\n      this.componentContext = null;\n    }\n  }\n  getGlobalCompletions(context, node) {\n    if (this.componentContext === null) {\n      return null;\n    }\n    const templateContext = this.getTemplateContextCompletions(context);\n    if (templateContext === null) {\n      return null;\n    }\n    let nodeContext = null;\n    if (node instanceof EmptyExpr) {\n      const nodeLocation = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isIdentifier,\n        withSpan: node.sourceSpan\n      });\n      if (nodeLocation !== null) {\n        nodeContext = {\n          tcbPath: this.tcbPath,\n          isShimFile: this.tcbIsShim,\n          positionInFile: nodeLocation.getStart()\n        };\n      }\n    }\n    if (node instanceof PropertyRead2 && node.receiver instanceof ImplicitReceiver2) {\n      const nodeLocation = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isPropertyAccessExpression,\n        withSpan: node.sourceSpan\n      });\n      if (nodeLocation) {\n        nodeContext = {\n          tcbPath: this.tcbPath,\n          isShimFile: this.tcbIsShim,\n          positionInFile: nodeLocation.getStart()\n        };\n      }\n    }\n    return {\n      componentContext: this.componentContext,\n      templateContext,\n      nodeContext\n    };\n  }\n  getExpressionCompletionLocation(expr) {\n    if (this.expressionCompletionCache.has(expr)) {\n      return this.expressionCompletionCache.get(expr);\n    }\n    let tsExpr = null;\n    if (expr instanceof PropertyRead2 || expr instanceof PropertyWrite2) {\n      tsExpr = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isPropertyAccessExpression,\n        withSpan: expr.nameSpan\n      });\n    } else if (expr instanceof SafePropertyRead) {\n      const ternaryExpr = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isParenthesizedExpression,\n        withSpan: expr.sourceSpan\n      });\n      if (ternaryExpr === null || !ts11.isConditionalExpression(ternaryExpr.expression)) {\n        return null;\n      }\n      const whenTrue = ternaryExpr.expression.whenTrue;\n      if (ts11.isPropertyAccessExpression(whenTrue)) {\n        tsExpr = whenTrue;\n      } else if (ts11.isCallExpression(whenTrue) && ts11.isPropertyAccessExpression(whenTrue.expression)) {\n        tsExpr = whenTrue.expression;\n      }\n    }\n    if (tsExpr === null) {\n      return null;\n    }\n    const res = {\n      tcbPath: this.tcbPath,\n      isShimFile: this.tcbIsShim,\n      positionInFile: tsExpr.name.getEnd()\n    };\n    this.expressionCompletionCache.set(expr, res);\n    return res;\n  }\n  getLiteralCompletionLocation(expr) {\n    if (this.expressionCompletionCache.has(expr)) {\n      return this.expressionCompletionCache.get(expr);\n    }\n    let tsExpr = null;\n    if (expr instanceof TmplAstTextAttribute) {\n      const strNode = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isParenthesizedExpression,\n        withSpan: expr.sourceSpan\n      });\n      if (strNode !== null && ts11.isStringLiteral(strNode.expression)) {\n        tsExpr = strNode.expression;\n      }\n    } else {\n      tsExpr = findFirstMatchingNode(this.tcb, {\n        filter: n => ts11.isStringLiteral(n) || ts11.isNumericLiteral(n),\n        withSpan: expr.sourceSpan\n      });\n    }\n    if (tsExpr === null) {\n      return null;\n    }\n    let positionInShimFile = tsExpr.getEnd();\n    if (ts11.isStringLiteral(tsExpr)) {\n      positionInShimFile -= 1;\n    }\n    const res = {\n      tcbPath: this.tcbPath,\n      isShimFile: this.tcbIsShim,\n      positionInFile: positionInShimFile\n    };\n    this.expressionCompletionCache.set(expr, res);\n    return res;\n  }\n  getTemplateContextCompletions(context) {\n    if (this.templateContextCache.has(context)) {\n      return this.templateContextCache.get(context);\n    }\n    const templateContext = /* @__PURE__ */new Map();\n    for (const node of this.data.boundTarget.getEntitiesInTemplateScope(context)) {\n      if (node instanceof TmplAstReference2) {\n        templateContext.set(node.name, {\n          kind: CompletionKind.Reference,\n          node\n        });\n      } else {\n        templateContext.set(node.name, {\n          kind: CompletionKind.Variable,\n          node\n        });\n      }\n    }\n    this.templateContextCache.set(context, templateContext);\n    return templateContext;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/context.mjs\nimport ts25 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/dom.mjs\nimport { DomElementSchemaRegistry } from \"@angular/compiler\";\nimport ts12 from \"typescript\";\nvar REGISTRY = new DomElementSchemaRegistry();\nvar REMOVE_XHTML_REGEX = /^:xhtml:/;\nvar RegistryDomSchemaChecker = class {\n  get diagnostics() {\n    return this._diagnostics;\n  }\n  constructor(resolver) {\n    this.resolver = resolver;\n    this._diagnostics = [];\n  }\n  checkElement(id, element, schemas, hostIsStandalone) {\n    const name = element.name.replace(REMOVE_XHTML_REGEX, \"\");\n    if (!REGISTRY.hasElement(name, schemas)) {\n      const mapping = this.resolver.getSourceMapping(id);\n      const schemas2 = `'${hostIsStandalone ? \"@Component\" : \"@NgModule\"}.schemas'`;\n      let errorMsg = `'${name}' is not a known element:\n`;\n      errorMsg += `1. If '${name}' is an Angular component, then verify that it is ${hostIsStandalone ? \"included in the '@Component.imports' of this component\" : \"part of this module\"}.\n`;\n      if (name.indexOf(\"-\") > -1) {\n        errorMsg += `2. If '${name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;\n      } else {\n        errorMsg += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;\n      }\n      const diag = makeTemplateDiagnostic(id, mapping, element.startSourceSpan, ts12.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SCHEMA_INVALID_ELEMENT), errorMsg);\n      this._diagnostics.push(diag);\n    }\n  }\n  checkProperty(id, element, name, span, schemas, hostIsStandalone) {\n    if (!REGISTRY.hasProperty(element.name, name, schemas)) {\n      const mapping = this.resolver.getSourceMapping(id);\n      const decorator = hostIsStandalone ? \"@Component\" : \"@NgModule\";\n      const schemas2 = `'${decorator}.schemas'`;\n      let errorMsg = `Can't bind to '${name}' since it isn't a known property of '${element.name}'.`;\n      if (element.name.startsWith(\"ng-\")) {\n        errorMsg += `\n1. If '${name}' is an Angular directive, then add 'CommonModule' to the '${decorator}.imports' of this component.\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;\n      } else if (element.name.indexOf(\"-\") > -1) {\n        errorMsg += `\n1. If '${element.name}' is an Angular component and it has '${name}' input, then verify that it is ${hostIsStandalone ? \"included in the '@Component.imports' of this component\" : \"part of this module\"}.\n2. If '${element.name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;\n      }\n      const diag = makeTemplateDiagnostic(id, mapping, span, ts12.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SCHEMA_INVALID_ATTRIBUTE), errorMsg);\n      this._diagnostics.push(diag);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/environment.mjs\nimport { ExpressionType, ExternalExpr, TypeModifier } from \"@angular/compiler\";\nimport ts18 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/ts_util.mjs\nimport ts13 from \"typescript\";\nvar SAFE_TO_CAST_WITHOUT_PARENS = /* @__PURE__ */new Set([ts13.SyntaxKind.ParenthesizedExpression, ts13.SyntaxKind.Identifier, ts13.SyntaxKind.CallExpression, ts13.SyntaxKind.NonNullExpression, ts13.SyntaxKind.ElementAccessExpression, ts13.SyntaxKind.PropertyAccessExpression, ts13.SyntaxKind.ArrayLiteralExpression, ts13.SyntaxKind.ObjectLiteralExpression, ts13.SyntaxKind.StringLiteral, ts13.SyntaxKind.NumericLiteral, ts13.SyntaxKind.TrueKeyword, ts13.SyntaxKind.FalseKeyword, ts13.SyntaxKind.NullKeyword, ts13.SyntaxKind.UndefinedKeyword]);\nfunction tsCastToAny(expr) {\n  if (!SAFE_TO_CAST_WITHOUT_PARENS.has(expr.kind)) {\n    expr = ts13.factory.createParenthesizedExpression(expr);\n  }\n  return ts13.factory.createParenthesizedExpression(ts13.factory.createAsExpression(expr, ts13.factory.createKeywordTypeNode(ts13.SyntaxKind.AnyKeyword)));\n}\nfunction tsCreateElement(tagName) {\n  const createElement = ts13.factory.createPropertyAccessExpression(ts13.factory.createIdentifier(\"document\"), \"createElement\");\n  return ts13.factory.createCallExpression(createElement, void 0, [ts13.factory.createStringLiteral(tagName)]);\n}\nfunction tsDeclareVariable(id, type) {\n  const decl = ts13.factory.createVariableDeclaration(id, void 0, type, ts13.factory.createNonNullExpression(ts13.factory.createNull()));\n  return ts13.factory.createVariableStatement(void 0, [decl]);\n}\nfunction tsCreateTypeQueryForCoercedInput(typeName, coercedInputName) {\n  return ts13.factory.createTypeQueryNode(ts13.factory.createQualifiedName(typeName, `ngAcceptInputType_${coercedInputName}`));\n}\nfunction tsCreateVariable(id, initializer) {\n  const decl = ts13.factory.createVariableDeclaration(id, void 0, void 0, initializer);\n  return ts13.factory.createVariableStatement(void 0, [decl]);\n}\nfunction tsCallMethod(receiver, methodName, args = []) {\n  const methodAccess = ts13.factory.createPropertyAccessExpression(receiver, methodName);\n  return ts13.factory.createCallExpression(methodAccess, void 0, args);\n}\nfunction isAccessExpression(node) {\n  return ts13.isPropertyAccessExpression(node) || ts13.isElementAccessExpression(node);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.mjs\nimport ts17 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.mjs\nimport ts16 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter.mjs\nimport ts15 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_emitter.mjs\nimport ts14 from \"typescript\";\nvar INELIGIBLE = {};\nfunction canEmitType(type, canEmit) {\n  return canEmitTypeWorker(type);\n  function canEmitTypeWorker(type2) {\n    return visitNode(type2) !== INELIGIBLE;\n  }\n  function visitNode(node) {\n    if (ts14.isImportTypeNode(node)) {\n      return INELIGIBLE;\n    }\n    if (ts14.isTypeReferenceNode(node) && !canEmitTypeReference(node)) {\n      return INELIGIBLE;\n    } else {\n      return ts14.forEachChild(node, visitNode);\n    }\n  }\n  function canEmitTypeReference(type2) {\n    if (!canEmit(type2)) {\n      return false;\n    }\n    return type2.typeArguments === void 0 || type2.typeArguments.every(canEmitTypeWorker);\n  }\n}\nvar TypeEmitter = class {\n  constructor(translator) {\n    this.translator = translator;\n  }\n  emitType(type) {\n    const typeReferenceTransformer = context => {\n      const visitNode = node => {\n        if (ts14.isImportTypeNode(node)) {\n          throw new Error(\"Unable to emit import type\");\n        }\n        if (ts14.isTypeReferenceNode(node)) {\n          return this.emitTypeReference(node);\n        } else if (ts14.isLiteralExpression(node)) {\n          let clone;\n          if (ts14.isStringLiteral(node)) {\n            clone = ts14.factory.createStringLiteral(node.text);\n          } else if (ts14.isNumericLiteral(node)) {\n            clone = ts14.factory.createNumericLiteral(node.text);\n          } else if (ts14.isBigIntLiteral(node)) {\n            clone = ts14.factory.createBigIntLiteral(node.text);\n          } else if (ts14.isNoSubstitutionTemplateLiteral(node)) {\n            clone = ts14.factory.createNoSubstitutionTemplateLiteral(node.text, node.rawText);\n          } else if (ts14.isRegularExpressionLiteral(node)) {\n            clone = ts14.factory.createRegularExpressionLiteral(node.text);\n          } else {\n            throw new Error(`Unsupported literal kind ${ts14.SyntaxKind[node.kind]}`);\n          }\n          ts14.setTextRange(clone, {\n            pos: -1,\n            end: -1\n          });\n          return clone;\n        } else {\n          return ts14.visitEachChild(node, visitNode, context);\n        }\n      };\n      return node => ts14.visitNode(node, visitNode, ts14.isTypeNode);\n    };\n    return ts14.transform(type, [typeReferenceTransformer]).transformed[0];\n  }\n  emitTypeReference(type) {\n    const translatedType = this.translator(type);\n    if (translatedType === null) {\n      throw new Error(\"Unable to emit an unresolved reference\");\n    }\n    let typeArguments = void 0;\n    if (type.typeArguments !== void 0) {\n      typeArguments = ts14.factory.createNodeArray(type.typeArguments.map(typeArg => this.emitType(typeArg)));\n    }\n    return ts14.factory.updateTypeReferenceNode(type, translatedType.typeName, typeArguments);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter.mjs\nvar TypeParameterEmitter = class {\n  constructor(typeParameters, reflector) {\n    this.typeParameters = typeParameters;\n    this.reflector = reflector;\n  }\n  canEmit(canEmitReference) {\n    if (this.typeParameters === void 0) {\n      return true;\n    }\n    return this.typeParameters.every(typeParam => {\n      return this.canEmitType(typeParam.constraint, canEmitReference) && this.canEmitType(typeParam.default, canEmitReference);\n    });\n  }\n  canEmitType(type, canEmitReference) {\n    if (type === void 0) {\n      return true;\n    }\n    return canEmitType(type, typeReference => {\n      const reference = this.resolveTypeReference(typeReference);\n      if (reference === null) {\n        return false;\n      }\n      if (reference instanceof Reference) {\n        return canEmitReference(reference);\n      }\n      return true;\n    });\n  }\n  emit(emitReference) {\n    if (this.typeParameters === void 0) {\n      return void 0;\n    }\n    const emitter = new TypeEmitter(type => this.translateTypeReference(type, emitReference));\n    return this.typeParameters.map(typeParam => {\n      const constraint = typeParam.constraint !== void 0 ? emitter.emitType(typeParam.constraint) : void 0;\n      const defaultType = typeParam.default !== void 0 ? emitter.emitType(typeParam.default) : void 0;\n      return ts15.factory.updateTypeParameterDeclaration(typeParam, typeParam.modifiers, typeParam.name, constraint, defaultType);\n    });\n  }\n  resolveTypeReference(type) {\n    const target = ts15.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;\n    const declaration = this.reflector.getDeclarationOfIdentifier(target);\n    if (declaration === null || declaration.node === null) {\n      return null;\n    }\n    if (this.isLocalTypeParameter(declaration.node)) {\n      return type;\n    }\n    let owningModule = null;\n    if (declaration.viaModule !== null) {\n      owningModule = {\n        specifier: declaration.viaModule,\n        resolutionContext: type.getSourceFile().fileName\n      };\n    }\n    return new Reference(declaration.node, owningModule);\n  }\n  translateTypeReference(type, emitReference) {\n    const reference = this.resolveTypeReference(type);\n    if (!(reference instanceof Reference)) {\n      return reference;\n    }\n    const typeNode = emitReference(reference);\n    if (typeNode === null) {\n      return null;\n    }\n    if (!ts15.isTypeReferenceNode(typeNode)) {\n      throw new Error(`Expected TypeReferenceNode for emitted reference, got ${ts15.SyntaxKind[typeNode.kind]}.`);\n    }\n    return typeNode;\n  }\n  isLocalTypeParameter(decl) {\n    return this.typeParameters.some(param => param === decl);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.mjs\nvar TcbInliningRequirement;\n(function (TcbInliningRequirement2) {\n  TcbInliningRequirement2[TcbInliningRequirement2[\"MustInline\"] = 0] = \"MustInline\";\n  TcbInliningRequirement2[TcbInliningRequirement2[\"ShouldInlineForGenericBounds\"] = 1] = \"ShouldInlineForGenericBounds\";\n  TcbInliningRequirement2[TcbInliningRequirement2[\"None\"] = 2] = \"None\";\n})(TcbInliningRequirement || (TcbInliningRequirement = {}));\nfunction requiresInlineTypeCheckBlock(ref, env, usedPipes, reflector) {\n  if (!env.canReferenceType(ref)) {\n    return TcbInliningRequirement.MustInline;\n  } else if (!checkIfGenericTypeBoundsCanBeEmitted(ref.node, reflector, env)) {\n    return TcbInliningRequirement.ShouldInlineForGenericBounds;\n  } else if (usedPipes.some(pipeRef => !env.canReferenceType(pipeRef))) {\n    return TcbInliningRequirement.MustInline;\n  } else {\n    return TcbInliningRequirement.None;\n  }\n}\nfunction getTemplateMapping(shimSf, position, resolver, isDiagnosticRequest) {\n  const node = getTokenAtPosition(shimSf, position);\n  const sourceLocation = findSourceLocation(node, shimSf, isDiagnosticRequest);\n  if (sourceLocation === null) {\n    return null;\n  }\n  const mapping = resolver.getSourceMapping(sourceLocation.id);\n  const span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);\n  if (span === null) {\n    return null;\n  }\n  return {\n    sourceLocation,\n    templateSourceMapping: mapping,\n    span\n  };\n}\nfunction findTypeCheckBlock(file, id, isDiagnosticRequest) {\n  for (const stmt of file.statements) {\n    if (ts16.isFunctionDeclaration(stmt) && getTemplateId2(stmt, file, isDiagnosticRequest) === id) {\n      return stmt;\n    }\n  }\n  return null;\n}\nfunction findSourceLocation(node, sourceFile, isDiagnosticsRequest) {\n  while (node !== void 0 && !ts16.isFunctionDeclaration(node)) {\n    if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticsRequest) {\n      return null;\n    }\n    const span = readSpanComment(node, sourceFile);\n    if (span !== null) {\n      const id = getTemplateId2(node, sourceFile, isDiagnosticsRequest);\n      if (id === null) {\n        return null;\n      }\n      return {\n        id,\n        span\n      };\n    }\n    node = node.parent;\n  }\n  return null;\n}\nfunction getTemplateId2(node, sourceFile, isDiagnosticRequest) {\n  while (!ts16.isFunctionDeclaration(node)) {\n    if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticRequest) {\n      return null;\n    }\n    node = node.parent;\n    if (node === void 0) {\n      return null;\n    }\n  }\n  const start = node.getFullStart();\n  return ts16.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {\n    if (kind !== ts16.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText;\n  }) || null;\n}\nfunction checkIfGenericTypeBoundsCanBeEmitted(node, reflector, env) {\n  const emitter = new TypeParameterEmitter(node.typeParameters, reflector);\n  return emitter.canEmit(ref => env.canReferenceType(ref));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.mjs\nfunction generateTypeCtorDeclarationFn(node, meta, nodeTypeRef, typeParams) {\n  const rawTypeArgs = typeParams !== void 0 ? generateGenericArgs(typeParams) : void 0;\n  const rawType = ts17.factory.createTypeReferenceNode(nodeTypeRef, rawTypeArgs);\n  const initParam = constructTypeCtorParameter(node, meta, rawType);\n  const typeParameters = typeParametersWithDefaultTypes(typeParams);\n  if (meta.body) {\n    const fnType = ts17.factory.createFunctionTypeNode(typeParameters, [initParam], rawType);\n    const decl = ts17.factory.createVariableDeclaration(meta.fnName, void 0, fnType, ts17.factory.createNonNullExpression(ts17.factory.createNull()));\n    const declList = ts17.factory.createVariableDeclarationList([decl], ts17.NodeFlags.Const);\n    return ts17.factory.createVariableStatement(void 0, declList);\n  } else {\n    return ts17.factory.createFunctionDeclaration([ts17.factory.createModifier(ts17.SyntaxKind.DeclareKeyword)], void 0, meta.fnName, typeParameters, [initParam], rawType, void 0);\n  }\n}\nfunction generateInlineTypeCtor(node, meta) {\n  const rawTypeArgs = node.typeParameters !== void 0 ? generateGenericArgs(node.typeParameters) : void 0;\n  const rawType = ts17.factory.createTypeReferenceNode(node.name, rawTypeArgs);\n  const initParam = constructTypeCtorParameter(node, meta, rawType);\n  let body = void 0;\n  if (meta.body) {\n    body = ts17.factory.createBlock([ts17.factory.createReturnStatement(ts17.factory.createNonNullExpression(ts17.factory.createNull()))]);\n  }\n  return ts17.factory.createMethodDeclaration([ts17.factory.createModifier(ts17.SyntaxKind.StaticKeyword)], void 0, meta.fnName, void 0, typeParametersWithDefaultTypes(node.typeParameters), [initParam], rawType, body);\n}\nfunction constructTypeCtorParameter(node, meta, rawType) {\n  let initType = null;\n  const plainKeys = [];\n  const coercedKeys = [];\n  for (const {\n    classPropertyName,\n    transform\n  } of meta.fields.inputs) {\n    if (!meta.coercedInputFields.has(classPropertyName)) {\n      plainKeys.push(ts17.factory.createLiteralTypeNode(ts17.factory.createStringLiteral(classPropertyName)));\n    } else {\n      coercedKeys.push(ts17.factory.createPropertySignature(void 0, classPropertyName, void 0, transform == null ? tsCreateTypeQueryForCoercedInput(rawType.typeName, classPropertyName) : transform.type));\n    }\n  }\n  if (plainKeys.length > 0) {\n    const keyTypeUnion = ts17.factory.createUnionTypeNode(plainKeys);\n    initType = ts17.factory.createTypeReferenceNode(\"Pick\", [rawType, keyTypeUnion]);\n  }\n  if (coercedKeys.length > 0) {\n    const coercedLiteral = ts17.factory.createTypeLiteralNode(coercedKeys);\n    initType = initType !== null ? ts17.factory.createIntersectionTypeNode([initType, coercedLiteral]) : coercedLiteral;\n  }\n  if (initType === null) {\n    initType = ts17.factory.createTypeLiteralNode([]);\n  }\n  return ts17.factory.createParameterDeclaration(void 0, void 0, \"init\", void 0, initType, void 0);\n}\nfunction generateGenericArgs(params) {\n  return params.map(param => ts17.factory.createTypeReferenceNode(param.name, void 0));\n}\nfunction requiresInlineTypeCtor(node, host, env) {\n  return !checkIfGenericTypeBoundsCanBeEmitted(node, host, env);\n}\nfunction typeParametersWithDefaultTypes(params) {\n  if (params === void 0) {\n    return void 0;\n  }\n  return params.map(param => {\n    if (param.default === void 0) {\n      return ts17.factory.updateTypeParameterDeclaration(param, param.modifiers, param.name, param.constraint, ts17.factory.createKeywordTypeNode(ts17.SyntaxKind.AnyKeyword));\n    } else {\n      return param;\n    }\n  });\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/environment.mjs\nvar Environment = class {\n  constructor(config, importManager, refEmitter, reflector, contextFile) {\n    this.config = config;\n    this.importManager = importManager;\n    this.refEmitter = refEmitter;\n    this.reflector = reflector;\n    this.contextFile = contextFile;\n    this.nextIds = {\n      pipeInst: 1,\n      typeCtor: 1\n    };\n    this.typeCtors = /* @__PURE__ */new Map();\n    this.typeCtorStatements = [];\n    this.pipeInsts = /* @__PURE__ */new Map();\n    this.pipeInstStatements = [];\n  }\n  typeCtorFor(dir) {\n    const dirRef = dir.ref;\n    const node = dirRef.node;\n    if (this.typeCtors.has(node)) {\n      return this.typeCtors.get(node);\n    }\n    if (requiresInlineTypeCtor(node, this.reflector, this)) {\n      const ref = this.reference(dirRef);\n      const typeCtorExpr = ts18.factory.createPropertyAccessExpression(ref, \"ngTypeCtor\");\n      this.typeCtors.set(node, typeCtorExpr);\n      return typeCtorExpr;\n    } else {\n      const fnName = `_ctor${this.nextIds.typeCtor++}`;\n      const nodeTypeRef = this.referenceType(dirRef);\n      if (!ts18.isTypeReferenceNode(nodeTypeRef)) {\n        throw new Error(`Expected TypeReferenceNode from reference to ${dirRef.debugName}`);\n      }\n      const meta = {\n        fnName,\n        body: true,\n        fields: {\n          inputs: dir.inputs,\n          queries: dir.queries\n        },\n        coercedInputFields: dir.coercedInputFields\n      };\n      const typeParams = this.emitTypeParameters(node);\n      const typeCtor = generateTypeCtorDeclarationFn(node, meta, nodeTypeRef.typeName, typeParams);\n      this.typeCtorStatements.push(typeCtor);\n      const fnId = ts18.factory.createIdentifier(fnName);\n      this.typeCtors.set(node, fnId);\n      return fnId;\n    }\n  }\n  pipeInst(ref) {\n    if (this.pipeInsts.has(ref.node)) {\n      return this.pipeInsts.get(ref.node);\n    }\n    const pipeType = this.referenceType(ref);\n    const pipeInstId = ts18.factory.createIdentifier(`_pipe${this.nextIds.pipeInst++}`);\n    this.pipeInstStatements.push(tsDeclareVariable(pipeInstId, pipeType));\n    this.pipeInsts.set(ref.node, pipeInstId);\n    return pipeInstId;\n  }\n  reference(ref) {\n    const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);\n    assertSuccessfulReferenceEmit(ngExpr, this.contextFile, \"class\");\n    return translateExpression(ngExpr.expression, this.importManager);\n  }\n  canReferenceType(ref) {\n    const result = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports);\n    return result.kind === 0;\n  }\n  referenceType(ref) {\n    const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports);\n    assertSuccessfulReferenceEmit(ngExpr, this.contextFile, \"symbol\");\n    return translateType(new ExpressionType(ngExpr.expression), this.contextFile, this.reflector, this.refEmitter, this.importManager);\n  }\n  emitTypeParameters(declaration) {\n    const emitter = new TypeParameterEmitter(declaration.typeParameters, this.reflector);\n    return emitter.emit(ref => this.referenceType(ref));\n  }\n  referenceExternalType(moduleName, name, typeParams) {\n    const external = new ExternalExpr({\n      moduleName,\n      name\n    });\n    return translateType(new ExpressionType(external, TypeModifier.None, typeParams), this.contextFile, this.reflector, this.refEmitter, this.importManager);\n  }\n  referenceTransplantedType(type) {\n    return translateType(type, this.contextFile, this.reflector, this.refEmitter, this.importManager);\n  }\n  getPreludeStatements() {\n    return [...this.pipeInstStatements, ...this.typeCtorStatements];\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/oob.mjs\nimport { TmplAstElement as TmplAstElement2 } from \"@angular/compiler\";\nimport ts19 from \"typescript\";\nvar OutOfBandDiagnosticRecorderImpl = class {\n  constructor(resolver) {\n    this.resolver = resolver;\n    this._diagnostics = [];\n    this.recordedPipes = /* @__PURE__ */new Set();\n  }\n  get diagnostics() {\n    return this._diagnostics;\n  }\n  missingReferenceTarget(templateId, ref) {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const value = ref.value.trim();\n    const errorMsg = `No directive found with exportAs '${value}'.`;\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, ref.valueSpan || ref.sourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));\n  }\n  missingPipe(templateId, ast) {\n    if (this.recordedPipes.has(ast)) {\n      return;\n    }\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `No pipe found with name '${ast.name}'.`;\n    const sourceSpan = this.resolver.toParseSourceSpan(templateId, ast.nameSpan);\n    if (sourceSpan === null) {\n      throw new Error(`Assertion failure: no SourceLocation found for usage of pipe '${ast.name}'.`);\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_PIPE), errorMsg));\n    this.recordedPipes.add(ast);\n  }\n  illegalAssignmentToTemplateVar(templateId, assignment, target) {\n    var _a, _b;\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `Cannot use variable '${assignment.name}' as the left-hand side of an assignment expression. Template variables are read-only.`;\n    const sourceSpan = this.resolver.toParseSourceSpan(templateId, assignment.sourceSpan);\n    if (sourceSpan === null) {\n      throw new Error(`Assertion failure: no SourceLocation found for property binding.`);\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMsg, [{\n      text: `The variable ${assignment.name} is declared here.`,\n      start: ((_a = target.valueSpan) == null ? void 0 : _a.start.offset) || target.sourceSpan.start.offset,\n      end: ((_b = target.valueSpan) == null ? void 0 : _b.end.offset) || target.sourceSpan.end.offset,\n      sourceFile: mapping.node.getSourceFile()\n    }]));\n  }\n  duplicateTemplateVar(templateId, variable, firstDecl) {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `Cannot redeclare variable '${variable.name}' as it was previously declared elsewhere for the same template.`;\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, variable.sourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, [{\n      text: `The variable '${firstDecl.name}' was first declared here.`,\n      start: firstDecl.sourceSpan.start.offset,\n      end: firstDecl.sourceSpan.end.offset,\n      sourceFile: mapping.node.getSourceFile()\n    }]));\n  }\n  requiresInlineTcb(templateId, node) {\n    this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TCB_REQUIRED, node.name, `This component requires inline template type-checking, which is not supported by the current environment.`));\n  }\n  requiresInlineTypeConstructors(templateId, node, directives) {\n    let message;\n    if (directives.length > 1) {\n      message = `This component uses directives which require inline type constructors, which are not supported by the current environment.`;\n    } else {\n      message = `This component uses a directive which requires an inline type constructor, which is not supported by the current environment.`;\n    }\n    this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message, directives.map(dir => makeRelatedInformation(dir.name, `Requires an inline type constructor.`))));\n  }\n  suboptimalTypeInference(templateId, variables) {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    let diagnosticVar = null;\n    for (const variable of variables) {\n      if (diagnosticVar === null || variable.value === \"\" || variable.value === \"$implicit\") {\n        diagnosticVar = variable;\n      }\n    }\n    if (diagnosticVar === null) {\n      return;\n    }\n    let varIdentification = `'${diagnosticVar.name}'`;\n    if (variables.length === 2) {\n      varIdentification += ` (and 1 other)`;\n    } else if (variables.length > 2) {\n      varIdentification += ` (and ${variables.length - 1} others)`;\n    }\n    const message = `This structural directive supports advanced type inference, but the current compiler configuration prevents its usage. The variable ${varIdentification} will have type 'any' as a result.\n\nConsider enabling the 'strictTemplates' option in your tsconfig.json for better type inference within this template.`;\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, diagnosticVar.keySpan, ts19.DiagnosticCategory.Suggestion, ngErrorCode(ErrorCode.SUGGEST_SUBOPTIMAL_TYPE_INFERENCE), message));\n  }\n  splitTwoWayBinding(templateId, input, output, inputConsumer, outputConsumer) {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `The property and event halves of the two-way binding '${input.name}' are not bound to the same target.\n            Find more at https://angular.io/guide/two-way-binding#how-two-way-binding-works`;\n    const relatedMessages = [];\n    relatedMessages.push({\n      text: `The property half of the binding is to the '${inputConsumer.name.text}' component.`,\n      start: inputConsumer.name.getStart(),\n      end: inputConsumer.name.getEnd(),\n      sourceFile: inputConsumer.name.getSourceFile()\n    });\n    if (outputConsumer instanceof TmplAstElement2) {\n      let message = `The event half of the binding is to a native event called '${input.name}' on the <${outputConsumer.name}> DOM element.`;\n      if (!mapping.node.getSourceFile().isDeclarationFile) {\n        message += `\n \n Are you missing an output declaration called '${output.name}'?`;\n      }\n      relatedMessages.push({\n        text: message,\n        start: outputConsumer.sourceSpan.start.offset + 1,\n        end: outputConsumer.sourceSpan.start.offset + outputConsumer.name.length + 1,\n        sourceFile: mapping.node.getSourceFile()\n      });\n    } else {\n      relatedMessages.push({\n        text: `The event half of the binding is to the '${outputConsumer.name.text}' component.`,\n        start: outputConsumer.name.getStart(),\n        end: outputConsumer.name.getEnd(),\n        sourceFile: outputConsumer.name.getSourceFile()\n      });\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, input.keySpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SPLIT_TWO_WAY_BINDING), errorMsg, relatedMessages));\n  }\n  missingRequiredInputs(templateId, element, directiveName, isComponent, inputAliases) {\n    const message = `Required input${inputAliases.length === 1 ? \"\" : \"s\"} ${inputAliases.map(n => `'${n}'`).join(\", \")} from ${isComponent ? \"component\" : \"directive\"} ${directiveName} must be specified.`;\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, this.resolver.getSourceMapping(templateId), element.startSourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_REQUIRED_INPUTS), message));\n  }\n};\nfunction makeInlineDiagnostic(templateId, code, node, messageText, relatedInformation) {\n  return {\n    ...makeDiagnostic(code, node, messageText, relatedInformation),\n    componentFile: node.getSourceFile(),\n    templateId\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/shim.mjs\nimport ts20 from \"typescript\";\nvar TypeCheckShimGenerator = class {\n  constructor() {\n    this.extensionPrefix = \"ngtypecheck\";\n    this.shouldEmit = false;\n  }\n  generateShimForFile(sf, genFilePath, priorShimSf) {\n    if (priorShimSf !== null) {\n      return priorShimSf;\n    }\n    return ts20.createSourceFile(genFilePath, \"export const USED_FOR_NG_TYPE_CHECKING = true;\", ts20.ScriptTarget.Latest, true, ts20.ScriptKind.TS);\n  }\n  static shimFor(fileName) {\n    return absoluteFrom(fileName.replace(/\\.tsx?$/, \".ngtypecheck.ts\"));\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.mjs\nimport { BindingPipe, Call as Call2, DYNAMIC_TYPE, ImplicitReceiver as ImplicitReceiver4, PropertyRead as PropertyRead4, PropertyWrite as PropertyWrite3, SafeCall, SafePropertyRead as SafePropertyRead3, ThisReceiver, TmplAstBoundAttribute, TmplAstBoundText, TmplAstElement as TmplAstElement3, TmplAstIcu, TmplAstReference as TmplAstReference3, TmplAstTemplate as TmplAstTemplate2, TmplAstTextAttribute as TmplAstTextAttribute2, TmplAstVariable as TmplAstVariable2, TransplantedType } from \"@angular/compiler\";\nimport ts23 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/diagnostics.mjs\nimport { AbsoluteSourceSpan as AbsoluteSourceSpan3 } from \"@angular/compiler\";\nimport ts21 from \"typescript\";\nfunction wrapForDiagnostics(expr) {\n  return ts21.factory.createParenthesizedExpression(expr);\n}\nfunction wrapForTypeChecker(expr) {\n  return ts21.factory.createParenthesizedExpression(expr);\n}\nfunction addParseSpanInfo(node, span) {\n  let commentText;\n  if (span instanceof AbsoluteSourceSpan3) {\n    commentText = `${span.start},${span.end}`;\n  } else {\n    commentText = `${span.start.offset},${span.end.offset}`;\n  }\n  ts21.addSyntheticTrailingComment(node, ts21.SyntaxKind.MultiLineCommentTrivia, commentText, false);\n}\nfunction addTemplateId(tcb, id) {\n  ts21.addSyntheticLeadingComment(tcb, ts21.SyntaxKind.MultiLineCommentTrivia, id, true);\n}\nfunction shouldReportDiagnostic(diagnostic) {\n  const {\n    code\n  } = diagnostic;\n  if (code === 6133) {\n    return false;\n  } else if (code === 6199) {\n    return false;\n  } else if (code === 2695) {\n    return false;\n  } else if (code === 7006) {\n    return false;\n  }\n  return true;\n}\nfunction translateDiagnostic(diagnostic, resolver) {\n  if (diagnostic.file === void 0 || diagnostic.start === void 0) {\n    return null;\n  }\n  const fullMapping = getTemplateMapping(diagnostic.file, diagnostic.start, resolver, true);\n  if (fullMapping === null) {\n    return null;\n  }\n  const {\n    sourceLocation,\n    templateSourceMapping,\n    span\n  } = fullMapping;\n  return makeTemplateDiagnostic(sourceLocation.id, templateSourceMapping, span, diagnostic.category, diagnostic.code, diagnostic.messageText);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/expression.mjs\nimport { ASTWithSource as ASTWithSource2, Call, EmptyExpr as EmptyExpr2, PropertyRead as PropertyRead3, SafeKeyedRead, SafePropertyRead as SafePropertyRead2 } from \"@angular/compiler\";\nimport ts22 from \"typescript\";\nvar NULL_AS_ANY = ts22.factory.createAsExpression(ts22.factory.createNull(), ts22.factory.createKeywordTypeNode(ts22.SyntaxKind.AnyKeyword));\nvar UNDEFINED = ts22.factory.createIdentifier(\"undefined\");\nvar UNARY_OPS = /* @__PURE__ */new Map([[\"+\", ts22.SyntaxKind.PlusToken], [\"-\", ts22.SyntaxKind.MinusToken]]);\nvar BINARY_OPS = /* @__PURE__ */new Map([[\"+\", ts22.SyntaxKind.PlusToken], [\"-\", ts22.SyntaxKind.MinusToken], [\"<\", ts22.SyntaxKind.LessThanToken], [\">\", ts22.SyntaxKind.GreaterThanToken], [\"<=\", ts22.SyntaxKind.LessThanEqualsToken], [\">=\", ts22.SyntaxKind.GreaterThanEqualsToken], [\"==\", ts22.SyntaxKind.EqualsEqualsToken], [\"===\", ts22.SyntaxKind.EqualsEqualsEqualsToken], [\"*\", ts22.SyntaxKind.AsteriskToken], [\"/\", ts22.SyntaxKind.SlashToken], [\"%\", ts22.SyntaxKind.PercentToken], [\"!=\", ts22.SyntaxKind.ExclamationEqualsToken], [\"!==\", ts22.SyntaxKind.ExclamationEqualsEqualsToken], [\"||\", ts22.SyntaxKind.BarBarToken], [\"&&\", ts22.SyntaxKind.AmpersandAmpersandToken], [\"&\", ts22.SyntaxKind.AmpersandToken], [\"|\", ts22.SyntaxKind.BarToken], [\"??\", ts22.SyntaxKind.QuestionQuestionToken]]);\nfunction astToTypescript(ast, maybeResolve, config) {\n  const translator = new AstTranslator(maybeResolve, config);\n  return translator.translate(ast);\n}\nvar AstTranslator = class {\n  constructor(maybeResolve, config) {\n    this.maybeResolve = maybeResolve;\n    this.config = config;\n  }\n  translate(ast) {\n    if (ast instanceof ASTWithSource2) {\n      ast = ast.ast;\n    }\n    if (ast instanceof EmptyExpr2) {\n      const res = ts22.factory.createIdentifier(\"undefined\");\n      addParseSpanInfo(res, ast.sourceSpan);\n      return res;\n    }\n    const resolved = this.maybeResolve(ast);\n    if (resolved !== null) {\n      return resolved;\n    }\n    return ast.visit(this);\n  }\n  visitUnary(ast) {\n    const expr = this.translate(ast.expr);\n    const op = UNARY_OPS.get(ast.operator);\n    if (op === void 0) {\n      throw new Error(`Unsupported Unary.operator: ${ast.operator}`);\n    }\n    const node = wrapForDiagnostics(ts22.factory.createPrefixUnaryExpression(op, expr));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitBinary(ast) {\n    const lhs = wrapForDiagnostics(this.translate(ast.left));\n    const rhs = wrapForDiagnostics(this.translate(ast.right));\n    const op = BINARY_OPS.get(ast.operation);\n    if (op === void 0) {\n      throw new Error(`Unsupported Binary.operation: ${ast.operation}`);\n    }\n    const node = ts22.factory.createBinaryExpression(lhs, op, rhs);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitChain(ast) {\n    const elements = ast.expressions.map(expr => this.translate(expr));\n    const node = wrapForDiagnostics(ts22.factory.createCommaListExpression(elements));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitConditional(ast) {\n    const condExpr = this.translate(ast.condition);\n    const trueExpr = this.translate(ast.trueExp);\n    const falseExpr = wrapForTypeChecker(this.translate(ast.falseExp));\n    const node = ts22.factory.createParenthesizedExpression(ts22.factory.createConditionalExpression(condExpr, void 0, trueExpr, void 0, falseExpr));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitImplicitReceiver(ast) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitThisReceiver(ast) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitInterpolation(ast) {\n    return ast.expressions.reduce((lhs, ast2) => ts22.factory.createBinaryExpression(lhs, ts22.SyntaxKind.PlusToken, wrapForTypeChecker(this.translate(ast2))), ts22.factory.createStringLiteral(\"\"));\n  }\n  visitKeyedRead(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const key = this.translate(ast.key);\n    const node = ts22.factory.createElementAccessExpression(receiver, key);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitKeyedWrite(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const left = ts22.factory.createElementAccessExpression(receiver, this.translate(ast.key));\n    const right = wrapForTypeChecker(this.translate(ast.value));\n    const node = wrapForDiagnostics(ts22.factory.createBinaryExpression(left, ts22.SyntaxKind.EqualsToken, right));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitLiteralArray(ast) {\n    const elements = ast.expressions.map(expr => this.translate(expr));\n    const literal = ts22.factory.createArrayLiteralExpression(elements);\n    const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitLiteralMap(ast) {\n    const properties = ast.keys.map(({\n      key\n    }, idx) => {\n      const value = this.translate(ast.values[idx]);\n      return ts22.factory.createPropertyAssignment(ts22.factory.createStringLiteral(key), value);\n    });\n    const literal = ts22.factory.createObjectLiteralExpression(properties, true);\n    const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitLiteralPrimitive(ast) {\n    let node;\n    if (ast.value === void 0) {\n      node = ts22.factory.createIdentifier(\"undefined\");\n    } else if (ast.value === null) {\n      node = ts22.factory.createNull();\n    } else if (typeof ast.value === \"string\") {\n      node = ts22.factory.createStringLiteral(ast.value);\n    } else if (typeof ast.value === \"number\") {\n      node = ts22.factory.createNumericLiteral(ast.value);\n    } else if (typeof ast.value === \"boolean\") {\n      node = ast.value ? ts22.factory.createTrue() : ts22.factory.createFalse();\n    } else {\n      throw Error(`Unsupported AST value of type ${typeof ast.value}`);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitNonNullAssert(ast) {\n    const expr = wrapForDiagnostics(this.translate(ast.expression));\n    const node = ts22.factory.createNonNullExpression(expr);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitPipe(ast) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitPrefixNot(ast) {\n    const expression = wrapForDiagnostics(this.translate(ast.expression));\n    const node = ts22.factory.createLogicalNot(expression);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitPropertyRead(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const name = ts22.factory.createPropertyAccessExpression(receiver, ast.name);\n    addParseSpanInfo(name, ast.nameSpan);\n    const node = wrapForDiagnostics(name);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitPropertyWrite(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const left = ts22.factory.createPropertyAccessExpression(receiver, ast.name);\n    addParseSpanInfo(left, ast.nameSpan);\n    const leftWithPath = wrapForDiagnostics(left);\n    addParseSpanInfo(leftWithPath, ast.sourceSpan);\n    const right = wrapForTypeChecker(this.translate(ast.value));\n    const node = wrapForDiagnostics(ts22.factory.createBinaryExpression(leftWithPath, ts22.SyntaxKind.EqualsToken, right));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitSafePropertyRead(ast) {\n    let node;\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    if (this.config.strictSafeNavigationTypes) {\n      const expr = ts22.factory.createPropertyAccessExpression(ts22.factory.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(expr, ast.nameSpan);\n      node = ts22.factory.createParenthesizedExpression(ts22.factory.createConditionalExpression(NULL_AS_ANY, void 0, expr, void 0, UNDEFINED));\n    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      node = ts22.factory.createPropertyAccessExpression(tsCastToAny(receiver), ast.name);\n    } else {\n      const expr = ts22.factory.createPropertyAccessExpression(ts22.factory.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(expr, ast.nameSpan);\n      node = tsCastToAny(expr);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitSafeKeyedRead(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const key = this.translate(ast.key);\n    let node;\n    if (this.config.strictSafeNavigationTypes) {\n      const expr = ts22.factory.createElementAccessExpression(ts22.factory.createNonNullExpression(receiver), key);\n      addParseSpanInfo(expr, ast.sourceSpan);\n      node = ts22.factory.createParenthesizedExpression(ts22.factory.createConditionalExpression(NULL_AS_ANY, void 0, expr, void 0, UNDEFINED));\n    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      node = ts22.factory.createElementAccessExpression(tsCastToAny(receiver), key);\n    } else {\n      const expr = ts22.factory.createElementAccessExpression(ts22.factory.createNonNullExpression(receiver), key);\n      addParseSpanInfo(expr, ast.sourceSpan);\n      node = tsCastToAny(expr);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitCall(ast) {\n    const args = ast.args.map(expr2 => this.translate(expr2));\n    let expr;\n    const receiver = ast.receiver;\n    if (receiver instanceof PropertyRead3) {\n      const resolved = this.maybeResolve(receiver);\n      if (resolved !== null) {\n        expr = resolved;\n      } else {\n        const propertyReceiver = wrapForDiagnostics(this.translate(receiver.receiver));\n        expr = ts22.factory.createPropertyAccessExpression(propertyReceiver, receiver.name);\n        addParseSpanInfo(expr, receiver.nameSpan);\n      }\n    } else {\n      expr = this.translate(receiver);\n    }\n    let node;\n    if (ast.receiver instanceof SafePropertyRead2 || ast.receiver instanceof SafeKeyedRead) {\n      node = this.convertToSafeCall(ast, expr, args);\n    } else {\n      node = ts22.factory.createCallExpression(expr, void 0, args);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitSafeCall(ast) {\n    const args = ast.args.map(expr2 => this.translate(expr2));\n    const expr = wrapForDiagnostics(this.translate(ast.receiver));\n    const node = this.convertToSafeCall(ast, expr, args);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  convertToSafeCall(ast, expr, args) {\n    if (this.config.strictSafeNavigationTypes) {\n      const call = ts22.factory.createCallExpression(ts22.factory.createNonNullExpression(expr), void 0, args);\n      return ts22.factory.createParenthesizedExpression(ts22.factory.createConditionalExpression(NULL_AS_ANY, void 0, call, void 0, UNDEFINED));\n    }\n    if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      return ts22.factory.createCallExpression(tsCastToAny(expr), void 0, args);\n    }\n    return tsCastToAny(ts22.factory.createCallExpression(ts22.factory.createNonNullExpression(expr), void 0, args));\n  }\n};\nvar _VeSafeLhsInferenceBugDetector = class {\n  static veWillInferAnyFor(ast) {\n    const visitor = _VeSafeLhsInferenceBugDetector.SINGLETON;\n    return ast instanceof Call ? ast.visit(visitor) : ast.receiver.visit(visitor);\n  }\n  visitUnary(ast) {\n    return ast.expr.visit(this);\n  }\n  visitBinary(ast) {\n    return ast.left.visit(this) || ast.right.visit(this);\n  }\n  visitChain(ast) {\n    return false;\n  }\n  visitConditional(ast) {\n    return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);\n  }\n  visitCall(ast) {\n    return true;\n  }\n  visitSafeCall(ast) {\n    return false;\n  }\n  visitImplicitReceiver(ast) {\n    return false;\n  }\n  visitThisReceiver(ast) {\n    return false;\n  }\n  visitInterpolation(ast) {\n    return ast.expressions.some(exp => exp.visit(this));\n  }\n  visitKeyedRead(ast) {\n    return false;\n  }\n  visitKeyedWrite(ast) {\n    return false;\n  }\n  visitLiteralArray(ast) {\n    return true;\n  }\n  visitLiteralMap(ast) {\n    return true;\n  }\n  visitLiteralPrimitive(ast) {\n    return false;\n  }\n  visitPipe(ast) {\n    return true;\n  }\n  visitPrefixNot(ast) {\n    return ast.expression.visit(this);\n  }\n  visitNonNullAssert(ast) {\n    return ast.expression.visit(this);\n  }\n  visitPropertyRead(ast) {\n    return false;\n  }\n  visitPropertyWrite(ast) {\n    return false;\n  }\n  visitSafePropertyRead(ast) {\n    return false;\n  }\n  visitSafeKeyedRead(ast) {\n    return false;\n  }\n};\nvar VeSafeLhsInferenceBugDetector = _VeSafeLhsInferenceBugDetector;\n(() => {\n  _VeSafeLhsInferenceBugDetector.SINGLETON = new _VeSafeLhsInferenceBugDetector();\n})();\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/template_semantics.mjs\nimport { ImplicitReceiver as ImplicitReceiver3, RecursiveAstVisitor as RecursiveAstVisitor2, TmplAstVariable } from \"@angular/compiler\";\nvar ExpressionSemanticVisitor = class extends RecursiveAstVisitor2 {\n  constructor(templateId, boundTarget, oob) {\n    super();\n    this.templateId = templateId;\n    this.boundTarget = boundTarget;\n    this.oob = oob;\n  }\n  visitPropertyWrite(ast, context) {\n    super.visitPropertyWrite(ast, context);\n    if (!(ast.receiver instanceof ImplicitReceiver3)) {\n      return;\n    }\n    const target = this.boundTarget.getExpressionTarget(ast);\n    if (target instanceof TmplAstVariable) {\n      this.oob.illegalAssignmentToTemplateVar(this.templateId, ast, target);\n    }\n  }\n  static visit(ast, id, boundTarget, oob) {\n    ast.visit(new ExpressionSemanticVisitor(id, boundTarget, oob));\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.mjs\nvar TcbGenericContextBehavior;\n(function (TcbGenericContextBehavior2) {\n  TcbGenericContextBehavior2[TcbGenericContextBehavior2[\"UseEmitter\"] = 0] = \"UseEmitter\";\n  TcbGenericContextBehavior2[TcbGenericContextBehavior2[\"CopyClassNodes\"] = 1] = \"CopyClassNodes\";\n  TcbGenericContextBehavior2[TcbGenericContextBehavior2[\"FallbackToAny\"] = 2] = \"FallbackToAny\";\n})(TcbGenericContextBehavior || (TcbGenericContextBehavior = {}));\nfunction generateTypeCheckBlock(env, ref, name, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {\n  const tcb = new Context(env, domSchemaChecker, oobRecorder, meta.id, meta.boundTarget, meta.pipes, meta.schemas, meta.isStandalone);\n  const scope = Scope.forNodes(tcb, null, tcb.boundTarget.target.template, null);\n  const ctxRawType = env.referenceType(ref);\n  if (!ts23.isTypeReferenceNode(ctxRawType)) {\n    throw new Error(`Expected TypeReferenceNode when referencing the ctx param for ${ref.debugName}`);\n  }\n  let typeParameters = void 0;\n  let typeArguments = void 0;\n  if (ref.node.typeParameters !== void 0) {\n    if (!env.config.useContextGenericType) {\n      genericContextBehavior = TcbGenericContextBehavior.FallbackToAny;\n    }\n    switch (genericContextBehavior) {\n      case TcbGenericContextBehavior.UseEmitter:\n        typeParameters = new TypeParameterEmitter(ref.node.typeParameters, env.reflector).emit(typeRef => env.referenceType(typeRef));\n        typeArguments = typeParameters.map(param => ts23.factory.createTypeReferenceNode(param.name));\n        break;\n      case TcbGenericContextBehavior.CopyClassNodes:\n        typeParameters = [...ref.node.typeParameters];\n        typeArguments = typeParameters.map(param => ts23.factory.createTypeReferenceNode(param.name));\n        break;\n      case TcbGenericContextBehavior.FallbackToAny:\n        typeArguments = ref.node.typeParameters.map(() => ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n        break;\n    }\n  }\n  const paramList = [tcbThisParam(ctxRawType.typeName, typeArguments)];\n  const scopeStatements = scope.render();\n  const innerBody = ts23.factory.createBlock([...env.getPreludeStatements(), ...scopeStatements]);\n  const body = ts23.factory.createBlock([ts23.factory.createIfStatement(ts23.factory.createTrue(), innerBody, void 0)]);\n  const fnDecl = ts23.factory.createFunctionDeclaration(void 0, void 0, name, env.config.useContextGenericType ? typeParameters : void 0, paramList, void 0, body);\n  addTemplateId(fnDecl, meta.id);\n  return fnDecl;\n}\nvar TcbOp = class {\n  circularFallback() {\n    return INFER_TYPE_FOR_CIRCULAR_OP_EXPR;\n  }\n};\nvar TcbElementOp = class extends TcbOp {\n  constructor(tcb, scope, element) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.element = element;\n  }\n  get optional() {\n    return true;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    const initializer = tsCreateElement(this.element.name);\n    addParseSpanInfo(initializer, this.element.startSourceSpan || this.element.sourceSpan);\n    this.scope.addStatement(tsCreateVariable(id, initializer));\n    return id;\n  }\n};\nvar TcbVariableOp = class extends TcbOp {\n  constructor(tcb, scope, template, variable) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.template = template;\n    this.variable = variable;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    const ctx = this.scope.resolve(this.template);\n    const id = this.tcb.allocateId();\n    const initializer = ts23.factory.createPropertyAccessExpression(ctx, this.variable.value || \"$implicit\");\n    addParseSpanInfo(id, this.variable.keySpan);\n    let variable;\n    if (this.variable.valueSpan !== void 0) {\n      addParseSpanInfo(initializer, this.variable.valueSpan);\n      variable = tsCreateVariable(id, wrapForTypeChecker(initializer));\n    } else {\n      variable = tsCreateVariable(id, initializer);\n    }\n    addParseSpanInfo(variable.declarationList.declarations[0], this.variable.sourceSpan);\n    this.scope.addStatement(variable);\n    return id;\n  }\n};\nvar TcbTemplateContextOp = class extends TcbOp {\n  constructor(tcb, scope) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.optional = true;\n  }\n  execute() {\n    const ctx = this.tcb.allocateId();\n    const type = ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword);\n    this.scope.addStatement(tsDeclareVariable(ctx, type));\n    return ctx;\n  }\n};\nvar TcbTemplateBodyOp = class extends TcbOp {\n  constructor(tcb, scope, template) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.template = template;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    const directiveGuards = [];\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(this.template);\n    if (directives !== null) {\n      for (const dir of directives) {\n        const dirInstId = this.scope.resolve(this.template, dir);\n        const dirId = this.tcb.env.reference(dir.ref);\n        dir.ngTemplateGuards.forEach(guard2 => {\n          const boundInput = this.template.inputs.find(i => i.name === guard2.inputName) || this.template.templateAttrs.find(i => i instanceof TmplAstBoundAttribute && i.name === guard2.inputName);\n          if (boundInput !== void 0) {\n            const expr = tcbExpression(boundInput.value, this.tcb, this.scope);\n            markIgnoreDiagnostics(expr);\n            if (guard2.type === \"binding\") {\n              directiveGuards.push(expr);\n            } else {\n              const guardInvoke = tsCallMethod(dirId, `ngTemplateGuard_${guard2.inputName}`, [dirInstId, expr]);\n              addParseSpanInfo(guardInvoke, boundInput.value.sourceSpan);\n              directiveGuards.push(guardInvoke);\n            }\n          }\n        });\n        if (dir.hasNgTemplateContextGuard) {\n          if (this.tcb.env.config.applyTemplateContextGuards) {\n            const ctx = this.scope.resolve(this.template);\n            const guardInvoke = tsCallMethod(dirId, \"ngTemplateContextGuard\", [dirInstId, ctx]);\n            addParseSpanInfo(guardInvoke, this.template.sourceSpan);\n            directiveGuards.push(guardInvoke);\n          } else if (this.template.variables.length > 0 && this.tcb.env.config.suggestionsForSuboptimalTypeInference) {\n            this.tcb.oobRecorder.suboptimalTypeInference(this.tcb.id, this.template.variables);\n          }\n        }\n      }\n    }\n    let guard = null;\n    if (directiveGuards.length > 0) {\n      guard = directiveGuards.reduce((expr, dirGuard) => ts23.factory.createBinaryExpression(expr, ts23.SyntaxKind.AmpersandAmpersandToken, dirGuard), directiveGuards.pop());\n    }\n    const tmplScope = Scope.forNodes(this.tcb, this.scope, this.template, guard);\n    const statements = tmplScope.render();\n    if (statements.length === 0) {\n      return null;\n    }\n    let tmplBlock = ts23.factory.createBlock(statements);\n    if (guard !== null) {\n      tmplBlock = ts23.factory.createIfStatement(guard, tmplBlock);\n    }\n    this.scope.addStatement(tmplBlock);\n    return null;\n  }\n};\nvar TcbTextInterpolationOp = class extends TcbOp {\n  constructor(tcb, scope, binding) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.binding = binding;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    const expr = tcbExpression(this.binding.value, this.tcb, this.scope);\n    this.scope.addStatement(ts23.factory.createExpressionStatement(expr));\n    return null;\n  }\n};\nvar TcbDirectiveTypeOpBase = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return true;\n  }\n  execute() {\n    const dirRef = this.dir.ref;\n    const rawType = this.tcb.env.referenceType(this.dir.ref);\n    let type;\n    if (this.dir.isGeneric === false || dirRef.node.typeParameters === void 0) {\n      type = rawType;\n    } else {\n      if (!ts23.isTypeReferenceNode(rawType)) {\n        throw new Error(`Expected TypeReferenceNode when referencing the type for ${this.dir.ref.debugName}`);\n      }\n      const typeArguments = dirRef.node.typeParameters.map(() => ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n      type = ts23.factory.createTypeReferenceNode(rawType.typeName, typeArguments);\n    }\n    const id = this.tcb.allocateId();\n    addExpressionIdentifier(type, ExpressionIdentifier.DIRECTIVE);\n    addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);\n    this.scope.addStatement(tsDeclareVariable(id, type));\n    return id;\n  }\n};\nvar TcbNonGenericDirectiveTypeOp = class extends TcbDirectiveTypeOpBase {\n  execute() {\n    const dirRef = this.dir.ref;\n    if (this.dir.isGeneric) {\n      throw new Error(`Assertion Error: expected ${dirRef.debugName} not to be generic.`);\n    }\n    return super.execute();\n  }\n};\nvar TcbGenericDirectiveTypeWithAnyParamsOp = class extends TcbDirectiveTypeOpBase {\n  execute() {\n    const dirRef = this.dir.ref;\n    if (dirRef.node.typeParameters === void 0) {\n      throw new Error(`Assertion Error: expected typeParameters when creating a declaration for ${dirRef.debugName}`);\n    }\n    return super.execute();\n  }\n};\nvar TcbReferenceOp = class extends TcbOp {\n  constructor(tcb, scope, node, host, target) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.host = host;\n    this.target = target;\n    this.optional = true;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    let initializer = this.target instanceof TmplAstTemplate2 || this.target instanceof TmplAstElement3 ? this.scope.resolve(this.target) : this.scope.resolve(this.host, this.target);\n    if (this.target instanceof TmplAstElement3 && !this.tcb.env.config.checkTypeOfDomReferences || !this.tcb.env.config.checkTypeOfNonDomReferences) {\n      initializer = ts23.factory.createAsExpression(initializer, ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n    } else if (this.target instanceof TmplAstTemplate2) {\n      initializer = ts23.factory.createAsExpression(initializer, ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n      initializer = ts23.factory.createAsExpression(initializer, this.tcb.env.referenceExternalType(\"@angular/core\", \"TemplateRef\", [DYNAMIC_TYPE]));\n      initializer = ts23.factory.createParenthesizedExpression(initializer);\n    }\n    addParseSpanInfo(initializer, this.node.sourceSpan);\n    addParseSpanInfo(id, this.node.keySpan);\n    this.scope.addStatement(tsCreateVariable(id, initializer));\n    return id;\n  }\n};\nvar TcbInvalidReferenceOp = class extends TcbOp {\n  constructor(tcb, scope) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.optional = true;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    this.scope.addStatement(tsCreateVariable(id, NULL_AS_ANY));\n    return id;\n  }\n};\nvar TcbDirectiveCtorOp = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return true;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    addExpressionIdentifier(id, ExpressionIdentifier.DIRECTIVE);\n    addParseSpanInfo(id, this.node.startSourceSpan || this.node.sourceSpan);\n    const genericInputs = /* @__PURE__ */new Map();\n    const boundAttrs = getBoundAttributes(this.dir, this.node);\n    for (const attr of boundAttrs) {\n      if (!this.tcb.env.config.checkTypeOfAttributes && attr.attribute instanceof TmplAstTextAttribute2) {\n        continue;\n      }\n      for (const {\n        fieldName\n      } of attr.inputs) {\n        if (genericInputs.has(fieldName)) {\n          continue;\n        }\n        const expression = translateInput(attr.attribute, this.tcb, this.scope);\n        genericInputs.set(fieldName, {\n          type: \"binding\",\n          field: fieldName,\n          expression,\n          sourceSpan: attr.attribute.sourceSpan\n        });\n      }\n    }\n    for (const {\n      classPropertyName\n    } of this.dir.inputs) {\n      if (!genericInputs.has(classPropertyName)) {\n        genericInputs.set(classPropertyName, {\n          type: \"unset\",\n          field: classPropertyName\n        });\n      }\n    }\n    const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, Array.from(genericInputs.values()));\n    markIgnoreDiagnostics(typeCtor);\n    this.scope.addStatement(tsCreateVariable(id, typeCtor));\n    return id;\n  }\n  circularFallback() {\n    return new TcbDirectiveCtorCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);\n  }\n};\nvar TcbDirectiveInputsOp = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    let dirId = null;\n    const boundAttrs = getBoundAttributes(this.dir, this.node);\n    const seenRequiredInputs = /* @__PURE__ */new Set();\n    for (const attr of boundAttrs) {\n      const expr = widenBinding(translateInput(attr.attribute, this.tcb, this.scope), this.tcb);\n      let assignment = wrapForDiagnostics(expr);\n      for (const {\n        fieldName,\n        required,\n        transformType\n      } of attr.inputs) {\n        let target;\n        if (required) {\n          seenRequiredInputs.add(fieldName);\n        }\n        if (this.dir.coercedInputFields.has(fieldName)) {\n          let type;\n          if (transformType) {\n            type = this.tcb.env.referenceTransplantedType(new TransplantedType(transformType));\n          } else {\n            const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n            if (!ts23.isTypeReferenceNode(dirTypeRef)) {\n              throw new Error(`Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n            }\n            type = tsCreateTypeQueryForCoercedInput(dirTypeRef.typeName, fieldName);\n          }\n          const id = this.tcb.allocateId();\n          this.scope.addStatement(tsDeclareVariable(id, type));\n          target = id;\n        } else if (this.dir.undeclaredInputFields.has(fieldName)) {\n          continue;\n        } else if (!this.tcb.env.config.honorAccessModifiersForInputBindings && this.dir.restrictedInputFields.has(fieldName)) {\n          if (dirId === null) {\n            dirId = this.scope.resolve(this.node, this.dir);\n          }\n          const id = this.tcb.allocateId();\n          const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n          if (!ts23.isTypeReferenceNode(dirTypeRef)) {\n            throw new Error(`Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n          }\n          const type = ts23.factory.createIndexedAccessTypeNode(ts23.factory.createTypeQueryNode(dirId), ts23.factory.createLiteralTypeNode(ts23.factory.createStringLiteral(fieldName)));\n          const temp = tsDeclareVariable(id, type);\n          this.scope.addStatement(temp);\n          target = id;\n        } else {\n          if (dirId === null) {\n            dirId = this.scope.resolve(this.node, this.dir);\n          }\n          target = this.dir.stringLiteralInputFields.has(fieldName) ? ts23.factory.createElementAccessExpression(dirId, ts23.factory.createStringLiteral(fieldName)) : ts23.factory.createPropertyAccessExpression(dirId, ts23.factory.createIdentifier(fieldName));\n        }\n        if (attr.attribute.keySpan !== void 0) {\n          addParseSpanInfo(target, attr.attribute.keySpan);\n        }\n        assignment = ts23.factory.createBinaryExpression(target, ts23.SyntaxKind.EqualsToken, assignment);\n      }\n      addParseSpanInfo(assignment, attr.attribute.sourceSpan);\n      if (!this.tcb.env.config.checkTypeOfAttributes && attr.attribute instanceof TmplAstTextAttribute2) {\n        markIgnoreDiagnostics(assignment);\n      }\n      this.scope.addStatement(ts23.factory.createExpressionStatement(assignment));\n    }\n    this.checkRequiredInputs(seenRequiredInputs);\n    return null;\n  }\n  checkRequiredInputs(seenRequiredInputs) {\n    const missing = [];\n    for (const input of this.dir.inputs) {\n      if (input.required && !seenRequiredInputs.has(input.classPropertyName)) {\n        missing.push(input.bindingPropertyName);\n      }\n    }\n    if (missing.length > 0) {\n      this.tcb.oobRecorder.missingRequiredInputs(this.tcb.id, this.node, this.dir.name, this.dir.isComponent, missing);\n    }\n  }\n};\nvar TcbDirectiveCtorCircularFallbackOp = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    const typeCtor = this.tcb.env.typeCtorFor(this.dir);\n    const circularPlaceholder = ts23.factory.createCallExpression(typeCtor, void 0, [ts23.factory.createNonNullExpression(ts23.factory.createNull())]);\n    this.scope.addStatement(tsCreateVariable(id, circularPlaceholder));\n    return id;\n  }\n};\nvar TcbDomSchemaCheckerOp = class extends TcbOp {\n  constructor(tcb, element, checkElement, claimedInputs) {\n    super();\n    this.tcb = tcb;\n    this.element = element;\n    this.checkElement = checkElement;\n    this.claimedInputs = claimedInputs;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    var _a;\n    if (this.checkElement) {\n      this.tcb.domSchemaChecker.checkElement(this.tcb.id, this.element, this.tcb.schemas, this.tcb.hostIsStandalone);\n    }\n    for (const binding of this.element.inputs) {\n      if (binding.type === 0 && this.claimedInputs.has(binding.name)) {\n        continue;\n      }\n      if (binding.type === 0) {\n        if (binding.name !== \"style\" && binding.name !== \"class\") {\n          const propertyName = (_a = ATTR_TO_PROP.get(binding.name)) != null ? _a : binding.name;\n          this.tcb.domSchemaChecker.checkProperty(this.tcb.id, this.element, propertyName, binding.sourceSpan, this.tcb.schemas, this.tcb.hostIsStandalone);\n        }\n      }\n    }\n    return null;\n  }\n};\nvar ATTR_TO_PROP = new Map(Object.entries({\n  \"class\": \"className\",\n  \"for\": \"htmlFor\",\n  \"formaction\": \"formAction\",\n  \"innerHtml\": \"innerHTML\",\n  \"readonly\": \"readOnly\",\n  \"tabindex\": \"tabIndex\"\n}));\nvar TcbUnclaimedInputsOp = class extends TcbOp {\n  constructor(tcb, scope, element, claimedInputs) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.element = element;\n    this.claimedInputs = claimedInputs;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    var _a;\n    let elId = null;\n    for (const binding of this.element.inputs) {\n      if (binding.type === 0 && this.claimedInputs.has(binding.name)) {\n        continue;\n      }\n      const expr = widenBinding(tcbExpression(binding.value, this.tcb, this.scope), this.tcb);\n      if (this.tcb.env.config.checkTypeOfDomBindings && binding.type === 0) {\n        if (binding.name !== \"style\" && binding.name !== \"class\") {\n          if (elId === null) {\n            elId = this.scope.resolve(this.element);\n          }\n          const propertyName = (_a = ATTR_TO_PROP.get(binding.name)) != null ? _a : binding.name;\n          const prop = ts23.factory.createElementAccessExpression(elId, ts23.factory.createStringLiteral(propertyName));\n          const stmt = ts23.factory.createBinaryExpression(prop, ts23.SyntaxKind.EqualsToken, wrapForDiagnostics(expr));\n          addParseSpanInfo(stmt, binding.sourceSpan);\n          this.scope.addStatement(ts23.factory.createExpressionStatement(stmt));\n        } else {\n          this.scope.addStatement(ts23.factory.createExpressionStatement(expr));\n        }\n      } else {\n        this.scope.addStatement(ts23.factory.createExpressionStatement(expr));\n      }\n    }\n    return null;\n  }\n};\nvar TcbDirectiveOutputsOp = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    let dirId = null;\n    const outputs = this.dir.outputs;\n    for (const output of this.node.outputs) {\n      if (output.type !== 0 || !outputs.hasBindingPropertyName(output.name)) {\n        continue;\n      }\n      if (this.tcb.env.config.checkTypeOfOutputEvents && output.name.endsWith(\"Change\")) {\n        const inputName = output.name.slice(0, -6);\n        isSplitTwoWayBinding(inputName, output, this.node.inputs, this.tcb);\n      }\n      const field = outputs.getByBindingPropertyName(output.name)[0].classPropertyName;\n      if (dirId === null) {\n        dirId = this.scope.resolve(this.node, this.dir);\n      }\n      const outputField = ts23.factory.createElementAccessExpression(dirId, ts23.factory.createStringLiteral(field));\n      addParseSpanInfo(outputField, output.keySpan);\n      if (this.tcb.env.config.checkTypeOfOutputEvents) {\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0);\n        const subscribeFn = ts23.factory.createPropertyAccessExpression(outputField, \"subscribe\");\n        const call = ts23.factory.createCallExpression(subscribeFn, void 0, [handler]);\n        addParseSpanInfo(call, output.sourceSpan);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(call));\n      } else {\n        this.scope.addStatement(ts23.factory.createExpressionStatement(outputField));\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(handler));\n      }\n      ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n    }\n    return null;\n  }\n};\nvar TcbUnclaimedOutputsOp = class extends TcbOp {\n  constructor(tcb, scope, element, claimedOutputs) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.element = element;\n    this.claimedOutputs = claimedOutputs;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    let elId = null;\n    for (const output of this.element.outputs) {\n      if (this.claimedOutputs.has(output.name)) {\n        continue;\n      }\n      if (this.tcb.env.config.checkTypeOfOutputEvents && output.name.endsWith(\"Change\")) {\n        const inputName = output.name.slice(0, -6);\n        if (isSplitTwoWayBinding(inputName, output, this.element.inputs, this.tcb)) {\n          continue;\n        }\n      }\n      if (output.type === 1) {\n        const eventType = this.tcb.env.config.checkTypeOfAnimationEvents ? this.tcb.env.referenceExternalType(\"@angular/animations\", \"AnimationEvent\") : 1;\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, eventType);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(handler));\n      } else if (this.tcb.env.config.checkTypeOfDomEvents) {\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0);\n        if (elId === null) {\n          elId = this.scope.resolve(this.element);\n        }\n        const propertyAccess = ts23.factory.createPropertyAccessExpression(elId, \"addEventListener\");\n        addParseSpanInfo(propertyAccess, output.keySpan);\n        const call = ts23.factory.createCallExpression(propertyAccess, void 0, [ts23.factory.createStringLiteral(output.name), handler]);\n        addParseSpanInfo(call, output.sourceSpan);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(call));\n      } else {\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(handler));\n      }\n      ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n    }\n    return null;\n  }\n};\nvar TcbComponentContextCompletionOp = class extends TcbOp {\n  constructor(scope) {\n    super();\n    this.scope = scope;\n    this.optional = false;\n  }\n  execute() {\n    const ctx = ts23.factory.createThis();\n    const ctxDot = ts23.factory.createPropertyAccessExpression(ctx, \"\");\n    markIgnoreDiagnostics(ctxDot);\n    addExpressionIdentifier(ctxDot, ExpressionIdentifier.COMPONENT_COMPLETION);\n    this.scope.addStatement(ts23.factory.createExpressionStatement(ctxDot));\n    return null;\n  }\n};\nvar INFER_TYPE_FOR_CIRCULAR_OP_EXPR = ts23.factory.createNonNullExpression(ts23.factory.createNull());\nvar Context = class {\n  constructor(env, domSchemaChecker, oobRecorder, id, boundTarget, pipes, schemas, hostIsStandalone) {\n    this.env = env;\n    this.domSchemaChecker = domSchemaChecker;\n    this.oobRecorder = oobRecorder;\n    this.id = id;\n    this.boundTarget = boundTarget;\n    this.pipes = pipes;\n    this.schemas = schemas;\n    this.hostIsStandalone = hostIsStandalone;\n    this.nextId = 1;\n  }\n  allocateId() {\n    return ts23.factory.createIdentifier(`_t${this.nextId++}`);\n  }\n  getPipeByName(name) {\n    if (!this.pipes.has(name)) {\n      return null;\n    }\n    return this.pipes.get(name);\n  }\n};\nvar Scope = class {\n  constructor(tcb, parent = null, guard = null) {\n    this.tcb = tcb;\n    this.parent = parent;\n    this.guard = guard;\n    this.opQueue = [];\n    this.elementOpMap = /* @__PURE__ */new Map();\n    this.directiveOpMap = /* @__PURE__ */new Map();\n    this.referenceOpMap = /* @__PURE__ */new Map();\n    this.templateCtxOpMap = /* @__PURE__ */new Map();\n    this.varMap = /* @__PURE__ */new Map();\n    this.statements = [];\n  }\n  static forNodes(tcb, parent, templateOrNodes, guard) {\n    const scope = new Scope(tcb, parent, guard);\n    if (parent === null && tcb.env.config.enableTemplateTypeChecker) {\n      scope.opQueue.push(new TcbComponentContextCompletionOp(scope));\n    }\n    let children;\n    if (templateOrNodes instanceof TmplAstTemplate2) {\n      const varMap = /* @__PURE__ */new Map();\n      for (const v of templateOrNodes.variables) {\n        if (!varMap.has(v.name)) {\n          varMap.set(v.name, v);\n        } else {\n          const firstDecl = varMap.get(v.name);\n          tcb.oobRecorder.duplicateTemplateVar(tcb.id, v, firstDecl);\n        }\n        const opIndex = scope.opQueue.push(new TcbVariableOp(tcb, scope, templateOrNodes, v)) - 1;\n        scope.varMap.set(v, opIndex);\n      }\n      children = templateOrNodes.children;\n    } else {\n      children = templateOrNodes;\n    }\n    for (const node of children) {\n      scope.appendNode(node);\n    }\n    return scope;\n  }\n  resolve(node, directive) {\n    const res = this.resolveLocal(node, directive);\n    if (res !== null) {\n      let clone;\n      if (ts23.isIdentifier(res)) {\n        clone = ts23.factory.createIdentifier(res.text);\n      } else if (ts23.isNonNullExpression(res)) {\n        clone = ts23.factory.createNonNullExpression(res.expression);\n      } else {\n        throw new Error(`Could not resolve ${node} to an Identifier or a NonNullExpression`);\n      }\n      ts23.setOriginalNode(clone, res);\n      clone.parent = clone.parent;\n      return ts23.setSyntheticTrailingComments(clone, []);\n    } else if (this.parent !== null) {\n      return this.parent.resolve(node, directive);\n    } else {\n      throw new Error(`Could not resolve ${node} / ${directive}`);\n    }\n  }\n  addStatement(stmt) {\n    this.statements.push(stmt);\n  }\n  render() {\n    for (let i = 0; i < this.opQueue.length; i++) {\n      const skipOptional = !this.tcb.env.config.enableTemplateTypeChecker;\n      this.executeOp(i, skipOptional);\n    }\n    return this.statements;\n  }\n  guards() {\n    let parentGuards = null;\n    if (this.parent !== null) {\n      parentGuards = this.parent.guards();\n    }\n    if (this.guard === null) {\n      return parentGuards;\n    } else if (parentGuards === null) {\n      return this.guard;\n    } else {\n      return ts23.factory.createBinaryExpression(parentGuards, ts23.SyntaxKind.AmpersandAmpersandToken, this.guard);\n    }\n  }\n  resolveLocal(ref, directive) {\n    if (ref instanceof TmplAstReference3 && this.referenceOpMap.has(ref)) {\n      return this.resolveOp(this.referenceOpMap.get(ref));\n    } else if (ref instanceof TmplAstVariable2 && this.varMap.has(ref)) {\n      return this.resolveOp(this.varMap.get(ref));\n    } else if (ref instanceof TmplAstTemplate2 && directive === void 0 && this.templateCtxOpMap.has(ref)) {\n      return this.resolveOp(this.templateCtxOpMap.get(ref));\n    } else if ((ref instanceof TmplAstElement3 || ref instanceof TmplAstTemplate2) && directive !== void 0 && this.directiveOpMap.has(ref)) {\n      const dirMap = this.directiveOpMap.get(ref);\n      if (dirMap.has(directive)) {\n        return this.resolveOp(dirMap.get(directive));\n      } else {\n        return null;\n      }\n    } else if (ref instanceof TmplAstElement3 && this.elementOpMap.has(ref)) {\n      return this.resolveOp(this.elementOpMap.get(ref));\n    } else {\n      return null;\n    }\n  }\n  resolveOp(opIndex) {\n    const res = this.executeOp(opIndex, false);\n    if (res === null) {\n      throw new Error(`Error resolving operation, got null`);\n    }\n    return res;\n  }\n  executeOp(opIndex, skipOptional) {\n    const op = this.opQueue[opIndex];\n    if (!(op instanceof TcbOp)) {\n      return op;\n    }\n    if (skipOptional && op.optional) {\n      return null;\n    }\n    this.opQueue[opIndex] = op.circularFallback();\n    const res = op.execute();\n    this.opQueue[opIndex] = res;\n    return res;\n  }\n  appendNode(node) {\n    if (node instanceof TmplAstElement3) {\n      const opIndex = this.opQueue.push(new TcbElementOp(this.tcb, this, node)) - 1;\n      this.elementOpMap.set(node, opIndex);\n      this.appendDirectivesAndInputsOfNode(node);\n      this.appendOutputsOfNode(node);\n      for (const child of node.children) {\n        this.appendNode(child);\n      }\n      this.checkAndAppendReferencesOfNode(node);\n    } else if (node instanceof TmplAstTemplate2) {\n      this.appendDirectivesAndInputsOfNode(node);\n      this.appendOutputsOfNode(node);\n      const ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;\n      this.templateCtxOpMap.set(node, ctxIndex);\n      if (this.tcb.env.config.checkTemplateBodies) {\n        this.opQueue.push(new TcbTemplateBodyOp(this.tcb, this, node));\n      } else if (this.tcb.env.config.alwaysCheckSchemaInTemplateBodies) {\n        this.appendDeepSchemaChecks(node.children);\n      }\n      this.checkAndAppendReferencesOfNode(node);\n    } else if (node instanceof TmplAstBoundText) {\n      this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, node));\n    } else if (node instanceof TmplAstIcu) {\n      this.appendIcuExpressions(node);\n    }\n  }\n  checkAndAppendReferencesOfNode(node) {\n    for (const ref of node.references) {\n      const target = this.tcb.boundTarget.getReferenceTarget(ref);\n      let ctxIndex;\n      if (target === null) {\n        this.tcb.oobRecorder.missingReferenceTarget(this.tcb.id, ref);\n        ctxIndex = this.opQueue.push(new TcbInvalidReferenceOp(this.tcb, this)) - 1;\n      } else if (target instanceof TmplAstTemplate2 || target instanceof TmplAstElement3) {\n        ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target)) - 1;\n      } else {\n        ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target.directive)) - 1;\n      }\n      this.referenceOpMap.set(ref, ctxIndex);\n    }\n  }\n  appendDirectivesAndInputsOfNode(node) {\n    const claimedInputs = /* @__PURE__ */new Set();\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n    if (directives === null || directives.length === 0) {\n      if (node instanceof TmplAstElement3) {\n        this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));\n        this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, true, claimedInputs));\n      }\n      return;\n    }\n    const dirMap = /* @__PURE__ */new Map();\n    for (const dir of directives) {\n      let directiveOp;\n      const host = this.tcb.env.reflector;\n      const dirRef = dir.ref;\n      if (!dir.isGeneric) {\n        directiveOp = new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);\n      } else if (!requiresInlineTypeCtor(dirRef.node, host, this.tcb.env) || this.tcb.env.config.useInlineTypeConstructors) {\n        directiveOp = new TcbDirectiveCtorOp(this.tcb, this, node, dir);\n      } else {\n        directiveOp = new TcbGenericDirectiveTypeWithAnyParamsOp(this.tcb, this, node, dir);\n      }\n      const dirIndex = this.opQueue.push(directiveOp) - 1;\n      dirMap.set(dir, dirIndex);\n      this.opQueue.push(new TcbDirectiveInputsOp(this.tcb, this, node, dir));\n    }\n    this.directiveOpMap.set(node, dirMap);\n    if (node instanceof TmplAstElement3) {\n      for (const dir of directives) {\n        for (const propertyName of dir.inputs.propertyNames) {\n          claimedInputs.add(propertyName);\n        }\n      }\n      this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));\n      const checkElement = directives.length === 0;\n      this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, checkElement, claimedInputs));\n    }\n  }\n  appendOutputsOfNode(node) {\n    const claimedOutputs = /* @__PURE__ */new Set();\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n    if (directives === null || directives.length === 0) {\n      if (node instanceof TmplAstElement3) {\n        this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n      }\n      return;\n    }\n    for (const dir of directives) {\n      this.opQueue.push(new TcbDirectiveOutputsOp(this.tcb, this, node, dir));\n    }\n    if (node instanceof TmplAstElement3) {\n      for (const dir of directives) {\n        for (const outputProperty of dir.outputs.propertyNames) {\n          claimedOutputs.add(outputProperty);\n        }\n      }\n      this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n    }\n  }\n  appendDeepSchemaChecks(nodes) {\n    for (const node of nodes) {\n      if (!(node instanceof TmplAstElement3 || node instanceof TmplAstTemplate2)) {\n        continue;\n      }\n      if (node instanceof TmplAstElement3) {\n        const claimedInputs = /* @__PURE__ */new Set();\n        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n        let hasDirectives;\n        if (directives === null || directives.length === 0) {\n          hasDirectives = false;\n        } else {\n          hasDirectives = true;\n          for (const dir of directives) {\n            for (const propertyName of dir.inputs.propertyNames) {\n              claimedInputs.add(propertyName);\n            }\n          }\n        }\n        this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, !hasDirectives, claimedInputs));\n      }\n      this.appendDeepSchemaChecks(node.children);\n    }\n  }\n  appendIcuExpressions(node) {\n    for (const variable of Object.values(node.vars)) {\n      this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, variable));\n    }\n    for (const placeholder of Object.values(node.placeholders)) {\n      if (placeholder instanceof TmplAstBoundText) {\n        this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, placeholder));\n      }\n    }\n  }\n};\nfunction tcbThisParam(name, typeArguments) {\n  return ts23.factory.createParameterDeclaration(void 0, void 0, \"this\", void 0, ts23.factory.createTypeReferenceNode(name, typeArguments), void 0);\n}\nfunction tcbExpression(ast, tcb, scope) {\n  const translator = new TcbExpressionTranslator(tcb, scope);\n  return translator.translate(ast);\n}\nvar TcbExpressionTranslator = class {\n  constructor(tcb, scope) {\n    this.tcb = tcb;\n    this.scope = scope;\n  }\n  translate(ast) {\n    return astToTypescript(ast, ast2 => this.resolve(ast2), this.tcb.env.config);\n  }\n  resolve(ast) {\n    if (ast instanceof PropertyRead4 && ast.receiver instanceof ImplicitReceiver4) {\n      return this.resolveTarget(ast);\n    } else if (ast instanceof PropertyWrite3 && ast.receiver instanceof ImplicitReceiver4) {\n      const target = this.resolveTarget(ast);\n      if (target === null) {\n        return null;\n      }\n      const expr = this.translate(ast.value);\n      const result = ts23.factory.createParenthesizedExpression(ts23.factory.createBinaryExpression(target, ts23.SyntaxKind.EqualsToken, expr));\n      addParseSpanInfo(result, ast.sourceSpan);\n      return result;\n    } else if (ast instanceof ImplicitReceiver4) {\n      return ts23.factory.createThis();\n    } else if (ast instanceof BindingPipe) {\n      const expr = this.translate(ast.exp);\n      const pipeRef = this.tcb.getPipeByName(ast.name);\n      let pipe;\n      if (pipeRef === null) {\n        this.tcb.oobRecorder.missingPipe(this.tcb.id, ast);\n        pipe = NULL_AS_ANY;\n      } else {\n        pipe = this.tcb.env.pipeInst(pipeRef);\n      }\n      const args = ast.args.map(arg => this.translate(arg));\n      let methodAccess = ts23.factory.createPropertyAccessExpression(pipe, \"transform\");\n      addParseSpanInfo(methodAccess, ast.nameSpan);\n      if (!this.tcb.env.config.checkTypeOfPipes) {\n        methodAccess = ts23.factory.createAsExpression(methodAccess, ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n      }\n      const result = ts23.factory.createCallExpression(methodAccess, void 0, [expr, ...args]);\n      addParseSpanInfo(result, ast.sourceSpan);\n      return result;\n    } else if ((ast instanceof Call2 || ast instanceof SafeCall) && (ast.receiver instanceof PropertyRead4 || ast.receiver instanceof SafePropertyRead3)) {\n      if (ast.receiver.receiver instanceof ImplicitReceiver4 && !(ast.receiver.receiver instanceof ThisReceiver) && ast.receiver.name === \"$any\" && ast.args.length === 1) {\n        const expr = this.translate(ast.args[0]);\n        const exprAsAny = ts23.factory.createAsExpression(expr, ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n        const result = ts23.factory.createParenthesizedExpression(exprAsAny);\n        addParseSpanInfo(result, ast.sourceSpan);\n        return result;\n      }\n      const receiver = this.resolveTarget(ast);\n      if (receiver === null) {\n        return null;\n      }\n      const method = wrapForDiagnostics(receiver);\n      addParseSpanInfo(method, ast.receiver.nameSpan);\n      const args = ast.args.map(arg => this.translate(arg));\n      const node = ts23.factory.createCallExpression(method, void 0, args);\n      addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    } else {\n      return null;\n    }\n  }\n  resolveTarget(ast) {\n    const binding = this.tcb.boundTarget.getExpressionTarget(ast);\n    if (binding === null) {\n      return null;\n    }\n    const expr = this.scope.resolve(binding);\n    addParseSpanInfo(expr, ast.sourceSpan);\n    return expr;\n  }\n};\nfunction tcbCallTypeCtor(dir, tcb, inputs) {\n  const typeCtor = tcb.env.typeCtorFor(dir);\n  const members = inputs.map(input => {\n    const propertyName = ts23.factory.createStringLiteral(input.field);\n    if (input.type === \"binding\") {\n      const expr = widenBinding(input.expression, tcb);\n      const assignment = ts23.factory.createPropertyAssignment(propertyName, wrapForDiagnostics(expr));\n      addParseSpanInfo(assignment, input.sourceSpan);\n      return assignment;\n    } else {\n      return ts23.factory.createPropertyAssignment(propertyName, NULL_AS_ANY);\n    }\n  });\n  return ts23.factory.createCallExpression(typeCtor, void 0, [ts23.factory.createObjectLiteralExpression(members)]);\n}\nfunction getBoundAttributes(directive, node) {\n  const boundInputs = [];\n  const processAttribute = attr => {\n    if (attr instanceof TmplAstBoundAttribute && attr.type !== 0) {\n      return;\n    }\n    const inputs = directive.inputs.getByBindingPropertyName(attr.name);\n    if (inputs !== null) {\n      boundInputs.push({\n        attribute: attr,\n        inputs: inputs.map(input => {\n          var _a;\n          return {\n            fieldName: input.classPropertyName,\n            required: input.required,\n            transformType: ((_a = input.transform) == null ? void 0 : _a.type) || null\n          };\n        })\n      });\n    }\n  };\n  node.inputs.forEach(processAttribute);\n  node.attributes.forEach(processAttribute);\n  if (node instanceof TmplAstTemplate2) {\n    node.templateAttrs.forEach(processAttribute);\n  }\n  return boundInputs;\n}\nfunction translateInput(attr, tcb, scope) {\n  if (attr instanceof TmplAstBoundAttribute) {\n    return tcbExpression(attr.value, tcb, scope);\n  } else {\n    return ts23.factory.createStringLiteral(attr.value);\n  }\n}\nfunction widenBinding(expr, tcb) {\n  if (!tcb.env.config.checkTypeOfInputBindings) {\n    return tsCastToAny(expr);\n  } else if (!tcb.env.config.strictNullInputBindings) {\n    if (ts23.isObjectLiteralExpression(expr) || ts23.isArrayLiteralExpression(expr)) {\n      return expr;\n    } else {\n      return ts23.factory.createNonNullExpression(expr);\n    }\n  } else {\n    return expr;\n  }\n}\nvar EVENT_PARAMETER = \"$event\";\nfunction tcbCreateEventHandler(event, tcb, scope, eventType) {\n  const handler = tcbEventHandlerExpression(event.handler, tcb, scope);\n  let eventParamType;\n  if (eventType === 0) {\n    eventParamType = void 0;\n  } else if (eventType === 1) {\n    eventParamType = ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword);\n  } else {\n    eventParamType = eventType;\n  }\n  const guards = scope.guards();\n  let body = ts23.factory.createExpressionStatement(handler);\n  if (guards !== null) {\n    body = ts23.factory.createIfStatement(guards, body);\n  }\n  const eventParam = ts23.factory.createParameterDeclaration(void 0, void 0, EVENT_PARAMETER, void 0, eventParamType);\n  addExpressionIdentifier(eventParam, ExpressionIdentifier.EVENT_PARAMETER);\n  return ts23.factory.createArrowFunction(void 0, void 0, [eventParam], ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword), void 0, ts23.factory.createBlock([body]));\n}\nfunction tcbEventHandlerExpression(ast, tcb, scope) {\n  const translator = new TcbEventHandlerTranslator(tcb, scope);\n  return translator.translate(ast);\n}\nfunction isSplitTwoWayBinding(inputName, output, inputs, tcb) {\n  const input = inputs.find(input2 => input2.name === inputName);\n  if (input === void 0 || input.sourceSpan !== output.sourceSpan) {\n    return false;\n  }\n  const inputConsumer = tcb.boundTarget.getConsumerOfBinding(input);\n  const outputConsumer = tcb.boundTarget.getConsumerOfBinding(output);\n  if (outputConsumer === null || inputConsumer.ref === void 0 || outputConsumer instanceof TmplAstTemplate2) {\n    return false;\n  }\n  if (outputConsumer instanceof TmplAstElement3) {\n    tcb.oobRecorder.splitTwoWayBinding(tcb.id, input, output, inputConsumer.ref.node, outputConsumer);\n    return true;\n  } else if (outputConsumer.ref !== inputConsumer.ref) {\n    tcb.oobRecorder.splitTwoWayBinding(tcb.id, input, output, inputConsumer.ref.node, outputConsumer.ref.node);\n    return true;\n  }\n  return false;\n}\nvar TcbEventHandlerTranslator = class extends TcbExpressionTranslator {\n  resolve(ast) {\n    if (ast instanceof PropertyRead4 && ast.receiver instanceof ImplicitReceiver4 && !(ast.receiver instanceof ThisReceiver) && ast.name === EVENT_PARAMETER) {\n      const event = ts23.factory.createIdentifier(EVENT_PARAMETER);\n      addParseSpanInfo(event, ast.nameSpan);\n      return event;\n    }\n    return super.resolve(ast);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_check_file.mjs\nimport ts24 from \"typescript\";\nvar TypeCheckFile = class extends Environment {\n  constructor(fileName, config, refEmitter, reflector, compilerHost) {\n    super(config, new ImportManager(new NoopImportRewriter(), \"i\"), refEmitter, reflector, ts24.createSourceFile(compilerHost.getCanonicalFileName(fileName), \"\", ts24.ScriptTarget.Latest, true));\n    this.fileName = fileName;\n    this.nextTcbId = 1;\n    this.tcbStatements = [];\n  }\n  addTypeCheckBlock(ref, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {\n    const fnId = ts24.factory.createIdentifier(`_tcb${this.nextTcbId++}`);\n    const fn = generateTypeCheckBlock(this, ref, fnId, meta, domSchemaChecker, oobRecorder, genericContextBehavior);\n    this.tcbStatements.push(fn);\n  }\n  render(removeComments) {\n    let source = this.importManager.getAllImports(this.contextFile.fileName).map(i => `import * as ${i.qualifier.text} from '${i.specifier}';`).join(\"\\n\") + \"\\n\\n\";\n    const printer = ts24.createPrinter({\n      removeComments\n    });\n    source += \"\\n\";\n    for (const stmt of this.pipeInstStatements) {\n      source += printer.printNode(ts24.EmitHint.Unspecified, stmt, this.contextFile) + \"\\n\";\n    }\n    for (const stmt of this.typeCtorStatements) {\n      source += printer.printNode(ts24.EmitHint.Unspecified, stmt, this.contextFile) + \"\\n\";\n    }\n    source += \"\\n\";\n    for (const stmt of this.tcbStatements) {\n      source += printer.printNode(ts24.EmitHint.Unspecified, stmt, this.contextFile) + \"\\n\";\n    }\n    source += \"\\nexport const IS_A_MODULE = true;\\n\";\n    return source;\n  }\n  getPreludeStatements() {\n    return [];\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/context.mjs\nvar InliningMode;\n(function (InliningMode2) {\n  InliningMode2[InliningMode2[\"InlineOps\"] = 0] = \"InlineOps\";\n  InliningMode2[InliningMode2[\"Error\"] = 1] = \"Error\";\n})(InliningMode || (InliningMode = {}));\nvar TypeCheckContextImpl = class {\n  constructor(config, compilerHost, refEmitter, reflector, host, inlining, perf) {\n    this.config = config;\n    this.compilerHost = compilerHost;\n    this.refEmitter = refEmitter;\n    this.reflector = reflector;\n    this.host = host;\n    this.inlining = inlining;\n    this.perf = perf;\n    this.fileMap = /* @__PURE__ */new Map();\n    this.opMap = /* @__PURE__ */new Map();\n    this.typeCtorPending = /* @__PURE__ */new Set();\n    if (inlining === InliningMode.Error && config.useInlineTypeConstructors) {\n      throw new Error(`AssertionError: invalid inlining configuration.`);\n    }\n  }\n  addTemplate(ref, binder, template, pipes, schemas, sourceMapping, file, parseErrors, isStandalone) {\n    if (!this.host.shouldCheckComponent(ref.node)) {\n      return;\n    }\n    const fileData = this.dataForFile(ref.node.getSourceFile());\n    const shimData = this.pendingShimForComponent(ref.node);\n    const templateId = fileData.sourceManager.getTemplateId(ref.node);\n    const templateDiagnostics = [];\n    if (parseErrors !== null) {\n      templateDiagnostics.push(...this.getTemplateDiagnostics(parseErrors, templateId, sourceMapping));\n    }\n    const boundTarget = binder.bind({\n      template\n    });\n    if (this.inlining === InliningMode.InlineOps) {\n      for (const dir of boundTarget.getUsedDirectives()) {\n        const dirRef = dir.ref;\n        const dirNode = dirRef.node;\n        if (!dir.isGeneric || !requiresInlineTypeCtor(dirNode, this.reflector, shimData.file)) {\n          continue;\n        }\n        this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {\n          fnName: \"ngTypeCtor\",\n          body: !dirNode.getSourceFile().isDeclarationFile,\n          fields: {\n            inputs: dir.inputs,\n            queries: dir.queries\n          },\n          coercedInputFields: dir.coercedInputFields\n        });\n      }\n    }\n    shimData.templates.set(templateId, {\n      template,\n      boundTarget,\n      templateDiagnostics\n    });\n    const usedPipes = [];\n    for (const name of boundTarget.getUsedPipes()) {\n      if (!pipes.has(name)) {\n        continue;\n      }\n      usedPipes.push(pipes.get(name));\n    }\n    const inliningRequirement = requiresInlineTypeCheckBlock(ref, shimData.file, usedPipes, this.reflector);\n    if (this.inlining === InliningMode.Error && inliningRequirement === TcbInliningRequirement.MustInline) {\n      shimData.oobRecorder.requiresInlineTcb(templateId, ref.node);\n      this.perf.eventCount(PerfEvent.SkipGenerateTcbNoInline);\n      return;\n    }\n    const meta = {\n      id: fileData.sourceManager.captureSource(ref.node, sourceMapping, file),\n      boundTarget,\n      pipes,\n      schemas,\n      isStandalone\n    };\n    this.perf.eventCount(PerfEvent.GenerateTcb);\n    if (inliningRequirement !== TcbInliningRequirement.None && this.inlining === InliningMode.InlineOps) {\n      this.addInlineTypeCheckBlock(fileData, shimData, ref, meta);\n    } else if (inliningRequirement === TcbInliningRequirement.ShouldInlineForGenericBounds && this.inlining === InliningMode.Error) {\n      shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, TcbGenericContextBehavior.FallbackToAny);\n    } else {\n      shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, TcbGenericContextBehavior.UseEmitter);\n    }\n  }\n  addInlineTypeCtor(fileData, sf, ref, ctorMeta) {\n    if (this.typeCtorPending.has(ref.node)) {\n      return;\n    }\n    this.typeCtorPending.add(ref.node);\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf);\n    ops.push(new TypeCtorOp(ref, ctorMeta));\n    fileData.hasInlines = true;\n  }\n  transform(sf) {\n    if (!this.opMap.has(sf)) {\n      return null;\n    }\n    const importManager = new ImportManager(new NoopImportRewriter(), \"_i\");\n    const ops = this.opMap.get(sf).sort(orderOps);\n    const textParts = splitStringAtPoints(sf.text, ops.map(op => op.splitPoint));\n    const printer = ts25.createPrinter({\n      omitTrailingSemicolon: true\n    });\n    let code = textParts[0];\n    ops.forEach((op, idx) => {\n      const text = op.execute(importManager, sf, this.refEmitter, printer);\n      code += \"\\n\\n\" + text + textParts[idx + 1];\n    });\n    let imports = importManager.getAllImports(sf.fileName).map(i => `import * as ${i.qualifier.text} from '${i.specifier}';`).join(\"\\n\");\n    code = imports + \"\\n\" + code;\n    return code;\n  }\n  finalize() {\n    const updates = /* @__PURE__ */new Map();\n    for (const originalSf of this.opMap.keys()) {\n      const newText = this.transform(originalSf);\n      if (newText !== null) {\n        updates.set(absoluteFromSourceFile(originalSf), {\n          newText,\n          originalFile: originalSf\n        });\n      }\n    }\n    for (const [sfPath, pendingFileData] of this.fileMap) {\n      for (const pendingShimData of pendingFileData.shimData.values()) {\n        this.host.recordShimData(sfPath, {\n          genesisDiagnostics: [...pendingShimData.domSchemaChecker.diagnostics, ...pendingShimData.oobRecorder.diagnostics],\n          hasInlines: pendingFileData.hasInlines,\n          path: pendingShimData.file.fileName,\n          templates: pendingShimData.templates\n        });\n        const sfText = pendingShimData.file.render(false);\n        updates.set(pendingShimData.file.fileName, {\n          newText: sfText,\n          originalFile: null\n        });\n      }\n    }\n    return updates;\n  }\n  addInlineTypeCheckBlock(fileData, shimData, ref, tcbMeta) {\n    const sf = ref.node.getSourceFile();\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf);\n    ops.push(new InlineTcbOp(ref, tcbMeta, this.config, this.reflector, shimData.domSchemaChecker, shimData.oobRecorder));\n    fileData.hasInlines = true;\n  }\n  pendingShimForComponent(node) {\n    const fileData = this.dataForFile(node.getSourceFile());\n    const shimPath = TypeCheckShimGenerator.shimFor(absoluteFromSourceFile(node.getSourceFile()));\n    if (!fileData.shimData.has(shimPath)) {\n      fileData.shimData.set(shimPath, {\n        domSchemaChecker: new RegistryDomSchemaChecker(fileData.sourceManager),\n        oobRecorder: new OutOfBandDiagnosticRecorderImpl(fileData.sourceManager),\n        file: new TypeCheckFile(shimPath, this.config, this.refEmitter, this.reflector, this.compilerHost),\n        templates: /* @__PURE__ */new Map()\n      });\n    }\n    return fileData.shimData.get(shimPath);\n  }\n  dataForFile(sf) {\n    const sfPath = absoluteFromSourceFile(sf);\n    if (!this.fileMap.has(sfPath)) {\n      const data = {\n        hasInlines: false,\n        sourceManager: this.host.getSourceManager(sfPath),\n        shimData: /* @__PURE__ */new Map()\n      };\n      this.fileMap.set(sfPath, data);\n    }\n    return this.fileMap.get(sfPath);\n  }\n  getTemplateDiagnostics(parseErrors, templateId, sourceMapping) {\n    return parseErrors.map(error => {\n      const span = error.span;\n      if (span.start.offset === span.end.offset) {\n        span.end.offset++;\n      }\n      return makeTemplateDiagnostic(templateId, sourceMapping, span, ts25.DiagnosticCategory.Error, ngErrorCode(ErrorCode.TEMPLATE_PARSE_ERROR), error.msg);\n    });\n  }\n};\nvar InlineTcbOp = class {\n  constructor(ref, meta, config, reflector, domSchemaChecker, oobRecorder) {\n    this.ref = ref;\n    this.meta = meta;\n    this.config = config;\n    this.reflector = reflector;\n    this.domSchemaChecker = domSchemaChecker;\n    this.oobRecorder = oobRecorder;\n  }\n  get splitPoint() {\n    return this.ref.node.end + 1;\n  }\n  execute(im, sf, refEmitter, printer) {\n    const env = new Environment(this.config, im, refEmitter, this.reflector, sf);\n    const fnName = ts25.factory.createIdentifier(`_tcb_${this.ref.node.pos}`);\n    const fn = generateTypeCheckBlock(env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder, TcbGenericContextBehavior.CopyClassNodes);\n    return printer.printNode(ts25.EmitHint.Unspecified, fn, sf);\n  }\n};\nvar TypeCtorOp = class {\n  constructor(ref, meta) {\n    this.ref = ref;\n    this.meta = meta;\n  }\n  get splitPoint() {\n    return this.ref.node.end - 1;\n  }\n  execute(im, sf, refEmitter, printer) {\n    const tcb = generateInlineTypeCtor(this.ref.node, this.meta);\n    return printer.printNode(ts25.EmitHint.Unspecified, tcb, sf);\n  }\n};\nfunction orderOps(op1, op2) {\n  return op1.splitPoint - op2.splitPoint;\n}\nfunction splitStringAtPoints(str, points) {\n  const splits = [];\n  let start = 0;\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    splits.push(str.substring(start, point));\n    start = point;\n  }\n  splits.push(str.substring(start));\n  return splits;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/source.mjs\nimport { ParseLocation, ParseSourceSpan } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/line_mappings.mjs\nvar LF_CHAR = 10;\nvar CR_CHAR = 13;\nvar LINE_SEP_CHAR = 8232;\nvar PARAGRAPH_CHAR = 8233;\nfunction getLineAndCharacterFromPosition(lineStartsMap, position) {\n  const lineIndex = findClosestLineStartPosition(lineStartsMap, position);\n  return {\n    character: position - lineStartsMap[lineIndex],\n    line: lineIndex\n  };\n}\nfunction computeLineStartsMap(text) {\n  const result = [0];\n  let pos = 0;\n  while (pos < text.length) {\n    const char = text.charCodeAt(pos++);\n    if (char === CR_CHAR) {\n      if (text.charCodeAt(pos) === LF_CHAR) {\n        pos++;\n      }\n      result.push(pos);\n    } else if (char === LF_CHAR || char === LINE_SEP_CHAR || char === PARAGRAPH_CHAR) {\n      result.push(pos);\n    }\n  }\n  result.push(pos);\n  return result;\n}\nfunction findClosestLineStartPosition(linesMap, position, low = 0, high = linesMap.length - 1) {\n  while (low <= high) {\n    const pivotIdx = Math.floor((low + high) / 2);\n    const pivotEl = linesMap[pivotIdx];\n    if (pivotEl === position) {\n      return pivotIdx;\n    } else if (position > pivotEl) {\n      low = pivotIdx + 1;\n    } else {\n      high = pivotIdx - 1;\n    }\n  }\n  return low - 1;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/source.mjs\nvar TemplateSource = class {\n  constructor(mapping, file) {\n    this.mapping = mapping;\n    this.file = file;\n    this.lineStarts = null;\n  }\n  toParseSourceSpan(start, end) {\n    const startLoc = this.toParseLocation(start);\n    const endLoc = this.toParseLocation(end);\n    return new ParseSourceSpan(startLoc, endLoc);\n  }\n  toParseLocation(position) {\n    const lineStarts = this.acquireLineStarts();\n    const {\n      line,\n      character\n    } = getLineAndCharacterFromPosition(lineStarts, position);\n    return new ParseLocation(this.file, position, line, character);\n  }\n  acquireLineStarts() {\n    if (this.lineStarts === null) {\n      this.lineStarts = computeLineStartsMap(this.file.content);\n    }\n    return this.lineStarts;\n  }\n};\nvar TemplateSourceManager = class {\n  constructor() {\n    this.templateSources = /* @__PURE__ */new Map();\n  }\n  getTemplateId(node) {\n    return getTemplateId(node);\n  }\n  captureSource(node, mapping, file) {\n    const id = getTemplateId(node);\n    this.templateSources.set(id, new TemplateSource(mapping, file));\n    return id;\n  }\n  getSourceMapping(id) {\n    if (!this.templateSources.has(id)) {\n      throw new Error(`Unexpected unknown template ID: ${id}`);\n    }\n    return this.templateSources.get(id).mapping;\n  }\n  toParseSourceSpan(id, span) {\n    if (!this.templateSources.has(id)) {\n      return null;\n    }\n    const templateSource = this.templateSources.get(id);\n    return templateSource.toParseSourceSpan(span.start, span.end);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.mjs\nimport { AST, ASTWithSource as ASTWithSource3, BindingPipe as BindingPipe2, PropertyRead as PropertyRead5, PropertyWrite as PropertyWrite4, SafePropertyRead as SafePropertyRead4, TmplAstBoundAttribute as TmplAstBoundAttribute2, TmplAstBoundEvent, TmplAstElement as TmplAstElement4, TmplAstReference as TmplAstReference4, TmplAstTemplate as TmplAstTemplate3, TmplAstTextAttribute as TmplAstTextAttribute3, TmplAstVariable as TmplAstVariable3 } from \"@angular/compiler\";\nimport ts26 from \"typescript\";\nvar SymbolBuilder = class {\n  constructor(tcbPath, tcbIsShim, typeCheckBlock, templateData, componentScopeReader, getTypeChecker) {\n    this.tcbPath = tcbPath;\n    this.tcbIsShim = tcbIsShim;\n    this.typeCheckBlock = typeCheckBlock;\n    this.templateData = templateData;\n    this.componentScopeReader = componentScopeReader;\n    this.getTypeChecker = getTypeChecker;\n    this.symbolCache = /* @__PURE__ */new Map();\n  }\n  getSymbol(node) {\n    if (this.symbolCache.has(node)) {\n      return this.symbolCache.get(node);\n    }\n    let symbol = null;\n    if (node instanceof TmplAstBoundAttribute2 || node instanceof TmplAstTextAttribute3) {\n      symbol = this.getSymbolOfInputBinding(node);\n    } else if (node instanceof TmplAstBoundEvent) {\n      symbol = this.getSymbolOfBoundEvent(node);\n    } else if (node instanceof TmplAstElement4) {\n      symbol = this.getSymbolOfElement(node);\n    } else if (node instanceof TmplAstTemplate3) {\n      symbol = this.getSymbolOfAstTemplate(node);\n    } else if (node instanceof TmplAstVariable3) {\n      symbol = this.getSymbolOfVariable(node);\n    } else if (node instanceof TmplAstReference4) {\n      symbol = this.getSymbolOfReference(node);\n    } else if (node instanceof BindingPipe2) {\n      symbol = this.getSymbolOfPipe(node);\n    } else if (node instanceof AST) {\n      symbol = this.getSymbolOfTemplateExpression(node);\n    } else {}\n    this.symbolCache.set(node, symbol);\n    return symbol;\n  }\n  getSymbolOfAstTemplate(template) {\n    const directives = this.getDirectivesOfNode(template);\n    return {\n      kind: SymbolKind.Template,\n      directives,\n      templateNode: template\n    };\n  }\n  getSymbolOfElement(element) {\n    var _a;\n    const elementSourceSpan = (_a = element.startSourceSpan) != null ? _a : element.sourceSpan;\n    const node = findFirstMatchingNode(this.typeCheckBlock, {\n      withSpan: elementSourceSpan,\n      filter: ts26.isVariableDeclaration\n    });\n    if (node === null) {\n      return null;\n    }\n    const symbolFromDeclaration = this.getSymbolOfTsNode(node);\n    if (symbolFromDeclaration === null || symbolFromDeclaration.tsSymbol === null) {\n      return null;\n    }\n    const directives = this.getDirectivesOfNode(element);\n    return {\n      ...symbolFromDeclaration,\n      kind: SymbolKind.Element,\n      directives,\n      templateNode: element\n    };\n  }\n  getDirectivesOfNode(element) {\n    var _a;\n    const elementSourceSpan = (_a = element.startSourceSpan) != null ? _a : element.sourceSpan;\n    const tcbSourceFile = this.typeCheckBlock.getSourceFile();\n    const isDirectiveDeclaration = node => (ts26.isTypeNode(node) || ts26.isIdentifier(node)) && ts26.isVariableDeclaration(node.parent) && hasExpressionIdentifier(tcbSourceFile, node, ExpressionIdentifier.DIRECTIVE);\n    const nodes = findAllMatchingNodes(this.typeCheckBlock, {\n      withSpan: elementSourceSpan,\n      filter: isDirectiveDeclaration\n    });\n    const symbols = [];\n    for (const node of nodes) {\n      const symbol = this.getSymbolOfTsNode(node.parent);\n      if (symbol === null || !isSymbolWithValueDeclaration(symbol.tsSymbol) || !ts26.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n        continue;\n      }\n      const meta = this.getDirectiveMeta(element, symbol.tsSymbol.valueDeclaration);\n      if (meta !== null && meta.selector !== null) {\n        const ref = new Reference(symbol.tsSymbol.valueDeclaration);\n        if (meta.hostDirectives !== null) {\n          this.addHostDirectiveSymbols(element, meta.hostDirectives, symbols);\n        }\n        const directiveSymbol = {\n          ...symbol,\n          ref,\n          tsSymbol: symbol.tsSymbol,\n          selector: meta.selector,\n          isComponent: meta.isComponent,\n          ngModule: this.getDirectiveModule(symbol.tsSymbol.valueDeclaration),\n          kind: SymbolKind.Directive,\n          isStructural: meta.isStructural,\n          isInScope: true,\n          isHostDirective: false\n        };\n        symbols.push(directiveSymbol);\n      }\n    }\n    return symbols;\n  }\n  addHostDirectiveSymbols(host, hostDirectives, symbols) {\n    for (const current of hostDirectives) {\n      if (!ts26.isClassDeclaration(current.directive.node)) {\n        continue;\n      }\n      const symbol = this.getSymbolOfTsNode(current.directive.node);\n      const meta = this.getDirectiveMeta(host, current.directive.node);\n      if (meta !== null && symbol !== null && isSymbolWithValueDeclaration(symbol.tsSymbol)) {\n        if (meta.hostDirectives !== null) {\n          this.addHostDirectiveSymbols(host, meta.hostDirectives, symbols);\n        }\n        const directiveSymbol = {\n          ...symbol,\n          isHostDirective: true,\n          ref: current.directive,\n          tsSymbol: symbol.tsSymbol,\n          exposedInputs: current.inputs,\n          exposedOutputs: current.outputs,\n          selector: meta.selector,\n          isComponent: meta.isComponent,\n          ngModule: this.getDirectiveModule(current.directive.node),\n          kind: SymbolKind.Directive,\n          isStructural: meta.isStructural,\n          isInScope: true\n        };\n        symbols.push(directiveSymbol);\n      }\n    }\n  }\n  getDirectiveMeta(host, directiveDeclaration) {\n    var _a;\n    let directives = this.templateData.boundTarget.getDirectivesOfNode(host);\n    const firstChild = host.children[0];\n    if (firstChild instanceof TmplAstElement4) {\n      const isMicrosyntaxTemplate = host instanceof TmplAstTemplate3 && sourceSpanEqual(firstChild.sourceSpan, host.sourceSpan);\n      if (isMicrosyntaxTemplate) {\n        const firstChildDirectives = this.templateData.boundTarget.getDirectivesOfNode(firstChild);\n        if (firstChildDirectives !== null && directives !== null) {\n          directives = directives.concat(firstChildDirectives);\n        } else {\n          directives = directives != null ? directives : firstChildDirectives;\n        }\n      }\n    }\n    if (directives === null) {\n      return null;\n    }\n    return (_a = directives.find(m => m.ref.node === directiveDeclaration)) != null ? _a : null;\n  }\n  getDirectiveModule(declaration) {\n    const scope = this.componentScopeReader.getScopeForComponent(declaration);\n    if (scope === null || scope.kind !== ComponentScopeKind.NgModule) {\n      return null;\n    }\n    return scope.ngModule;\n  }\n  getSymbolOfBoundEvent(eventBinding) {\n    const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n    if (consumer === null) {\n      return null;\n    }\n    let expectedAccess;\n    if (consumer instanceof TmplAstTemplate3 || consumer instanceof TmplAstElement4) {\n      expectedAccess = \"addEventListener\";\n    } else {\n      const bindingPropertyNames = consumer.outputs.getByBindingPropertyName(eventBinding.name);\n      if (bindingPropertyNames === null || bindingPropertyNames.length === 0) {\n        return null;\n      }\n      expectedAccess = bindingPropertyNames[0].classPropertyName;\n    }\n    function filter(n) {\n      if (!isAccessExpression(n)) {\n        return false;\n      }\n      if (ts26.isPropertyAccessExpression(n)) {\n        return n.name.getText() === expectedAccess;\n      } else {\n        return ts26.isStringLiteral(n.argumentExpression) && n.argumentExpression.text === expectedAccess;\n      }\n    }\n    const outputFieldAccesses = findAllMatchingNodes(this.typeCheckBlock, {\n      withSpan: eventBinding.keySpan,\n      filter\n    });\n    const bindings = [];\n    for (const outputFieldAccess of outputFieldAccesses) {\n      if (consumer instanceof TmplAstTemplate3 || consumer instanceof TmplAstElement4) {\n        if (!ts26.isPropertyAccessExpression(outputFieldAccess)) {\n          continue;\n        }\n        const addEventListener = outputFieldAccess.name;\n        const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);\n        const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);\n        const positionInFile = this.getTcbPositionForNode(addEventListener);\n        const target = this.getSymbol(consumer);\n        if (target === null || tsSymbol === void 0) {\n          continue;\n        }\n        bindings.push({\n          kind: SymbolKind.Binding,\n          tsSymbol,\n          tsType,\n          target,\n          tcbLocation: {\n            tcbPath: this.tcbPath,\n            isShimFile: this.tcbIsShim,\n            positionInFile\n          }\n        });\n      } else {\n        if (!ts26.isElementAccessExpression(outputFieldAccess)) {\n          continue;\n        }\n        const tsSymbol = this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n        if (tsSymbol === void 0) {\n          continue;\n        }\n        const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n        if (target === null) {\n          continue;\n        }\n        const positionInFile = this.getTcbPositionForNode(outputFieldAccess);\n        const tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);\n        bindings.push({\n          kind: SymbolKind.Binding,\n          tsSymbol,\n          tsType,\n          target,\n          tcbLocation: {\n            tcbPath: this.tcbPath,\n            isShimFile: this.tcbIsShim,\n            positionInFile\n          }\n        });\n      }\n    }\n    if (bindings.length === 0) {\n      return null;\n    }\n    return {\n      kind: SymbolKind.Output,\n      bindings\n    };\n  }\n  getSymbolOfInputBinding(binding) {\n    const consumer = this.templateData.boundTarget.getConsumerOfBinding(binding);\n    if (consumer === null) {\n      return null;\n    }\n    if (consumer instanceof TmplAstElement4 || consumer instanceof TmplAstTemplate3) {\n      const host = this.getSymbol(consumer);\n      return host !== null ? {\n        kind: SymbolKind.DomBinding,\n        host\n      } : null;\n    }\n    const nodes = findAllMatchingNodes(this.typeCheckBlock, {\n      withSpan: binding.sourceSpan,\n      filter: isAssignment\n    });\n    const bindings = [];\n    for (const node of nodes) {\n      if (!isAccessExpression(node.left)) {\n        continue;\n      }\n      const symbolInfo = this.getSymbolOfTsNode(node.left);\n      if (symbolInfo === null || symbolInfo.tsSymbol === null) {\n        continue;\n      }\n      const target = this.getDirectiveSymbolForAccessExpression(node.left, consumer);\n      if (target === null) {\n        continue;\n      }\n      bindings.push({\n        ...symbolInfo,\n        tsSymbol: symbolInfo.tsSymbol,\n        kind: SymbolKind.Binding,\n        target\n      });\n    }\n    if (bindings.length === 0) {\n      return null;\n    }\n    return {\n      kind: SymbolKind.Input,\n      bindings\n    };\n  }\n  getDirectiveSymbolForAccessExpression(node, {\n    isComponent,\n    selector,\n    isStructural\n  }) {\n    var _a;\n    const tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.expression);\n    if ((tsSymbol == null ? void 0 : tsSymbol.declarations) === void 0 || tsSymbol.declarations.length === 0 || selector === null) {\n      return null;\n    }\n    const [declaration] = tsSymbol.declarations;\n    if (!ts26.isVariableDeclaration(declaration) || !hasExpressionIdentifier(declaration.getSourceFile(), (_a = declaration.type) != null ? _a : declaration.name, ExpressionIdentifier.DIRECTIVE)) {\n      return null;\n    }\n    const symbol = this.getSymbolOfTsNode(declaration);\n    if (symbol === null || !isSymbolWithValueDeclaration(symbol.tsSymbol) || !ts26.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n      return null;\n    }\n    const ref = new Reference(symbol.tsSymbol.valueDeclaration);\n    const ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);\n    return {\n      ref,\n      kind: SymbolKind.Directive,\n      tsSymbol: symbol.tsSymbol,\n      tsType: symbol.tsType,\n      tcbLocation: symbol.tcbLocation,\n      isComponent,\n      isStructural,\n      selector,\n      ngModule,\n      isHostDirective: false,\n      isInScope: true\n    };\n  }\n  getSymbolOfVariable(variable) {\n    const node = findFirstMatchingNode(this.typeCheckBlock, {\n      withSpan: variable.sourceSpan,\n      filter: ts26.isVariableDeclaration\n    });\n    if (node === null || node.initializer === void 0) {\n      return null;\n    }\n    const expressionSymbol = this.getSymbolOfTsNode(node.initializer);\n    if (expressionSymbol === null) {\n      return null;\n    }\n    return {\n      tsType: expressionSymbol.tsType,\n      tsSymbol: expressionSymbol.tsSymbol,\n      initializerLocation: expressionSymbol.tcbLocation,\n      kind: SymbolKind.Variable,\n      declaration: variable,\n      localVarLocation: {\n        tcbPath: this.tcbPath,\n        isShimFile: this.tcbIsShim,\n        positionInFile: this.getTcbPositionForNode(node.name)\n      }\n    };\n  }\n  getSymbolOfReference(ref) {\n    const target = this.templateData.boundTarget.getReferenceTarget(ref);\n    let node = findFirstMatchingNode(this.typeCheckBlock, {\n      withSpan: ref.sourceSpan,\n      filter: ts26.isVariableDeclaration\n    });\n    if (node === null || target === null || node.initializer === void 0) {\n      return null;\n    }\n    const originalDeclaration = ts26.isParenthesizedExpression(node.initializer) && ts26.isAsExpression(node.initializer.expression) ? this.getTypeChecker().getSymbolAtLocation(node.name) : this.getTypeChecker().getSymbolAtLocation(node.initializer);\n    if (originalDeclaration === void 0 || originalDeclaration.valueDeclaration === void 0) {\n      return null;\n    }\n    const symbol = this.getSymbolOfTsNode(originalDeclaration.valueDeclaration);\n    if (symbol === null || symbol.tsSymbol === null) {\n      return null;\n    }\n    const referenceVarTcbLocation = {\n      tcbPath: this.tcbPath,\n      isShimFile: this.tcbIsShim,\n      positionInFile: this.getTcbPositionForNode(node)\n    };\n    if (target instanceof TmplAstTemplate3 || target instanceof TmplAstElement4) {\n      return {\n        kind: SymbolKind.Reference,\n        tsSymbol: symbol.tsSymbol,\n        tsType: symbol.tsType,\n        target,\n        declaration: ref,\n        targetLocation: symbol.tcbLocation,\n        referenceVarLocation: referenceVarTcbLocation\n      };\n    } else {\n      if (!ts26.isClassDeclaration(target.directive.ref.node)) {\n        return null;\n      }\n      return {\n        kind: SymbolKind.Reference,\n        tsSymbol: symbol.tsSymbol,\n        tsType: symbol.tsType,\n        declaration: ref,\n        target: target.directive.ref.node,\n        targetLocation: symbol.tcbLocation,\n        referenceVarLocation: referenceVarTcbLocation\n      };\n    }\n  }\n  getSymbolOfPipe(expression) {\n    const methodAccess = findFirstMatchingNode(this.typeCheckBlock, {\n      withSpan: expression.nameSpan,\n      filter: ts26.isPropertyAccessExpression\n    });\n    if (methodAccess === null) {\n      return null;\n    }\n    const pipeVariableNode = methodAccess.expression;\n    const pipeDeclaration = this.getTypeChecker().getSymbolAtLocation(pipeVariableNode);\n    if (pipeDeclaration === void 0 || pipeDeclaration.valueDeclaration === void 0) {\n      return null;\n    }\n    const pipeInstance = this.getSymbolOfTsNode(pipeDeclaration.valueDeclaration);\n    if (pipeInstance === null || !isSymbolWithValueDeclaration(pipeInstance.tsSymbol)) {\n      return null;\n    }\n    const symbolInfo = this.getSymbolOfTsNode(methodAccess);\n    if (symbolInfo === null) {\n      return null;\n    }\n    return {\n      kind: SymbolKind.Pipe,\n      ...symbolInfo,\n      classSymbol: {\n        ...pipeInstance,\n        tsSymbol: pipeInstance.tsSymbol\n      }\n    };\n  }\n  getSymbolOfTemplateExpression(expression) {\n    if (expression instanceof ASTWithSource3) {\n      expression = expression.ast;\n    }\n    const expressionTarget = this.templateData.boundTarget.getExpressionTarget(expression);\n    if (expressionTarget !== null) {\n      return this.getSymbol(expressionTarget);\n    }\n    let withSpan = expression.sourceSpan;\n    if (expression instanceof PropertyWrite4) {\n      withSpan = expression.nameSpan;\n    }\n    let node = null;\n    if (expression instanceof PropertyRead5) {\n      node = findFirstMatchingNode(this.typeCheckBlock, {\n        withSpan,\n        filter: ts26.isPropertyAccessExpression\n      });\n    }\n    if (node === null) {\n      node = findFirstMatchingNode(this.typeCheckBlock, {\n        withSpan,\n        filter: anyNodeFilter\n      });\n    }\n    if (node === null) {\n      return null;\n    }\n    while (ts26.isParenthesizedExpression(node)) {\n      node = node.expression;\n    }\n    if (expression instanceof SafePropertyRead4 && ts26.isConditionalExpression(node)) {\n      const whenTrueSymbol = this.getSymbolOfTsNode(node.whenTrue);\n      if (whenTrueSymbol === null) {\n        return null;\n      }\n      return {\n        ...whenTrueSymbol,\n        kind: SymbolKind.Expression,\n        tsType: this.getTypeChecker().getTypeAtLocation(node)\n      };\n    } else {\n      const symbolInfo = this.getSymbolOfTsNode(node);\n      return symbolInfo === null ? null : {\n        ...symbolInfo,\n        kind: SymbolKind.Expression\n      };\n    }\n  }\n  getSymbolOfTsNode(node) {\n    var _a;\n    while (ts26.isParenthesizedExpression(node)) {\n      node = node.expression;\n    }\n    let tsSymbol;\n    if (ts26.isPropertyAccessExpression(node)) {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.name);\n    } else if (ts26.isElementAccessExpression(node)) {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.argumentExpression);\n    } else {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node);\n    }\n    const positionInFile = this.getTcbPositionForNode(node);\n    const type = this.getTypeChecker().getTypeAtLocation(node);\n    return {\n      tsSymbol: (_a = tsSymbol != null ? tsSymbol : type.symbol) != null ? _a : null,\n      tsType: type,\n      tcbLocation: {\n        tcbPath: this.tcbPath,\n        isShimFile: this.tcbIsShim,\n        positionInFile\n      }\n    };\n  }\n  getTcbPositionForNode(node) {\n    if (ts26.isTypeReferenceNode(node)) {\n      return this.getTcbPositionForNode(node.typeName);\n    } else if (ts26.isQualifiedName(node)) {\n      return node.right.getStart();\n    } else if (ts26.isPropertyAccessExpression(node)) {\n      return node.name.getStart();\n    } else if (ts26.isElementAccessExpression(node)) {\n      return node.argumentExpression.getStart();\n    } else {\n      return node.getStart();\n    }\n  }\n};\nfunction anyNodeFilter(n) {\n  return true;\n}\nfunction sourceSpanEqual(a, b) {\n  return a.start.offset === b.start.offset && a.end.offset === b.end.offset;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/checker.mjs\nvar REGISTRY2 = new DomElementSchemaRegistry2();\nvar TemplateTypeCheckerImpl = class {\n  constructor(originalProgram, programDriver, typeCheckAdapter, config, refEmitter, reflector, compilerHost, priorBuild, metaReader, localMetaReader, ngModuleIndex, componentScopeReader, typeCheckScopeRegistry, perf) {\n    this.originalProgram = originalProgram;\n    this.programDriver = programDriver;\n    this.typeCheckAdapter = typeCheckAdapter;\n    this.config = config;\n    this.refEmitter = refEmitter;\n    this.reflector = reflector;\n    this.compilerHost = compilerHost;\n    this.priorBuild = priorBuild;\n    this.metaReader = metaReader;\n    this.localMetaReader = localMetaReader;\n    this.ngModuleIndex = ngModuleIndex;\n    this.componentScopeReader = componentScopeReader;\n    this.typeCheckScopeRegistry = typeCheckScopeRegistry;\n    this.perf = perf;\n    this.state = /* @__PURE__ */new Map();\n    this.completionCache = /* @__PURE__ */new Map();\n    this.symbolBuilderCache = /* @__PURE__ */new Map();\n    this.scopeCache = /* @__PURE__ */new Map();\n    this.elementTagCache = /* @__PURE__ */new Map();\n    this.isComplete = false;\n  }\n  getTemplate(component) {\n    const {\n      data\n    } = this.getLatestComponentState(component);\n    if (data === null) {\n      return null;\n    }\n    return data.template;\n  }\n  getUsedDirectives(component) {\n    var _a;\n    return ((_a = this.getLatestComponentState(component).data) == null ? void 0 : _a.boundTarget.getUsedDirectives()) || null;\n  }\n  getUsedPipes(component) {\n    var _a;\n    return ((_a = this.getLatestComponentState(component).data) == null ? void 0 : _a.boundTarget.getUsedPipes()) || null;\n  }\n  getLatestComponentState(component) {\n    this.ensureShimForComponent(component);\n    const sf = component.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    const fileRecord = this.getFileData(sfPath);\n    if (!fileRecord.shimData.has(shimPath)) {\n      return {\n        data: null,\n        tcb: null,\n        tcbPath: shimPath,\n        tcbIsShim: true\n      };\n    }\n    const templateId = fileRecord.sourceManager.getTemplateId(component);\n    const shimRecord = fileRecord.shimData.get(shimPath);\n    const id = fileRecord.sourceManager.getTemplateId(component);\n    const program = this.programDriver.getProgram();\n    const shimSf = getSourceFileOrNull(program, shimPath);\n    if (shimSf === null || !fileRecord.shimData.has(shimPath)) {\n      throw new Error(`Error: no shim file in program: ${shimPath}`);\n    }\n    let tcb = findTypeCheckBlock(shimSf, id, false);\n    let tcbPath = shimPath;\n    if (tcb === null) {\n      const inlineSf = getSourceFileOrError(program, sfPath);\n      tcb = findTypeCheckBlock(inlineSf, id, false);\n      if (tcb !== null) {\n        tcbPath = sfPath;\n      }\n    }\n    let data = null;\n    if (shimRecord.templates.has(templateId)) {\n      data = shimRecord.templates.get(templateId);\n    }\n    return {\n      data,\n      tcb,\n      tcbPath,\n      tcbIsShim: tcbPath === shimPath\n    };\n  }\n  isTrackedTypeCheckFile(filePath) {\n    return this.getFileAndShimRecordsForPath(filePath) !== null;\n  }\n  getFileRecordForTcbLocation({\n    tcbPath,\n    isShimFile\n  }) {\n    if (!isShimFile) {\n      if (this.state.has(tcbPath)) {\n        return this.state.get(tcbPath);\n      } else {\n        return null;\n      }\n    }\n    const records = this.getFileAndShimRecordsForPath(tcbPath);\n    if (records !== null) {\n      return records.fileRecord;\n    } else {\n      return null;\n    }\n  }\n  getFileAndShimRecordsForPath(shimPath) {\n    for (const fileRecord of this.state.values()) {\n      if (fileRecord.shimData.has(shimPath)) {\n        return {\n          fileRecord,\n          shimRecord: fileRecord.shimData.get(shimPath)\n        };\n      }\n    }\n    return null;\n  }\n  getTemplateMappingAtTcbLocation(tcbLocation) {\n    const fileRecord = this.getFileRecordForTcbLocation(tcbLocation);\n    if (fileRecord === null) {\n      return null;\n    }\n    const shimSf = this.programDriver.getProgram().getSourceFile(tcbLocation.tcbPath);\n    if (shimSf === void 0) {\n      return null;\n    }\n    return getTemplateMapping(shimSf, tcbLocation.positionInFile, fileRecord.sourceManager, false);\n  }\n  generateAllTypeCheckBlocks() {\n    this.ensureAllShimsForAllFiles();\n  }\n  getDiagnosticsForFile(sf, optimizeFor) {\n    switch (optimizeFor) {\n      case OptimizeFor.WholeProgram:\n        this.ensureAllShimsForAllFiles();\n        break;\n      case OptimizeFor.SingleFile:\n        this.ensureAllShimsForOneFile(sf);\n        break;\n    }\n    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n      const sfPath = absoluteFromSourceFile(sf);\n      const fileRecord = this.state.get(sfPath);\n      const typeCheckProgram = this.programDriver.getProgram();\n      const diagnostics = [];\n      if (fileRecord.hasInlines) {\n        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n      }\n      for (const [shimPath, shimRecord] of fileRecord.shimData) {\n        const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n        diagnostics.push(...shimRecord.genesisDiagnostics);\n        for (const templateData of shimRecord.templates.values()) {\n          diagnostics.push(...templateData.templateDiagnostics);\n        }\n      }\n      return diagnostics.filter(diag => diag !== null);\n    });\n  }\n  getDiagnosticsForComponent(component) {\n    this.ensureShimForComponent(component);\n    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n      const sf = component.getSourceFile();\n      const sfPath = absoluteFromSourceFile(sf);\n      const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n      const fileRecord = this.getFileData(sfPath);\n      if (!fileRecord.shimData.has(shimPath)) {\n        return [];\n      }\n      const templateId = fileRecord.sourceManager.getTemplateId(component);\n      const shimRecord = fileRecord.shimData.get(shimPath);\n      const typeCheckProgram = this.programDriver.getProgram();\n      const diagnostics = [];\n      if (shimRecord.hasInlines) {\n        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n      }\n      const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n      diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n      diagnostics.push(...shimRecord.genesisDiagnostics);\n      for (const templateData of shimRecord.templates.values()) {\n        diagnostics.push(...templateData.templateDiagnostics);\n      }\n      return diagnostics.filter(diag => diag !== null && diag.templateId === templateId);\n    });\n  }\n  getTypeCheckBlock(component) {\n    return this.getLatestComponentState(component).tcb;\n  }\n  getGlobalCompletions(context, component, node) {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getGlobalCompletions(context, node));\n  }\n  getExpressionCompletionLocation(ast, component) {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getExpressionCompletionLocation(ast));\n  }\n  getLiteralCompletionLocation(node, component) {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getLiteralCompletionLocation(node));\n  }\n  invalidateClass(clazz) {\n    this.completionCache.delete(clazz);\n    this.symbolBuilderCache.delete(clazz);\n    this.scopeCache.delete(clazz);\n    this.elementTagCache.delete(clazz);\n    const sf = clazz.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    const fileData = this.getFileData(sfPath);\n    const templateId = fileData.sourceManager.getTemplateId(clazz);\n    fileData.shimData.delete(shimPath);\n    fileData.isComplete = false;\n    this.isComplete = false;\n  }\n  makeTemplateDiagnostic(clazz, sourceSpan, category, errorCode, message, relatedInformation) {\n    const sfPath = absoluteFromSourceFile(clazz.getSourceFile());\n    const fileRecord = this.state.get(sfPath);\n    const templateId = fileRecord.sourceManager.getTemplateId(clazz);\n    const mapping = fileRecord.sourceManager.getSourceMapping(templateId);\n    return {\n      ...makeTemplateDiagnostic(templateId, mapping, sourceSpan, category, ngErrorCode(errorCode), message, relatedInformation),\n      __ngCode: errorCode\n    };\n  }\n  getOrCreateCompletionEngine(component) {\n    if (this.completionCache.has(component)) {\n      return this.completionCache.get(component);\n    }\n    const {\n      tcb,\n      data,\n      tcbPath,\n      tcbIsShim\n    } = this.getLatestComponentState(component);\n    if (tcb === null || data === null) {\n      return null;\n    }\n    const engine = new CompletionEngine(tcb, data, tcbPath, tcbIsShim);\n    this.completionCache.set(component, engine);\n    return engine;\n  }\n  maybeAdoptPriorResultsForFile(sf) {\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.state.has(sfPath)) {\n      const existingResults = this.state.get(sfPath);\n      if (existingResults.isComplete) {\n        return;\n      }\n    }\n    const previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);\n    if (previousResults === null || !previousResults.isComplete) {\n      return;\n    }\n    this.perf.eventCount(PerfEvent.ReuseTypeCheckFile);\n    this.state.set(sfPath, previousResults);\n  }\n  ensureAllShimsForAllFiles() {\n    if (this.isComplete) {\n      return;\n    }\n    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n      const host = new WholeProgramTypeCheckingHost(this);\n      const ctx = this.newContext(host);\n      for (const sf of this.originalProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile || isShim(sf)) {\n          continue;\n        }\n        this.maybeAdoptPriorResultsForFile(sf);\n        const sfPath = absoluteFromSourceFile(sf);\n        const fileData = this.getFileData(sfPath);\n        if (fileData.isComplete) {\n          continue;\n        }\n        this.typeCheckAdapter.typeCheck(sf, ctx);\n        fileData.isComplete = true;\n      }\n      this.updateFromContext(ctx);\n      this.isComplete = true;\n    });\n  }\n  ensureAllShimsForOneFile(sf) {\n    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n      this.maybeAdoptPriorResultsForFile(sf);\n      const sfPath = absoluteFromSourceFile(sf);\n      const fileData = this.getFileData(sfPath);\n      if (fileData.isComplete) {\n        return;\n      }\n      const host = new SingleFileTypeCheckingHost(sfPath, fileData, this);\n      const ctx = this.newContext(host);\n      this.typeCheckAdapter.typeCheck(sf, ctx);\n      fileData.isComplete = true;\n      this.updateFromContext(ctx);\n    });\n  }\n  ensureShimForComponent(component) {\n    const sf = component.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    this.maybeAdoptPriorResultsForFile(sf);\n    const fileData = this.getFileData(sfPath);\n    if (fileData.shimData.has(shimPath)) {\n      return;\n    }\n    const host = new SingleShimTypeCheckingHost(sfPath, fileData, this, shimPath);\n    const ctx = this.newContext(host);\n    this.typeCheckAdapter.typeCheck(sf, ctx);\n    this.updateFromContext(ctx);\n  }\n  newContext(host) {\n    const inlining = this.programDriver.supportsInlineOperations ? InliningMode.InlineOps : InliningMode.Error;\n    return new TypeCheckContextImpl(this.config, this.compilerHost, this.refEmitter, this.reflector, host, inlining, this.perf);\n  }\n  clearAllShimDataUsingInlines() {\n    for (const fileData of this.state.values()) {\n      if (!fileData.hasInlines) {\n        continue;\n      }\n      for (const [shimFile, shimData] of fileData.shimData.entries()) {\n        if (shimData.hasInlines) {\n          fileData.shimData.delete(shimFile);\n        }\n      }\n      fileData.hasInlines = false;\n      fileData.isComplete = false;\n      this.isComplete = false;\n    }\n  }\n  updateFromContext(ctx) {\n    const updates = ctx.finalize();\n    return this.perf.inPhase(PerfPhase.TcbUpdateProgram, () => {\n      if (updates.size > 0) {\n        this.perf.eventCount(PerfEvent.UpdateTypeCheckProgram);\n      }\n      this.programDriver.updateFiles(updates, UpdateMode.Incremental);\n      this.priorBuild.recordSuccessfulTypeCheck(this.state);\n      this.perf.memory(PerfCheckpoint.TtcUpdateProgram);\n    });\n  }\n  getFileData(path2) {\n    if (!this.state.has(path2)) {\n      this.state.set(path2, {\n        hasInlines: false,\n        sourceManager: new TemplateSourceManager(),\n        isComplete: false,\n        shimData: /* @__PURE__ */new Map()\n      });\n    }\n    return this.state.get(path2);\n  }\n  getSymbolOfNode(node, component) {\n    const builder = this.getOrCreateSymbolBuilder(component);\n    if (builder === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcSymbol, () => builder.getSymbol(node));\n  }\n  getOrCreateSymbolBuilder(component) {\n    if (this.symbolBuilderCache.has(component)) {\n      return this.symbolBuilderCache.get(component);\n    }\n    const {\n      tcb,\n      data,\n      tcbPath,\n      tcbIsShim\n    } = this.getLatestComponentState(component);\n    if (tcb === null || data === null) {\n      return null;\n    }\n    const builder = new SymbolBuilder(tcbPath, tcbIsShim, tcb, data, this.componentScopeReader, () => this.programDriver.getProgram().getTypeChecker());\n    this.symbolBuilderCache.set(component, builder);\n    return builder;\n  }\n  getPotentialTemplateDirectives(component) {\n    var _a, _b;\n    const typeChecker = this.programDriver.getProgram().getTypeChecker();\n    const inScopeDirectives = (_b = (_a = this.getScopeData(component)) == null ? void 0 : _a.directives) != null ? _b : [];\n    const resultingDirectives = /* @__PURE__ */new Map();\n    for (const d of inScopeDirectives) {\n      resultingDirectives.set(d.ref.node, d);\n    }\n    for (const directiveClass of this.localMetaReader.getKnown(MetaKind.Directive)) {\n      const directiveMeta = this.metaReader.getDirectiveMetadata(new Reference(directiveClass));\n      if (directiveMeta === null) continue;\n      if (resultingDirectives.has(directiveClass)) continue;\n      const withScope = this.scopeDataOfDirectiveMeta(typeChecker, directiveMeta);\n      if (withScope === null) continue;\n      resultingDirectives.set(directiveClass, {\n        ...withScope,\n        isInScope: false\n      });\n    }\n    return Array.from(resultingDirectives.values());\n  }\n  getPotentialPipes(component) {\n    var _a, _b;\n    const typeChecker = this.programDriver.getProgram().getTypeChecker();\n    const inScopePipes = (_b = (_a = this.getScopeData(component)) == null ? void 0 : _a.pipes) != null ? _b : [];\n    const resultingPipes = /* @__PURE__ */new Map();\n    for (const p of inScopePipes) {\n      resultingPipes.set(p.ref.node, p);\n    }\n    for (const pipeClass of this.localMetaReader.getKnown(MetaKind.Pipe)) {\n      const pipeMeta = this.metaReader.getPipeMetadata(new Reference(pipeClass));\n      if (pipeMeta === null) continue;\n      if (resultingPipes.has(pipeClass)) continue;\n      const withScope = this.scopeDataOfPipeMeta(typeChecker, pipeMeta);\n      if (withScope === null) continue;\n      resultingPipes.set(pipeClass, {\n        ...withScope,\n        isInScope: false\n      });\n    }\n    return Array.from(resultingPipes.values());\n  }\n  getDirectiveMetadata(dir) {\n    if (!isNamedClassDeclaration(dir)) {\n      return null;\n    }\n    return this.typeCheckScopeRegistry.getTypeCheckDirectiveMetadata(new Reference(dir));\n  }\n  getNgModuleMetadata(module) {\n    if (!isNamedClassDeclaration(module)) {\n      return null;\n    }\n    return this.metaReader.getNgModuleMetadata(new Reference(module));\n  }\n  getPipeMetadata(pipe) {\n    if (!isNamedClassDeclaration(pipe)) {\n      return null;\n    }\n    return this.metaReader.getPipeMetadata(new Reference(pipe));\n  }\n  getPotentialElementTags(component) {\n    if (this.elementTagCache.has(component)) {\n      return this.elementTagCache.get(component);\n    }\n    const tagMap = /* @__PURE__ */new Map();\n    for (const tag of REGISTRY2.allKnownElementNames()) {\n      tagMap.set(tag, null);\n    }\n    const scope = this.getScopeData(component);\n    if (scope !== null) {\n      for (const directive of scope.directives) {\n        if (directive.selector === null) {\n          continue;\n        }\n        for (const selector of CssSelector.parse(directive.selector)) {\n          if (selector.element === null || tagMap.has(selector.element)) {\n            continue;\n          }\n          tagMap.set(selector.element, directive);\n        }\n      }\n    }\n    this.elementTagCache.set(component, tagMap);\n    return tagMap;\n  }\n  getPotentialDomBindings(tagName) {\n    const attributes = REGISTRY2.allKnownAttributesOfElement(tagName);\n    return attributes.map(attribute => ({\n      attribute,\n      property: REGISTRY2.getMappedPropName(attribute)\n    }));\n  }\n  getPotentialDomEvents(tagName) {\n    return REGISTRY2.allKnownEventsOfElement(tagName);\n  }\n  getPrimaryAngularDecorator(target) {\n    this.ensureAllShimsForOneFile(target.getSourceFile());\n    if (!isNamedClassDeclaration(target)) {\n      return null;\n    }\n    const ref = new Reference(target);\n    const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n    if (dirMeta !== null) {\n      return dirMeta.decorator;\n    }\n    const pipeMeta = this.metaReader.getPipeMetadata(ref);\n    if (pipeMeta !== null) {\n      return pipeMeta.decorator;\n    }\n    const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);\n    if (ngModuleMeta !== null) {\n      return ngModuleMeta.decorator;\n    }\n    return null;\n  }\n  getOwningNgModule(component) {\n    if (!isNamedClassDeclaration(component)) {\n      return null;\n    }\n    const dirMeta = this.metaReader.getDirectiveMetadata(new Reference(component));\n    if (dirMeta !== null && dirMeta.isStandalone) {\n      return null;\n    }\n    const scope = this.componentScopeReader.getScopeForComponent(component);\n    if (scope === null || scope.kind !== ComponentScopeKind.NgModule || !isNamedClassDeclaration(scope.ngModule)) {\n      return null;\n    }\n    return scope.ngModule;\n  }\n  emit(kind, refTo, inContext) {\n    var _a, _b;\n    const emittedRef = this.refEmitter.emit(refTo, inContext.getSourceFile());\n    if (emittedRef.kind === 1) {\n      return null;\n    }\n    const emitted = emittedRef.expression;\n    if (emitted instanceof WrappedNodeExpr) {\n      if (refTo.node === inContext) {\n        return null;\n      }\n      let isForwardReference = false;\n      if (emitted.node.getStart() > inContext.getStart()) {\n        const declaration = (_b = (_a = this.programDriver.getProgram().getTypeChecker().getTypeAtLocation(emitted.node).getSymbol()) == null ? void 0 : _a.declarations) == null ? void 0 : _b[0];\n        if (declaration && declaration.getSourceFile() === inContext.getSourceFile()) {\n          isForwardReference = true;\n        }\n      }\n      return {\n        kind,\n        symbolName: emitted.node.text,\n        isForwardReference\n      };\n    } else if (emitted instanceof ExternalExpr2 && emitted.value.moduleName !== null && emitted.value.name !== null) {\n      return {\n        kind,\n        moduleSpecifier: emitted.value.moduleName,\n        symbolName: emitted.value.name,\n        isForwardReference: false\n      };\n    }\n    return null;\n  }\n  getPotentialImportsFor(toImport, inContext, importMode) {\n    var _a;\n    const imports = [];\n    const meta = (_a = this.metaReader.getDirectiveMetadata(toImport)) != null ? _a : this.metaReader.getPipeMetadata(toImport);\n    if (meta === null) {\n      return imports;\n    }\n    if (meta.isStandalone || importMode === PotentialImportMode.ForceDirect) {\n      const emitted = this.emit(PotentialImportKind.Standalone, toImport, inContext);\n      if (emitted !== null) {\n        imports.push(emitted);\n      }\n    }\n    const exportingNgModules = this.ngModuleIndex.getNgModulesExporting(meta.ref.node);\n    if (exportingNgModules !== null) {\n      for (const exporter of exportingNgModules) {\n        const emittedRef = this.emit(PotentialImportKind.NgModule, exporter, inContext);\n        if (emittedRef !== null) {\n          imports.push(emittedRef);\n        }\n      }\n    }\n    return imports;\n  }\n  getScopeData(component) {\n    if (this.scopeCache.has(component)) {\n      return this.scopeCache.get(component);\n    }\n    if (!isNamedClassDeclaration(component)) {\n      throw new Error(`AssertionError: components must have names`);\n    }\n    const scope = this.componentScopeReader.getScopeForComponent(component);\n    if (scope === null) {\n      return null;\n    }\n    const dependencies = scope.kind === ComponentScopeKind.NgModule ? scope.compilation.dependencies : scope.dependencies;\n    const data = {\n      directives: [],\n      pipes: [],\n      isPoisoned: scope.kind === ComponentScopeKind.NgModule ? scope.compilation.isPoisoned : scope.isPoisoned\n    };\n    const typeChecker = this.programDriver.getProgram().getTypeChecker();\n    for (const dep of dependencies) {\n      if (dep.kind === MetaKind.Directive) {\n        const dirScope = this.scopeDataOfDirectiveMeta(typeChecker, dep);\n        if (dirScope === null) continue;\n        data.directives.push({\n          ...dirScope,\n          isInScope: true\n        });\n      } else if (dep.kind === MetaKind.Pipe) {\n        const pipeScope = this.scopeDataOfPipeMeta(typeChecker, dep);\n        if (pipeScope === null) continue;\n        data.pipes.push({\n          ...pipeScope,\n          isInScope: true\n        });\n      }\n    }\n    this.scopeCache.set(component, data);\n    return data;\n  }\n  scopeDataOfDirectiveMeta(typeChecker, dep) {\n    if (dep.selector === null) {\n      return null;\n    }\n    const tsSymbol = typeChecker.getSymbolAtLocation(dep.ref.node.name);\n    if (!isSymbolWithValueDeclaration(tsSymbol)) {\n      return null;\n    }\n    let ngModule = null;\n    const moduleScopeOfDir = this.componentScopeReader.getScopeForComponent(dep.ref.node);\n    if (moduleScopeOfDir !== null && moduleScopeOfDir.kind === ComponentScopeKind.NgModule) {\n      ngModule = moduleScopeOfDir.ngModule;\n    }\n    return {\n      ref: dep.ref,\n      isComponent: dep.isComponent,\n      isStructural: dep.isStructural,\n      selector: dep.selector,\n      tsSymbol,\n      ngModule\n    };\n  }\n  scopeDataOfPipeMeta(typeChecker, dep) {\n    const tsSymbol = typeChecker.getSymbolAtLocation(dep.ref.node.name);\n    if (tsSymbol === void 0) {\n      return null;\n    }\n    return {\n      ref: dep.ref,\n      name: dep.name,\n      tsSymbol\n    };\n  }\n};\nfunction convertDiagnostic(diag, sourceResolver) {\n  if (!shouldReportDiagnostic(diag)) {\n    return null;\n  }\n  return translateDiagnostic(diag, sourceResolver);\n}\nvar WholeProgramTypeCheckingHost = class {\n  constructor(impl) {\n    this.impl = impl;\n  }\n  getSourceManager(sfPath) {\n    return this.impl.getFileData(sfPath).sourceManager;\n  }\n  shouldCheckComponent(node) {\n    const sfPath = absoluteFromSourceFile(node.getSourceFile());\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    const fileData = this.impl.getFileData(sfPath);\n    return !fileData.shimData.has(shimPath);\n  }\n  recordShimData(sfPath, data) {\n    const fileData = this.impl.getFileData(sfPath);\n    fileData.shimData.set(data.path, data);\n    if (data.hasInlines) {\n      fileData.hasInlines = true;\n    }\n  }\n  recordComplete(sfPath) {\n    this.impl.getFileData(sfPath).isComplete = true;\n  }\n};\nvar SingleFileTypeCheckingHost = class {\n  constructor(sfPath, fileData, impl) {\n    this.sfPath = sfPath;\n    this.fileData = fileData;\n    this.impl = impl;\n    this.seenInlines = false;\n  }\n  assertPath(sfPath) {\n    if (this.sfPath !== sfPath) {\n      throw new Error(`AssertionError: querying TypeCheckingHost outside of assigned file`);\n    }\n  }\n  getSourceManager(sfPath) {\n    this.assertPath(sfPath);\n    return this.fileData.sourceManager;\n  }\n  shouldCheckComponent(node) {\n    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n      return false;\n    }\n    const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);\n    return !this.fileData.shimData.has(shimPath);\n  }\n  recordShimData(sfPath, data) {\n    this.assertPath(sfPath);\n    if (data.hasInlines && !this.seenInlines) {\n      this.impl.clearAllShimDataUsingInlines();\n      this.seenInlines = true;\n    }\n    this.fileData.shimData.set(data.path, data);\n    if (data.hasInlines) {\n      this.fileData.hasInlines = true;\n    }\n  }\n  recordComplete(sfPath) {\n    this.assertPath(sfPath);\n    this.fileData.isComplete = true;\n  }\n};\nvar SingleShimTypeCheckingHost = class extends SingleFileTypeCheckingHost {\n  constructor(sfPath, fileData, impl, shimPath) {\n    super(sfPath, fileData, impl);\n    this.shimPath = shimPath;\n  }\n  shouldCheckNode(node) {\n    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n      return false;\n    }\n    const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);\n    if (shimPath !== this.shimPath) {\n      return false;\n    }\n    return !this.fileData.shimData.has(shimPath);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/invalid_banana_in_box/index.mjs\nimport { TmplAstBoundEvent as TmplAstBoundEvent2 } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/api/api.mjs\nimport { ASTWithSource as ASTWithSource4, RecursiveAstVisitor as RecursiveAstVisitor3 } from \"@angular/compiler\";\nvar TemplateCheckWithVisitor = class {\n  run(ctx, component, template) {\n    const visitor = new TemplateVisitor2(ctx, component, this);\n    return visitor.getDiagnostics(template);\n  }\n};\nvar TemplateVisitor2 = class extends RecursiveAstVisitor3 {\n  constructor(ctx, component, check) {\n    super();\n    this.ctx = ctx;\n    this.component = component;\n    this.check = check;\n    this.diagnostics = [];\n  }\n  visit(node, context) {\n    this.diagnostics.push(...this.check.visitNode(this.ctx, this.component, node));\n    node.visit(this);\n  }\n  visitAllNodes(nodes) {\n    for (const node of nodes) {\n      this.visit(node);\n    }\n  }\n  visitAst(ast) {\n    if (ast instanceof ASTWithSource4) {\n      ast = ast.ast;\n    }\n    this.visit(ast);\n  }\n  visitElement(element) {\n    this.visitAllNodes(element.attributes);\n    this.visitAllNodes(element.inputs);\n    this.visitAllNodes(element.outputs);\n    this.visitAllNodes(element.references);\n    this.visitAllNodes(element.children);\n  }\n  visitTemplate(template) {\n    this.visitAllNodes(template.attributes);\n    if (template.tagName === \"ng-template\") {\n      this.visitAllNodes(template.inputs);\n      this.visitAllNodes(template.outputs);\n      this.visitAllNodes(template.templateAttrs);\n    }\n    this.visitAllNodes(template.variables);\n    this.visitAllNodes(template.references);\n    this.visitAllNodes(template.children);\n  }\n  visitContent(content) {}\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitBoundAttribute(attribute) {\n    this.visitAst(attribute.value);\n  }\n  visitBoundEvent(attribute) {\n    this.visitAst(attribute.handler);\n  }\n  visitText(text) {}\n  visitBoundText(text) {\n    this.visitAst(text.value);\n  }\n  visitIcu(icu) {}\n  getDiagnostics(template) {\n    this.diagnostics = [];\n    this.visitAllNodes(template);\n    return this.diagnostics;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/invalid_banana_in_box/index.mjs\nvar InvalidBananaInBoxCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.INVALID_BANANA_IN_BOX;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof TmplAstBoundEvent2)) return [];\n    const name = node.name;\n    if (!name.startsWith(\"[\") || !name.endsWith(\"]\")) return [];\n    const boundSyntax = node.sourceSpan.toString();\n    const expectedBoundSyntax = boundSyntax.replace(`(${name})`, `[(${name.slice(1, -1)})]`);\n    const diagnostic = ctx.makeTemplateDiagnostic(node.sourceSpan, `In the two-way binding syntax the parentheses should be inside the brackets, ex. '${expectedBoundSyntax}'.\n        Find more at https://angular.io/guide/two-way-binding`);\n    return [diagnostic];\n  }\n};\nvar factory = {\n  code: ErrorCode.INVALID_BANANA_IN_BOX,\n  name: ExtendedTemplateDiagnosticName.INVALID_BANANA_IN_BOX,\n  create: () => new InvalidBananaInBoxCheck()\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/missing_control_flow_directive/index.mjs\nimport { TmplAstTemplate as TmplAstTemplate4 } from \"@angular/compiler\";\nvar KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */new Map([[\"ngIf\", \"NgIf\"], [\"ngFor\", \"NgFor\"], [\"ngSwitchCase\", \"NgSwitchCase\"], [\"ngSwitchDefault\", \"NgSwitchDefault\"]]);\nvar MissingControlFlowDirectiveCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE;\n  }\n  run(ctx, component, template) {\n    const componentMetadata = ctx.templateTypeChecker.getDirectiveMetadata(component);\n    if (!componentMetadata || !componentMetadata.isStandalone) {\n      return [];\n    }\n    return super.run(ctx, component, template);\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof TmplAstTemplate4)) return [];\n    const controlFlowAttr = node.templateAttrs.find(attr => KNOWN_CONTROL_FLOW_DIRECTIVES.has(attr.name));\n    if (!controlFlowAttr) return [];\n    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);\n    if (symbol === null || symbol.directives.length > 0) {\n      return [];\n    }\n    const sourceSpan = controlFlowAttr.keySpan || controlFlowAttr.sourceSpan;\n    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(controlFlowAttr.name);\n    const errorMessage = `The \\`*${controlFlowAttr.name}\\` directive was used in the template, but neither the \\`${correspondingImport}\\` directive nor the \\`CommonModule\\` was imported. Please make sure that either the \\`${correspondingImport}\\` directive or the \\`CommonModule\\` is included in the \\`@Component.imports\\` array of this component.`;\n    const diagnostic = ctx.makeTemplateDiagnostic(sourceSpan, errorMessage);\n    return [diagnostic];\n  }\n};\nvar factory2 = {\n  code: ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE,\n  name: ExtendedTemplateDiagnosticName.MISSING_CONTROL_FLOW_DIRECTIVE,\n  create: options => {\n    return new MissingControlFlowDirectiveCheck();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/missing_ngforof_let/index.mjs\nimport { TmplAstTemplate as TmplAstTemplate5 } from \"@angular/compiler\";\nvar MissingNgForOfLetCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.MISSING_NGFOROF_LET;\n  }\n  visitNode(ctx, component, node) {\n    const isTemplate = node instanceof TmplAstTemplate5;\n    if (!(node instanceof TmplAstTemplate5)) {\n      return [];\n    }\n    if (node.templateAttrs.length === 0) {\n      return [];\n    }\n    const attr = node.templateAttrs.find(x => x.name === \"ngFor\");\n    if (attr === void 0) {\n      return [];\n    }\n    if (node.variables.length > 0) {\n      return [];\n    }\n    const errorString = \"Your ngFor is missing a value. Did you forget to add the `let` keyword?\";\n    const diagnostic = ctx.makeTemplateDiagnostic(attr.sourceSpan, errorString);\n    return [diagnostic];\n  }\n};\nvar factory3 = {\n  code: ErrorCode.MISSING_NGFOROF_LET,\n  name: ExtendedTemplateDiagnosticName.MISSING_NGFOROF_LET,\n  create: () => new MissingNgForOfLetCheck()\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/nullish_coalescing_not_nullable/index.mjs\nimport { Binary } from \"@angular/compiler\";\nimport ts27 from \"typescript\";\nvar NullishCoalescingNotNullableCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.NULLISH_COALESCING_NOT_NULLABLE;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof Binary) || node.operation !== \"??\") return [];\n    const symbolLeft = ctx.templateTypeChecker.getSymbolOfNode(node.left, component);\n    if (symbolLeft === null || symbolLeft.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const typeLeft = symbolLeft.tsType;\n    if (typeLeft.flags & (ts27.TypeFlags.Any | ts27.TypeFlags.Unknown)) {\n      return [];\n    }\n    if (typeLeft.getNonNullableType() !== typeLeft) return [];\n    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);\n    if (symbol.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const templateMapping = ctx.templateTypeChecker.getTemplateMappingAtTcbLocation(symbol.tcbLocation);\n    if (templateMapping === null) {\n      return [];\n    }\n    const diagnostic = ctx.makeTemplateDiagnostic(templateMapping.span, `The left side of this nullish coalescing operation does not include 'null' or 'undefined' in its type, therefore the '??' operator can be safely removed.`);\n    return [diagnostic];\n  }\n};\nvar factory4 = {\n  code: ErrorCode.NULLISH_COALESCING_NOT_NULLABLE,\n  name: ExtendedTemplateDiagnosticName.NULLISH_COALESCING_NOT_NULLABLE,\n  create: options => {\n    const strictNullChecks = options.strictNullChecks === void 0 ? !!options.strict : !!options.strictNullChecks;\n    if (!strictNullChecks) {\n      return null;\n    }\n    return new NullishCoalescingNotNullableCheck();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/optional_chain_not_nullable/index.mjs\nimport { SafeCall as SafeCall2, SafeKeyedRead as SafeKeyedRead2, SafePropertyRead as SafePropertyRead5 } from \"@angular/compiler\";\nimport ts28 from \"typescript\";\nvar OptionalChainNotNullableCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof SafeCall2) && !(node instanceof SafePropertyRead5) && !(node instanceof SafeKeyedRead2)) return [];\n    const symbolLeft = ctx.templateTypeChecker.getSymbolOfNode(node.receiver, component);\n    if (symbolLeft === null || symbolLeft.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const typeLeft = symbolLeft.tsType;\n    if (typeLeft.flags & (ts28.TypeFlags.Any | ts28.TypeFlags.Unknown)) {\n      return [];\n    }\n    if (typeLeft.getNonNullableType() !== typeLeft) return [];\n    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);\n    if (symbol.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const templateMapping = ctx.templateTypeChecker.getTemplateMappingAtTcbLocation(symbol.tcbLocation);\n    if (templateMapping === null) {\n      return [];\n    }\n    const advice = node instanceof SafePropertyRead5 ? `the '?.' operator can be replaced with the '.' operator` : `the '?.' operator can be safely removed`;\n    const diagnostic = ctx.makeTemplateDiagnostic(templateMapping.span, `The left side of this optional chain operation does not include 'null' or 'undefined' in its type, therefore ${advice}.`);\n    return [diagnostic];\n  }\n};\nvar factory5 = {\n  code: ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE,\n  name: ExtendedTemplateDiagnosticName.OPTIONAL_CHAIN_NOT_NULLABLE,\n  create: options => {\n    const strictNullChecks = options.strictNullChecks === void 0 ? !!options.strict : !!options.strictNullChecks;\n    if (!strictNullChecks) {\n      return null;\n    }\n    return new OptionalChainNotNullableCheck();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/suffix_not_supported/index.mjs\nimport { TmplAstBoundAttribute as TmplAstBoundAttribute3 } from \"@angular/compiler\";\nvar STYLE_SUFFIXES = [\"px\", \"%\", \"em\"];\nvar SuffixNotSupportedCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.SUFFIX_NOT_SUPPORTED;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof TmplAstBoundAttribute3)) return [];\n    if (!node.keySpan.toString().startsWith(\"attr.\") || !STYLE_SUFFIXES.some(suffix => node.name.endsWith(`.${suffix}`))) {\n      return [];\n    }\n    const diagnostic = ctx.makeTemplateDiagnostic(node.keySpan, `The ${STYLE_SUFFIXES.map(suffix => `'.${suffix}'`).join(\", \")} suffixes are only supported on style bindings.`);\n    return [diagnostic];\n  }\n};\nvar factory6 = {\n  code: ErrorCode.SUFFIX_NOT_SUPPORTED,\n  name: ExtendedTemplateDiagnosticName.SUFFIX_NOT_SUPPORTED,\n  create: () => new SuffixNotSupportedCheck()\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/text_attribute_not_binding/index.mjs\nimport { TmplAstTextAttribute as TmplAstTextAttribute4 } from \"@angular/compiler\";\nvar TextAttributeNotBindingSpec = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof TmplAstTextAttribute4)) return [];\n    const name = node.name;\n    if (!name.startsWith(\"attr.\") && !name.startsWith(\"style.\") && !name.startsWith(\"class.\")) {\n      return [];\n    }\n    let errorString;\n    if (name.startsWith(\"attr.\")) {\n      const staticAttr = name.replace(\"attr.\", \"\");\n      errorString = `Static attributes should be written without the 'attr.' prefix.`;\n      if (node.value) {\n        errorString += ` For example, ${staticAttr}=\"${node.value}\".`;\n      }\n    } else {\n      const expectedKey = `[${name}]`;\n      const expectedValue = node.value === \"true\" || node.value === \"false\" ? node.value : `'${node.value}'`;\n      errorString = \"Attribute, style, and class bindings should be enclosed with square braces.\";\n      if (node.value) {\n        errorString += ` For example, '${expectedKey}=\"${expectedValue}\"'.`;\n      }\n    }\n    const diagnostic = ctx.makeTemplateDiagnostic(node.sourceSpan, errorString);\n    return [diagnostic];\n  }\n};\nvar factory7 = {\n  code: ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING,\n  name: ExtendedTemplateDiagnosticName.TEXT_ATTRIBUTE_NOT_BINDING,\n  create: () => new TextAttributeNotBindingSpec()\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/src/extended_template_checker.mjs\nimport ts29 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/core/api/src/public_options.mjs\nvar DiagnosticCategoryLabel;\n(function (DiagnosticCategoryLabel2) {\n  DiagnosticCategoryLabel2[\"Warning\"] = \"warning\";\n  DiagnosticCategoryLabel2[\"Error\"] = \"error\";\n  DiagnosticCategoryLabel2[\"Suppress\"] = \"suppress\";\n})(DiagnosticCategoryLabel || (DiagnosticCategoryLabel = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/src/extended_template_checker.mjs\nvar ExtendedTemplateCheckerImpl = class {\n  constructor(templateTypeChecker, typeChecker, templateCheckFactories, options) {\n    var _a, _b, _c, _d, _e;\n    this.partialCtx = {\n      templateTypeChecker,\n      typeChecker\n    };\n    this.templateChecks = /* @__PURE__ */new Map();\n    for (const factory8 of templateCheckFactories) {\n      const category = diagnosticLabelToCategory((_e = (_d = (_b = (_a = options == null ? void 0 : options.extendedDiagnostics) == null ? void 0 : _a.checks) == null ? void 0 : _b[factory8.name]) != null ? _d : (_c = options == null ? void 0 : options.extendedDiagnostics) == null ? void 0 : _c.defaultCategory) != null ? _e : DiagnosticCategoryLabel.Warning);\n      if (category === null) {\n        continue;\n      }\n      const check = factory8.create(options);\n      if (check === null) {\n        continue;\n      }\n      this.templateChecks.set(check, category);\n    }\n  }\n  getDiagnosticsForComponent(component) {\n    const template = this.partialCtx.templateTypeChecker.getTemplate(component);\n    if (template === null) {\n      return [];\n    }\n    const diagnostics = [];\n    for (const [check, category] of this.templateChecks.entries()) {\n      const ctx = {\n        ...this.partialCtx,\n        makeTemplateDiagnostic: (span, message, relatedInformation) => {\n          return this.partialCtx.templateTypeChecker.makeTemplateDiagnostic(component, span, category, check.code, message, relatedInformation);\n        }\n      };\n      diagnostics.push(...check.run(ctx, component, template));\n    }\n    return diagnostics;\n  }\n};\nfunction diagnosticLabelToCategory(label) {\n  switch (label) {\n    case DiagnosticCategoryLabel.Warning:\n      return ts29.DiagnosticCategory.Warning;\n    case DiagnosticCategoryLabel.Error:\n      return ts29.DiagnosticCategory.Error;\n    case DiagnosticCategoryLabel.Suppress:\n      return null;\n    default:\n      return assertNever(label);\n  }\n}\nfunction assertNever(value) {\n  throw new Error(`Unexpected call to 'assertNever()' with value:\n${value}`);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/index.mjs\nvar ALL_DIAGNOSTIC_FACTORIES = [factory, factory4, factory5, factory2, factory7, factory3, factory6];\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/core/src/compiler.mjs\nvar CompilationTicketKind;\n(function (CompilationTicketKind2) {\n  CompilationTicketKind2[CompilationTicketKind2[\"Fresh\"] = 0] = \"Fresh\";\n  CompilationTicketKind2[CompilationTicketKind2[\"IncrementalTypeScript\"] = 1] = \"IncrementalTypeScript\";\n  CompilationTicketKind2[CompilationTicketKind2[\"IncrementalResource\"] = 2] = \"IncrementalResource\";\n})(CompilationTicketKind || (CompilationTicketKind = {}));\nfunction freshCompilationTicket(tsProgram, options, incrementalBuildStrategy, programDriver, perfRecorder, enableTemplateTypeChecker, usePoisonedData) {\n  return {\n    kind: CompilationTicketKind.Fresh,\n    tsProgram,\n    options,\n    incrementalBuildStrategy,\n    programDriver,\n    enableTemplateTypeChecker,\n    usePoisonedData,\n    perfRecorder: perfRecorder != null ? perfRecorder : ActivePerfRecorder.zeroedToNow()\n  };\n}\nfunction incrementalFromCompilerTicket(oldCompiler, newProgram, incrementalBuildStrategy, programDriver, modifiedResourceFiles, perfRecorder) {\n  const oldProgram = oldCompiler.getCurrentProgram();\n  const oldState = oldCompiler.incrementalStrategy.getIncrementalState(oldProgram);\n  if (oldState === null) {\n    return freshCompilationTicket(newProgram, oldCompiler.options, incrementalBuildStrategy, programDriver, perfRecorder, oldCompiler.enableTemplateTypeChecker, oldCompiler.usePoisonedData);\n  }\n  if (perfRecorder === null) {\n    perfRecorder = ActivePerfRecorder.zeroedToNow();\n  }\n  const incrementalCompilation = IncrementalCompilation.incremental(newProgram, versionMapFromProgram(newProgram, programDriver), oldProgram, oldState, modifiedResourceFiles, perfRecorder);\n  return {\n    kind: CompilationTicketKind.IncrementalTypeScript,\n    enableTemplateTypeChecker: oldCompiler.enableTemplateTypeChecker,\n    usePoisonedData: oldCompiler.usePoisonedData,\n    options: oldCompiler.options,\n    incrementalBuildStrategy,\n    incrementalCompilation,\n    programDriver,\n    newProgram,\n    perfRecorder\n  };\n}\nfunction incrementalFromStateTicket(oldProgram, oldState, newProgram, options, incrementalBuildStrategy, programDriver, modifiedResourceFiles, perfRecorder, enableTemplateTypeChecker, usePoisonedData) {\n  if (perfRecorder === null) {\n    perfRecorder = ActivePerfRecorder.zeroedToNow();\n  }\n  const incrementalCompilation = IncrementalCompilation.incremental(newProgram, versionMapFromProgram(newProgram, programDriver), oldProgram, oldState, modifiedResourceFiles, perfRecorder);\n  return {\n    kind: CompilationTicketKind.IncrementalTypeScript,\n    newProgram,\n    options,\n    incrementalBuildStrategy,\n    incrementalCompilation,\n    programDriver,\n    enableTemplateTypeChecker,\n    usePoisonedData,\n    perfRecorder\n  };\n}\nvar NgCompiler = class {\n  static fromTicket(ticket, adapter) {\n    switch (ticket.kind) {\n      case CompilationTicketKind.Fresh:\n        return new NgCompiler(adapter, ticket.options, ticket.tsProgram, ticket.programDriver, ticket.incrementalBuildStrategy, IncrementalCompilation.fresh(ticket.tsProgram, versionMapFromProgram(ticket.tsProgram, ticket.programDriver)), ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);\n      case CompilationTicketKind.IncrementalTypeScript:\n        return new NgCompiler(adapter, ticket.options, ticket.newProgram, ticket.programDriver, ticket.incrementalBuildStrategy, ticket.incrementalCompilation, ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);\n      case CompilationTicketKind.IncrementalResource:\n        const compiler = ticket.compiler;\n        compiler.updateWithChangedResources(ticket.modifiedResourceFiles, ticket.perfRecorder);\n        return compiler;\n    }\n  }\n  constructor(adapter, options, inputProgram, programDriver, incrementalStrategy, incrementalCompilation, enableTemplateTypeChecker, usePoisonedData, livePerfRecorder) {\n    var _a;\n    this.adapter = adapter;\n    this.options = options;\n    this.inputProgram = inputProgram;\n    this.programDriver = programDriver;\n    this.incrementalStrategy = incrementalStrategy;\n    this.incrementalCompilation = incrementalCompilation;\n    this.usePoisonedData = usePoisonedData;\n    this.livePerfRecorder = livePerfRecorder;\n    this.compilation = null;\n    this.constructionDiagnostics = [];\n    this.nonTemplateDiagnostics = null;\n    this.delegatingPerfRecorder = new DelegatingPerfRecorder(this.perfRecorder);\n    this.enableTemplateTypeChecker = enableTemplateTypeChecker || ((_a = options._enableTemplateTypeChecker) != null ? _a : false);\n    this.constructionDiagnostics.push(...this.adapter.constructionDiagnostics, ...verifyCompatibleTypeCheckOptions(this.options));\n    this.currentProgram = inputProgram;\n    this.closureCompilerEnabled = !!this.options.annotateForClosureCompiler;\n    this.entryPoint = adapter.entryPoint !== null ? getSourceFileOrNull(inputProgram, adapter.entryPoint) : null;\n    const moduleResolutionCache = ts30.createModuleResolutionCache(this.adapter.getCurrentDirectory(), this.adapter.getCanonicalFileName.bind(this.adapter));\n    this.moduleResolver = new ModuleResolver(inputProgram, this.options, this.adapter, moduleResolutionCache);\n    this.resourceManager = new AdapterResourceLoader(adapter, this.options);\n    this.cycleAnalyzer = new CycleAnalyzer(new ImportGraph(inputProgram.getTypeChecker(), this.delegatingPerfRecorder));\n    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, inputProgram);\n    this.ignoreForDiagnostics = new Set(inputProgram.getSourceFiles().filter(sf => this.adapter.isShim(sf)));\n    this.ignoreForEmit = this.adapter.ignoreForEmit;\n    let dtsFileCount = 0;\n    let nonDtsFileCount = 0;\n    for (const sf of inputProgram.getSourceFiles()) {\n      if (sf.isDeclarationFile) {\n        dtsFileCount++;\n      } else {\n        nonDtsFileCount++;\n      }\n    }\n    livePerfRecorder.eventCount(PerfEvent.InputDtsFile, dtsFileCount);\n    livePerfRecorder.eventCount(PerfEvent.InputTsFile, nonDtsFileCount);\n  }\n  get perfRecorder() {\n    return this.livePerfRecorder;\n  }\n  updateWithChangedResources(changedResources, perfRecorder) {\n    this.livePerfRecorder = perfRecorder;\n    this.delegatingPerfRecorder.target = perfRecorder;\n    perfRecorder.inPhase(PerfPhase.ResourceUpdate, () => {\n      if (this.compilation === null) {\n        return;\n      }\n      this.resourceManager.invalidate();\n      const classesToUpdate = /* @__PURE__ */new Set();\n      for (const resourceFile of changedResources) {\n        for (const templateClass of this.getComponentsWithTemplateFile(resourceFile)) {\n          classesToUpdate.add(templateClass);\n        }\n        for (const styleClass of this.getComponentsWithStyleFile(resourceFile)) {\n          classesToUpdate.add(styleClass);\n        }\n      }\n      for (const clazz of classesToUpdate) {\n        this.compilation.traitCompiler.updateResources(clazz);\n        if (!ts30.isClassDeclaration(clazz)) {\n          continue;\n        }\n        this.compilation.templateTypeChecker.invalidateClass(clazz);\n      }\n    });\n  }\n  getResourceDependencies(file) {\n    this.ensureAnalyzed();\n    return this.incrementalCompilation.depGraph.getResourceDependencies(file);\n  }\n  getDiagnostics() {\n    const diagnostics = [];\n    diagnostics.push(...this.getNonTemplateDiagnostics(), ...this.getTemplateDiagnostics());\n    if (this.options.strictTemplates) {\n      diagnostics.push(...this.getExtendedTemplateDiagnostics());\n    }\n    return this.addMessageTextDetails(diagnostics);\n  }\n  getDiagnosticsForFile(file, optimizeFor) {\n    const diagnostics = [];\n    diagnostics.push(...this.getNonTemplateDiagnostics().filter(diag => diag.file === file), ...this.getTemplateDiagnosticsForFile(file, optimizeFor));\n    if (this.options.strictTemplates) {\n      diagnostics.push(...this.getExtendedTemplateDiagnostics(file));\n    }\n    return this.addMessageTextDetails(diagnostics);\n  }\n  getDiagnosticsForComponent(component) {\n    const compilation = this.ensureAnalyzed();\n    const ttc = compilation.templateTypeChecker;\n    const diagnostics = [];\n    try {\n      diagnostics.push(...ttc.getDiagnosticsForComponent(component));\n      const extendedTemplateChecker = compilation.extendedTemplateChecker;\n      if (this.options.strictTemplates && extendedTemplateChecker) {\n        diagnostics.push(...extendedTemplateChecker.getDiagnosticsForComponent(component));\n      }\n    } catch (err) {\n      if (!(err instanceof FatalDiagnosticError)) {\n        throw err;\n      }\n      diagnostics.push(err.toDiagnostic());\n    }\n    return this.addMessageTextDetails(diagnostics);\n  }\n  addMessageTextDetails(diagnostics) {\n    return diagnostics.map(diag => {\n      if (diag.code && COMPILER_ERRORS_WITH_GUIDES.has(ngErrorCode(diag.code))) {\n        return {\n          ...diag,\n          messageText: diag.messageText + `. Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/NG${ngErrorCode(diag.code)}`\n        };\n      }\n      return diag;\n    });\n  }\n  getOptionDiagnostics() {\n    return this.constructionDiagnostics;\n  }\n  getCurrentProgram() {\n    return this.currentProgram;\n  }\n  getTemplateTypeChecker() {\n    if (!this.enableTemplateTypeChecker) {\n      throw new Error(\"The `TemplateTypeChecker` does not work without `enableTemplateTypeChecker`.\");\n    }\n    return this.ensureAnalyzed().templateTypeChecker;\n  }\n  getComponentsWithTemplateFile(templateFilePath) {\n    const {\n      resourceRegistry\n    } = this.ensureAnalyzed();\n    return resourceRegistry.getComponentsWithTemplate(resolve(templateFilePath));\n  }\n  getComponentsWithStyleFile(styleFilePath) {\n    const {\n      resourceRegistry\n    } = this.ensureAnalyzed();\n    return resourceRegistry.getComponentsWithStyle(resolve(styleFilePath));\n  }\n  getComponentResources(classDecl) {\n    if (!isNamedClassDeclaration(classDecl)) {\n      return null;\n    }\n    const {\n      resourceRegistry\n    } = this.ensureAnalyzed();\n    const styles = resourceRegistry.getStyles(classDecl);\n    const template = resourceRegistry.getTemplate(classDecl);\n    if (template === null) {\n      return null;\n    }\n    return {\n      styles,\n      template\n    };\n  }\n  getMeta(classDecl) {\n    var _a;\n    if (!isNamedClassDeclaration(classDecl)) {\n      return null;\n    }\n    const ref = new Reference(classDecl);\n    const {\n      metaReader\n    } = this.ensureAnalyzed();\n    const meta = (_a = metaReader.getPipeMetadata(ref)) != null ? _a : metaReader.getDirectiveMetadata(ref);\n    if (meta === null) {\n      return null;\n    }\n    return meta;\n  }\n  analyzeAsync() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.compilation !== null) {\n        return;\n      }\n      yield _this3.perfRecorder.inPhase(PerfPhase.Analysis, /*#__PURE__*/_asyncToGenerator(function* () {\n        _this3.compilation = _this3.makeCompilation();\n        const promises = [];\n        for (const sf of _this3.inputProgram.getSourceFiles()) {\n          if (sf.isDeclarationFile) {\n            continue;\n          }\n          let analysisPromise = _this3.compilation.traitCompiler.analyzeAsync(sf);\n          if (analysisPromise !== void 0) {\n            promises.push(analysisPromise);\n          }\n        }\n        yield Promise.all(promises);\n        _this3.perfRecorder.memory(PerfCheckpoint.Analysis);\n        _this3.resolveCompilation(_this3.compilation.traitCompiler);\n      }));\n    })();\n  }\n  prepareEmit() {\n    const compilation = this.ensureAnalyzed();\n    const coreImportsFrom = compilation.isCore ? getR3SymbolsFile(this.inputProgram) : null;\n    let importRewriter;\n    if (coreImportsFrom !== null) {\n      importRewriter = new R3SymbolsImportRewriter(coreImportsFrom.fileName);\n    } else {\n      importRewriter = new NoopImportRewriter();\n    }\n    const defaultImportTracker = new DefaultImportTracker();\n    const before = [ivyTransformFactory(compilation.traitCompiler, compilation.reflector, importRewriter, defaultImportTracker, this.delegatingPerfRecorder, compilation.isCore, this.closureCompilerEnabled), aliasTransformFactory(compilation.traitCompiler.exportStatements), defaultImportTracker.importPreservingTransformer()];\n    const afterDeclarations = [];\n    if (this.options.compilationMode !== \"experimental-local\" && compilation.dtsTransforms !== null) {\n      afterDeclarations.push(declarationTransformFactory(compilation.dtsTransforms, compilation.reflector, compilation.refEmitter, importRewriter));\n    }\n    if (compilation.aliasingHost !== null && compilation.aliasingHost.aliasExportsInDts) {\n      afterDeclarations.push(aliasTransformFactory(compilation.traitCompiler.exportStatements));\n    }\n    return {\n      transformers: {\n        before,\n        afterDeclarations\n      }\n    };\n  }\n  getIndexedComponents() {\n    const compilation = this.ensureAnalyzed();\n    const context = new IndexingContext();\n    compilation.traitCompiler.index(context);\n    return generateAnalysis(context);\n  }\n  xi18n(ctx) {\n    const compilation = this.ensureAnalyzed();\n    compilation.traitCompiler.xi18n(ctx);\n  }\n  ensureAnalyzed() {\n    if (this.compilation === null) {\n      this.analyzeSync();\n    }\n    return this.compilation;\n  }\n  analyzeSync() {\n    this.perfRecorder.inPhase(PerfPhase.Analysis, () => {\n      this.compilation = this.makeCompilation();\n      for (const sf of this.inputProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile) {\n          continue;\n        }\n        this.compilation.traitCompiler.analyzeSync(sf);\n      }\n      this.perfRecorder.memory(PerfCheckpoint.Analysis);\n      this.resolveCompilation(this.compilation.traitCompiler);\n    });\n  }\n  resolveCompilation(traitCompiler) {\n    this.perfRecorder.inPhase(PerfPhase.Resolve, () => {\n      traitCompiler.resolve();\n      this.incrementalCompilation.recordSuccessfulAnalysis(traitCompiler);\n      this.perfRecorder.memory(PerfCheckpoint.Resolve);\n    });\n  }\n  get fullTemplateTypeCheck() {\n    const strictTemplates = !!this.options.strictTemplates;\n    return strictTemplates || !!this.options.fullTemplateTypeCheck;\n  }\n  getTypeCheckingConfig() {\n    const strictTemplates = !!this.options.strictTemplates;\n    const useInlineTypeConstructors = this.programDriver.supportsInlineOperations;\n    let typeCheckingConfig;\n    if (this.fullTemplateTypeCheck) {\n      typeCheckingConfig = {\n        applyTemplateContextGuards: strictTemplates,\n        checkQueries: false,\n        checkTemplateBodies: true,\n        alwaysCheckSchemaInTemplateBodies: true,\n        checkTypeOfInputBindings: strictTemplates,\n        honorAccessModifiersForInputBindings: false,\n        strictNullInputBindings: strictTemplates,\n        checkTypeOfAttributes: strictTemplates,\n        checkTypeOfDomBindings: false,\n        checkTypeOfOutputEvents: strictTemplates,\n        checkTypeOfAnimationEvents: strictTemplates,\n        checkTypeOfDomEvents: strictTemplates,\n        checkTypeOfDomReferences: strictTemplates,\n        checkTypeOfNonDomReferences: true,\n        checkTypeOfPipes: true,\n        strictSafeNavigationTypes: strictTemplates,\n        useContextGenericType: strictTemplates,\n        strictLiteralTypes: true,\n        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n        useInlineTypeConstructors,\n        suggestionsForSuboptimalTypeInference: this.enableTemplateTypeChecker && !strictTemplates\n      };\n    } else {\n      typeCheckingConfig = {\n        applyTemplateContextGuards: false,\n        checkQueries: false,\n        checkTemplateBodies: false,\n        alwaysCheckSchemaInTemplateBodies: this.closureCompilerEnabled,\n        checkTypeOfInputBindings: false,\n        strictNullInputBindings: false,\n        honorAccessModifiersForInputBindings: false,\n        checkTypeOfAttributes: false,\n        checkTypeOfDomBindings: false,\n        checkTypeOfOutputEvents: false,\n        checkTypeOfAnimationEvents: false,\n        checkTypeOfDomEvents: false,\n        checkTypeOfDomReferences: false,\n        checkTypeOfNonDomReferences: false,\n        checkTypeOfPipes: false,\n        strictSafeNavigationTypes: false,\n        useContextGenericType: false,\n        strictLiteralTypes: false,\n        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n        useInlineTypeConstructors,\n        suggestionsForSuboptimalTypeInference: false\n      };\n    }\n    if (this.options.strictInputTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfInputBindings = this.options.strictInputTypes;\n      typeCheckingConfig.applyTemplateContextGuards = this.options.strictInputTypes;\n    }\n    if (this.options.strictInputAccessModifiers !== void 0) {\n      typeCheckingConfig.honorAccessModifiersForInputBindings = this.options.strictInputAccessModifiers;\n    }\n    if (this.options.strictNullInputTypes !== void 0) {\n      typeCheckingConfig.strictNullInputBindings = this.options.strictNullInputTypes;\n    }\n    if (this.options.strictOutputEventTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfOutputEvents = this.options.strictOutputEventTypes;\n      typeCheckingConfig.checkTypeOfAnimationEvents = this.options.strictOutputEventTypes;\n    }\n    if (this.options.strictDomEventTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfDomEvents = this.options.strictDomEventTypes;\n    }\n    if (this.options.strictSafeNavigationTypes !== void 0) {\n      typeCheckingConfig.strictSafeNavigationTypes = this.options.strictSafeNavigationTypes;\n    }\n    if (this.options.strictDomLocalRefTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfDomReferences = this.options.strictDomLocalRefTypes;\n    }\n    if (this.options.strictAttributeTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfAttributes = this.options.strictAttributeTypes;\n    }\n    if (this.options.strictContextGenerics !== void 0) {\n      typeCheckingConfig.useContextGenericType = this.options.strictContextGenerics;\n    }\n    if (this.options.strictLiteralTypes !== void 0) {\n      typeCheckingConfig.strictLiteralTypes = this.options.strictLiteralTypes;\n    }\n    return typeCheckingConfig;\n  }\n  getTemplateDiagnostics() {\n    const compilation = this.ensureAnalyzed();\n    const diagnostics = [];\n    for (const sf of this.inputProgram.getSourceFiles()) {\n      if (sf.isDeclarationFile || this.adapter.isShim(sf)) {\n        continue;\n      }\n      try {\n        diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram));\n      } catch (err) {\n        if (!(err instanceof FatalDiagnosticError)) {\n          throw err;\n        }\n        diagnostics.push(err.toDiagnostic());\n      }\n    }\n    const program = this.programDriver.getProgram();\n    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n    this.currentProgram = program;\n    return diagnostics;\n  }\n  getTemplateDiagnosticsForFile(sf, optimizeFor) {\n    const compilation = this.ensureAnalyzed();\n    const diagnostics = [];\n    if (!sf.isDeclarationFile && !this.adapter.isShim(sf)) {\n      try {\n        diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, optimizeFor));\n      } catch (err) {\n        if (!(err instanceof FatalDiagnosticError)) {\n          throw err;\n        }\n        diagnostics.push(err.toDiagnostic());\n      }\n    }\n    const program = this.programDriver.getProgram();\n    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n    this.currentProgram = program;\n    return diagnostics;\n  }\n  getNonTemplateDiagnostics() {\n    if (this.nonTemplateDiagnostics === null) {\n      const compilation = this.ensureAnalyzed();\n      this.nonTemplateDiagnostics = [...compilation.traitCompiler.diagnostics];\n      if (this.entryPoint !== null && compilation.exportReferenceGraph !== null) {\n        this.nonTemplateDiagnostics.push(...checkForPrivateExports(this.entryPoint, this.inputProgram.getTypeChecker(), compilation.exportReferenceGraph));\n      }\n    }\n    return this.nonTemplateDiagnostics;\n  }\n  getExtendedTemplateDiagnostics(sf) {\n    const diagnostics = [];\n    const compilation = this.ensureAnalyzed();\n    const extendedTemplateChecker = compilation.extendedTemplateChecker;\n    if (!extendedTemplateChecker) {\n      return [];\n    }\n    if (sf !== void 0) {\n      return compilation.traitCompiler.extendedTemplateCheck(sf, extendedTemplateChecker);\n    }\n    for (const sf2 of this.inputProgram.getSourceFiles()) {\n      diagnostics.push(...compilation.traitCompiler.extendedTemplateCheck(sf2, extendedTemplateChecker));\n    }\n    return diagnostics;\n  }\n  makeCompilation() {\n    var _a;\n    const checker = this.inputProgram.getTypeChecker();\n    const reflector = new TypeScriptReflectionHost(checker);\n    let refEmitter;\n    let aliasingHost = null;\n    if (this.adapter.unifiedModulesHost === null || !this.options._useHostForImportGeneration) {\n      let localImportStrategy;\n      if (this.options.rootDir !== void 0 || this.options.rootDirs !== void 0 && this.options.rootDirs.length > 0) {\n        localImportStrategy = new LogicalProjectStrategy(reflector, new LogicalFileSystem([...this.adapter.rootDirs], this.adapter));\n      } else {\n        localImportStrategy = new RelativePathStrategy(reflector);\n      }\n      refEmitter = new ReferenceEmitter([new LocalIdentifierStrategy(), new AbsoluteModuleStrategy(this.inputProgram, checker, this.moduleResolver, reflector), localImportStrategy]);\n      if (this.entryPoint === null && this.options.generateDeepReexports === true) {\n        aliasingHost = new PrivateExportAliasingHost(reflector);\n      }\n    } else {\n      refEmitter = new ReferenceEmitter([new LocalIdentifierStrategy(), new AliasStrategy(), new UnifiedModulesStrategy(reflector, this.adapter.unifiedModulesHost)]);\n      aliasingHost = new UnifiedModulesAliasingHost(this.adapter.unifiedModulesHost);\n    }\n    const isCore = isAngularCorePackage(this.inputProgram);\n    const evaluator = new PartialEvaluator(reflector, checker, this.incrementalCompilation.depGraph);\n    const dtsReader = new DtsMetadataReader(checker, reflector);\n    const localMetaRegistry = new LocalMetadataRegistry();\n    const localMetaReader = localMetaRegistry;\n    const depScopeReader = new MetadataDtsModuleScopeResolver(dtsReader, aliasingHost);\n    const metaReader = new CompoundMetadataReader([localMetaReader, dtsReader]);\n    const ngModuleIndex = new NgModuleIndexImpl(metaReader, localMetaReader);\n    const ngModuleScopeRegistry = new LocalModuleScopeRegistry(localMetaReader, metaReader, depScopeReader, refEmitter, aliasingHost);\n    const standaloneScopeReader = new StandaloneComponentScopeReader(metaReader, ngModuleScopeRegistry, depScopeReader);\n    const scopeReader = new CompoundComponentScopeReader([ngModuleScopeRegistry, standaloneScopeReader]);\n    const semanticDepGraphUpdater = this.incrementalCompilation.semanticDepGraphUpdater;\n    const metaRegistry = new CompoundMetadataRegistry([localMetaRegistry, ngModuleScopeRegistry]);\n    const injectableRegistry = new InjectableClassRegistry(reflector, isCore);\n    const hostDirectivesResolver = new HostDirectivesResolver(metaReader);\n    const exportedProviderStatusResolver = new ExportedProviderStatusResolver(metaReader);\n    const typeCheckScopeRegistry = new TypeCheckScopeRegistry(scopeReader, metaReader, hostDirectivesResolver);\n    let referencesRegistry;\n    let exportReferenceGraph = null;\n    if (this.entryPoint !== null) {\n      exportReferenceGraph = new ReferenceGraph();\n      referencesRegistry = new ReferenceGraphAdapter(exportReferenceGraph);\n    } else {\n      referencesRegistry = new NoopReferencesRegistry();\n    }\n    const dtsTransforms = new DtsTransformRegistry();\n    const resourceRegistry = new ResourceRegistry();\n    let compilationMode = CompilationMode.FULL;\n    if (!isCore) {\n      switch (this.options.compilationMode) {\n        case \"full\":\n          compilationMode = CompilationMode.FULL;\n          break;\n        case \"partial\":\n          compilationMode = CompilationMode.PARTIAL;\n          break;\n        case \"experimental-local\":\n          compilationMode = CompilationMode.LOCAL;\n          break;\n      }\n    }\n    const cycleHandlingStrategy = compilationMode === CompilationMode.FULL ? 0 : 1;\n    const strictCtorDeps = this.options.strictInjectionParameters || false;\n    const handlers = [new ComponentDecoratorHandler(reflector, evaluator, metaRegistry, metaReader, scopeReader, depScopeReader, ngModuleScopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, strictCtorDeps, this.resourceManager, this.adapter.rootDirs, this.options.preserveWhitespaces || false, this.options.i18nUseExternalIds !== false, this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData, this.options.i18nNormalizeLineEndingsInICUs === true, this.moduleResolver, this.cycleAnalyzer, cycleHandlingStrategy, refEmitter, referencesRegistry, this.incrementalCompilation.depGraph, injectableRegistry, semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder, hostDirectivesResolver), new DirectiveDecoratorHandler(reflector, evaluator, metaRegistry, ngModuleScopeRegistry, metaReader, injectableRegistry, refEmitter, referencesRegistry, isCore, strictCtorDeps, semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder), new PipeDecoratorHandler(reflector, evaluator, metaRegistry, ngModuleScopeRegistry, injectableRegistry, isCore, this.delegatingPerfRecorder), new InjectableDecoratorHandler(reflector, evaluator, isCore, strictCtorDeps, injectableRegistry, this.delegatingPerfRecorder), new NgModuleDecoratorHandler(reflector, evaluator, metaReader, metaRegistry, ngModuleScopeRegistry, referencesRegistry, exportedProviderStatusResolver, semanticDepGraphUpdater, isCore, refEmitter, this.closureCompilerEnabled, (_a = this.options.onlyPublishPublicTypingsForNgModules) != null ? _a : false, injectableRegistry, this.delegatingPerfRecorder)];\n    const traitCompiler = new TraitCompiler(handlers, reflector, this.delegatingPerfRecorder, this.incrementalCompilation, this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms, semanticDepGraphUpdater, this.adapter);\n    const notifyingDriver = new NotifyingProgramDriverWrapper(this.programDriver, program => {\n      this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n      this.currentProgram = program;\n    });\n    const templateTypeChecker = new TemplateTypeCheckerImpl(this.inputProgram, notifyingDriver, traitCompiler, this.getTypeCheckingConfig(), refEmitter, reflector, this.adapter, this.incrementalCompilation, metaReader, localMetaReader, ngModuleIndex, scopeReader, typeCheckScopeRegistry, this.delegatingPerfRecorder);\n    const extendedTemplateChecker = this.constructionDiagnostics.length === 0 ? new ExtendedTemplateCheckerImpl(templateTypeChecker, checker, ALL_DIAGNOSTIC_FACTORIES, this.options) : null;\n    return {\n      isCore,\n      traitCompiler,\n      reflector,\n      scopeRegistry: ngModuleScopeRegistry,\n      dtsTransforms,\n      exportReferenceGraph,\n      metaReader,\n      typeCheckScopeRegistry,\n      aliasingHost,\n      refEmitter,\n      templateTypeChecker,\n      resourceRegistry,\n      extendedTemplateChecker\n    };\n  }\n};\nfunction isAngularCorePackage(program) {\n  const r3Symbols = getR3SymbolsFile(program);\n  if (r3Symbols === null) {\n    return false;\n  }\n  return r3Symbols.statements.some(stmt => {\n    if (!ts30.isVariableStatement(stmt)) {\n      return false;\n    }\n    const modifiers = ts30.getModifiers(stmt);\n    if (modifiers === void 0 || !modifiers.some(mod => mod.kind === ts30.SyntaxKind.ExportKeyword)) {\n      return false;\n    }\n    return stmt.declarationList.declarations.some(decl => {\n      if (!ts30.isIdentifier(decl.name) || decl.name.text !== \"ITS_JUST_ANGULAR\") {\n        return false;\n      }\n      if (decl.initializer === void 0 || decl.initializer.kind !== ts30.SyntaxKind.TrueKeyword) {\n        return false;\n      }\n      return true;\n    });\n  });\n}\nfunction getR3SymbolsFile(program) {\n  return program.getSourceFiles().find(file => file.fileName.indexOf(\"r3_symbols.ts\") >= 0) || null;\n}\nfunction* verifyCompatibleTypeCheckOptions(options) {\n  var _a, _b, _c;\n  if (options.fullTemplateTypeCheck === false && options.strictTemplates === true) {\n    yield makeConfigDiagnostic({\n      category: ts30.DiagnosticCategory.Error,\n      code: ErrorCode.CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK,\n      messageText: `\nAngular compiler option \"strictTemplates\" is enabled, however \"fullTemplateTypeCheck\" is disabled.\n\nHaving the \"strictTemplates\" flag enabled implies that \"fullTemplateTypeCheck\" is also enabled, so\nthe latter can not be explicitly disabled.\n\nOne of the following actions is required:\n1. Remove the \"fullTemplateTypeCheck\" option.\n2. Remove \"strictTemplates\" or set it to 'false'.\n\nMore information about the template type checking compiler options can be found in the documentation:\nhttps://angular.io/guide/template-typecheck\n      `.trim()\n    });\n  }\n  if (options.extendedDiagnostics && options.strictTemplates === false) {\n    yield makeConfigDiagnostic({\n      category: ts30.DiagnosticCategory.Error,\n      code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_IMPLIES_STRICT_TEMPLATES,\n      messageText: `\nAngular compiler option \"extendedDiagnostics\" is configured, however \"strictTemplates\" is disabled.\n\nUsing \"extendedDiagnostics\" requires that \"strictTemplates\" is also enabled.\n\nOne of the following actions is required:\n1. Remove \"strictTemplates: false\" to enable it.\n2. Remove \"extendedDiagnostics\" configuration to disable them.\n      `.trim()\n    });\n  }\n  const allowedCategoryLabels = Array.from(Object.values(DiagnosticCategoryLabel));\n  const defaultCategory = (_a = options.extendedDiagnostics) == null ? void 0 : _a.defaultCategory;\n  if (defaultCategory && !allowedCategoryLabels.includes(defaultCategory)) {\n    yield makeConfigDiagnostic({\n      category: ts30.DiagnosticCategory.Error,\n      code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL,\n      messageText: `\nAngular compiler option \"extendedDiagnostics.defaultCategory\" has an unknown diagnostic category: \"${defaultCategory}\".\n\nAllowed diagnostic categories are:\n${allowedCategoryLabels.join(\"\\n\")}\n      `.trim()\n    });\n  }\n  const allExtendedDiagnosticNames = ALL_DIAGNOSTIC_FACTORIES.map(factory8 => factory8.name);\n  for (const [checkName, category] of Object.entries((_c = (_b = options.extendedDiagnostics) == null ? void 0 : _b.checks) != null ? _c : {})) {\n    if (!allExtendedDiagnosticNames.includes(checkName)) {\n      yield makeConfigDiagnostic({\n        category: ts30.DiagnosticCategory.Error,\n        code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CHECK,\n        messageText: `\nAngular compiler option \"extendedDiagnostics.checks\" has an unknown check: \"${checkName}\".\n\nAllowed check names are:\n${allExtendedDiagnosticNames.join(\"\\n\")}\n        `.trim()\n      });\n    }\n    if (!allowedCategoryLabels.includes(category)) {\n      yield makeConfigDiagnostic({\n        category: ts30.DiagnosticCategory.Error,\n        code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL,\n        messageText: `\nAngular compiler option \"extendedDiagnostics.checks['${checkName}']\" has an unknown diagnostic category: \"${category}\".\n\nAllowed diagnostic categories are:\n${allowedCategoryLabels.join(\"\\n\")}\n        `.trim()\n      });\n    }\n  }\n}\nfunction makeConfigDiagnostic({\n  category,\n  code,\n  messageText\n}) {\n  return {\n    category,\n    code: ngErrorCode(code),\n    file: void 0,\n    start: void 0,\n    length: void 0,\n    messageText\n  };\n}\nvar ReferenceGraphAdapter = class {\n  constructor(graph) {\n    this.graph = graph;\n  }\n  add(source, ...references) {\n    for (const {\n      node\n    } of references) {\n      let sourceFile = node.getSourceFile();\n      if (sourceFile === void 0) {\n        sourceFile = ts30.getOriginalNode(node).getSourceFile();\n      }\n      if (sourceFile === void 0 || !isDtsPath(sourceFile.fileName)) {\n        this.graph.add(source, node);\n      }\n    }\n  }\n};\nvar NotifyingProgramDriverWrapper = class {\n  constructor(delegate, notifyNewProgram) {\n    var _a;\n    this.delegate = delegate;\n    this.notifyNewProgram = notifyNewProgram;\n    this.getSourceFileVersion = (_a = this.delegate.getSourceFileVersion) == null ? void 0 : _a.bind(this);\n  }\n  get supportsInlineOperations() {\n    return this.delegate.supportsInlineOperations;\n  }\n  getProgram() {\n    return this.delegate.getProgram();\n  }\n  updateFiles(contents, updateMode) {\n    this.delegate.updateFiles(contents, updateMode);\n    this.notifyNewProgram(this.delegate.getProgram());\n  }\n};\nfunction versionMapFromProgram(program, driver) {\n  if (driver.getSourceFileVersion === void 0) {\n    return null;\n  }\n  const versions = /* @__PURE__ */new Map();\n  for (const possiblyRedirectedSourceFile of program.getSourceFiles()) {\n    const sf = toUnredirectedSourceFile(possiblyRedirectedSourceFile);\n    versions.set(absoluteFromSourceFile(sf), driver.getSourceFileVersion(sf));\n  }\n  return versions;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/core/src/host.mjs\nimport ts31 from \"typescript\";\nvar DelegatingCompilerHost2 = class {\n  constructor(delegate) {\n    this.delegate = delegate;\n    this.createHash = this.delegateMethod(\"createHash\");\n    this.directoryExists = this.delegateMethod(\"directoryExists\");\n    this.fileNameToModuleName = this.delegateMethod(\"fileNameToModuleName\");\n    this.getCancellationToken = this.delegateMethod(\"getCancellationToken\");\n    this.getCanonicalFileName = this.delegateMethod(\"getCanonicalFileName\");\n    this.getCurrentDirectory = this.delegateMethod(\"getCurrentDirectory\");\n    this.getDefaultLibFileName = this.delegateMethod(\"getDefaultLibFileName\");\n    this.getDefaultLibLocation = this.delegateMethod(\"getDefaultLibLocation\");\n    this.getDirectories = this.delegateMethod(\"getDirectories\");\n    this.getEnvironmentVariable = this.delegateMethod(\"getEnvironmentVariable\");\n    this.getModifiedResourceFiles = this.delegateMethod(\"getModifiedResourceFiles\");\n    this.getNewLine = this.delegateMethod(\"getNewLine\");\n    this.getParsedCommandLine = this.delegateMethod(\"getParsedCommandLine\");\n    this.getSourceFileByPath = this.delegateMethod(\"getSourceFileByPath\");\n    this.readDirectory = this.delegateMethod(\"readDirectory\");\n    this.readFile = this.delegateMethod(\"readFile\");\n    this.readResource = this.delegateMethod(\"readResource\");\n    this.transformResource = this.delegateMethod(\"transformResource\");\n    this.realpath = this.delegateMethod(\"realpath\");\n    this.resolveModuleNames = this.delegateMethod(\"resolveModuleNames\");\n    this.resolveTypeReferenceDirectives = this.delegateMethod(\"resolveTypeReferenceDirectives\");\n    this.resourceNameToFileName = this.delegateMethod(\"resourceNameToFileName\");\n    this.trace = this.delegateMethod(\"trace\");\n    this.useCaseSensitiveFileNames = this.delegateMethod(\"useCaseSensitiveFileNames\");\n    this.writeFile = this.delegateMethod(\"writeFile\");\n    this.getModuleResolutionCache = this.delegateMethod(\"getModuleResolutionCache\");\n    this.hasInvalidatedResolutions = this.delegateMethod(\"hasInvalidatedResolutions\");\n    this.resolveModuleNameLiterals = this.delegateMethod(\"resolveModuleNameLiterals\");\n    this.resolveTypeReferenceDirectiveReferences = this.delegateMethod(\"resolveTypeReferenceDirectiveReferences\");\n  }\n  delegateMethod(name) {\n    return this.delegate[name] !== void 0 ? this.delegate[name].bind(this.delegate) : void 0;\n  }\n};\nvar NgCompilerHost = class extends DelegatingCompilerHost2 {\n  constructor(delegate, inputFiles, rootDirs, shimAdapter, shimTagger, entryPoint, diagnostics) {\n    super(delegate);\n    this.shimAdapter = shimAdapter;\n    this.shimTagger = shimTagger;\n    this.entryPoint = null;\n    this.entryPoint = entryPoint;\n    this.constructionDiagnostics = diagnostics;\n    this.inputFiles = [...inputFiles, ...shimAdapter.extraInputFiles];\n    this.rootDirs = rootDirs;\n    if (this.resolveModuleNames === void 0) {\n      this.resolveModuleNames = this.createCachedResolveModuleNamesFunction();\n    }\n  }\n  get ignoreForEmit() {\n    return this.shimAdapter.ignoreForEmit;\n  }\n  get shimExtensionPrefixes() {\n    return this.shimAdapter.extensionPrefixes;\n  }\n  postProgramCreationCleanup() {\n    this.shimTagger.finalize();\n  }\n  static wrap(delegate, inputFiles, options, oldProgram) {\n    const topLevelShimGenerators = [];\n    const perFileShimGenerators = [];\n    const rootDirs = getRootDirs(delegate, options);\n    perFileShimGenerators.push(new TypeCheckShimGenerator());\n    let diagnostics = [];\n    const normalizedTsInputFiles = [];\n    for (const inputFile of inputFiles) {\n      if (!isNonDeclarationTsPath(inputFile)) {\n        continue;\n      }\n      normalizedTsInputFiles.push(resolve(inputFile));\n    }\n    let entryPoint = null;\n    if (options.flatModuleOutFile != null && options.flatModuleOutFile !== \"\") {\n      entryPoint = findFlatIndexEntryPoint(normalizedTsInputFiles);\n      if (entryPoint === null) {\n        diagnostics.push({\n          category: ts31.DiagnosticCategory.Error,\n          code: ngErrorCode(ErrorCode.CONFIG_FLAT_MODULE_NO_INDEX),\n          file: void 0,\n          start: void 0,\n          length: void 0,\n          messageText: 'Angular compiler option \"flatModuleOutFile\" requires one and only one .ts file in the \"files\" field.'\n        });\n      } else {\n        const flatModuleId = options.flatModuleId || null;\n        const flatModuleOutFile = normalizeSeparators(options.flatModuleOutFile);\n        const flatIndexGenerator = new FlatIndexGenerator(entryPoint, flatModuleOutFile, flatModuleId);\n        topLevelShimGenerators.push(flatIndexGenerator);\n      }\n    }\n    const shimAdapter = new ShimAdapter(delegate, normalizedTsInputFiles, topLevelShimGenerators, perFileShimGenerators, oldProgram);\n    const shimTagger = new ShimReferenceTagger(perFileShimGenerators.map(gen => gen.extensionPrefix));\n    return new NgCompilerHost(delegate, inputFiles, rootDirs, shimAdapter, shimTagger, entryPoint, diagnostics);\n  }\n  isShim(sf) {\n    return isShim(sf);\n  }\n  isResource(sf) {\n    return false;\n  }\n  getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile) {\n    const shimSf = this.shimAdapter.maybeGenerate(resolve(fileName));\n    if (shimSf !== null) {\n      return shimSf;\n    }\n    const sf = this.delegate.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);\n    if (sf === void 0) {\n      return void 0;\n    }\n    this.shimTagger.tag(sf);\n    return sf;\n  }\n  fileExists(fileName) {\n    return this.delegate.fileExists(fileName) || this.shimAdapter.maybeGenerate(resolve(fileName)) != null;\n  }\n  get unifiedModulesHost() {\n    return this.fileNameToModuleName !== void 0 ? this : null;\n  }\n  createCachedResolveModuleNamesFunction() {\n    const moduleResolutionCache = ts31.createModuleResolutionCache(this.getCurrentDirectory(), this.getCanonicalFileName.bind(this));\n    return (moduleNames, containingFile, reusedNames, redirectedReference, options) => {\n      return moduleNames.map(moduleName => {\n        const module = ts31.resolveModuleName(moduleName, containingFile, options, this, moduleResolutionCache, redirectedReference);\n        return module.resolvedModule;\n      });\n    };\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program.mjs\nvar NgtscProgram = class {\n  constructor(rootNames, options, delegateHost, oldProgram) {\n    this.options = options;\n    const perfRecorder = ActivePerfRecorder.zeroedToNow();\n    perfRecorder.phase(PerfPhase.Setup);\n    if (!options.disableTypeScriptVersionCheck) {\n      verifySupportedTypeScriptVersion();\n    }\n    const reuseProgram = oldProgram == null ? void 0 : oldProgram.compiler.getCurrentProgram();\n    this.host = NgCompilerHost.wrap(delegateHost, rootNames, options, reuseProgram != null ? reuseProgram : null);\n    if (reuseProgram !== void 0) {\n      retagAllTsFiles(reuseProgram);\n    }\n    this.tsProgram = perfRecorder.inPhase(PerfPhase.TypeScriptProgramCreate, () => ts32.createProgram(this.host.inputFiles, options, this.host, reuseProgram));\n    perfRecorder.phase(PerfPhase.Unaccounted);\n    perfRecorder.memory(PerfCheckpoint.TypeScriptProgramCreate);\n    this.host.postProgramCreationCleanup();\n    untagAllTsFiles(this.tsProgram);\n    const programDriver = new TsCreateProgramDriver(this.tsProgram, this.host, this.options, this.host.shimExtensionPrefixes);\n    this.incrementalStrategy = oldProgram !== void 0 ? oldProgram.incrementalStrategy.toNextBuildStrategy() : new TrackedIncrementalBuildStrategy();\n    const modifiedResourceFiles = /* @__PURE__ */new Set();\n    if (this.host.getModifiedResourceFiles !== void 0) {\n      const strings = this.host.getModifiedResourceFiles();\n      if (strings !== void 0) {\n        for (const fileString of strings) {\n          modifiedResourceFiles.add(absoluteFrom(fileString));\n        }\n      }\n    }\n    let ticket;\n    if (oldProgram === void 0) {\n      ticket = freshCompilationTicket(this.tsProgram, options, this.incrementalStrategy, programDriver, perfRecorder, false, false);\n    } else {\n      ticket = incrementalFromCompilerTicket(oldProgram.compiler, this.tsProgram, this.incrementalStrategy, programDriver, modifiedResourceFiles, perfRecorder);\n    }\n    this.compiler = NgCompiler.fromTicket(ticket, this.host);\n  }\n  getTsProgram() {\n    return this.tsProgram;\n  }\n  getReuseTsProgram() {\n    return this.compiler.getCurrentProgram();\n  }\n  getTsOptionDiagnostics(cancellationToken) {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => this.tsProgram.getOptionsDiagnostics(cancellationToken));\n  }\n  getTsSyntacticDiagnostics(sourceFile, cancellationToken) {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n      let res;\n      if (sourceFile !== void 0) {\n        if (ignoredFiles.has(sourceFile)) {\n          return [];\n        }\n        res = this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n      } else {\n        const diagnostics = [];\n        for (const sf of this.tsProgram.getSourceFiles()) {\n          if (!ignoredFiles.has(sf)) {\n            diagnostics.push(...this.tsProgram.getSyntacticDiagnostics(sf, cancellationToken));\n          }\n        }\n        res = diagnostics;\n      }\n      return res;\n    });\n  }\n  getTsSemanticDiagnostics(sourceFile, cancellationToken) {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n      let res;\n      if (sourceFile !== void 0) {\n        if (ignoredFiles.has(sourceFile)) {\n          return [];\n        }\n        res = this.tsProgram.getSemanticDiagnostics(sourceFile, cancellationToken);\n      } else {\n        const diagnostics = [];\n        for (const sf of this.tsProgram.getSourceFiles()) {\n          if (!ignoredFiles.has(sf)) {\n            diagnostics.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n          }\n        }\n        res = diagnostics;\n      }\n      return res;\n    });\n  }\n  getNgOptionDiagnostics(cancellationToken) {\n    return this.compiler.getOptionDiagnostics();\n  }\n  getNgStructuralDiagnostics(cancellationToken) {\n    return [];\n  }\n  getNgSemanticDiagnostics(fileName, cancellationToken) {\n    let sf = void 0;\n    if (fileName !== void 0) {\n      sf = this.tsProgram.getSourceFile(fileName);\n      if (sf === void 0) {\n        return [];\n      }\n    }\n    if (sf === void 0) {\n      return this.compiler.getDiagnostics();\n    } else {\n      return this.compiler.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n    }\n  }\n  loadNgStructureAsync() {\n    return this.compiler.analyzeAsync();\n  }\n  listLazyRoutes(entryRoute) {\n    return [];\n  }\n  emitXi18n() {\n    var _a, _b, _c;\n    const ctx = new MessageBundle(new HtmlParser(), [], {}, (_a = this.options.i18nOutLocale) != null ? _a : null);\n    this.compiler.xi18n(ctx);\n    i18nExtract((_b = this.options.i18nOutFormat) != null ? _b : null, (_c = this.options.i18nOutFile) != null ? _c : null, this.host, this.options, ctx, resolve);\n  }\n  emit(opts) {\n    var _a;\n    if (opts !== void 0 && opts.emitFlags !== void 0 && opts.emitFlags & EmitFlags.I18nBundle) {\n      this.emitXi18n();\n      if (!(opts.emitFlags & EmitFlags.JS)) {\n        return {\n          diagnostics: [],\n          emitSkipped: true,\n          emittedFiles: []\n        };\n      }\n    }\n    const forceEmit = (_a = opts == null ? void 0 : opts.forceEmit) != null ? _a : false;\n    this.compiler.perfRecorder.memory(PerfCheckpoint.PreEmit);\n    const res = this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptEmit, () => {\n      var _a2;\n      const {\n        transformers\n      } = this.compiler.prepareEmit();\n      const ignoreFiles = this.compiler.ignoreForEmit;\n      const emitCallback = (_a2 = opts == null ? void 0 : opts.emitCallback) != null ? _a2 : defaultEmitCallback;\n      const writeFile = (fileName, data, writeByteOrderMark, onError, sourceFiles) => {\n        if (sourceFiles !== void 0) {\n          for (const writtenSf of sourceFiles) {\n            if (writtenSf.isDeclarationFile) {\n              continue;\n            }\n            this.compiler.incrementalCompilation.recordSuccessfulEmit(writtenSf);\n          }\n        }\n        this.host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n      };\n      const customTransforms = opts && opts.customTransformers;\n      const beforeTransforms = transformers.before || [];\n      const afterDeclarationsTransforms = transformers.afterDeclarations;\n      if (customTransforms !== void 0 && customTransforms.beforeTs !== void 0) {\n        beforeTransforms.push(...customTransforms.beforeTs);\n      }\n      const emitResults = [];\n      for (const targetSourceFile of this.tsProgram.getSourceFiles()) {\n        if (targetSourceFile.isDeclarationFile || ignoreFiles.has(targetSourceFile)) {\n          continue;\n        }\n        if (!forceEmit && this.compiler.incrementalCompilation.safeToSkipEmit(targetSourceFile)) {\n          this.compiler.perfRecorder.eventCount(PerfEvent.EmitSkipSourceFile);\n          continue;\n        }\n        this.compiler.perfRecorder.eventCount(PerfEvent.EmitSourceFile);\n        emitResults.push(emitCallback({\n          targetSourceFile,\n          program: this.tsProgram,\n          host: this.host,\n          options: this.options,\n          emitOnlyDtsFiles: false,\n          writeFile,\n          customTransformers: {\n            before: beforeTransforms,\n            after: customTransforms && customTransforms.afterTs,\n            afterDeclarations: afterDeclarationsTransforms\n          }\n        }));\n      }\n      this.compiler.perfRecorder.memory(PerfCheckpoint.Emit);\n      return (opts && opts.mergeEmitResultsCallback || mergeEmitResults)(emitResults);\n    });\n    if (this.options.tracePerformance !== void 0) {\n      const perf = this.compiler.perfRecorder.finalize();\n      getFileSystem().writeFile(getFileSystem().resolve(this.options.tracePerformance), JSON.stringify(perf, null, 2));\n    }\n    return res;\n  }\n  getIndexedComponents() {\n    return this.compiler.getIndexedComponents();\n  }\n  getEmittedSourceFiles() {\n    throw new Error(\"Method not implemented.\");\n  }\n};\nvar defaultEmitCallback = ({\n  program,\n  targetSourceFile,\n  writeFile,\n  cancellationToken,\n  emitOnlyDtsFiles,\n  customTransformers\n}) => program.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\nfunction mergeEmitResults(emitResults) {\n  const diagnostics = [];\n  let emitSkipped = false;\n  const emittedFiles = [];\n  for (const er of emitResults) {\n    diagnostics.push(...er.diagnostics);\n    emitSkipped = emitSkipped || er.emitSkipped;\n    emittedFiles.push(...(er.emittedFiles || []));\n  }\n  return {\n    diagnostics,\n    emitSkipped,\n    emittedFiles\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/program.mjs\nfunction createProgram({\n  rootNames,\n  options,\n  host,\n  oldProgram\n}) {\n  return new NgtscProgram(rootNames, options, host, oldProgram);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/perform_compile.mjs\nimport ts34 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/util.mjs\nimport ts33 from \"typescript\";\nfunction createMessageDiagnostic(messageText) {\n  return {\n    file: void 0,\n    start: void 0,\n    length: void 0,\n    category: ts33.DiagnosticCategory.Message,\n    messageText,\n    code: DEFAULT_ERROR_CODE,\n    source: SOURCE\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/perform_compile.mjs\nvar defaultFormatHost = {\n  getCurrentDirectory: () => ts34.sys.getCurrentDirectory(),\n  getCanonicalFileName: fileName => fileName,\n  getNewLine: () => ts34.sys.newLine\n};\nfunction formatDiagnostics(diags, host = defaultFormatHost) {\n  if (diags && diags.length) {\n    return diags.map(diagnostic => replaceTsWithNgInErrors(ts34.formatDiagnosticsWithColorAndContext([diagnostic], host))).join(\"\");\n  } else {\n    return \"\";\n  }\n}\nfunction calcProjectFileAndBasePath(project, host = getFileSystem()) {\n  const absProject = host.resolve(project);\n  const projectIsDir = host.lstat(absProject).isDirectory();\n  const projectFile = projectIsDir ? host.join(absProject, \"tsconfig.json\") : absProject;\n  const projectDir = projectIsDir ? absProject : host.dirname(absProject);\n  const basePath = host.resolve(projectDir);\n  return {\n    projectFile,\n    basePath\n  };\n}\nfunction readConfiguration(project, existingOptions, host = getFileSystem()) {\n  var _a;\n  try {\n    const fs = getFileSystem();\n    const readConfigFile = configFile => ts34.readConfigFile(configFile, file => host.readFile(host.resolve(file)));\n    const readAngularCompilerOptions = (configFile, parentOptions = {}) => {\n      const {\n        config: config2,\n        error: error2\n      } = readConfigFile(configFile);\n      if (error2) {\n        return parentOptions;\n      }\n      let existingNgCompilerOptions = {\n        ...config2.angularCompilerOptions,\n        ...parentOptions\n      };\n      if (!config2.extends) {\n        return existingNgCompilerOptions;\n      }\n      const extendsPaths = typeof config2.extends === \"string\" ? [config2.extends] : config2.extends;\n      return [...extendsPaths].reverse().reduce((prevOptions, extendsPath) => {\n        const extendedConfigPath = getExtendedConfigPath(configFile, extendsPath, host, fs);\n        return extendedConfigPath === null ? prevOptions : readAngularCompilerOptions(extendedConfigPath, prevOptions);\n      }, existingNgCompilerOptions);\n    };\n    const {\n      projectFile,\n      basePath\n    } = calcProjectFileAndBasePath(project, host);\n    const configFileName = host.resolve(host.pwd(), projectFile);\n    const {\n      config,\n      error\n    } = readConfigFile(projectFile);\n    if (error) {\n      return {\n        project,\n        errors: [error],\n        rootNames: [],\n        options: {},\n        emitFlags: EmitFlags.Default\n      };\n    }\n    const existingCompilerOptions = {\n      genDir: basePath,\n      basePath,\n      ...readAngularCompilerOptions(configFileName),\n      ...existingOptions\n    };\n    const parseConfigHost = createParseConfigHost(host, fs);\n    const {\n      options,\n      errors,\n      fileNames: rootNames,\n      projectReferences\n    } = ts34.parseJsonConfigFileContent(config, parseConfigHost, basePath, existingCompilerOptions, configFileName);\n    let emitFlags = EmitFlags.Default;\n    if (!(options.skipMetadataEmit || options.flatModuleOutFile)) {\n      emitFlags |= EmitFlags.Metadata;\n    }\n    if (options.skipTemplateCodegen) {\n      emitFlags = emitFlags & ~EmitFlags.Codegen;\n    }\n    return {\n      project: projectFile,\n      rootNames,\n      projectReferences,\n      options,\n      errors,\n      emitFlags\n    };\n  } catch (e) {\n    const errors = [{\n      category: ts34.DiagnosticCategory.Error,\n      messageText: (_a = e.stack) != null ? _a : e.message,\n      file: void 0,\n      start: void 0,\n      length: void 0,\n      source: \"angular\",\n      code: UNKNOWN_ERROR_CODE\n    }];\n    return {\n      project: \"\",\n      errors,\n      rootNames: [],\n      options: {},\n      emitFlags: EmitFlags.Default\n    };\n  }\n}\nfunction createParseConfigHost(host, fs = getFileSystem()) {\n  return {\n    fileExists: host.exists.bind(host),\n    readDirectory: ts34.sys.readDirectory,\n    readFile: host.readFile.bind(host),\n    useCaseSensitiveFileNames: fs.isCaseSensitive()\n  };\n}\nfunction getExtendedConfigPath(configFile, extendsValue, host, fs) {\n  const result = getExtendedConfigPathWorker(configFile, extendsValue, host, fs);\n  if (result !== null) {\n    return result;\n  }\n  return getExtendedConfigPathWorker(configFile, `${extendsValue}.json`, host, fs);\n}\nfunction getExtendedConfigPathWorker(configFile, extendsValue, host, fs) {\n  if (extendsValue.startsWith(\".\") || fs.isRooted(extendsValue)) {\n    const extendedConfigPath = host.resolve(host.dirname(configFile), extendsValue);\n    if (host.exists(extendedConfigPath)) {\n      return extendedConfigPath;\n    }\n  } else {\n    const parseConfigHost = createParseConfigHost(host, fs);\n    const {\n      resolvedModule\n    } = ts34.nodeModuleNameResolver(extendsValue, configFile, {\n      moduleResolution: 2,\n      resolveJsonModule: true\n    }, parseConfigHost);\n    if (resolvedModule) {\n      return absoluteFrom(resolvedModule.resolvedFileName);\n    }\n  }\n  return null;\n}\nfunction exitCodeFromResult(diags) {\n  if (!diags) return 0;\n  if (diags.every(diag => diag.category !== ts34.DiagnosticCategory.Error)) {\n    return 0;\n  }\n  return diags.some(d => d.source === \"angular\" && d.code === UNKNOWN_ERROR_CODE) ? 2 : 1;\n}\nfunction performCompilation({\n  rootNames,\n  options,\n  host,\n  oldProgram,\n  emitCallback,\n  mergeEmitResultsCallback,\n  gatherDiagnostics = defaultGatherDiagnostics,\n  customTransformers,\n  emitFlags = EmitFlags.Default,\n  forceEmit = false,\n  modifiedResourceFiles = null\n}) {\n  var _a;\n  let program;\n  let emitResult;\n  let allDiagnostics = [];\n  try {\n    if (!host) {\n      host = createCompilerHost({\n        options\n      });\n    }\n    if (modifiedResourceFiles) {\n      host.getModifiedResourceFiles = () => modifiedResourceFiles;\n    }\n    program = createProgram({\n      rootNames,\n      host,\n      options,\n      oldProgram\n    });\n    const beforeDiags = Date.now();\n    allDiagnostics.push(...gatherDiagnostics(program));\n    if (options.diagnostics) {\n      const afterDiags = Date.now();\n      allDiagnostics.push(createMessageDiagnostic(`Time for diagnostics: ${afterDiags - beforeDiags}ms.`));\n    }\n    if (!hasErrors(allDiagnostics)) {\n      emitResult = program.emit({\n        emitCallback,\n        mergeEmitResultsCallback,\n        customTransformers,\n        emitFlags,\n        forceEmit\n      });\n      allDiagnostics.push(...emitResult.diagnostics);\n      return {\n        diagnostics: allDiagnostics,\n        program,\n        emitResult\n      };\n    }\n    return {\n      diagnostics: allDiagnostics,\n      program\n    };\n  } catch (e) {\n    program = void 0;\n    allDiagnostics.push({\n      category: ts34.DiagnosticCategory.Error,\n      messageText: (_a = e.stack) != null ? _a : e.message,\n      code: UNKNOWN_ERROR_CODE,\n      file: void 0,\n      start: void 0,\n      length: void 0\n    });\n    return {\n      diagnostics: allDiagnostics,\n      program\n    };\n  }\n}\nfunction defaultGatherDiagnostics(program) {\n  const allDiagnostics = [];\n  function checkDiagnostics(diags) {\n    if (diags) {\n      allDiagnostics.push(...diags);\n      return !hasErrors(diags);\n    }\n    return true;\n  }\n  let checkOtherDiagnostics = true;\n  checkOtherDiagnostics = checkOtherDiagnostics && checkDiagnostics([...program.getTsOptionDiagnostics(), ...program.getNgOptionDiagnostics()]);\n  checkOtherDiagnostics = checkOtherDiagnostics && checkDiagnostics(program.getTsSyntacticDiagnostics());\n  checkOtherDiagnostics = checkOtherDiagnostics && checkDiagnostics([...program.getTsSemanticDiagnostics(), ...program.getNgStructuralDiagnostics()]);\n  checkOtherDiagnostics = checkOtherDiagnostics && checkDiagnostics(program.getNgSemanticDiagnostics());\n  return allDiagnostics;\n}\nfunction hasErrors(diags) {\n  return diags.some(d => d.category === ts34.DiagnosticCategory.Error);\n}\nexport { DEFAULT_ERROR_CODE, UNKNOWN_ERROR_CODE, SOURCE, isTsDiagnostic, EmitFlags, createCompilerHost, untagAllTsFiles, TsCreateProgramDriver, PatchedProgramIncrementalBuildStrategy, freshCompilationTicket, incrementalFromStateTicket, NgCompiler, NgCompilerHost, NgtscProgram, createProgram, createMessageDiagnostic, formatDiagnostics, calcProjectFileAndBasePath, readConfiguration, exitCodeFromResult, performCompilation, defaultGatherDiagnostics };\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */","map":{"version":3,"names":["createRequire","__cjsCompatRequire","require","import","meta","url","CompilationMode","CompletionKind","ComponentDecoratorHandler","ComponentScopeKind","CompoundComponentScopeReader","CompoundMetadataReader","CompoundMetadataRegistry","DirectiveDecoratorHandler","DtsMetadataReader","DtsTransformRegistry","ExportedProviderStatusResolver","HostDirectivesResolver","InjectableClassRegistry","InjectableDecoratorHandler","LocalMetadataRegistry","LocalModuleScopeRegistry","MetaKind","MetadataDtsModuleScopeResolver","NgModuleDecoratorHandler","NoopReferencesRegistry","OptimizeFor","PartialEvaluator","PipeDecoratorHandler","PotentialImportKind","PotentialImportMode","ResourceRegistry","SemanticDepGraphUpdater","SymbolKind","TraitCompiler","TypeCheckScopeRegistry","aliasTransformFactory","declarationTransformFactory","ivyTransformFactory","TypeScriptReflectionHost","isNamedClassDeclaration","ImportManager","translateExpression","translateType","AbsoluteModuleStrategy","AliasStrategy","COMPILER_ERRORS_WITH_GUIDES","DefaultImportTracker","ERROR_DETAILS_PAGE_BASE_URL","ErrorCode","ExtendedTemplateDiagnosticName","FatalDiagnosticError","ImportFlags","LocalIdentifierStrategy","LogicalProjectStrategy","ModuleResolver","NoopImportRewriter","PrivateExportAliasingHost","R3SymbolsImportRewriter","Reference","ReferenceEmitter","RelativePathStrategy","UnifiedModulesAliasingHost","UnifiedModulesStrategy","addDiagnosticChain","assertSuccessfulReferenceEmit","getRootDirs","getSourceFileOrNull","getTokenAtPosition","isAssignment","isDtsPath","isNonDeclarationTsPath","isSymbolWithValueDeclaration","makeDiagnostic","makeDiagnosticChain","makeRelatedInformation","ngErrorCode","normalizeSeparators","relativePathBetween","replaceTsWithNgInErrors","toUnredirectedSourceFile","ActivePerfRecorder","DelegatingPerfRecorder","PerfCheckpoint","PerfEvent","PerfPhase","LogicalFileSystem","absoluteFrom","absoluteFromSourceFile","dirname","getFileSystem","getSourceFileOrError","join","resolve","DEFAULT_ERROR_CODE","UNKNOWN_ERROR_CODE","SOURCE","isTsDiagnostic","diagnostic","source","EmitFlags","EmitFlags2","ts","wrapHostForTest","createCompilerHost","options","tsHost","HtmlParser","MessageBundle","ts32","Xliff","Xliff2","Xmb","path","i18nGetExtension","formatName","format","toLowerCase","Error","i18nExtract","outFile","host","bundle","pathResolve","ext","content","i18nSerialize","dstFile","dstPath","outDir","basePath","writeFile","serializer","write","getPathNormalizer","sourcePath","relative","split","sep","ts2","toNumbers","value","suffixIndex","lastIndexOf","slice","length","map","segment","parsed","parseInt","isNaN","compareNumbers","a","b","max","Math","min","i","longestArray","comparisonResult","compareVersions","v1","v2","MIN_TS_VERSION","MAX_TS_VERSION","tsVersion","version","checkVersion","minVersion","maxVersion","verifySupportedTypeScriptVersion","ts30","CycleAnalyzer","constructor","importGraph","cachedResults","wouldCreateCycle","from","to","CycleResults","wouldBeCyclic","Cycle","recordSyntheticImport","addSyntheticImport","NgCyclicResult","Symbol","cyclic","acyclic","sf","cached","getCachedResult","markAcyclic","imports","importsOf","imported","markCyclic","result","getPath","findPath","ts3","ImportGraph","checker","perf","Map","has","set","scanImports","get","start","end","found","Set","queue","Found","current","shift","sourceFile","importedFile","next","toPath","add","push","isLocalFile","inPhase","CycleDetection","stmt","statements","isImportDeclaration","isExportDeclaration","moduleSpecifier","importClause","isTypeOnlyImportClause","symbol","getSymbolAtLocation","valueDeclaration","moduleFile","isSourceFile","isDeclarationFile","node","isTypeOnly","namedBindings","isNamedImports","elements","every","specifier","parent","array","reverse","ts4","FlatIndexGenerator","entryPoint","relativeFlatIndexPath","moduleName","shouldEmit","flatIndexPath","replace","makeTopLevelShim","relativeEntryPoint","contents","genFile","createSourceFile","ScriptTarget","ES2015","ScriptKind","TS","findFlatIndexEntryPoint","rootFiles","tsFiles","filter","file","resolvedEntryPoint","tsFile","basename","ts5","checkForPrivateExports","refGraph","diagnostics","topLevelExports","moduleSymbol","exportedSymbols","getExportsOfModule","forEach","flags","SymbolFlags","Alias","getAliasedSymbol","decl","checkedSet","mainExport","transitiveReferencesOf","transitiveReference","descriptor","getDescriptorOfDeclaration","name","getNameOfDeclaration","visibleVia","transitivePath","pathFrom","seg","category","DiagnosticCategory","code","SYMBOL_NOT_EXPORTED","getSourceFile","getPosOfDeclaration","messageText","getIdentifierOfDeclaration","getStart","getEnd","isClassDeclaration","isVariableDeclaration","isFunctionDeclaration","isIdentifier","id","text","kind","SyntaxKind","ClassDeclaration","FunctionDeclaration","VariableDeclaration","EnumDeclaration","ReferenceGraph","references","target","collectTransitiveReferences","collectPathFrom","seen","candidatePath","edge","partialPath","ref","NgOriginalFile","UpdateMode","UpdateMode2","ts7","ts6","NgExtension","isExtended","sfExtensionData","extSf","extension","isTopLevelShim","fileShim","originalReferencedFiles","taggedReferenceFiles","isFileShimSourceFile","isShim","copyFileShimData","untagAllTsFiles","program","getSourceFiles","untagTsFile","retagAllTsFiles","retagTsFile","referencedFiles","TS_EXTENSIONS","makeShimFileName","fileName","suffix","ShimAdapter","delegate","tsRootFiles","topLevelGenerators","perFileGenerators","oldProgram","shims","priorShims","notShims","generators","ignoreForEmit","extensionPrefixes","gen","pattern","extensionPrefix","regexp","RegExp","generator","test","extraInputFiles","rootFile","oldSf","maybeGenerate","record","match","exec","prefix","baseFileName","inputFile","Latest","generateSpecific","priorShimSf","delete","shimSf","generateShimForFile","generatedFrom","ShimReferenceTagger","shimExtensions","tagged","enabled","suffixes","tag","sfPath","pos","finalize","clear","DelegatingCompilerHost","createHash","delegateMethod","directoryExists","getCancellationToken","getCanonicalFileName","getCurrentDirectory","getDefaultLibFileName","getDefaultLibLocation","getDirectories","getEnvironmentVariable","getNewLine","getParsedCommandLine","getSourceFileByPath","readDirectory","readFile","realpath","resolveModuleNames","resolveTypeReferenceDirectives","trace","useCaseSensitiveFileNames","getModuleResolutionCache","hasInvalidatedResolutions","resolveModuleNameLiterals","resolveTypeReferenceDirectiveReferences","bind","UpdatedProgramHost","sfMap","originalProgram","shimExtensionPrefixes","shimTagger","languageVersion","onError","shouldCreateNewSourceFile","delegateSf","postProgramCreationCleanup","fileExists","TsCreateProgramDriver","originalHost","supportsInlineOperations","getProgram","updateFiles","updateMode","size","Complete","filePath","newText","originalFile","entries","createProgram","rootNames","getRootFileNames","FileDependencyGraph","nodes","addDependency","on","nodeFor","dependsOn","addResourceDependency","resource","usesResources","recordDependencyAnalysisFailure","failedAnalysis","getResourceDependencies","updateWithPhysicalChanges","previous","changedTsPaths","deletedTsPaths","changedResources","logicallyChanged","keys","isLogicallyChanged","dep","IncrementalStateKind","IncrementalStateKind2","PhaseKind","PhaseKind2","IncrementalCompilation","state","depGraph","versions","step","_state","phase","Analysis","semanticDepGraphUpdater","priorState","semanticDepGraph","fresh","Fresh","incremental","newVersions","oldState","modifiedResourceFiles","Reconciliation","physicallyChangedTsFiles","changedResourceFiles","priorAnalysis","Analyzed","Delta","lastAnalyzedState","resourcePath","oldVersions","oldFilesArray","toOriginalSourceFile","oldFiles","deletedTsFiles","possiblyRedirectedNewFile","deletedFileName","logicallyChangedTsFiles","recordSuccessfulAnalysis","traitCompiler","needsEmit","needsTypeCheckEmit","newGraph","emitted","getAnalyzedRecords","typeCheckResults","TypeCheckAndEmit","recordSuccessfulTypeCheck","results","recordSuccessfulEmit","priorAnalysisFor","priorTypeCheckingResultsFor","priorResults","hasInlines","safeToSkipEmit","unredirectedSf","TrackedIncrementalBuildStrategy","isSet","getIncrementalState","setIncrementalState","toNextBuildStrategy","strategy","PatchedProgramIncrementalBuildStrategy","SYM_INCREMENTAL_STATE","IdentifierKind","IdentifierKind2","AbsoluteSourceSpan","IndexingContext","components","addComponent","info","ParseSourceFile","ASTWithSource","ImplicitReceiver","PropertyRead","PropertyWrite","RecursiveAstVisitor","TmplAstElement","TmplAstRecursiveVisitor","TmplAstReference","TmplAstTemplate","ExpressionVisitor","expressionStr","absoluteOffset","boundTemplate","targetToIdentifier","identifiers","errors","getIdentifiers","ast","visitor","visit","visitPropertyRead","context","visitIdentifier","Property","visitPropertyWrite","receiver","identifierStart","sourceSpan","nameSpan","substring","startsWith","absoluteStart","span","targetAst","getExpressionTarget","identifier","TemplateVisitor","targetIdentifierCache","elementAndTemplateIdentifierCache","visitAll","visitElement","element","elementIdentifier","elementOrTemplateToIdentifier","inputs","attributes","children","outputs","visitTemplate","template","templateIdentifier","variables","templateAttrs","visitBoundAttribute","attribute","valueSpan","toString","offset","visitBoundEvent","visitExpression","handler","visitBoundText","visitReference","reference","referenceIdentifier","visitVariable","variable","variableIdentifier","_a","tagName","Template","Element","pop","startSourceSpan","getStartLocation","absoluteSpan","name2","sourceSpan2","Attribute","usedDirectives","getDirectivesOfNode","dir","selector","refTarget","getReferenceTarget","node2","directive","Variable","localStr","includes","indexOf","getTemplateIdentifiers","generateAnalysis","analysis","declaration","templateMeta","getText","usedComponents","usedDirs","getUsedDirectives","isComponent","componentFile","getFullText","templateFile","isInline","NgModuleIndexImpl","metaReader","localReader","ngModuleAuthoritativeReference","typeToExportingModules","indexed","updateWith","cache","key","elem","index","seenTypesWithReexports","locallyDeclaredDirsAndNgModules","getKnown","NgModule","Directive","indexTrait","_b","_c","getDirectiveMetadata","getNgModuleMetadata","childRef","exports","childMeta","getPipeMetadata","Pipe","reexported","getNgModulesExporting","directiveOrPipe","refs","ngModule","ts8","CSS_PREPROCESSOR_EXT","RESOURCE_MARKER","RESOURCE_MARKER_TS","AdapterResourceLoader","adapter","fetching","lookupResolutionHost","createLookupResolutionHost","canPreload","readResource","canPreprocess","transformResource","fromFile","resolvedUrl","resourceNameToFileName","url2","fromFile2","fallbackResolve","preload","_this","type","resourceContext","containingFile","resourceFile","Promise","then","_ref","_asyncToGenerator","str","transformResult","_x","apply","arguments","fetchCompletion","preprocessInline","data","_this2","load","invalidate","candidateLocations","getRootedCandidateLocations","getResolvedCandidateLocations","candidate","cssFallbackUrl","rootDirs","rootDir","failedLookup","resolveModuleName","failedLookupLocations","endsWith","directoryName","StandaloneComponentScopeReader","localModuleReader","dtsModuleReader","getScopeForComponent","clazz","clazzRef","clazzMeta","isStandalone","dependencies","isPoisoned","dirMeta","pipeMeta","ngModuleMeta","ngModuleScope","getScopeOfModule","exported","Standalone","component","Array","schemas","getRemoteScope","CssSelector","DomElementSchemaRegistry","DomElementSchemaRegistry2","ExternalExpr","ExternalExpr2","WrappedNodeExpr","ts9","makeTemplateDiagnostic","templateId","mapping","relatedMessages","relatedInformation","relatedMessage","Message","componentSf","componentClass","componentName","templateUrl","getParsedTemplateSourceFile","e","failureChain","line","col","stack","TemplateSourceFile","parseTemplateAsSourceFile","parseTemplateAsSourceFileForTest","JSX","TEMPLATE_ID","NEXT_TEMPLATE_ID","getTemplateId","allocateTemplateId","EmptyExpr","ImplicitReceiver2","PropertyRead2","PropertyWrite2","SafePropertyRead","TmplAstReference2","TmplAstTextAttribute","ts11","AbsoluteSourceSpan2","ts10","parseSpanComment","readSpanComment","forEachTrailingCommentRange","MultiLineCommentTrivia","commentText","CommentTriviaType","CommentTriviaType2","ExpressionIdentifier","ExpressionIdentifier2","addExpressionIdentifier","addSyntheticTrailingComment","EXPRESSION_TYPE_IDENTIFIER","IGNORE_FOR_DIAGNOSTICS_MARKER","DIAGNOSTIC","markIgnoreDiagnostics","hasIgnoreForDiagnosticsMarker","makeRecursiveVisitor","recursiveVisitor","res","forEachChild","getSpanFromOptions","opts","withSpan","findFirstMatchingNode","tcb","withExpressionIdentifier","comment","hasExpressionIdentifier","findAllMatchingNodes","getChildren","CompletionEngine","tcbPath","tcbIsShim","templateContextCache","expressionCompletionCache","globalRead","isPropertyAccessExpression","COMPONENT_COMPLETION","componentContext","isShimFile","positionInFile","getGlobalCompletions","templateContext","getTemplateContextCompletions","nodeContext","nodeLocation","getExpressionCompletionLocation","expr","tsExpr","ternaryExpr","isParenthesizedExpression","isConditionalExpression","expression","whenTrue","isCallExpression","getLiteralCompletionLocation","strNode","isStringLiteral","n","isNumericLiteral","positionInShimFile","boundTarget","getEntitiesInTemplateScope","ts25","ts12","REGISTRY","REMOVE_XHTML_REGEX","RegistryDomSchemaChecker","_diagnostics","resolver","checkElement","hostIsStandalone","hasElement","getSourceMapping","schemas2","errorMsg","diag","SCHEMA_INVALID_ELEMENT","checkProperty","hasProperty","decorator","SCHEMA_INVALID_ATTRIBUTE","ExpressionType","TypeModifier","ts18","ts13","SAFE_TO_CAST_WITHOUT_PARENS","ParenthesizedExpression","Identifier","CallExpression","NonNullExpression","ElementAccessExpression","PropertyAccessExpression","ArrayLiteralExpression","ObjectLiteralExpression","StringLiteral","NumericLiteral","TrueKeyword","FalseKeyword","NullKeyword","UndefinedKeyword","tsCastToAny","factory","createParenthesizedExpression","createAsExpression","createKeywordTypeNode","AnyKeyword","tsCreateElement","createElement","createPropertyAccessExpression","createIdentifier","createCallExpression","createStringLiteral","tsDeclareVariable","createVariableDeclaration","createNonNullExpression","createNull","createVariableStatement","tsCreateTypeQueryForCoercedInput","typeName","coercedInputName","createTypeQueryNode","createQualifiedName","tsCreateVariable","initializer","tsCallMethod","methodName","args","methodAccess","isAccessExpression","isElementAccessExpression","ts17","ts16","ts15","ts14","INELIGIBLE","canEmitType","canEmit","canEmitTypeWorker","type2","visitNode","isImportTypeNode","isTypeReferenceNode","canEmitTypeReference","typeArguments","TypeEmitter","translator","emitType","typeReferenceTransformer","emitTypeReference","isLiteralExpression","clone","createNumericLiteral","isBigIntLiteral","createBigIntLiteral","isNoSubstitutionTemplateLiteral","createNoSubstitutionTemplateLiteral","rawText","isRegularExpressionLiteral","createRegularExpressionLiteral","setTextRange","visitEachChild","isTypeNode","transform","transformed","translatedType","createNodeArray","typeArg","updateTypeReferenceNode","TypeParameterEmitter","typeParameters","reflector","canEmitReference","typeParam","constraint","default","typeReference","resolveTypeReference","emit","emitReference","emitter","translateTypeReference","defaultType","updateTypeParameterDeclaration","modifiers","right","getDeclarationOfIdentifier","isLocalTypeParameter","owningModule","viaModule","resolutionContext","typeNode","some","param","TcbInliningRequirement","TcbInliningRequirement2","requiresInlineTypeCheckBlock","env","usedPipes","canReferenceType","MustInline","checkIfGenericTypeBoundsCanBeEmitted","ShouldInlineForGenericBounds","pipeRef","None","getTemplateMapping","position","isDiagnosticRequest","sourceLocation","findSourceLocation","toParseSourceSpan","templateSourceMapping","findTypeCheckBlock","getTemplateId2","isDiagnosticsRequest","getFullStart","forEachLeadingCommentRange","generateTypeCtorDeclarationFn","nodeTypeRef","typeParams","rawTypeArgs","generateGenericArgs","rawType","createTypeReferenceNode","initParam","constructTypeCtorParameter","typeParametersWithDefaultTypes","body","fnType","createFunctionTypeNode","fnName","declList","createVariableDeclarationList","NodeFlags","Const","createFunctionDeclaration","createModifier","DeclareKeyword","generateInlineTypeCtor","createBlock","createReturnStatement","createMethodDeclaration","StaticKeyword","initType","plainKeys","coercedKeys","classPropertyName","fields","coercedInputFields","createLiteralTypeNode","createPropertySignature","keyTypeUnion","createUnionTypeNode","coercedLiteral","createTypeLiteralNode","createIntersectionTypeNode","createParameterDeclaration","params","requiresInlineTypeCtor","Environment","config","importManager","refEmitter","contextFile","nextIds","pipeInst","typeCtor","typeCtors","typeCtorStatements","pipeInsts","pipeInstStatements","typeCtorFor","dirRef","typeCtorExpr","referenceType","debugName","queries","emitTypeParameters","fnId","pipeType","pipeInstId","ngExpr","NoAliasing","AllowTypeImports","AllowRelativeDtsImports","referenceExternalType","external","referenceTransplantedType","getPreludeStatements","TmplAstElement2","ts19","OutOfBandDiagnosticRecorderImpl","recordedPipes","missingReferenceTarget","trim","MISSING_REFERENCE_TARGET","missingPipe","MISSING_PIPE","illegalAssignmentToTemplateVar","assignment","WRITE_TO_READ_ONLY_VARIABLE","duplicateTemplateVar","firstDecl","DUPLICATE_VARIABLE_DECLARATION","requiresInlineTcb","makeInlineDiagnostic","INLINE_TCB_REQUIRED","requiresInlineTypeConstructors","directives","message","INLINE_TYPE_CTOR_REQUIRED","suboptimalTypeInference","diagnosticVar","varIdentification","keySpan","Suggestion","SUGGEST_SUBOPTIMAL_TYPE_INFERENCE","splitTwoWayBinding","input","output","inputConsumer","outputConsumer","SPLIT_TWO_WAY_BINDING","missingRequiredInputs","directiveName","inputAliases","MISSING_REQUIRED_INPUTS","ts20","TypeCheckShimGenerator","genFilePath","shimFor","BindingPipe","Call","Call2","DYNAMIC_TYPE","ImplicitReceiver4","PropertyRead4","PropertyWrite3","SafeCall","SafePropertyRead3","ThisReceiver","TmplAstBoundAttribute","TmplAstBoundText","TmplAstElement3","TmplAstIcu","TmplAstReference3","TmplAstTemplate2","TmplAstTextAttribute2","TmplAstVariable","TmplAstVariable2","TransplantedType","ts23","AbsoluteSourceSpan3","ts21","wrapForDiagnostics","wrapForTypeChecker","addParseSpanInfo","addTemplateId","addSyntheticLeadingComment","shouldReportDiagnostic","translateDiagnostic","fullMapping","ASTWithSource2","EmptyExpr2","PropertyRead3","SafeKeyedRead","SafePropertyRead2","ts22","NULL_AS_ANY","UNDEFINED","UNARY_OPS","PlusToken","MinusToken","BINARY_OPS","LessThanToken","GreaterThanToken","LessThanEqualsToken","GreaterThanEqualsToken","EqualsEqualsToken","EqualsEqualsEqualsToken","AsteriskToken","SlashToken","PercentToken","ExclamationEqualsToken","ExclamationEqualsEqualsToken","BarBarToken","AmpersandAmpersandToken","AmpersandToken","BarToken","QuestionQuestionToken","astToTypescript","maybeResolve","AstTranslator","translate","resolved","visitUnary","op","operator","createPrefixUnaryExpression","visitBinary","lhs","left","rhs","operation","createBinaryExpression","visitChain","expressions","createCommaListExpression","visitConditional","condExpr","condition","trueExpr","trueExp","falseExpr","falseExp","createConditionalExpression","visitImplicitReceiver","visitThisReceiver","visitInterpolation","reduce","ast2","visitKeyedRead","createElementAccessExpression","visitKeyedWrite","EqualsToken","visitLiteralArray","literal","createArrayLiteralExpression","strictLiteralTypes","visitLiteralMap","properties","idx","values","createPropertyAssignment","createObjectLiteralExpression","visitLiteralPrimitive","createTrue","createFalse","visitNonNullAssert","visitPipe","visitPrefixNot","createLogicalNot","leftWithPath","visitSafePropertyRead","strictSafeNavigationTypes","VeSafeLhsInferenceBugDetector","veWillInferAnyFor","visitSafeKeyedRead","visitCall","expr2","propertyReceiver","convertToSafeCall","visitSafeCall","call","_VeSafeLhsInferenceBugDetector","SINGLETON","exp","ImplicitReceiver3","RecursiveAstVisitor2","ExpressionSemanticVisitor","oob","TcbGenericContextBehavior","TcbGenericContextBehavior2","generateTypeCheckBlock","domSchemaChecker","oobRecorder","genericContextBehavior","Context","pipes","scope","Scope","forNodes","ctxRawType","useContextGenericType","FallbackToAny","UseEmitter","typeRef","CopyClassNodes","paramList","tcbThisParam","scopeStatements","render","innerBody","createIfStatement","fnDecl","TcbOp","circularFallback","INFER_TYPE_FOR_CIRCULAR_OP_EXPR","TcbElementOp","optional","execute","allocateId","addStatement","TcbVariableOp","ctx","declarationList","declarations","TcbTemplateContextOp","TcbTemplateBodyOp","directiveGuards","dirInstId","dirId","ngTemplateGuards","guard2","boundInput","find","inputName","tcbExpression","guardInvoke","hasNgTemplateContextGuard","applyTemplateContextGuards","suggestionsForSuboptimalTypeInference","guard","dirGuard","tmplScope","tmplBlock","TcbTextInterpolationOp","binding","createExpressionStatement","TcbDirectiveTypeOpBase","isGeneric","DIRECTIVE","TcbNonGenericDirectiveTypeOp","TcbGenericDirectiveTypeWithAnyParamsOp","TcbReferenceOp","checkTypeOfDomReferences","checkTypeOfNonDomReferences","TcbInvalidReferenceOp","TcbDirectiveCtorOp","genericInputs","boundAttrs","getBoundAttributes","attr","checkTypeOfAttributes","fieldName","translateInput","field","tcbCallTypeCtor","TcbDirectiveCtorCircularFallbackOp","TcbDirectiveInputsOp","seenRequiredInputs","widenBinding","required","transformType","dirTypeRef","undeclaredInputFields","honorAccessModifiersForInputBindings","restrictedInputFields","createIndexedAccessTypeNode","temp","stringLiteralInputFields","checkRequiredInputs","missing","bindingPropertyName","circularPlaceholder","TcbDomSchemaCheckerOp","claimedInputs","propertyName","ATTR_TO_PROP","Object","TcbUnclaimedInputsOp","elId","checkTypeOfDomBindings","prop","TcbDirectiveOutputsOp","hasBindingPropertyName","checkTypeOfOutputEvents","isSplitTwoWayBinding","getByBindingPropertyName","outputField","tcbCreateEventHandler","subscribeFn","TcbUnclaimedOutputsOp","claimedOutputs","eventType","checkTypeOfAnimationEvents","checkTypeOfDomEvents","propertyAccess","TcbComponentContextCompletionOp","createThis","ctxDot","nextId","getPipeByName","opQueue","elementOpMap","directiveOpMap","referenceOpMap","templateCtxOpMap","varMap","templateOrNodes","enableTemplateTypeChecker","v","opIndex","appendNode","resolveLocal","isNonNullExpression","setOriginalNode","setSyntheticTrailingComments","skipOptional","executeOp","guards","parentGuards","resolveOp","dirMap","appendDirectivesAndInputsOfNode","appendOutputsOfNode","child","checkAndAppendReferencesOfNode","ctxIndex","checkTemplateBodies","alwaysCheckSchemaInTemplateBodies","appendDeepSchemaChecks","appendIcuExpressions","directiveOp","useInlineTypeConstructors","dirIndex","propertyNames","outputProperty","hasDirectives","vars","placeholder","placeholders","TcbExpressionTranslator","resolveTarget","pipe","arg","checkTypeOfPipes","exprAsAny","method","members","boundInputs","processAttribute","checkTypeOfInputBindings","strictNullInputBindings","isObjectLiteralExpression","isArrayLiteralExpression","EVENT_PARAMETER","event","tcbEventHandlerExpression","eventParamType","eventParam","createArrowFunction","TcbEventHandlerTranslator","input2","getConsumerOfBinding","ts24","TypeCheckFile","compilerHost","nextTcbId","tcbStatements","addTypeCheckBlock","fn","removeComments","getAllImports","qualifier","printer","createPrinter","printNode","EmitHint","Unspecified","InliningMode","InliningMode2","TypeCheckContextImpl","inlining","fileMap","opMap","typeCtorPending","addTemplate","binder","sourceMapping","parseErrors","shouldCheckComponent","fileData","dataForFile","shimData","pendingShimForComponent","sourceManager","templateDiagnostics","getTemplateDiagnostics","InlineOps","dirNode","addInlineTypeCtor","templates","getUsedPipes","inliningRequirement","eventCount","SkipGenerateTcbNoInline","captureSource","GenerateTcb","addInlineTypeCheckBlock","ctorMeta","ops","TypeCtorOp","sort","orderOps","textParts","splitStringAtPoints","splitPoint","omitTrailingSemicolon","updates","originalSf","pendingFileData","pendingShimData","recordShimData","genesisDiagnostics","sfText","tcbMeta","InlineTcbOp","shimPath","getSourceManager","error","TEMPLATE_PARSE_ERROR","msg","im","op1","op2","points","splits","point","ParseLocation","ParseSourceSpan","LF_CHAR","CR_CHAR","LINE_SEP_CHAR","PARAGRAPH_CHAR","getLineAndCharacterFromPosition","lineStartsMap","lineIndex","findClosestLineStartPosition","character","computeLineStartsMap","char","charCodeAt","linesMap","low","high","pivotIdx","floor","pivotEl","TemplateSource","lineStarts","startLoc","toParseLocation","endLoc","acquireLineStarts","TemplateSourceManager","templateSources","templateSource","AST","ASTWithSource3","BindingPipe2","PropertyRead5","PropertyWrite4","SafePropertyRead4","TmplAstBoundAttribute2","TmplAstBoundEvent","TmplAstElement4","TmplAstReference4","TmplAstTemplate3","TmplAstTextAttribute3","TmplAstVariable3","ts26","SymbolBuilder","typeCheckBlock","templateData","componentScopeReader","getTypeChecker","symbolCache","getSymbol","getSymbolOfInputBinding","getSymbolOfBoundEvent","getSymbolOfElement","getSymbolOfAstTemplate","getSymbolOfVariable","getSymbolOfReference","getSymbolOfPipe","getSymbolOfTemplateExpression","templateNode","elementSourceSpan","symbolFromDeclaration","getSymbolOfTsNode","tsSymbol","tcbSourceFile","isDirectiveDeclaration","symbols","getDirectiveMeta","hostDirectives","addHostDirectiveSymbols","directiveSymbol","getDirectiveModule","isStructural","isInScope","isHostDirective","exposedInputs","exposedOutputs","directiveDeclaration","firstChild","isMicrosyntaxTemplate","sourceSpanEqual","firstChildDirectives","concat","m","eventBinding","consumer","expectedAccess","bindingPropertyNames","argumentExpression","outputFieldAccesses","bindings","outputFieldAccess","addEventListener","tsType","getTypeAtLocation","getTcbPositionForNode","Binding","tcbLocation","getDirectiveSymbolForAccessExpression","Output","DomBinding","symbolInfo","Input","expressionSymbol","initializerLocation","localVarLocation","originalDeclaration","isAsExpression","referenceVarTcbLocation","targetLocation","referenceVarLocation","pipeVariableNode","pipeDeclaration","pipeInstance","classSymbol","expressionTarget","anyNodeFilter","whenTrueSymbol","Expression","isQualifiedName","REGISTRY2","TemplateTypeCheckerImpl","programDriver","typeCheckAdapter","priorBuild","localMetaReader","ngModuleIndex","typeCheckScopeRegistry","completionCache","symbolBuilderCache","scopeCache","elementTagCache","isComplete","getTemplate","getLatestComponentState","ensureShimForComponent","fileRecord","getFileData","shimRecord","inlineSf","isTrackedTypeCheckFile","getFileAndShimRecordsForPath","getFileRecordForTcbLocation","records","getTemplateMappingAtTcbLocation","generateAllTypeCheckBlocks","ensureAllShimsForAllFiles","getDiagnosticsForFile","optimizeFor","WholeProgram","SingleFile","ensureAllShimsForOneFile","TtcDiagnostics","typeCheckProgram","getSemanticDiagnostics","convertDiagnostic","getDiagnosticsForComponent","getTypeCheckBlock","engine","getOrCreateCompletionEngine","TtcAutocompletion","invalidateClass","errorCode","__ngCode","maybeAdoptPriorResultsForFile","existingResults","previousResults","ReuseTypeCheckFile","TcbGeneration","WholeProgramTypeCheckingHost","newContext","typeCheck","updateFromContext","SingleFileTypeCheckingHost","SingleShimTypeCheckingHost","clearAllShimDataUsingInlines","shimFile","TcbUpdateProgram","UpdateTypeCheckProgram","Incremental","memory","TtcUpdateProgram","path2","getSymbolOfNode","builder","getOrCreateSymbolBuilder","TtcSymbol","getPotentialTemplateDirectives","typeChecker","inScopeDirectives","getScopeData","resultingDirectives","d","directiveClass","directiveMeta","withScope","scopeDataOfDirectiveMeta","getPotentialPipes","inScopePipes","resultingPipes","p","pipeClass","scopeDataOfPipeMeta","getTypeCheckDirectiveMetadata","module","getPotentialElementTags","tagMap","allKnownElementNames","parse","getPotentialDomBindings","allKnownAttributesOfElement","property","getMappedPropName","getPotentialDomEvents","allKnownEventsOfElement","getPrimaryAngularDecorator","getOwningNgModule","refTo","inContext","emittedRef","isForwardReference","symbolName","getPotentialImportsFor","toImport","importMode","ForceDirect","exportingNgModules","exporter","compilation","dirScope","pipeScope","moduleScopeOfDir","sourceResolver","impl","recordComplete","seenInlines","assertPath","shouldCheckNode","TmplAstBoundEvent2","ASTWithSource4","RecursiveAstVisitor3","TemplateCheckWithVisitor","run","TemplateVisitor2","getDiagnostics","check","visitAllNodes","visitAst","visitContent","visitTextAttribute","visitText","visitIcu","icu","InvalidBananaInBoxCheck","INVALID_BANANA_IN_BOX","boundSyntax","expectedBoundSyntax","create","TmplAstTemplate4","KNOWN_CONTROL_FLOW_DIRECTIVES","MissingControlFlowDirectiveCheck","MISSING_CONTROL_FLOW_DIRECTIVE","componentMetadata","templateTypeChecker","controlFlowAttr","correspondingImport","errorMessage","factory2","TmplAstTemplate5","MissingNgForOfLetCheck","MISSING_NGFOROF_LET","isTemplate","x","errorString","factory3","Binary","ts27","NullishCoalescingNotNullableCheck","NULLISH_COALESCING_NOT_NULLABLE","symbolLeft","typeLeft","TypeFlags","Any","Unknown","getNonNullableType","templateMapping","factory4","strictNullChecks","strict","SafeCall2","SafeKeyedRead2","SafePropertyRead5","ts28","OptionalChainNotNullableCheck","OPTIONAL_CHAIN_NOT_NULLABLE","advice","factory5","TmplAstBoundAttribute3","STYLE_SUFFIXES","SuffixNotSupportedCheck","SUFFIX_NOT_SUPPORTED","factory6","TmplAstTextAttribute4","TextAttributeNotBindingSpec","TEXT_ATTRIBUTE_NOT_BINDING","staticAttr","expectedKey","expectedValue","factory7","ts29","DiagnosticCategoryLabel","DiagnosticCategoryLabel2","ExtendedTemplateCheckerImpl","templateCheckFactories","_d","_e","partialCtx","templateChecks","factory8","diagnosticLabelToCategory","extendedDiagnostics","checks","defaultCategory","Warning","label","Suppress","assertNever","ALL_DIAGNOSTIC_FACTORIES","CompilationTicketKind","CompilationTicketKind2","freshCompilationTicket","tsProgram","incrementalBuildStrategy","perfRecorder","usePoisonedData","zeroedToNow","incrementalFromCompilerTicket","oldCompiler","newProgram","getCurrentProgram","incrementalStrategy","incrementalCompilation","versionMapFromProgram","IncrementalTypeScript","incrementalFromStateTicket","NgCompiler","fromTicket","ticket","IncrementalResource","compiler","updateWithChangedResources","inputProgram","livePerfRecorder","constructionDiagnostics","nonTemplateDiagnostics","delegatingPerfRecorder","_enableTemplateTypeChecker","verifyCompatibleTypeCheckOptions","currentProgram","closureCompilerEnabled","annotateForClosureCompiler","moduleResolutionCache","createModuleResolutionCache","moduleResolver","resourceManager","cycleAnalyzer","ignoreForDiagnostics","dtsFileCount","nonDtsFileCount","InputDtsFile","InputTsFile","ResourceUpdate","classesToUpdate","templateClass","getComponentsWithTemplateFile","styleClass","getComponentsWithStyleFile","updateResources","ensureAnalyzed","getNonTemplateDiagnostics","strictTemplates","getExtendedTemplateDiagnostics","addMessageTextDetails","getTemplateDiagnosticsForFile","ttc","extendedTemplateChecker","err","toDiagnostic","getOptionDiagnostics","getTemplateTypeChecker","templateFilePath","resourceRegistry","getComponentsWithTemplate","styleFilePath","getComponentsWithStyle","getComponentResources","classDecl","styles","getStyles","getMeta","analyzeAsync","_this3","makeCompilation","promises","analysisPromise","all","resolveCompilation","prepareEmit","coreImportsFrom","isCore","getR3SymbolsFile","importRewriter","defaultImportTracker","before","exportStatements","importPreservingTransformer","afterDeclarations","compilationMode","dtsTransforms","aliasingHost","aliasExportsInDts","transformers","getIndexedComponents","xi18n","analyzeSync","Resolve","fullTemplateTypeCheck","getTypeCheckingConfig","typeCheckingConfig","checkQueries","strictInputTypes","strictInputAccessModifiers","strictNullInputTypes","strictOutputEventTypes","strictDomEventTypes","strictDomLocalRefTypes","strictAttributeTypes","strictContextGenerics","exportReferenceGraph","extendedTemplateCheck","sf2","unifiedModulesHost","_useHostForImportGeneration","localImportStrategy","generateDeepReexports","isAngularCorePackage","evaluator","dtsReader","localMetaRegistry","depScopeReader","ngModuleScopeRegistry","standaloneScopeReader","scopeReader","metaRegistry","injectableRegistry","hostDirectivesResolver","exportedProviderStatusResolver","referencesRegistry","ReferenceGraphAdapter","FULL","PARTIAL","LOCAL","cycleHandlingStrategy","strictCtorDeps","strictInjectionParameters","handlers","preserveWhitespaces","i18nUseExternalIds","enableI18nLegacyMessageIdFormat","i18nNormalizeLineEndingsInICUs","onlyPublishPublicTypingsForNgModules","compileNonExportedClasses","notifyingDriver","NotifyingProgramDriverWrapper","scopeRegistry","r3Symbols","isVariableStatement","getModifiers","mod","ExportKeyword","makeConfigDiagnostic","CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK","CONFIG_EXTENDED_DIAGNOSTICS_IMPLIES_STRICT_TEMPLATES","allowedCategoryLabels","CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL","allExtendedDiagnosticNames","checkName","CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CHECK","graph","getOriginalNode","notifyNewProgram","getSourceFileVersion","driver","possiblyRedirectedSourceFile","ts31","DelegatingCompilerHost2","fileNameToModuleName","getModifiedResourceFiles","NgCompilerHost","inputFiles","shimAdapter","createCachedResolveModuleNamesFunction","wrap","topLevelShimGenerators","perFileShimGenerators","normalizedTsInputFiles","flatModuleOutFile","CONFIG_FLAT_MODULE_NO_INDEX","flatModuleId","flatIndexGenerator","isResource","moduleNames","reusedNames","redirectedReference","resolvedModule","NgtscProgram","delegateHost","Setup","disableTypeScriptVersionCheck","reuseProgram","TypeScriptProgramCreate","Unaccounted","strings","fileString","getTsProgram","getReuseTsProgram","getTsOptionDiagnostics","cancellationToken","TypeScriptDiagnostics","getOptionsDiagnostics","getTsSyntacticDiagnostics","ignoredFiles","getSyntacticDiagnostics","getTsSemanticDiagnostics","getNgOptionDiagnostics","getNgStructuralDiagnostics","getNgSemanticDiagnostics","loadNgStructureAsync","listLazyRoutes","entryRoute","emitXi18n","i18nOutLocale","i18nOutFormat","i18nOutFile","emitFlags","I18nBundle","JS","emitSkipped","emittedFiles","forceEmit","PreEmit","TypeScriptEmit","_a2","ignoreFiles","emitCallback","defaultEmitCallback","writeByteOrderMark","sourceFiles","writtenSf","customTransforms","customTransformers","beforeTransforms","afterDeclarationsTransforms","beforeTs","emitResults","targetSourceFile","EmitSkipSourceFile","EmitSourceFile","emitOnlyDtsFiles","after","afterTs","Emit","mergeEmitResultsCallback","mergeEmitResults","tracePerformance","JSON","stringify","getEmittedSourceFiles","er","ts34","ts33","createMessageDiagnostic","defaultFormatHost","sys","newLine","formatDiagnostics","diags","formatDiagnosticsWithColorAndContext","calcProjectFileAndBasePath","project","absProject","projectIsDir","lstat","isDirectory","projectFile","projectDir","readConfiguration","existingOptions","fs","readConfigFile","configFile","readAngularCompilerOptions","parentOptions","config2","error2","existingNgCompilerOptions","angularCompilerOptions","extends","extendsPaths","prevOptions","extendsPath","extendedConfigPath","getExtendedConfigPath","configFileName","pwd","Default","existingCompilerOptions","genDir","parseConfigHost","createParseConfigHost","fileNames","projectReferences","parseJsonConfigFileContent","skipMetadataEmit","Metadata","skipTemplateCodegen","Codegen","exists","isCaseSensitive","extendsValue","getExtendedConfigPathWorker","isRooted","nodeModuleNameResolver","moduleResolution","resolveJsonModule","resolvedFileName","exitCodeFromResult","performCompilation","gatherDiagnostics","defaultGatherDiagnostics","emitResult","allDiagnostics","beforeDiags","Date","now","afterDiags","hasErrors","checkDiagnostics","checkOtherDiagnostics"],"sources":["C:/Users/user/Desktop/SpringBootProject/src/main/resources/my-app/node_modules/@angular/compiler-cli/bundles/chunk-EMELASNB.js"],"sourcesContent":["\n      import {createRequire as __cjsCompatRequire} from 'module';\n      const require = __cjsCompatRequire(import.meta.url);\n    \nimport {\n  CompilationMode,\n  CompletionKind,\n  ComponentDecoratorHandler,\n  ComponentScopeKind,\n  CompoundComponentScopeReader,\n  CompoundMetadataReader,\n  CompoundMetadataRegistry,\n  DirectiveDecoratorHandler,\n  DtsMetadataReader,\n  DtsTransformRegistry,\n  ExportedProviderStatusResolver,\n  HostDirectivesResolver,\n  InjectableClassRegistry,\n  InjectableDecoratorHandler,\n  LocalMetadataRegistry,\n  LocalModuleScopeRegistry,\n  MetaKind,\n  MetadataDtsModuleScopeResolver,\n  NgModuleDecoratorHandler,\n  NoopReferencesRegistry,\n  OptimizeFor,\n  PartialEvaluator,\n  PipeDecoratorHandler,\n  PotentialImportKind,\n  PotentialImportMode,\n  ResourceRegistry,\n  SemanticDepGraphUpdater,\n  SymbolKind,\n  TraitCompiler,\n  TypeCheckScopeRegistry,\n  aliasTransformFactory,\n  declarationTransformFactory,\n  ivyTransformFactory\n} from \"./chunk-JXL4GN5W.js\";\nimport {\n  TypeScriptReflectionHost,\n  isNamedClassDeclaration\n} from \"./chunk-OIJPCKRW.js\";\nimport {\n  ImportManager,\n  translateExpression,\n  translateType\n} from \"./chunk-AAX4HKH5.js\";\nimport {\n  AbsoluteModuleStrategy,\n  AliasStrategy,\n  COMPILER_ERRORS_WITH_GUIDES,\n  DefaultImportTracker,\n  ERROR_DETAILS_PAGE_BASE_URL,\n  ErrorCode,\n  ExtendedTemplateDiagnosticName,\n  FatalDiagnosticError,\n  ImportFlags,\n  LocalIdentifierStrategy,\n  LogicalProjectStrategy,\n  ModuleResolver,\n  NoopImportRewriter,\n  PrivateExportAliasingHost,\n  R3SymbolsImportRewriter,\n  Reference,\n  ReferenceEmitter,\n  RelativePathStrategy,\n  UnifiedModulesAliasingHost,\n  UnifiedModulesStrategy,\n  addDiagnosticChain,\n  assertSuccessfulReferenceEmit,\n  getRootDirs,\n  getSourceFileOrNull,\n  getTokenAtPosition,\n  isAssignment,\n  isDtsPath,\n  isNonDeclarationTsPath,\n  isSymbolWithValueDeclaration,\n  makeDiagnostic,\n  makeDiagnosticChain,\n  makeRelatedInformation,\n  ngErrorCode,\n  normalizeSeparators,\n  relativePathBetween,\n  replaceTsWithNgInErrors,\n  toUnredirectedSourceFile\n} from \"./chunk-KPIJL3UY.js\";\nimport {\n  ActivePerfRecorder,\n  DelegatingPerfRecorder,\n  PerfCheckpoint,\n  PerfEvent,\n  PerfPhase\n} from \"./chunk-HJOPJLIM.js\";\nimport {\n  LogicalFileSystem,\n  absoluteFrom,\n  absoluteFromSourceFile,\n  dirname,\n  getFileSystem,\n  getSourceFileOrError,\n  join,\n  resolve\n} from \"./chunk-EC5K6QPP.js\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/api.mjs\nvar DEFAULT_ERROR_CODE = 100;\nvar UNKNOWN_ERROR_CODE = 500;\nvar SOURCE = \"angular\";\nfunction isTsDiagnostic(diagnostic) {\n  return diagnostic != null && diagnostic.source !== \"angular\";\n}\nvar EmitFlags;\n(function(EmitFlags2) {\n  EmitFlags2[EmitFlags2[\"DTS\"] = 1] = \"DTS\";\n  EmitFlags2[EmitFlags2[\"JS\"] = 2] = \"JS\";\n  EmitFlags2[EmitFlags2[\"Metadata\"] = 4] = \"Metadata\";\n  EmitFlags2[EmitFlags2[\"I18nBundle\"] = 8] = \"I18nBundle\";\n  EmitFlags2[EmitFlags2[\"Codegen\"] = 16] = \"Codegen\";\n  EmitFlags2[EmitFlags2[\"Default\"] = 19] = \"Default\";\n  EmitFlags2[EmitFlags2[\"All\"] = 31] = \"All\";\n})(EmitFlags || (EmitFlags = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/compiler_host.mjs\nimport ts from \"typescript\";\nvar wrapHostForTest = null;\nfunction createCompilerHost({ options, tsHost = ts.createCompilerHost(options, true) }) {\n  if (wrapHostForTest !== null) {\n    tsHost = wrapHostForTest(tsHost);\n  }\n  return tsHost;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program.mjs\nimport { HtmlParser, MessageBundle } from \"@angular/compiler\";\nimport ts32 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/i18n.mjs\nimport { Xliff, Xliff2, Xmb } from \"@angular/compiler\";\nimport * as path from \"path\";\nfunction i18nGetExtension(formatName) {\n  const format = formatName.toLowerCase();\n  switch (format) {\n    case \"xmb\":\n      return \"xmb\";\n    case \"xlf\":\n    case \"xlif\":\n    case \"xliff\":\n    case \"xlf2\":\n    case \"xliff2\":\n      return \"xlf\";\n  }\n  throw new Error(`Unsupported format \"${formatName}\"`);\n}\nfunction i18nExtract(formatName, outFile, host, options, bundle, pathResolve = path.resolve) {\n  formatName = formatName || \"xlf\";\n  const ext = i18nGetExtension(formatName);\n  const content = i18nSerialize(bundle, formatName, options);\n  const dstFile = outFile || `messages.${ext}`;\n  const dstPath = pathResolve(options.outDir || options.basePath, dstFile);\n  host.writeFile(dstPath, content, false, void 0, []);\n  return [dstPath];\n}\nfunction i18nSerialize(bundle, formatName, options) {\n  const format = formatName.toLowerCase();\n  let serializer;\n  switch (format) {\n    case \"xmb\":\n      serializer = new Xmb();\n      break;\n    case \"xliff2\":\n    case \"xlf2\":\n      serializer = new Xliff2();\n      break;\n    case \"xlf\":\n    case \"xliff\":\n    default:\n      serializer = new Xliff();\n  }\n  return bundle.write(serializer, getPathNormalizer(options.basePath));\n}\nfunction getPathNormalizer(basePath) {\n  return (sourcePath) => {\n    sourcePath = basePath ? path.relative(basePath, sourcePath) : sourcePath;\n    return sourcePath.split(path.sep).join(\"/\");\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/typescript_support.mjs\nimport ts2 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/version_helpers.mjs\nfunction toNumbers(value) {\n  const suffixIndex = value.lastIndexOf(\"-\");\n  return value.slice(0, suffixIndex === -1 ? value.length : suffixIndex).split(\".\").map((segment) => {\n    const parsed = parseInt(segment, 10);\n    if (isNaN(parsed)) {\n      throw Error(`Unable to parse version string ${value}.`);\n    }\n    return parsed;\n  });\n}\nfunction compareNumbers(a, b) {\n  const max = Math.max(a.length, b.length);\n  const min = Math.min(a.length, b.length);\n  for (let i = 0; i < min; i++) {\n    if (a[i] > b[i])\n      return 1;\n    if (a[i] < b[i])\n      return -1;\n  }\n  if (min !== max) {\n    const longestArray = a.length === max ? a : b;\n    const comparisonResult = a.length === max ? 1 : -1;\n    for (let i = min; i < max; i++) {\n      if (longestArray[i] > 0) {\n        return comparisonResult;\n      }\n    }\n  }\n  return 0;\n}\nfunction compareVersions(v1, v2) {\n  return compareNumbers(toNumbers(v1), toNumbers(v2));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/typescript_support.mjs\nvar MIN_TS_VERSION = \"4.9.3\";\nvar MAX_TS_VERSION = \"5.2.0\";\nvar tsVersion = ts2.version;\nfunction checkVersion(version, minVersion, maxVersion) {\n  if (compareVersions(version, minVersion) < 0 || compareVersions(version, maxVersion) >= 0) {\n    throw new Error(`The Angular Compiler requires TypeScript >=${minVersion} and <${maxVersion} but ${version} was found instead.`);\n  }\n}\nfunction verifySupportedTypeScriptVersion() {\n  checkVersion(tsVersion, MIN_TS_VERSION, MAX_TS_VERSION);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/core/src/compiler.mjs\nimport ts30 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/cycles/src/analyzer.mjs\nvar CycleAnalyzer = class {\n  constructor(importGraph) {\n    this.importGraph = importGraph;\n    this.cachedResults = null;\n  }\n  wouldCreateCycle(from, to) {\n    if (this.cachedResults === null || this.cachedResults.from !== from) {\n      this.cachedResults = new CycleResults(from, this.importGraph);\n    }\n    return this.cachedResults.wouldBeCyclic(to) ? new Cycle(this.importGraph, from, to) : null;\n  }\n  recordSyntheticImport(from, to) {\n    this.cachedResults = null;\n    this.importGraph.addSyntheticImport(from, to);\n  }\n};\nvar NgCyclicResult = Symbol(\"NgCyclicResult\");\nvar CycleResults = class {\n  constructor(from, importGraph) {\n    this.from = from;\n    this.importGraph = importGraph;\n    this.cyclic = {};\n    this.acyclic = {};\n  }\n  wouldBeCyclic(sf) {\n    const cached = this.getCachedResult(sf);\n    if (cached !== null) {\n      return cached;\n    }\n    if (sf === this.from) {\n      return true;\n    }\n    this.markAcyclic(sf);\n    const imports = this.importGraph.importsOf(sf);\n    for (const imported of imports) {\n      if (this.wouldBeCyclic(imported)) {\n        this.markCyclic(sf);\n        return true;\n      }\n    }\n    return false;\n  }\n  getCachedResult(sf) {\n    const result = sf[NgCyclicResult];\n    if (result === this.cyclic) {\n      return true;\n    } else if (result === this.acyclic) {\n      return false;\n    } else {\n      return null;\n    }\n  }\n  markCyclic(sf) {\n    sf[NgCyclicResult] = this.cyclic;\n  }\n  markAcyclic(sf) {\n    sf[NgCyclicResult] = this.acyclic;\n  }\n};\nvar Cycle = class {\n  constructor(importGraph, from, to) {\n    this.importGraph = importGraph;\n    this.from = from;\n    this.to = to;\n  }\n  getPath() {\n    return [this.from, ...this.importGraph.findPath(this.to, this.from)];\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/cycles/src/imports.mjs\nimport ts3 from \"typescript\";\nvar ImportGraph = class {\n  constructor(checker, perf) {\n    this.checker = checker;\n    this.perf = perf;\n    this.imports = /* @__PURE__ */ new Map();\n  }\n  importsOf(sf) {\n    if (!this.imports.has(sf)) {\n      this.imports.set(sf, this.scanImports(sf));\n    }\n    return this.imports.get(sf);\n  }\n  findPath(start, end) {\n    if (start === end) {\n      return [start];\n    }\n    const found = /* @__PURE__ */ new Set([start]);\n    const queue = [new Found(start, null)];\n    while (queue.length > 0) {\n      const current = queue.shift();\n      const imports = this.importsOf(current.sourceFile);\n      for (const importedFile of imports) {\n        if (!found.has(importedFile)) {\n          const next = new Found(importedFile, current);\n          if (next.sourceFile === end) {\n            return next.toPath();\n          }\n          found.add(importedFile);\n          queue.push(next);\n        }\n      }\n    }\n    return null;\n  }\n  addSyntheticImport(sf, imported) {\n    if (isLocalFile(imported)) {\n      this.importsOf(sf).add(imported);\n    }\n  }\n  scanImports(sf) {\n    return this.perf.inPhase(PerfPhase.CycleDetection, () => {\n      const imports = /* @__PURE__ */ new Set();\n      for (const stmt of sf.statements) {\n        if (!ts3.isImportDeclaration(stmt) && !ts3.isExportDeclaration(stmt) || stmt.moduleSpecifier === void 0) {\n          continue;\n        }\n        if (ts3.isImportDeclaration(stmt) && stmt.importClause !== void 0 && isTypeOnlyImportClause(stmt.importClause)) {\n          continue;\n        }\n        const symbol = this.checker.getSymbolAtLocation(stmt.moduleSpecifier);\n        if (symbol === void 0 || symbol.valueDeclaration === void 0) {\n          continue;\n        }\n        const moduleFile = symbol.valueDeclaration;\n        if (ts3.isSourceFile(moduleFile) && isLocalFile(moduleFile)) {\n          imports.add(moduleFile);\n        }\n      }\n      return imports;\n    });\n  }\n};\nfunction isLocalFile(sf) {\n  return !sf.isDeclarationFile;\n}\nfunction isTypeOnlyImportClause(node) {\n  if (node.isTypeOnly) {\n    return true;\n  }\n  if (node.namedBindings !== void 0 && ts3.isNamedImports(node.namedBindings) && node.namedBindings.elements.every((specifier) => specifier.isTypeOnly)) {\n    return true;\n  }\n  return false;\n}\nvar Found = class {\n  constructor(sourceFile, parent) {\n    this.sourceFile = sourceFile;\n    this.parent = parent;\n  }\n  toPath() {\n    const array = [];\n    let current = this;\n    while (current !== null) {\n      array.push(current.sourceFile);\n      current = current.parent;\n    }\n    return array.reverse();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/entry_point/src/generator.mjs\nimport ts4 from \"typescript\";\nvar FlatIndexGenerator = class {\n  constructor(entryPoint, relativeFlatIndexPath, moduleName) {\n    this.entryPoint = entryPoint;\n    this.moduleName = moduleName;\n    this.shouldEmit = true;\n    this.flatIndexPath = join(dirname(entryPoint), relativeFlatIndexPath).replace(/\\.js$/, \"\") + \".ts\";\n  }\n  makeTopLevelShim() {\n    const relativeEntryPoint = relativePathBetween(this.flatIndexPath, this.entryPoint);\n    const contents = `/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from '${relativeEntryPoint}';\n`;\n    const genFile = ts4.createSourceFile(this.flatIndexPath, contents, ts4.ScriptTarget.ES2015, true, ts4.ScriptKind.TS);\n    if (this.moduleName !== null) {\n      genFile.moduleName = this.moduleName;\n    }\n    return genFile;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/entry_point/src/logic.mjs\nfunction findFlatIndexEntryPoint(rootFiles) {\n  const tsFiles = rootFiles.filter((file) => isNonDeclarationTsPath(file));\n  let resolvedEntryPoint = null;\n  if (tsFiles.length === 1) {\n    resolvedEntryPoint = tsFiles[0];\n  } else {\n    for (const tsFile of tsFiles) {\n      if (getFileSystem().basename(tsFile) === \"index.ts\" && (resolvedEntryPoint === null || tsFile.length <= resolvedEntryPoint.length)) {\n        resolvedEntryPoint = tsFile;\n      }\n    }\n  }\n  return resolvedEntryPoint;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/entry_point/src/private_export_checker.mjs\nimport ts5 from \"typescript\";\nfunction checkForPrivateExports(entryPoint, checker, refGraph) {\n  const diagnostics = [];\n  const topLevelExports = /* @__PURE__ */ new Set();\n  const moduleSymbol = checker.getSymbolAtLocation(entryPoint);\n  if (moduleSymbol === void 0) {\n    throw new Error(`Internal error: failed to get symbol for entrypoint`);\n  }\n  const exportedSymbols = checker.getExportsOfModule(moduleSymbol);\n  exportedSymbols.forEach((symbol) => {\n    if (symbol.flags & ts5.SymbolFlags.Alias) {\n      symbol = checker.getAliasedSymbol(symbol);\n    }\n    const decl = symbol.valueDeclaration;\n    if (decl !== void 0) {\n      topLevelExports.add(decl);\n    }\n  });\n  const checkedSet = /* @__PURE__ */ new Set();\n  topLevelExports.forEach((mainExport) => {\n    refGraph.transitiveReferencesOf(mainExport).forEach((transitiveReference) => {\n      if (checkedSet.has(transitiveReference)) {\n        return;\n      }\n      checkedSet.add(transitiveReference);\n      if (!topLevelExports.has(transitiveReference)) {\n        const descriptor = getDescriptorOfDeclaration(transitiveReference);\n        const name = getNameOfDeclaration(transitiveReference);\n        let visibleVia = \"NgModule exports\";\n        const transitivePath = refGraph.pathFrom(mainExport, transitiveReference);\n        if (transitivePath !== null) {\n          visibleVia = transitivePath.map((seg) => getNameOfDeclaration(seg)).join(\" -> \");\n        }\n        const diagnostic = {\n          category: ts5.DiagnosticCategory.Error,\n          code: ngErrorCode(ErrorCode.SYMBOL_NOT_EXPORTED),\n          file: transitiveReference.getSourceFile(),\n          ...getPosOfDeclaration(transitiveReference),\n          messageText: `Unsupported private ${descriptor} ${name}. This ${descriptor} is visible to consumers via ${visibleVia}, but is not exported from the top-level library entrypoint.`\n        };\n        diagnostics.push(diagnostic);\n      }\n    });\n  });\n  return diagnostics;\n}\nfunction getPosOfDeclaration(decl) {\n  const node = getIdentifierOfDeclaration(decl) || decl;\n  return {\n    start: node.getStart(),\n    length: node.getEnd() + 1 - node.getStart()\n  };\n}\nfunction getIdentifierOfDeclaration(decl) {\n  if ((ts5.isClassDeclaration(decl) || ts5.isVariableDeclaration(decl) || ts5.isFunctionDeclaration(decl)) && decl.name !== void 0 && ts5.isIdentifier(decl.name)) {\n    return decl.name;\n  } else {\n    return null;\n  }\n}\nfunction getNameOfDeclaration(decl) {\n  const id = getIdentifierOfDeclaration(decl);\n  return id !== null ? id.text : \"(unnamed)\";\n}\nfunction getDescriptorOfDeclaration(decl) {\n  switch (decl.kind) {\n    case ts5.SyntaxKind.ClassDeclaration:\n      return \"class\";\n    case ts5.SyntaxKind.FunctionDeclaration:\n      return \"function\";\n    case ts5.SyntaxKind.VariableDeclaration:\n      return \"variable\";\n    case ts5.SyntaxKind.EnumDeclaration:\n      return \"enum\";\n    default:\n      return \"declaration\";\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/entry_point/src/reference_graph.mjs\nvar ReferenceGraph = class {\n  constructor() {\n    this.references = /* @__PURE__ */ new Map();\n  }\n  add(from, to) {\n    if (!this.references.has(from)) {\n      this.references.set(from, /* @__PURE__ */ new Set());\n    }\n    this.references.get(from).add(to);\n  }\n  transitiveReferencesOf(target) {\n    const set = /* @__PURE__ */ new Set();\n    this.collectTransitiveReferences(set, target);\n    return set;\n  }\n  pathFrom(source, target) {\n    return this.collectPathFrom(source, target, /* @__PURE__ */ new Set());\n  }\n  collectPathFrom(source, target, seen) {\n    if (source === target) {\n      return [target];\n    } else if (seen.has(source)) {\n      return null;\n    }\n    seen.add(source);\n    if (!this.references.has(source)) {\n      return null;\n    } else {\n      let candidatePath = null;\n      this.references.get(source).forEach((edge) => {\n        if (candidatePath !== null) {\n          return;\n        }\n        const partialPath = this.collectPathFrom(edge, target, seen);\n        if (partialPath !== null) {\n          candidatePath = [source, ...partialPath];\n        }\n      });\n      return candidatePath;\n    }\n  }\n  collectTransitiveReferences(set, decl) {\n    if (this.references.has(decl)) {\n      this.references.get(decl).forEach((ref) => {\n        if (!set.has(ref)) {\n          set.add(ref);\n          this.collectTransitiveReferences(set, ref);\n        }\n      });\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program_driver/src/api.mjs\nvar NgOriginalFile = Symbol(\"NgOriginalFile\");\nvar UpdateMode;\n(function(UpdateMode2) {\n  UpdateMode2[UpdateMode2[\"Complete\"] = 0] = \"Complete\";\n  UpdateMode2[UpdateMode2[\"Incremental\"] = 1] = \"Incremental\";\n})(UpdateMode || (UpdateMode = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program_driver/src/ts_create_program_driver.mjs\nimport ts7 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/adapter.mjs\nimport ts6 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/expando.mjs\nvar NgExtension = Symbol(\"NgExtension\");\nfunction isExtended(sf) {\n  return sf[NgExtension] !== void 0;\n}\nfunction sfExtensionData(sf) {\n  const extSf = sf;\n  if (extSf[NgExtension] !== void 0) {\n    return extSf[NgExtension];\n  }\n  const extension = {\n    isTopLevelShim: false,\n    fileShim: null,\n    originalReferencedFiles: null,\n    taggedReferenceFiles: null\n  };\n  extSf[NgExtension] = extension;\n  return extension;\n}\nfunction isFileShimSourceFile(sf) {\n  return isExtended(sf) && sf[NgExtension].fileShim !== null;\n}\nfunction isShim(sf) {\n  return isExtended(sf) && (sf[NgExtension].fileShim !== null || sf[NgExtension].isTopLevelShim);\n}\nfunction copyFileShimData(from, to) {\n  if (!isFileShimSourceFile(from)) {\n    return;\n  }\n  sfExtensionData(to).fileShim = sfExtensionData(from).fileShim;\n}\nfunction untagAllTsFiles(program) {\n  for (const sf of program.getSourceFiles()) {\n    untagTsFile(sf);\n  }\n}\nfunction retagAllTsFiles(program) {\n  for (const sf of program.getSourceFiles()) {\n    retagTsFile(sf);\n  }\n}\nfunction untagTsFile(sf) {\n  if (sf.isDeclarationFile || !isExtended(sf)) {\n    return;\n  }\n  const ext = sfExtensionData(sf);\n  if (ext.originalReferencedFiles !== null) {\n    sf.referencedFiles = ext.originalReferencedFiles;\n  }\n}\nfunction retagTsFile(sf) {\n  if (sf.isDeclarationFile || !isExtended(sf)) {\n    return;\n  }\n  const ext = sfExtensionData(sf);\n  if (ext.taggedReferenceFiles !== null) {\n    sf.referencedFiles = ext.taggedReferenceFiles;\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/util.mjs\nvar TS_EXTENSIONS = /\\.tsx?$/i;\nfunction makeShimFileName(fileName, suffix) {\n  return absoluteFrom(fileName.replace(TS_EXTENSIONS, suffix));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/adapter.mjs\nvar ShimAdapter = class {\n  constructor(delegate, tsRootFiles, topLevelGenerators, perFileGenerators, oldProgram) {\n    this.delegate = delegate;\n    this.shims = /* @__PURE__ */ new Map();\n    this.priorShims = /* @__PURE__ */ new Map();\n    this.notShims = /* @__PURE__ */ new Set();\n    this.generators = [];\n    this.ignoreForEmit = /* @__PURE__ */ new Set();\n    this.extensionPrefixes = [];\n    for (const gen of perFileGenerators) {\n      const pattern = `^(.*)\\\\.${gen.extensionPrefix}\\\\.ts$`;\n      const regexp = new RegExp(pattern, \"i\");\n      this.generators.push({\n        generator: gen,\n        test: regexp,\n        suffix: `.${gen.extensionPrefix}.ts`\n      });\n      this.extensionPrefixes.push(gen.extensionPrefix);\n    }\n    const extraInputFiles = [];\n    for (const gen of topLevelGenerators) {\n      const sf = gen.makeTopLevelShim();\n      sfExtensionData(sf).isTopLevelShim = true;\n      if (!gen.shouldEmit) {\n        this.ignoreForEmit.add(sf);\n      }\n      const fileName = absoluteFromSourceFile(sf);\n      this.shims.set(fileName, sf);\n      extraInputFiles.push(fileName);\n    }\n    for (const rootFile of tsRootFiles) {\n      for (const gen of this.generators) {\n        extraInputFiles.push(makeShimFileName(rootFile, gen.suffix));\n      }\n    }\n    this.extraInputFiles = extraInputFiles;\n    if (oldProgram !== null) {\n      for (const oldSf of oldProgram.getSourceFiles()) {\n        if (oldSf.isDeclarationFile || !isFileShimSourceFile(oldSf)) {\n          continue;\n        }\n        this.priorShims.set(absoluteFromSourceFile(oldSf), oldSf);\n      }\n    }\n  }\n  maybeGenerate(fileName) {\n    if (this.notShims.has(fileName)) {\n      return null;\n    } else if (this.shims.has(fileName)) {\n      return this.shims.get(fileName);\n    }\n    if (isDtsPath(fileName)) {\n      this.notShims.add(fileName);\n      return null;\n    }\n    for (const record of this.generators) {\n      const match = record.test.exec(fileName);\n      if (match === null) {\n        continue;\n      }\n      const prefix = match[1];\n      let baseFileName = absoluteFrom(prefix + \".ts\");\n      let inputFile = this.delegate.getSourceFile(baseFileName, ts6.ScriptTarget.Latest);\n      if (inputFile === void 0) {\n        baseFileName = absoluteFrom(prefix + \".tsx\");\n        inputFile = this.delegate.getSourceFile(baseFileName, ts6.ScriptTarget.Latest);\n      }\n      if (inputFile === void 0 || isShim(inputFile)) {\n        return void 0;\n      }\n      return this.generateSpecific(fileName, record.generator, inputFile);\n    }\n    this.notShims.add(fileName);\n    return null;\n  }\n  generateSpecific(fileName, generator, inputFile) {\n    let priorShimSf = null;\n    if (this.priorShims.has(fileName)) {\n      priorShimSf = this.priorShims.get(fileName);\n      this.priorShims.delete(fileName);\n    }\n    const shimSf = generator.generateShimForFile(inputFile, fileName, priorShimSf);\n    sfExtensionData(shimSf).fileShim = {\n      extension: generator.extensionPrefix,\n      generatedFrom: absoluteFromSourceFile(inputFile)\n    };\n    if (!generator.shouldEmit) {\n      this.ignoreForEmit.add(shimSf);\n    }\n    this.shims.set(fileName, shimSf);\n    return shimSf;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/shims/src/reference_tagger.mjs\nvar ShimReferenceTagger = class {\n  constructor(shimExtensions) {\n    this.tagged = /* @__PURE__ */ new Set();\n    this.enabled = true;\n    this.suffixes = shimExtensions.map((extension) => `.${extension}.ts`);\n  }\n  tag(sf) {\n    if (!this.enabled || sf.isDeclarationFile || isShim(sf) || this.tagged.has(sf) || !isNonDeclarationTsPath(sf.fileName)) {\n      return;\n    }\n    const ext = sfExtensionData(sf);\n    if (ext.originalReferencedFiles === null) {\n      ext.originalReferencedFiles = sf.referencedFiles;\n    }\n    const referencedFiles = [...ext.originalReferencedFiles];\n    const sfPath = absoluteFromSourceFile(sf);\n    for (const suffix of this.suffixes) {\n      referencedFiles.push({\n        fileName: makeShimFileName(sfPath, suffix),\n        pos: 0,\n        end: 0\n      });\n    }\n    ext.taggedReferenceFiles = referencedFiles;\n    sf.referencedFiles = referencedFiles;\n    this.tagged.add(sf);\n  }\n  finalize() {\n    this.enabled = false;\n    this.tagged.clear();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program_driver/src/ts_create_program_driver.mjs\nvar DelegatingCompilerHost = class {\n  constructor(delegate) {\n    this.delegate = delegate;\n    this.createHash = this.delegateMethod(\"createHash\");\n    this.directoryExists = this.delegateMethod(\"directoryExists\");\n    this.getCancellationToken = this.delegateMethod(\"getCancellationToken\");\n    this.getCanonicalFileName = this.delegateMethod(\"getCanonicalFileName\");\n    this.getCurrentDirectory = this.delegateMethod(\"getCurrentDirectory\");\n    this.getDefaultLibFileName = this.delegateMethod(\"getDefaultLibFileName\");\n    this.getDefaultLibLocation = this.delegateMethod(\"getDefaultLibLocation\");\n    this.getDirectories = this.delegateMethod(\"getDirectories\");\n    this.getEnvironmentVariable = this.delegateMethod(\"getEnvironmentVariable\");\n    this.getNewLine = this.delegateMethod(\"getNewLine\");\n    this.getParsedCommandLine = this.delegateMethod(\"getParsedCommandLine\");\n    this.getSourceFileByPath = this.delegateMethod(\"getSourceFileByPath\");\n    this.readDirectory = this.delegateMethod(\"readDirectory\");\n    this.readFile = this.delegateMethod(\"readFile\");\n    this.realpath = this.delegateMethod(\"realpath\");\n    this.resolveModuleNames = this.delegateMethod(\"resolveModuleNames\");\n    this.resolveTypeReferenceDirectives = this.delegateMethod(\"resolveTypeReferenceDirectives\");\n    this.trace = this.delegateMethod(\"trace\");\n    this.useCaseSensitiveFileNames = this.delegateMethod(\"useCaseSensitiveFileNames\");\n    this.getModuleResolutionCache = this.delegateMethod(\"getModuleResolutionCache\");\n    this.hasInvalidatedResolutions = this.delegateMethod(\"hasInvalidatedResolutions\");\n    this.resolveModuleNameLiterals = this.delegateMethod(\"resolveModuleNameLiterals\");\n    this.resolveTypeReferenceDirectiveReferences = this.delegateMethod(\"resolveTypeReferenceDirectiveReferences\");\n  }\n  delegateMethod(name) {\n    return this.delegate[name] !== void 0 ? this.delegate[name].bind(this.delegate) : void 0;\n  }\n};\nvar UpdatedProgramHost = class extends DelegatingCompilerHost {\n  constructor(sfMap, originalProgram, delegate, shimExtensionPrefixes) {\n    super(delegate);\n    this.originalProgram = originalProgram;\n    this.shimExtensionPrefixes = shimExtensionPrefixes;\n    this.shimTagger = new ShimReferenceTagger(this.shimExtensionPrefixes);\n    this.sfMap = sfMap;\n  }\n  getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile) {\n    let delegateSf = this.originalProgram.getSourceFile(fileName);\n    if (delegateSf === void 0) {\n      delegateSf = this.delegate.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);\n    }\n    if (delegateSf === void 0) {\n      return void 0;\n    }\n    let sf;\n    if (this.sfMap.has(fileName)) {\n      sf = this.sfMap.get(fileName);\n      copyFileShimData(delegateSf, sf);\n    } else {\n      sf = delegateSf;\n    }\n    sf = toUnredirectedSourceFile(sf);\n    this.shimTagger.tag(sf);\n    return sf;\n  }\n  postProgramCreationCleanup() {\n    this.shimTagger.finalize();\n  }\n  writeFile() {\n    throw new Error(`TypeCheckProgramHost should never write files`);\n  }\n  fileExists(fileName) {\n    return this.sfMap.has(fileName) || this.delegate.fileExists(fileName);\n  }\n};\nvar TsCreateProgramDriver = class {\n  constructor(originalProgram, originalHost, options, shimExtensionPrefixes) {\n    this.originalProgram = originalProgram;\n    this.originalHost = originalHost;\n    this.options = options;\n    this.shimExtensionPrefixes = shimExtensionPrefixes;\n    this.sfMap = /* @__PURE__ */ new Map();\n    this.supportsInlineOperations = true;\n    this.program = this.originalProgram;\n  }\n  getProgram() {\n    return this.program;\n  }\n  updateFiles(contents, updateMode) {\n    if (contents.size === 0) {\n      if (updateMode !== UpdateMode.Complete || this.sfMap.size === 0) {\n        return;\n      }\n    }\n    if (updateMode === UpdateMode.Complete) {\n      this.sfMap.clear();\n    }\n    for (const [filePath, { newText, originalFile }] of contents.entries()) {\n      const sf = ts7.createSourceFile(filePath, newText, ts7.ScriptTarget.Latest, true);\n      if (originalFile !== null) {\n        sf[NgOriginalFile] = originalFile;\n      }\n      this.sfMap.set(filePath, sf);\n    }\n    const host = new UpdatedProgramHost(this.sfMap, this.originalProgram, this.originalHost, this.shimExtensionPrefixes);\n    const oldProgram = this.program;\n    retagAllTsFiles(oldProgram);\n    this.program = ts7.createProgram({\n      host,\n      rootNames: this.program.getRootFileNames(),\n      options: this.options,\n      oldProgram\n    });\n    host.postProgramCreationCleanup();\n    untagAllTsFiles(this.program);\n    untagAllTsFiles(oldProgram);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/src/dependency_tracking.mjs\nvar FileDependencyGraph = class {\n  constructor() {\n    this.nodes = /* @__PURE__ */ new Map();\n  }\n  addDependency(from, on) {\n    this.nodeFor(from).dependsOn.add(absoluteFromSourceFile(on));\n  }\n  addResourceDependency(from, resource) {\n    this.nodeFor(from).usesResources.add(resource);\n  }\n  recordDependencyAnalysisFailure(file) {\n    this.nodeFor(file).failedAnalysis = true;\n  }\n  getResourceDependencies(from) {\n    const node = this.nodes.get(from);\n    return node ? [...node.usesResources] : [];\n  }\n  updateWithPhysicalChanges(previous, changedTsPaths, deletedTsPaths, changedResources) {\n    const logicallyChanged = /* @__PURE__ */ new Set();\n    for (const sf of previous.nodes.keys()) {\n      const sfPath = absoluteFromSourceFile(sf);\n      const node = previous.nodeFor(sf);\n      if (isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources)) {\n        logicallyChanged.add(sfPath);\n      } else if (!deletedTsPaths.has(sfPath)) {\n        this.nodes.set(sf, {\n          dependsOn: new Set(node.dependsOn),\n          usesResources: new Set(node.usesResources),\n          failedAnalysis: false\n        });\n      }\n    }\n    return logicallyChanged;\n  }\n  nodeFor(sf) {\n    if (!this.nodes.has(sf)) {\n      this.nodes.set(sf, {\n        dependsOn: /* @__PURE__ */ new Set(),\n        usesResources: /* @__PURE__ */ new Set(),\n        failedAnalysis: false\n      });\n    }\n    return this.nodes.get(sf);\n  }\n};\nfunction isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources) {\n  if (node.failedAnalysis) {\n    return true;\n  }\n  const sfPath = absoluteFromSourceFile(sf);\n  if (changedTsPaths.has(sfPath) || deletedTsPaths.has(sfPath)) {\n    return true;\n  }\n  for (const dep of node.dependsOn) {\n    if (changedTsPaths.has(dep) || deletedTsPaths.has(dep)) {\n      return true;\n    }\n  }\n  for (const dep of node.usesResources) {\n    if (changedResources.has(dep)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/src/state.mjs\nvar IncrementalStateKind;\n(function(IncrementalStateKind2) {\n  IncrementalStateKind2[IncrementalStateKind2[\"Fresh\"] = 0] = \"Fresh\";\n  IncrementalStateKind2[IncrementalStateKind2[\"Delta\"] = 1] = \"Delta\";\n  IncrementalStateKind2[IncrementalStateKind2[\"Analyzed\"] = 2] = \"Analyzed\";\n})(IncrementalStateKind || (IncrementalStateKind = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/src/incremental.mjs\nvar PhaseKind;\n(function(PhaseKind2) {\n  PhaseKind2[PhaseKind2[\"Analysis\"] = 0] = \"Analysis\";\n  PhaseKind2[PhaseKind2[\"TypeCheckAndEmit\"] = 1] = \"TypeCheckAndEmit\";\n})(PhaseKind || (PhaseKind = {}));\nvar IncrementalCompilation = class {\n  constructor(state, depGraph, versions, step) {\n    this.depGraph = depGraph;\n    this.versions = versions;\n    this.step = step;\n    this._state = state;\n    this.phase = {\n      kind: PhaseKind.Analysis,\n      semanticDepGraphUpdater: new SemanticDepGraphUpdater(step !== null ? step.priorState.semanticDepGraph : null)\n    };\n  }\n  static fresh(program, versions) {\n    const state = {\n      kind: IncrementalStateKind.Fresh\n    };\n    return new IncrementalCompilation(state, new FileDependencyGraph(), versions, null);\n  }\n  static incremental(program, newVersions, oldProgram, oldState, modifiedResourceFiles, perf) {\n    return perf.inPhase(PerfPhase.Reconciliation, () => {\n      const physicallyChangedTsFiles = /* @__PURE__ */ new Set();\n      const changedResourceFiles = new Set(modifiedResourceFiles != null ? modifiedResourceFiles : []);\n      let priorAnalysis;\n      switch (oldState.kind) {\n        case IncrementalStateKind.Fresh:\n          return IncrementalCompilation.fresh(program, newVersions);\n        case IncrementalStateKind.Analyzed:\n          priorAnalysis = oldState;\n          break;\n        case IncrementalStateKind.Delta:\n          priorAnalysis = oldState.lastAnalyzedState;\n          for (const sfPath of oldState.physicallyChangedTsFiles) {\n            physicallyChangedTsFiles.add(sfPath);\n          }\n          for (const resourcePath of oldState.changedResourceFiles) {\n            changedResourceFiles.add(resourcePath);\n          }\n          break;\n      }\n      const oldVersions = priorAnalysis.versions;\n      const oldFilesArray = oldProgram.getSourceFiles().map(toOriginalSourceFile);\n      const oldFiles = new Set(oldFilesArray);\n      const deletedTsFiles = new Set(oldFilesArray.map((sf) => absoluteFromSourceFile(sf)));\n      for (const possiblyRedirectedNewFile of program.getSourceFiles()) {\n        const sf = toOriginalSourceFile(possiblyRedirectedNewFile);\n        const sfPath = absoluteFromSourceFile(sf);\n        deletedTsFiles.delete(sfPath);\n        if (oldFiles.has(sf)) {\n          if (oldVersions === null || newVersions === null) {\n            continue;\n          }\n          if (oldVersions.has(sfPath) && newVersions.has(sfPath) && oldVersions.get(sfPath) === newVersions.get(sfPath)) {\n            continue;\n          }\n        }\n        if (sf.isDeclarationFile) {\n          return IncrementalCompilation.fresh(program, newVersions);\n        }\n        physicallyChangedTsFiles.add(sfPath);\n      }\n      for (const deletedFileName of deletedTsFiles) {\n        physicallyChangedTsFiles.delete(resolve(deletedFileName));\n      }\n      const depGraph = new FileDependencyGraph();\n      const logicallyChangedTsFiles = depGraph.updateWithPhysicalChanges(priorAnalysis.depGraph, physicallyChangedTsFiles, deletedTsFiles, changedResourceFiles);\n      for (const sfPath of physicallyChangedTsFiles) {\n        logicallyChangedTsFiles.add(sfPath);\n      }\n      const state = {\n        kind: IncrementalStateKind.Delta,\n        physicallyChangedTsFiles,\n        changedResourceFiles,\n        lastAnalyzedState: priorAnalysis\n      };\n      return new IncrementalCompilation(state, depGraph, newVersions, {\n        priorState: priorAnalysis,\n        logicallyChangedTsFiles\n      });\n    });\n  }\n  get state() {\n    return this._state;\n  }\n  get semanticDepGraphUpdater() {\n    if (this.phase.kind !== PhaseKind.Analysis) {\n      throw new Error(`AssertionError: Cannot update the SemanticDepGraph after analysis completes`);\n    }\n    return this.phase.semanticDepGraphUpdater;\n  }\n  recordSuccessfulAnalysis(traitCompiler) {\n    if (this.phase.kind !== PhaseKind.Analysis) {\n      throw new Error(`AssertionError: Incremental compilation in phase ${PhaseKind[this.phase.kind]}, expected Analysis`);\n    }\n    const { needsEmit, needsTypeCheckEmit, newGraph } = this.phase.semanticDepGraphUpdater.finalize();\n    let emitted;\n    if (this.step === null) {\n      emitted = /* @__PURE__ */ new Set();\n    } else {\n      emitted = new Set(this.step.priorState.emitted);\n      for (const sfPath of this.step.logicallyChangedTsFiles) {\n        emitted.delete(sfPath);\n      }\n      for (const sfPath of needsEmit) {\n        emitted.delete(sfPath);\n      }\n    }\n    this._state = {\n      kind: IncrementalStateKind.Analyzed,\n      versions: this.versions,\n      depGraph: this.depGraph,\n      semanticDepGraph: newGraph,\n      priorAnalysis: traitCompiler.getAnalyzedRecords(),\n      typeCheckResults: null,\n      emitted\n    };\n    this.phase = {\n      kind: PhaseKind.TypeCheckAndEmit,\n      needsEmit,\n      needsTypeCheckEmit\n    };\n  }\n  recordSuccessfulTypeCheck(results) {\n    if (this._state.kind !== IncrementalStateKind.Analyzed) {\n      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n    } else if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n      throw new Error(`AssertionError: Incremental compilation in phase ${PhaseKind[this.phase.kind]}, expected TypeCheck`);\n    }\n    this._state.typeCheckResults = results;\n  }\n  recordSuccessfulEmit(sf) {\n    if (this._state.kind !== IncrementalStateKind.Analyzed) {\n      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n    }\n    this._state.emitted.add(absoluteFromSourceFile(sf));\n  }\n  priorAnalysisFor(sf) {\n    if (this.step === null) {\n      return null;\n    }\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.step.logicallyChangedTsFiles.has(sfPath)) {\n      return null;\n    }\n    const priorAnalysis = this.step.priorState.priorAnalysis;\n    if (!priorAnalysis.has(sf)) {\n      return null;\n    }\n    return priorAnalysis.get(sf);\n  }\n  priorTypeCheckingResultsFor(sf) {\n    if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n    }\n    if (this.step === null) {\n      return null;\n    }\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.step.logicallyChangedTsFiles.has(sfPath) || this.phase.needsTypeCheckEmit.has(sfPath)) {\n      return null;\n    }\n    if (this.step.priorState.typeCheckResults === null || !this.step.priorState.typeCheckResults.has(sfPath)) {\n      return null;\n    }\n    const priorResults = this.step.priorState.typeCheckResults.get(sfPath);\n    if (priorResults.hasInlines) {\n      return null;\n    }\n    return priorResults;\n  }\n  safeToSkipEmit(sf) {\n    if (this.step === null) {\n      return false;\n    }\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.step.logicallyChangedTsFiles.has(sfPath)) {\n      return false;\n    }\n    if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n      throw new Error(`AssertionError: Expected successful analysis before attempting to emit files`);\n    }\n    if (this.phase.needsEmit.has(sfPath)) {\n      return false;\n    }\n    return this.step.priorState.emitted.has(sfPath);\n  }\n};\nfunction toOriginalSourceFile(sf) {\n  const unredirectedSf = toUnredirectedSourceFile(sf);\n  const originalFile = unredirectedSf[NgOriginalFile];\n  if (originalFile !== void 0) {\n    return originalFile;\n  } else {\n    return unredirectedSf;\n  }\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/src/strategy.mjs\nvar TrackedIncrementalBuildStrategy = class {\n  constructor() {\n    this.state = null;\n    this.isSet = false;\n  }\n  getIncrementalState() {\n    return this.state;\n  }\n  setIncrementalState(state) {\n    this.state = state;\n    this.isSet = true;\n  }\n  toNextBuildStrategy() {\n    const strategy = new TrackedIncrementalBuildStrategy();\n    strategy.state = this.isSet ? this.state : null;\n    return strategy;\n  }\n};\nvar PatchedProgramIncrementalBuildStrategy = class {\n  getIncrementalState(program) {\n    const state = program[SYM_INCREMENTAL_STATE];\n    if (state === void 0) {\n      return null;\n    }\n    return state;\n  }\n  setIncrementalState(state, program) {\n    program[SYM_INCREMENTAL_STATE] = state;\n  }\n  toNextBuildStrategy() {\n    return this;\n  }\n};\nvar SYM_INCREMENTAL_STATE = Symbol(\"NgIncrementalState\");\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/api.mjs\nvar IdentifierKind;\n(function(IdentifierKind2) {\n  IdentifierKind2[IdentifierKind2[\"Property\"] = 0] = \"Property\";\n  IdentifierKind2[IdentifierKind2[\"Method\"] = 1] = \"Method\";\n  IdentifierKind2[IdentifierKind2[\"Element\"] = 2] = \"Element\";\n  IdentifierKind2[IdentifierKind2[\"Template\"] = 3] = \"Template\";\n  IdentifierKind2[IdentifierKind2[\"Attribute\"] = 4] = \"Attribute\";\n  IdentifierKind2[IdentifierKind2[\"Reference\"] = 5] = \"Reference\";\n  IdentifierKind2[IdentifierKind2[\"Variable\"] = 6] = \"Variable\";\n})(IdentifierKind || (IdentifierKind = {}));\nvar AbsoluteSourceSpan = class {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/context.mjs\nvar IndexingContext = class {\n  constructor() {\n    this.components = /* @__PURE__ */ new Set();\n  }\n  addComponent(info) {\n    this.components.add(info);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/transform.mjs\nimport { ParseSourceFile } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/template.mjs\nimport { ASTWithSource, ImplicitReceiver, PropertyRead, PropertyWrite, RecursiveAstVisitor, TmplAstElement, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate } from \"@angular/compiler\";\nvar ExpressionVisitor = class extends RecursiveAstVisitor {\n  constructor(expressionStr, absoluteOffset, boundTemplate, targetToIdentifier) {\n    super();\n    this.expressionStr = expressionStr;\n    this.absoluteOffset = absoluteOffset;\n    this.boundTemplate = boundTemplate;\n    this.targetToIdentifier = targetToIdentifier;\n    this.identifiers = [];\n    this.errors = [];\n  }\n  static getIdentifiers(ast, source, absoluteOffset, boundTemplate, targetToIdentifier) {\n    const visitor = new ExpressionVisitor(source, absoluteOffset, boundTemplate, targetToIdentifier);\n    visitor.visit(ast);\n    return { identifiers: visitor.identifiers, errors: visitor.errors };\n  }\n  visit(ast) {\n    ast.visit(this);\n  }\n  visitPropertyRead(ast, context) {\n    this.visitIdentifier(ast, IdentifierKind.Property);\n    super.visitPropertyRead(ast, context);\n  }\n  visitPropertyWrite(ast, context) {\n    this.visitIdentifier(ast, IdentifierKind.Property);\n    super.visitPropertyWrite(ast, context);\n  }\n  visitIdentifier(ast, kind) {\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n    let identifierStart = ast.sourceSpan.start - this.absoluteOffset;\n    if (ast instanceof PropertyRead || ast instanceof PropertyWrite) {\n      identifierStart = ast.nameSpan.start - this.absoluteOffset;\n    }\n    if (!this.expressionStr.substring(identifierStart).startsWith(ast.name)) {\n      this.errors.push(new Error(`Impossible state: \"${ast.name}\" not found in \"${this.expressionStr}\" at location ${identifierStart}`));\n      return;\n    }\n    const absoluteStart = this.absoluteOffset + identifierStart;\n    const span = new AbsoluteSourceSpan(absoluteStart, absoluteStart + ast.name.length);\n    const targetAst = this.boundTemplate.getExpressionTarget(ast);\n    const target = targetAst ? this.targetToIdentifier(targetAst) : null;\n    const identifier = {\n      name: ast.name,\n      span,\n      kind,\n      target\n    };\n    this.identifiers.push(identifier);\n  }\n};\nvar TemplateVisitor = class extends TmplAstRecursiveVisitor {\n  constructor(boundTemplate) {\n    super();\n    this.boundTemplate = boundTemplate;\n    this.identifiers = /* @__PURE__ */ new Set();\n    this.errors = [];\n    this.targetIdentifierCache = /* @__PURE__ */ new Map();\n    this.elementAndTemplateIdentifierCache = /* @__PURE__ */ new Map();\n  }\n  visit(node) {\n    node.visit(this);\n  }\n  visitAll(nodes) {\n    nodes.forEach((node) => this.visit(node));\n  }\n  visitElement(element) {\n    const elementIdentifier = this.elementOrTemplateToIdentifier(element);\n    if (elementIdentifier !== null) {\n      this.identifiers.add(elementIdentifier);\n    }\n    this.visitAll(element.references);\n    this.visitAll(element.inputs);\n    this.visitAll(element.attributes);\n    this.visitAll(element.children);\n    this.visitAll(element.outputs);\n  }\n  visitTemplate(template) {\n    const templateIdentifier = this.elementOrTemplateToIdentifier(template);\n    if (templateIdentifier !== null) {\n      this.identifiers.add(templateIdentifier);\n    }\n    this.visitAll(template.variables);\n    this.visitAll(template.attributes);\n    this.visitAll(template.templateAttrs);\n    this.visitAll(template.children);\n    this.visitAll(template.references);\n  }\n  visitBoundAttribute(attribute) {\n    if (attribute.valueSpan === void 0) {\n      return;\n    }\n    const { identifiers, errors } = ExpressionVisitor.getIdentifiers(attribute.value, attribute.valueSpan.toString(), attribute.valueSpan.start.offset, this.boundTemplate, this.targetToIdentifier.bind(this));\n    identifiers.forEach((id) => this.identifiers.add(id));\n    this.errors.push(...errors);\n  }\n  visitBoundEvent(attribute) {\n    this.visitExpression(attribute.handler);\n  }\n  visitBoundText(text) {\n    this.visitExpression(text.value);\n  }\n  visitReference(reference) {\n    const referenceIdentifier = this.targetToIdentifier(reference);\n    if (referenceIdentifier === null) {\n      return;\n    }\n    this.identifiers.add(referenceIdentifier);\n  }\n  visitVariable(variable) {\n    const variableIdentifier = this.targetToIdentifier(variable);\n    if (variableIdentifier === null) {\n      return;\n    }\n    this.identifiers.add(variableIdentifier);\n  }\n  elementOrTemplateToIdentifier(node) {\n    var _a;\n    if (this.elementAndTemplateIdentifierCache.has(node)) {\n      return this.elementAndTemplateIdentifierCache.get(node);\n    }\n    let name;\n    let kind;\n    if (node instanceof TmplAstTemplate) {\n      name = (_a = node.tagName) != null ? _a : \"ng-template\";\n      kind = IdentifierKind.Template;\n    } else {\n      name = node.name;\n      kind = IdentifierKind.Element;\n    }\n    if (name.startsWith(\":\")) {\n      name = name.split(\":\").pop();\n    }\n    const sourceSpan = node.startSourceSpan;\n    const start = this.getStartLocation(name, sourceSpan);\n    if (start === null) {\n      return null;\n    }\n    const absoluteSpan = new AbsoluteSourceSpan(start, start + name.length);\n    const attributes = node.attributes.map(({ name: name2, sourceSpan: sourceSpan2 }) => {\n      return {\n        name: name2,\n        span: new AbsoluteSourceSpan(sourceSpan2.start.offset, sourceSpan2.end.offset),\n        kind: IdentifierKind.Attribute\n      };\n    });\n    const usedDirectives = this.boundTemplate.getDirectivesOfNode(node) || [];\n    const identifier = {\n      name,\n      span: absoluteSpan,\n      kind,\n      attributes: new Set(attributes),\n      usedDirectives: new Set(usedDirectives.map((dir) => {\n        return {\n          node: dir.ref.node,\n          selector: dir.selector\n        };\n      }))\n    };\n    this.elementAndTemplateIdentifierCache.set(node, identifier);\n    return identifier;\n  }\n  targetToIdentifier(node) {\n    if (this.targetIdentifierCache.has(node)) {\n      return this.targetIdentifierCache.get(node);\n    }\n    const { name, sourceSpan } = node;\n    const start = this.getStartLocation(name, sourceSpan);\n    if (start === null) {\n      return null;\n    }\n    const span = new AbsoluteSourceSpan(start, start + name.length);\n    let identifier;\n    if (node instanceof TmplAstReference) {\n      const refTarget = this.boundTemplate.getReferenceTarget(node);\n      let target = null;\n      if (refTarget) {\n        let node2 = null;\n        let directive = null;\n        if (refTarget instanceof TmplAstElement || refTarget instanceof TmplAstTemplate) {\n          node2 = this.elementOrTemplateToIdentifier(refTarget);\n        } else {\n          node2 = this.elementOrTemplateToIdentifier(refTarget.node);\n          directive = refTarget.directive.ref.node;\n        }\n        if (node2 === null) {\n          return null;\n        }\n        target = {\n          node: node2,\n          directive\n        };\n      }\n      identifier = {\n        name,\n        span,\n        kind: IdentifierKind.Reference,\n        target\n      };\n    } else {\n      identifier = {\n        name,\n        span,\n        kind: IdentifierKind.Variable\n      };\n    }\n    this.targetIdentifierCache.set(node, identifier);\n    return identifier;\n  }\n  getStartLocation(name, context) {\n    const localStr = context.toString();\n    if (!localStr.includes(name)) {\n      this.errors.push(new Error(`Impossible state: \"${name}\" not found in \"${localStr}\"`));\n      return null;\n    }\n    return context.start.offset + localStr.indexOf(name);\n  }\n  visitExpression(ast) {\n    if (ast instanceof ASTWithSource && ast.source !== null) {\n      const targetToIdentifier = this.targetToIdentifier.bind(this);\n      const absoluteOffset = ast.sourceSpan.start;\n      const { identifiers, errors } = ExpressionVisitor.getIdentifiers(ast, ast.source, absoluteOffset, this.boundTemplate, targetToIdentifier);\n      identifiers.forEach((id) => this.identifiers.add(id));\n      this.errors.push(...errors);\n    }\n  }\n};\nfunction getTemplateIdentifiers(boundTemplate) {\n  const visitor = new TemplateVisitor(boundTemplate);\n  if (boundTemplate.target.template !== void 0) {\n    visitor.visitAll(boundTemplate.target.template);\n  }\n  return { identifiers: visitor.identifiers, errors: visitor.errors };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/indexer/src/transform.mjs\nfunction generateAnalysis(context) {\n  const analysis = /* @__PURE__ */ new Map();\n  context.components.forEach(({ declaration, selector, boundTemplate, templateMeta }) => {\n    const name = declaration.name.getText();\n    const usedComponents = /* @__PURE__ */ new Set();\n    const usedDirs = boundTemplate.getUsedDirectives();\n    usedDirs.forEach((dir) => {\n      if (dir.isComponent) {\n        usedComponents.add(dir.ref.node);\n      }\n    });\n    const componentFile = new ParseSourceFile(declaration.getSourceFile().getFullText(), declaration.getSourceFile().fileName);\n    let templateFile;\n    if (templateMeta.isInline) {\n      templateFile = componentFile;\n    } else {\n      templateFile = templateMeta.file;\n    }\n    const { identifiers, errors } = getTemplateIdentifiers(boundTemplate);\n    analysis.set(declaration, {\n      name,\n      selector,\n      file: componentFile,\n      template: {\n        identifiers,\n        usedComponents,\n        isInline: templateMeta.isInline,\n        file: templateFile\n      },\n      errors\n    });\n  });\n  return analysis;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/ng_module_index.mjs\nvar NgModuleIndexImpl = class {\n  constructor(metaReader, localReader) {\n    this.metaReader = metaReader;\n    this.localReader = localReader;\n    this.ngModuleAuthoritativeReference = /* @__PURE__ */ new Map();\n    this.typeToExportingModules = /* @__PURE__ */ new Map();\n    this.indexed = false;\n  }\n  updateWith(cache, key, elem) {\n    if (cache.has(key)) {\n      cache.get(key).add(elem);\n    } else {\n      const set = /* @__PURE__ */ new Set();\n      set.add(elem);\n      cache.set(key, set);\n    }\n  }\n  index() {\n    const seenTypesWithReexports = /* @__PURE__ */ new Map();\n    const locallyDeclaredDirsAndNgModules = [\n      ...this.localReader.getKnown(MetaKind.NgModule),\n      ...this.localReader.getKnown(MetaKind.Directive)\n    ];\n    for (const decl of locallyDeclaredDirsAndNgModules) {\n      this.indexTrait(new Reference(decl), seenTypesWithReexports);\n    }\n    this.indexed = true;\n  }\n  indexTrait(ref, seenTypesWithReexports) {\n    var _a, _b, _c;\n    if (seenTypesWithReexports.has(ref.node)) {\n      return;\n    }\n    seenTypesWithReexports.set(ref.node, /* @__PURE__ */ new Set());\n    const meta = (_a = this.metaReader.getDirectiveMetadata(ref)) != null ? _a : this.metaReader.getNgModuleMetadata(ref);\n    if (meta === null) {\n      return;\n    }\n    if (meta.imports !== null) {\n      for (const childRef of meta.imports) {\n        this.indexTrait(childRef, seenTypesWithReexports);\n      }\n    }\n    if (meta.kind === MetaKind.NgModule) {\n      if (!this.ngModuleAuthoritativeReference.has(ref.node)) {\n        this.ngModuleAuthoritativeReference.set(ref.node, ref);\n      }\n      for (const childRef of meta.exports) {\n        this.indexTrait(childRef, seenTypesWithReexports);\n        const childMeta = (_c = (_b = this.metaReader.getDirectiveMetadata(childRef)) != null ? _b : this.metaReader.getPipeMetadata(childRef)) != null ? _c : this.metaReader.getNgModuleMetadata(childRef);\n        if (childMeta === null) {\n          continue;\n        }\n        switch (childMeta.kind) {\n          case MetaKind.Directive:\n          case MetaKind.Pipe:\n            this.updateWith(this.typeToExportingModules, childRef.node, ref.node);\n            this.updateWith(seenTypesWithReexports, ref.node, childRef.node);\n            break;\n          case MetaKind.NgModule:\n            if (seenTypesWithReexports.has(childRef.node)) {\n              for (const reexported of seenTypesWithReexports.get(childRef.node)) {\n                this.updateWith(this.typeToExportingModules, reexported, ref.node);\n                this.updateWith(seenTypesWithReexports, ref.node, reexported);\n              }\n            }\n            break;\n        }\n      }\n    }\n  }\n  getNgModulesExporting(directiveOrPipe) {\n    if (!this.indexed) {\n      this.index();\n    }\n    if (!this.typeToExportingModules.has(directiveOrPipe)) {\n      return [];\n    }\n    const refs = [];\n    for (const ngModule of this.typeToExportingModules.get(directiveOrPipe)) {\n      if (this.ngModuleAuthoritativeReference.has(ngModule)) {\n        refs.push(this.ngModuleAuthoritativeReference.get(ngModule));\n      }\n    }\n    return refs;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/resource/src/loader.mjs\nimport ts8 from \"typescript\";\nvar CSS_PREPROCESSOR_EXT = /(\\.scss|\\.sass|\\.less|\\.styl)$/;\nvar RESOURCE_MARKER = \".$ngresource$\";\nvar RESOURCE_MARKER_TS = RESOURCE_MARKER + \".ts\";\nvar AdapterResourceLoader = class {\n  constructor(adapter, options) {\n    this.adapter = adapter;\n    this.options = options;\n    this.cache = /* @__PURE__ */ new Map();\n    this.fetching = /* @__PURE__ */ new Map();\n    this.lookupResolutionHost = createLookupResolutionHost(this.adapter);\n    this.canPreload = !!this.adapter.readResource;\n    this.canPreprocess = !!this.adapter.transformResource;\n  }\n  resolve(url, fromFile) {\n    let resolvedUrl = null;\n    if (this.adapter.resourceNameToFileName) {\n      resolvedUrl = this.adapter.resourceNameToFileName(url, fromFile, (url2, fromFile2) => this.fallbackResolve(url2, fromFile2));\n    } else {\n      resolvedUrl = this.fallbackResolve(url, fromFile);\n    }\n    if (resolvedUrl === null) {\n      throw new Error(`HostResourceResolver: could not resolve ${url} in context of ${fromFile})`);\n    }\n    return resolvedUrl;\n  }\n  preload(resolvedUrl, context) {\n    if (!this.adapter.readResource) {\n      throw new Error(\"HostResourceLoader: the CompilerHost provided does not support pre-loading resources.\");\n    }\n    if (this.cache.has(resolvedUrl)) {\n      return void 0;\n    } else if (this.fetching.has(resolvedUrl)) {\n      return this.fetching.get(resolvedUrl);\n    }\n    let result = this.adapter.readResource(resolvedUrl);\n    if (this.adapter.transformResource && context.type === \"style\") {\n      const resourceContext = {\n        type: \"style\",\n        containingFile: context.containingFile,\n        resourceFile: resolvedUrl\n      };\n      result = Promise.resolve(result).then(async (str) => {\n        const transformResult = await this.adapter.transformResource(str, resourceContext);\n        return transformResult === null ? str : transformResult.content;\n      });\n    }\n    if (typeof result === \"string\") {\n      this.cache.set(resolvedUrl, result);\n      return void 0;\n    } else {\n      const fetchCompletion = result.then((str) => {\n        this.fetching.delete(resolvedUrl);\n        this.cache.set(resolvedUrl, str);\n      });\n      this.fetching.set(resolvedUrl, fetchCompletion);\n      return fetchCompletion;\n    }\n  }\n  async preprocessInline(data, context) {\n    if (!this.adapter.transformResource || context.type !== \"style\") {\n      return data;\n    }\n    const transformResult = await this.adapter.transformResource(data, { type: \"style\", containingFile: context.containingFile, resourceFile: null });\n    if (transformResult === null) {\n      return data;\n    }\n    return transformResult.content;\n  }\n  load(resolvedUrl) {\n    if (this.cache.has(resolvedUrl)) {\n      return this.cache.get(resolvedUrl);\n    }\n    const result = this.adapter.readResource ? this.adapter.readResource(resolvedUrl) : this.adapter.readFile(resolvedUrl);\n    if (typeof result !== \"string\") {\n      throw new Error(`HostResourceLoader: loader(${resolvedUrl}) returned a Promise`);\n    }\n    this.cache.set(resolvedUrl, result);\n    return result;\n  }\n  invalidate() {\n    this.cache.clear();\n  }\n  fallbackResolve(url, fromFile) {\n    let candidateLocations;\n    if (url.startsWith(\"/\")) {\n      candidateLocations = this.getRootedCandidateLocations(url);\n    } else {\n      if (!url.startsWith(\".\")) {\n        url = `./${url}`;\n      }\n      candidateLocations = this.getResolvedCandidateLocations(url, fromFile);\n    }\n    for (const candidate of candidateLocations) {\n      if (this.adapter.fileExists(candidate)) {\n        return candidate;\n      } else if (CSS_PREPROCESSOR_EXT.test(candidate)) {\n        const cssFallbackUrl = candidate.replace(CSS_PREPROCESSOR_EXT, \".css\");\n        if (this.adapter.fileExists(cssFallbackUrl)) {\n          return cssFallbackUrl;\n        }\n      }\n    }\n    return null;\n  }\n  getRootedCandidateLocations(url) {\n    const segment = \".\" + url;\n    return this.adapter.rootDirs.map((rootDir) => join(rootDir, segment));\n  }\n  getResolvedCandidateLocations(url, fromFile) {\n    const failedLookup = ts8.resolveModuleName(url + RESOURCE_MARKER, fromFile, this.options, this.lookupResolutionHost);\n    if (failedLookup.failedLookupLocations === void 0) {\n      throw new Error(`Internal error: expected to find failedLookupLocations during resolution of resource '${url}' in context of ${fromFile}`);\n    }\n    return failedLookup.failedLookupLocations.filter((candidate) => candidate.endsWith(RESOURCE_MARKER_TS)).map((candidate) => candidate.slice(0, -RESOURCE_MARKER_TS.length));\n  }\n};\nfunction createLookupResolutionHost(adapter) {\n  var _a, _b, _c;\n  return {\n    directoryExists(directoryName) {\n      if (directoryName.includes(RESOURCE_MARKER)) {\n        return false;\n      } else if (adapter.directoryExists !== void 0) {\n        return adapter.directoryExists(directoryName);\n      } else {\n        return true;\n      }\n    },\n    fileExists(fileName) {\n      if (fileName.includes(RESOURCE_MARKER)) {\n        return false;\n      } else {\n        return adapter.fileExists(fileName);\n      }\n    },\n    readFile: adapter.readFile.bind(adapter),\n    getCurrentDirectory: adapter.getCurrentDirectory.bind(adapter),\n    getDirectories: (_a = adapter.getDirectories) == null ? void 0 : _a.bind(adapter),\n    realpath: (_b = adapter.realpath) == null ? void 0 : _b.bind(adapter),\n    trace: (_c = adapter.trace) == null ? void 0 : _c.bind(adapter),\n    useCaseSensitiveFileNames: typeof adapter.useCaseSensitiveFileNames === \"function\" ? adapter.useCaseSensitiveFileNames.bind(adapter) : adapter.useCaseSensitiveFileNames\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/scope/src/standalone.mjs\nvar StandaloneComponentScopeReader = class {\n  constructor(metaReader, localModuleReader, dtsModuleReader) {\n    this.metaReader = metaReader;\n    this.localModuleReader = localModuleReader;\n    this.dtsModuleReader = dtsModuleReader;\n    this.cache = /* @__PURE__ */ new Map();\n  }\n  getScopeForComponent(clazz) {\n    var _a;\n    if (!this.cache.has(clazz)) {\n      const clazzRef = new Reference(clazz);\n      const clazzMeta = this.metaReader.getDirectiveMetadata(clazzRef);\n      if (clazzMeta === null || !clazzMeta.isComponent || !clazzMeta.isStandalone) {\n        this.cache.set(clazz, null);\n        return null;\n      }\n      const dependencies = /* @__PURE__ */ new Set([clazzMeta]);\n      const seen = /* @__PURE__ */ new Set([clazz]);\n      let isPoisoned = clazzMeta.isPoisoned;\n      if (clazzMeta.imports !== null) {\n        for (const ref of clazzMeta.imports) {\n          if (seen.has(ref.node)) {\n            continue;\n          }\n          seen.add(ref.node);\n          const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n          if (dirMeta !== null) {\n            dependencies.add({ ...dirMeta, ref });\n            isPoisoned = isPoisoned || dirMeta.isPoisoned || !dirMeta.isStandalone;\n            continue;\n          }\n          const pipeMeta = this.metaReader.getPipeMetadata(ref);\n          if (pipeMeta !== null) {\n            dependencies.add({ ...pipeMeta, ref });\n            isPoisoned = isPoisoned || !pipeMeta.isStandalone;\n            continue;\n          }\n          const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);\n          if (ngModuleMeta !== null) {\n            dependencies.add({ ...ngModuleMeta, ref });\n            let ngModuleScope;\n            if (ref.node.getSourceFile().isDeclarationFile) {\n              ngModuleScope = this.dtsModuleReader.resolve(ref);\n            } else {\n              ngModuleScope = this.localModuleReader.getScopeOfModule(ref.node);\n            }\n            if (ngModuleScope === null) {\n              isPoisoned = true;\n              continue;\n            }\n            isPoisoned = isPoisoned || ngModuleScope.exported.isPoisoned;\n            for (const dep of ngModuleScope.exported.dependencies) {\n              if (!seen.has(dep.ref.node)) {\n                seen.add(dep.ref.node);\n                dependencies.add(dep);\n              }\n            }\n            continue;\n          }\n          isPoisoned = true;\n        }\n      }\n      this.cache.set(clazz, {\n        kind: ComponentScopeKind.Standalone,\n        component: clazz,\n        dependencies: Array.from(dependencies),\n        isPoisoned,\n        schemas: (_a = clazzMeta.schemas) != null ? _a : []\n      });\n    }\n    return this.cache.get(clazz);\n  }\n  getRemoteScope() {\n    return null;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/checker.mjs\nimport { CssSelector, DomElementSchemaRegistry as DomElementSchemaRegistry2, ExternalExpr as ExternalExpr2, WrappedNodeExpr } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/diagnostics/src/diagnostic.mjs\nimport ts9 from \"typescript\";\nfunction makeTemplateDiagnostic(templateId, mapping, span, category, code, messageText, relatedMessages) {\n  var _a;\n  if (mapping.type === \"direct\") {\n    let relatedInformation = void 0;\n    if (relatedMessages !== void 0) {\n      relatedInformation = [];\n      for (const relatedMessage of relatedMessages) {\n        relatedInformation.push({\n          category: ts9.DiagnosticCategory.Message,\n          code: 0,\n          file: relatedMessage.sourceFile,\n          start: relatedMessage.start,\n          length: relatedMessage.end - relatedMessage.start,\n          messageText: relatedMessage.text\n        });\n      }\n    }\n    return {\n      source: \"ngtsc\",\n      code,\n      category,\n      messageText,\n      file: mapping.node.getSourceFile(),\n      componentFile: mapping.node.getSourceFile(),\n      templateId,\n      start: span.start.offset,\n      length: span.end.offset - span.start.offset,\n      relatedInformation\n    };\n  } else if (mapping.type === \"indirect\" || mapping.type === \"external\") {\n    const componentSf = mapping.componentClass.getSourceFile();\n    const componentName = mapping.componentClass.name.text;\n    const fileName = mapping.type === \"indirect\" ? `${componentSf.fileName} (${componentName} template)` : mapping.templateUrl;\n    let relatedInformation = [];\n    if (relatedMessages !== void 0) {\n      for (const relatedMessage of relatedMessages) {\n        relatedInformation.push({\n          category: ts9.DiagnosticCategory.Message,\n          code: 0,\n          file: relatedMessage.sourceFile,\n          start: relatedMessage.start,\n          length: relatedMessage.end - relatedMessage.start,\n          messageText: relatedMessage.text\n        });\n      }\n    }\n    let sf;\n    try {\n      sf = getParsedTemplateSourceFile(fileName, mapping);\n    } catch (e) {\n      const failureChain = makeDiagnosticChain(`Failed to report an error in '${fileName}' at ${span.start.line + 1}:${span.start.col + 1}`, [\n        makeDiagnosticChain((_a = e == null ? void 0 : e.stack) != null ? _a : `${e}`)\n      ]);\n      return {\n        source: \"ngtsc\",\n        category,\n        code,\n        messageText: addDiagnosticChain(messageText, [failureChain]),\n        file: componentSf,\n        componentFile: componentSf,\n        templateId,\n        start: mapping.node.getStart(),\n        length: mapping.node.getEnd() - mapping.node.getStart(),\n        relatedInformation\n      };\n    }\n    relatedInformation.push({\n      category: ts9.DiagnosticCategory.Message,\n      code: 0,\n      file: componentSf,\n      start: mapping.node.getStart(),\n      length: mapping.node.getEnd() - mapping.node.getStart(),\n      messageText: `Error occurs in the template of component ${componentName}.`\n    });\n    return {\n      source: \"ngtsc\",\n      category,\n      code,\n      messageText,\n      file: sf,\n      componentFile: componentSf,\n      templateId,\n      start: span.start.offset,\n      length: span.end.offset - span.start.offset,\n      relatedInformation\n    };\n  } else {\n    throw new Error(`Unexpected source mapping type: ${mapping.type}`);\n  }\n}\nvar TemplateSourceFile = Symbol(\"TemplateSourceFile\");\nfunction getParsedTemplateSourceFile(fileName, mapping) {\n  if (mapping[TemplateSourceFile] === void 0) {\n    mapping[TemplateSourceFile] = parseTemplateAsSourceFile(fileName, mapping.template);\n  }\n  return mapping[TemplateSourceFile];\n}\nvar parseTemplateAsSourceFileForTest = null;\nfunction parseTemplateAsSourceFile(fileName, template) {\n  if (parseTemplateAsSourceFileForTest !== null) {\n    return parseTemplateAsSourceFileForTest(fileName, template);\n  }\n  return ts9.createSourceFile(fileName, template, ts9.ScriptTarget.Latest, false, ts9.ScriptKind.JSX);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/diagnostics/src/id.mjs\nvar TEMPLATE_ID = Symbol(\"ngTemplateId\");\nvar NEXT_TEMPLATE_ID = Symbol(\"ngNextTemplateId\");\nfunction getTemplateId(clazz) {\n  const node = clazz;\n  if (node[TEMPLATE_ID] === void 0) {\n    node[TEMPLATE_ID] = allocateTemplateId(node.getSourceFile());\n  }\n  return node[TEMPLATE_ID];\n}\nfunction allocateTemplateId(sf) {\n  if (sf[NEXT_TEMPLATE_ID] === void 0) {\n    sf[NEXT_TEMPLATE_ID] = 1;\n  }\n  return `tcb${sf[NEXT_TEMPLATE_ID]++}`;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/completion.mjs\nimport { EmptyExpr, ImplicitReceiver as ImplicitReceiver2, PropertyRead as PropertyRead2, PropertyWrite as PropertyWrite2, SafePropertyRead, TmplAstReference as TmplAstReference2, TmplAstTextAttribute } from \"@angular/compiler\";\nimport ts11 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/comments.mjs\nimport { AbsoluteSourceSpan as AbsoluteSourceSpan2 } from \"@angular/compiler\";\nimport ts10 from \"typescript\";\nvar parseSpanComment = /^(\\d+),(\\d+)$/;\nfunction readSpanComment(node, sourceFile = node.getSourceFile()) {\n  return ts10.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts10.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    const match = commentText.match(parseSpanComment);\n    if (match === null) {\n      return null;\n    }\n    return new AbsoluteSourceSpan2(+match[1], +match[2]);\n  }) || null;\n}\nvar CommentTriviaType;\n(function(CommentTriviaType2) {\n  CommentTriviaType2[\"DIAGNOSTIC\"] = \"D\";\n  CommentTriviaType2[\"EXPRESSION_TYPE_IDENTIFIER\"] = \"T\";\n})(CommentTriviaType || (CommentTriviaType = {}));\nvar ExpressionIdentifier;\n(function(ExpressionIdentifier2) {\n  ExpressionIdentifier2[\"DIRECTIVE\"] = \"DIR\";\n  ExpressionIdentifier2[\"COMPONENT_COMPLETION\"] = \"COMPCOMP\";\n  ExpressionIdentifier2[\"EVENT_PARAMETER\"] = \"EP\";\n})(ExpressionIdentifier || (ExpressionIdentifier = {}));\nfunction addExpressionIdentifier(node, identifier) {\n  ts10.addSyntheticTrailingComment(\n    node,\n    ts10.SyntaxKind.MultiLineCommentTrivia,\n    `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`,\n    false\n  );\n}\nvar IGNORE_FOR_DIAGNOSTICS_MARKER = `${CommentTriviaType.DIAGNOSTIC}:ignore`;\nfunction markIgnoreDiagnostics(node) {\n  ts10.addSyntheticTrailingComment(\n    node,\n    ts10.SyntaxKind.MultiLineCommentTrivia,\n    IGNORE_FOR_DIAGNOSTICS_MARKER,\n    false\n  );\n}\nfunction hasIgnoreForDiagnosticsMarker(node, sourceFile) {\n  return ts10.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts10.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText === IGNORE_FOR_DIAGNOSTICS_MARKER;\n  }) === true;\n}\nfunction makeRecursiveVisitor(visitor) {\n  function recursiveVisitor(node) {\n    const res = visitor(node);\n    return res !== null ? res : node.forEachChild(recursiveVisitor);\n  }\n  return recursiveVisitor;\n}\nfunction getSpanFromOptions(opts) {\n  let withSpan = null;\n  if (opts.withSpan !== void 0) {\n    if (opts.withSpan instanceof AbsoluteSourceSpan2) {\n      withSpan = opts.withSpan;\n    } else {\n      withSpan = { start: opts.withSpan.start.offset, end: opts.withSpan.end.offset };\n    }\n  }\n  return withSpan;\n}\nfunction findFirstMatchingNode(tcb, opts) {\n  var _a;\n  const withSpan = getSpanFromOptions(opts);\n  const withExpressionIdentifier = opts.withExpressionIdentifier;\n  const sf = tcb.getSourceFile();\n  const visitor = makeRecursiveVisitor((node) => {\n    if (!opts.filter(node)) {\n      return null;\n    }\n    if (withSpan !== null) {\n      const comment = readSpanComment(node, sf);\n      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n        return null;\n      }\n    }\n    if (withExpressionIdentifier !== void 0 && !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n      return null;\n    }\n    return node;\n  });\n  return (_a = tcb.forEachChild(visitor)) != null ? _a : null;\n}\nfunction findAllMatchingNodes(tcb, opts) {\n  const withSpan = getSpanFromOptions(opts);\n  const withExpressionIdentifier = opts.withExpressionIdentifier;\n  const results = [];\n  const stack = [tcb];\n  const sf = tcb.getSourceFile();\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (!opts.filter(node)) {\n      stack.push(...node.getChildren());\n      continue;\n    }\n    if (withSpan !== null) {\n      const comment = readSpanComment(node, sf);\n      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n        stack.push(...node.getChildren());\n        continue;\n      }\n    }\n    if (withExpressionIdentifier !== void 0 && !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n      continue;\n    }\n    results.push(node);\n  }\n  return results;\n}\nfunction hasExpressionIdentifier(sourceFile, node, identifier) {\n  return ts10.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts10.SyntaxKind.MultiLineCommentTrivia) {\n      return false;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText === `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`;\n  }) || false;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/completion.mjs\nvar CompletionEngine = class {\n  constructor(tcb, data, tcbPath, tcbIsShim) {\n    this.tcb = tcb;\n    this.data = data;\n    this.tcbPath = tcbPath;\n    this.tcbIsShim = tcbIsShim;\n    this.templateContextCache = /* @__PURE__ */ new Map();\n    this.expressionCompletionCache = /* @__PURE__ */ new Map();\n    const globalRead = findFirstMatchingNode(this.tcb, {\n      filter: ts11.isPropertyAccessExpression,\n      withExpressionIdentifier: ExpressionIdentifier.COMPONENT_COMPLETION\n    });\n    if (globalRead !== null) {\n      this.componentContext = {\n        tcbPath: this.tcbPath,\n        isShimFile: this.tcbIsShim,\n        positionInFile: globalRead.name.getStart()\n      };\n    } else {\n      this.componentContext = null;\n    }\n  }\n  getGlobalCompletions(context, node) {\n    if (this.componentContext === null) {\n      return null;\n    }\n    const templateContext = this.getTemplateContextCompletions(context);\n    if (templateContext === null) {\n      return null;\n    }\n    let nodeContext = null;\n    if (node instanceof EmptyExpr) {\n      const nodeLocation = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isIdentifier,\n        withSpan: node.sourceSpan\n      });\n      if (nodeLocation !== null) {\n        nodeContext = {\n          tcbPath: this.tcbPath,\n          isShimFile: this.tcbIsShim,\n          positionInFile: nodeLocation.getStart()\n        };\n      }\n    }\n    if (node instanceof PropertyRead2 && node.receiver instanceof ImplicitReceiver2) {\n      const nodeLocation = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isPropertyAccessExpression,\n        withSpan: node.sourceSpan\n      });\n      if (nodeLocation) {\n        nodeContext = {\n          tcbPath: this.tcbPath,\n          isShimFile: this.tcbIsShim,\n          positionInFile: nodeLocation.getStart()\n        };\n      }\n    }\n    return {\n      componentContext: this.componentContext,\n      templateContext,\n      nodeContext\n    };\n  }\n  getExpressionCompletionLocation(expr) {\n    if (this.expressionCompletionCache.has(expr)) {\n      return this.expressionCompletionCache.get(expr);\n    }\n    let tsExpr = null;\n    if (expr instanceof PropertyRead2 || expr instanceof PropertyWrite2) {\n      tsExpr = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isPropertyAccessExpression,\n        withSpan: expr.nameSpan\n      });\n    } else if (expr instanceof SafePropertyRead) {\n      const ternaryExpr = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isParenthesizedExpression,\n        withSpan: expr.sourceSpan\n      });\n      if (ternaryExpr === null || !ts11.isConditionalExpression(ternaryExpr.expression)) {\n        return null;\n      }\n      const whenTrue = ternaryExpr.expression.whenTrue;\n      if (ts11.isPropertyAccessExpression(whenTrue)) {\n        tsExpr = whenTrue;\n      } else if (ts11.isCallExpression(whenTrue) && ts11.isPropertyAccessExpression(whenTrue.expression)) {\n        tsExpr = whenTrue.expression;\n      }\n    }\n    if (tsExpr === null) {\n      return null;\n    }\n    const res = {\n      tcbPath: this.tcbPath,\n      isShimFile: this.tcbIsShim,\n      positionInFile: tsExpr.name.getEnd()\n    };\n    this.expressionCompletionCache.set(expr, res);\n    return res;\n  }\n  getLiteralCompletionLocation(expr) {\n    if (this.expressionCompletionCache.has(expr)) {\n      return this.expressionCompletionCache.get(expr);\n    }\n    let tsExpr = null;\n    if (expr instanceof TmplAstTextAttribute) {\n      const strNode = findFirstMatchingNode(this.tcb, {\n        filter: ts11.isParenthesizedExpression,\n        withSpan: expr.sourceSpan\n      });\n      if (strNode !== null && ts11.isStringLiteral(strNode.expression)) {\n        tsExpr = strNode.expression;\n      }\n    } else {\n      tsExpr = findFirstMatchingNode(this.tcb, {\n        filter: (n) => ts11.isStringLiteral(n) || ts11.isNumericLiteral(n),\n        withSpan: expr.sourceSpan\n      });\n    }\n    if (tsExpr === null) {\n      return null;\n    }\n    let positionInShimFile = tsExpr.getEnd();\n    if (ts11.isStringLiteral(tsExpr)) {\n      positionInShimFile -= 1;\n    }\n    const res = {\n      tcbPath: this.tcbPath,\n      isShimFile: this.tcbIsShim,\n      positionInFile: positionInShimFile\n    };\n    this.expressionCompletionCache.set(expr, res);\n    return res;\n  }\n  getTemplateContextCompletions(context) {\n    if (this.templateContextCache.has(context)) {\n      return this.templateContextCache.get(context);\n    }\n    const templateContext = /* @__PURE__ */ new Map();\n    for (const node of this.data.boundTarget.getEntitiesInTemplateScope(context)) {\n      if (node instanceof TmplAstReference2) {\n        templateContext.set(node.name, {\n          kind: CompletionKind.Reference,\n          node\n        });\n      } else {\n        templateContext.set(node.name, {\n          kind: CompletionKind.Variable,\n          node\n        });\n      }\n    }\n    this.templateContextCache.set(context, templateContext);\n    return templateContext;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/context.mjs\nimport ts25 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/dom.mjs\nimport { DomElementSchemaRegistry } from \"@angular/compiler\";\nimport ts12 from \"typescript\";\nvar REGISTRY = new DomElementSchemaRegistry();\nvar REMOVE_XHTML_REGEX = /^:xhtml:/;\nvar RegistryDomSchemaChecker = class {\n  get diagnostics() {\n    return this._diagnostics;\n  }\n  constructor(resolver) {\n    this.resolver = resolver;\n    this._diagnostics = [];\n  }\n  checkElement(id, element, schemas, hostIsStandalone) {\n    const name = element.name.replace(REMOVE_XHTML_REGEX, \"\");\n    if (!REGISTRY.hasElement(name, schemas)) {\n      const mapping = this.resolver.getSourceMapping(id);\n      const schemas2 = `'${hostIsStandalone ? \"@Component\" : \"@NgModule\"}.schemas'`;\n      let errorMsg = `'${name}' is not a known element:\n`;\n      errorMsg += `1. If '${name}' is an Angular component, then verify that it is ${hostIsStandalone ? \"included in the '@Component.imports' of this component\" : \"part of this module\"}.\n`;\n      if (name.indexOf(\"-\") > -1) {\n        errorMsg += `2. If '${name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;\n      } else {\n        errorMsg += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;\n      }\n      const diag = makeTemplateDiagnostic(id, mapping, element.startSourceSpan, ts12.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SCHEMA_INVALID_ELEMENT), errorMsg);\n      this._diagnostics.push(diag);\n    }\n  }\n  checkProperty(id, element, name, span, schemas, hostIsStandalone) {\n    if (!REGISTRY.hasProperty(element.name, name, schemas)) {\n      const mapping = this.resolver.getSourceMapping(id);\n      const decorator = hostIsStandalone ? \"@Component\" : \"@NgModule\";\n      const schemas2 = `'${decorator}.schemas'`;\n      let errorMsg = `Can't bind to '${name}' since it isn't a known property of '${element.name}'.`;\n      if (element.name.startsWith(\"ng-\")) {\n        errorMsg += `\n1. If '${name}' is an Angular directive, then add 'CommonModule' to the '${decorator}.imports' of this component.\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;\n      } else if (element.name.indexOf(\"-\") > -1) {\n        errorMsg += `\n1. If '${element.name}' is an Angular component and it has '${name}' input, then verify that it is ${hostIsStandalone ? \"included in the '@Component.imports' of this component\" : \"part of this module\"}.\n2. If '${element.name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;\n      }\n      const diag = makeTemplateDiagnostic(id, mapping, span, ts12.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SCHEMA_INVALID_ATTRIBUTE), errorMsg);\n      this._diagnostics.push(diag);\n    }\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/environment.mjs\nimport { ExpressionType, ExternalExpr, TypeModifier } from \"@angular/compiler\";\nimport ts18 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/ts_util.mjs\nimport ts13 from \"typescript\";\nvar SAFE_TO_CAST_WITHOUT_PARENS = /* @__PURE__ */ new Set([\n  ts13.SyntaxKind.ParenthesizedExpression,\n  ts13.SyntaxKind.Identifier,\n  ts13.SyntaxKind.CallExpression,\n  ts13.SyntaxKind.NonNullExpression,\n  ts13.SyntaxKind.ElementAccessExpression,\n  ts13.SyntaxKind.PropertyAccessExpression,\n  ts13.SyntaxKind.ArrayLiteralExpression,\n  ts13.SyntaxKind.ObjectLiteralExpression,\n  ts13.SyntaxKind.StringLiteral,\n  ts13.SyntaxKind.NumericLiteral,\n  ts13.SyntaxKind.TrueKeyword,\n  ts13.SyntaxKind.FalseKeyword,\n  ts13.SyntaxKind.NullKeyword,\n  ts13.SyntaxKind.UndefinedKeyword\n]);\nfunction tsCastToAny(expr) {\n  if (!SAFE_TO_CAST_WITHOUT_PARENS.has(expr.kind)) {\n    expr = ts13.factory.createParenthesizedExpression(expr);\n  }\n  return ts13.factory.createParenthesizedExpression(ts13.factory.createAsExpression(expr, ts13.factory.createKeywordTypeNode(ts13.SyntaxKind.AnyKeyword)));\n}\nfunction tsCreateElement(tagName) {\n  const createElement = ts13.factory.createPropertyAccessExpression(\n    ts13.factory.createIdentifier(\"document\"),\n    \"createElement\"\n  );\n  return ts13.factory.createCallExpression(\n    createElement,\n    void 0,\n    [ts13.factory.createStringLiteral(tagName)]\n  );\n}\nfunction tsDeclareVariable(id, type) {\n  const decl = ts13.factory.createVariableDeclaration(\n    id,\n    void 0,\n    type,\n    ts13.factory.createNonNullExpression(ts13.factory.createNull())\n  );\n  return ts13.factory.createVariableStatement(\n    void 0,\n    [decl]\n  );\n}\nfunction tsCreateTypeQueryForCoercedInput(typeName, coercedInputName) {\n  return ts13.factory.createTypeQueryNode(ts13.factory.createQualifiedName(typeName, `ngAcceptInputType_${coercedInputName}`));\n}\nfunction tsCreateVariable(id, initializer) {\n  const decl = ts13.factory.createVariableDeclaration(\n    id,\n    void 0,\n    void 0,\n    initializer\n  );\n  return ts13.factory.createVariableStatement(\n    void 0,\n    [decl]\n  );\n}\nfunction tsCallMethod(receiver, methodName, args = []) {\n  const methodAccess = ts13.factory.createPropertyAccessExpression(receiver, methodName);\n  return ts13.factory.createCallExpression(\n    methodAccess,\n    void 0,\n    args\n  );\n}\nfunction isAccessExpression(node) {\n  return ts13.isPropertyAccessExpression(node) || ts13.isElementAccessExpression(node);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.mjs\nimport ts17 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.mjs\nimport ts16 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter.mjs\nimport ts15 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_emitter.mjs\nimport ts14 from \"typescript\";\nvar INELIGIBLE = {};\nfunction canEmitType(type, canEmit) {\n  return canEmitTypeWorker(type);\n  function canEmitTypeWorker(type2) {\n    return visitNode(type2) !== INELIGIBLE;\n  }\n  function visitNode(node) {\n    if (ts14.isImportTypeNode(node)) {\n      return INELIGIBLE;\n    }\n    if (ts14.isTypeReferenceNode(node) && !canEmitTypeReference(node)) {\n      return INELIGIBLE;\n    } else {\n      return ts14.forEachChild(node, visitNode);\n    }\n  }\n  function canEmitTypeReference(type2) {\n    if (!canEmit(type2)) {\n      return false;\n    }\n    return type2.typeArguments === void 0 || type2.typeArguments.every(canEmitTypeWorker);\n  }\n}\nvar TypeEmitter = class {\n  constructor(translator) {\n    this.translator = translator;\n  }\n  emitType(type) {\n    const typeReferenceTransformer = (context) => {\n      const visitNode = (node) => {\n        if (ts14.isImportTypeNode(node)) {\n          throw new Error(\"Unable to emit import type\");\n        }\n        if (ts14.isTypeReferenceNode(node)) {\n          return this.emitTypeReference(node);\n        } else if (ts14.isLiteralExpression(node)) {\n          let clone;\n          if (ts14.isStringLiteral(node)) {\n            clone = ts14.factory.createStringLiteral(node.text);\n          } else if (ts14.isNumericLiteral(node)) {\n            clone = ts14.factory.createNumericLiteral(node.text);\n          } else if (ts14.isBigIntLiteral(node)) {\n            clone = ts14.factory.createBigIntLiteral(node.text);\n          } else if (ts14.isNoSubstitutionTemplateLiteral(node)) {\n            clone = ts14.factory.createNoSubstitutionTemplateLiteral(node.text, node.rawText);\n          } else if (ts14.isRegularExpressionLiteral(node)) {\n            clone = ts14.factory.createRegularExpressionLiteral(node.text);\n          } else {\n            throw new Error(`Unsupported literal kind ${ts14.SyntaxKind[node.kind]}`);\n          }\n          ts14.setTextRange(clone, { pos: -1, end: -1 });\n          return clone;\n        } else {\n          return ts14.visitEachChild(node, visitNode, context);\n        }\n      };\n      return (node) => ts14.visitNode(node, visitNode, ts14.isTypeNode);\n    };\n    return ts14.transform(type, [typeReferenceTransformer]).transformed[0];\n  }\n  emitTypeReference(type) {\n    const translatedType = this.translator(type);\n    if (translatedType === null) {\n      throw new Error(\"Unable to emit an unresolved reference\");\n    }\n    let typeArguments = void 0;\n    if (type.typeArguments !== void 0) {\n      typeArguments = ts14.factory.createNodeArray(type.typeArguments.map((typeArg) => this.emitType(typeArg)));\n    }\n    return ts14.factory.updateTypeReferenceNode(type, translatedType.typeName, typeArguments);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter.mjs\nvar TypeParameterEmitter = class {\n  constructor(typeParameters, reflector) {\n    this.typeParameters = typeParameters;\n    this.reflector = reflector;\n  }\n  canEmit(canEmitReference) {\n    if (this.typeParameters === void 0) {\n      return true;\n    }\n    return this.typeParameters.every((typeParam) => {\n      return this.canEmitType(typeParam.constraint, canEmitReference) && this.canEmitType(typeParam.default, canEmitReference);\n    });\n  }\n  canEmitType(type, canEmitReference) {\n    if (type === void 0) {\n      return true;\n    }\n    return canEmitType(type, (typeReference) => {\n      const reference = this.resolveTypeReference(typeReference);\n      if (reference === null) {\n        return false;\n      }\n      if (reference instanceof Reference) {\n        return canEmitReference(reference);\n      }\n      return true;\n    });\n  }\n  emit(emitReference) {\n    if (this.typeParameters === void 0) {\n      return void 0;\n    }\n    const emitter = new TypeEmitter((type) => this.translateTypeReference(type, emitReference));\n    return this.typeParameters.map((typeParam) => {\n      const constraint = typeParam.constraint !== void 0 ? emitter.emitType(typeParam.constraint) : void 0;\n      const defaultType = typeParam.default !== void 0 ? emitter.emitType(typeParam.default) : void 0;\n      return ts15.factory.updateTypeParameterDeclaration(typeParam, typeParam.modifiers, typeParam.name, constraint, defaultType);\n    });\n  }\n  resolveTypeReference(type) {\n    const target = ts15.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;\n    const declaration = this.reflector.getDeclarationOfIdentifier(target);\n    if (declaration === null || declaration.node === null) {\n      return null;\n    }\n    if (this.isLocalTypeParameter(declaration.node)) {\n      return type;\n    }\n    let owningModule = null;\n    if (declaration.viaModule !== null) {\n      owningModule = {\n        specifier: declaration.viaModule,\n        resolutionContext: type.getSourceFile().fileName\n      };\n    }\n    return new Reference(declaration.node, owningModule);\n  }\n  translateTypeReference(type, emitReference) {\n    const reference = this.resolveTypeReference(type);\n    if (!(reference instanceof Reference)) {\n      return reference;\n    }\n    const typeNode = emitReference(reference);\n    if (typeNode === null) {\n      return null;\n    }\n    if (!ts15.isTypeReferenceNode(typeNode)) {\n      throw new Error(`Expected TypeReferenceNode for emitted reference, got ${ts15.SyntaxKind[typeNode.kind]}.`);\n    }\n    return typeNode;\n  }\n  isLocalTypeParameter(decl) {\n    return this.typeParameters.some((param) => param === decl);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.mjs\nvar TcbInliningRequirement;\n(function(TcbInliningRequirement2) {\n  TcbInliningRequirement2[TcbInliningRequirement2[\"MustInline\"] = 0] = \"MustInline\";\n  TcbInliningRequirement2[TcbInliningRequirement2[\"ShouldInlineForGenericBounds\"] = 1] = \"ShouldInlineForGenericBounds\";\n  TcbInliningRequirement2[TcbInliningRequirement2[\"None\"] = 2] = \"None\";\n})(TcbInliningRequirement || (TcbInliningRequirement = {}));\nfunction requiresInlineTypeCheckBlock(ref, env, usedPipes, reflector) {\n  if (!env.canReferenceType(ref)) {\n    return TcbInliningRequirement.MustInline;\n  } else if (!checkIfGenericTypeBoundsCanBeEmitted(ref.node, reflector, env)) {\n    return TcbInliningRequirement.ShouldInlineForGenericBounds;\n  } else if (usedPipes.some((pipeRef) => !env.canReferenceType(pipeRef))) {\n    return TcbInliningRequirement.MustInline;\n  } else {\n    return TcbInliningRequirement.None;\n  }\n}\nfunction getTemplateMapping(shimSf, position, resolver, isDiagnosticRequest) {\n  const node = getTokenAtPosition(shimSf, position);\n  const sourceLocation = findSourceLocation(node, shimSf, isDiagnosticRequest);\n  if (sourceLocation === null) {\n    return null;\n  }\n  const mapping = resolver.getSourceMapping(sourceLocation.id);\n  const span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);\n  if (span === null) {\n    return null;\n  }\n  return { sourceLocation, templateSourceMapping: mapping, span };\n}\nfunction findTypeCheckBlock(file, id, isDiagnosticRequest) {\n  for (const stmt of file.statements) {\n    if (ts16.isFunctionDeclaration(stmt) && getTemplateId2(stmt, file, isDiagnosticRequest) === id) {\n      return stmt;\n    }\n  }\n  return null;\n}\nfunction findSourceLocation(node, sourceFile, isDiagnosticsRequest) {\n  while (node !== void 0 && !ts16.isFunctionDeclaration(node)) {\n    if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticsRequest) {\n      return null;\n    }\n    const span = readSpanComment(node, sourceFile);\n    if (span !== null) {\n      const id = getTemplateId2(node, sourceFile, isDiagnosticsRequest);\n      if (id === null) {\n        return null;\n      }\n      return { id, span };\n    }\n    node = node.parent;\n  }\n  return null;\n}\nfunction getTemplateId2(node, sourceFile, isDiagnosticRequest) {\n  while (!ts16.isFunctionDeclaration(node)) {\n    if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticRequest) {\n      return null;\n    }\n    node = node.parent;\n    if (node === void 0) {\n      return null;\n    }\n  }\n  const start = node.getFullStart();\n  return ts16.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {\n    if (kind !== ts16.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText;\n  }) || null;\n}\nfunction checkIfGenericTypeBoundsCanBeEmitted(node, reflector, env) {\n  const emitter = new TypeParameterEmitter(node.typeParameters, reflector);\n  return emitter.canEmit((ref) => env.canReferenceType(ref));\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.mjs\nfunction generateTypeCtorDeclarationFn(node, meta, nodeTypeRef, typeParams) {\n  const rawTypeArgs = typeParams !== void 0 ? generateGenericArgs(typeParams) : void 0;\n  const rawType = ts17.factory.createTypeReferenceNode(nodeTypeRef, rawTypeArgs);\n  const initParam = constructTypeCtorParameter(node, meta, rawType);\n  const typeParameters = typeParametersWithDefaultTypes(typeParams);\n  if (meta.body) {\n    const fnType = ts17.factory.createFunctionTypeNode(\n      typeParameters,\n      [initParam],\n      rawType\n    );\n    const decl = ts17.factory.createVariableDeclaration(\n      meta.fnName,\n      void 0,\n      fnType,\n      ts17.factory.createNonNullExpression(ts17.factory.createNull())\n    );\n    const declList = ts17.factory.createVariableDeclarationList([decl], ts17.NodeFlags.Const);\n    return ts17.factory.createVariableStatement(\n      void 0,\n      declList\n    );\n  } else {\n    return ts17.factory.createFunctionDeclaration(\n      [ts17.factory.createModifier(ts17.SyntaxKind.DeclareKeyword)],\n      void 0,\n      meta.fnName,\n      typeParameters,\n      [initParam],\n      rawType,\n      void 0\n    );\n  }\n}\nfunction generateInlineTypeCtor(node, meta) {\n  const rawTypeArgs = node.typeParameters !== void 0 ? generateGenericArgs(node.typeParameters) : void 0;\n  const rawType = ts17.factory.createTypeReferenceNode(node.name, rawTypeArgs);\n  const initParam = constructTypeCtorParameter(node, meta, rawType);\n  let body = void 0;\n  if (meta.body) {\n    body = ts17.factory.createBlock([\n      ts17.factory.createReturnStatement(ts17.factory.createNonNullExpression(ts17.factory.createNull()))\n    ]);\n  }\n  return ts17.factory.createMethodDeclaration(\n    [ts17.factory.createModifier(ts17.SyntaxKind.StaticKeyword)],\n    void 0,\n    meta.fnName,\n    void 0,\n    typeParametersWithDefaultTypes(node.typeParameters),\n    [initParam],\n    rawType,\n    body\n  );\n}\nfunction constructTypeCtorParameter(node, meta, rawType) {\n  let initType = null;\n  const plainKeys = [];\n  const coercedKeys = [];\n  for (const { classPropertyName, transform } of meta.fields.inputs) {\n    if (!meta.coercedInputFields.has(classPropertyName)) {\n      plainKeys.push(ts17.factory.createLiteralTypeNode(ts17.factory.createStringLiteral(classPropertyName)));\n    } else {\n      coercedKeys.push(ts17.factory.createPropertySignature(\n        void 0,\n        classPropertyName,\n        void 0,\n        transform == null ? tsCreateTypeQueryForCoercedInput(rawType.typeName, classPropertyName) : transform.type\n      ));\n    }\n  }\n  if (plainKeys.length > 0) {\n    const keyTypeUnion = ts17.factory.createUnionTypeNode(plainKeys);\n    initType = ts17.factory.createTypeReferenceNode(\"Pick\", [rawType, keyTypeUnion]);\n  }\n  if (coercedKeys.length > 0) {\n    const coercedLiteral = ts17.factory.createTypeLiteralNode(coercedKeys);\n    initType = initType !== null ? ts17.factory.createIntersectionTypeNode([initType, coercedLiteral]) : coercedLiteral;\n  }\n  if (initType === null) {\n    initType = ts17.factory.createTypeLiteralNode([]);\n  }\n  return ts17.factory.createParameterDeclaration(\n    void 0,\n    void 0,\n    \"init\",\n    void 0,\n    initType,\n    void 0\n  );\n}\nfunction generateGenericArgs(params) {\n  return params.map((param) => ts17.factory.createTypeReferenceNode(param.name, void 0));\n}\nfunction requiresInlineTypeCtor(node, host, env) {\n  return !checkIfGenericTypeBoundsCanBeEmitted(node, host, env);\n}\nfunction typeParametersWithDefaultTypes(params) {\n  if (params === void 0) {\n    return void 0;\n  }\n  return params.map((param) => {\n    if (param.default === void 0) {\n      return ts17.factory.updateTypeParameterDeclaration(param, param.modifiers, param.name, param.constraint, ts17.factory.createKeywordTypeNode(ts17.SyntaxKind.AnyKeyword));\n    } else {\n      return param;\n    }\n  });\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/environment.mjs\nvar Environment = class {\n  constructor(config, importManager, refEmitter, reflector, contextFile) {\n    this.config = config;\n    this.importManager = importManager;\n    this.refEmitter = refEmitter;\n    this.reflector = reflector;\n    this.contextFile = contextFile;\n    this.nextIds = {\n      pipeInst: 1,\n      typeCtor: 1\n    };\n    this.typeCtors = /* @__PURE__ */ new Map();\n    this.typeCtorStatements = [];\n    this.pipeInsts = /* @__PURE__ */ new Map();\n    this.pipeInstStatements = [];\n  }\n  typeCtorFor(dir) {\n    const dirRef = dir.ref;\n    const node = dirRef.node;\n    if (this.typeCtors.has(node)) {\n      return this.typeCtors.get(node);\n    }\n    if (requiresInlineTypeCtor(node, this.reflector, this)) {\n      const ref = this.reference(dirRef);\n      const typeCtorExpr = ts18.factory.createPropertyAccessExpression(ref, \"ngTypeCtor\");\n      this.typeCtors.set(node, typeCtorExpr);\n      return typeCtorExpr;\n    } else {\n      const fnName = `_ctor${this.nextIds.typeCtor++}`;\n      const nodeTypeRef = this.referenceType(dirRef);\n      if (!ts18.isTypeReferenceNode(nodeTypeRef)) {\n        throw new Error(`Expected TypeReferenceNode from reference to ${dirRef.debugName}`);\n      }\n      const meta = {\n        fnName,\n        body: true,\n        fields: {\n          inputs: dir.inputs,\n          queries: dir.queries\n        },\n        coercedInputFields: dir.coercedInputFields\n      };\n      const typeParams = this.emitTypeParameters(node);\n      const typeCtor = generateTypeCtorDeclarationFn(node, meta, nodeTypeRef.typeName, typeParams);\n      this.typeCtorStatements.push(typeCtor);\n      const fnId = ts18.factory.createIdentifier(fnName);\n      this.typeCtors.set(node, fnId);\n      return fnId;\n    }\n  }\n  pipeInst(ref) {\n    if (this.pipeInsts.has(ref.node)) {\n      return this.pipeInsts.get(ref.node);\n    }\n    const pipeType = this.referenceType(ref);\n    const pipeInstId = ts18.factory.createIdentifier(`_pipe${this.nextIds.pipeInst++}`);\n    this.pipeInstStatements.push(tsDeclareVariable(pipeInstId, pipeType));\n    this.pipeInsts.set(ref.node, pipeInstId);\n    return pipeInstId;\n  }\n  reference(ref) {\n    const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);\n    assertSuccessfulReferenceEmit(ngExpr, this.contextFile, \"class\");\n    return translateExpression(ngExpr.expression, this.importManager);\n  }\n  canReferenceType(ref) {\n    const result = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports);\n    return result.kind === 0;\n  }\n  referenceType(ref) {\n    const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports);\n    assertSuccessfulReferenceEmit(ngExpr, this.contextFile, \"symbol\");\n    return translateType(new ExpressionType(ngExpr.expression), this.contextFile, this.reflector, this.refEmitter, this.importManager);\n  }\n  emitTypeParameters(declaration) {\n    const emitter = new TypeParameterEmitter(declaration.typeParameters, this.reflector);\n    return emitter.emit((ref) => this.referenceType(ref));\n  }\n  referenceExternalType(moduleName, name, typeParams) {\n    const external = new ExternalExpr({ moduleName, name });\n    return translateType(new ExpressionType(external, TypeModifier.None, typeParams), this.contextFile, this.reflector, this.refEmitter, this.importManager);\n  }\n  referenceTransplantedType(type) {\n    return translateType(type, this.contextFile, this.reflector, this.refEmitter, this.importManager);\n  }\n  getPreludeStatements() {\n    return [\n      ...this.pipeInstStatements,\n      ...this.typeCtorStatements\n    ];\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/oob.mjs\nimport { TmplAstElement as TmplAstElement2 } from \"@angular/compiler\";\nimport ts19 from \"typescript\";\nvar OutOfBandDiagnosticRecorderImpl = class {\n  constructor(resolver) {\n    this.resolver = resolver;\n    this._diagnostics = [];\n    this.recordedPipes = /* @__PURE__ */ new Set();\n  }\n  get diagnostics() {\n    return this._diagnostics;\n  }\n  missingReferenceTarget(templateId, ref) {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const value = ref.value.trim();\n    const errorMsg = `No directive found with exportAs '${value}'.`;\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, ref.valueSpan || ref.sourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));\n  }\n  missingPipe(templateId, ast) {\n    if (this.recordedPipes.has(ast)) {\n      return;\n    }\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `No pipe found with name '${ast.name}'.`;\n    const sourceSpan = this.resolver.toParseSourceSpan(templateId, ast.nameSpan);\n    if (sourceSpan === null) {\n      throw new Error(`Assertion failure: no SourceLocation found for usage of pipe '${ast.name}'.`);\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_PIPE), errorMsg));\n    this.recordedPipes.add(ast);\n  }\n  illegalAssignmentToTemplateVar(templateId, assignment, target) {\n    var _a, _b;\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `Cannot use variable '${assignment.name}' as the left-hand side of an assignment expression. Template variables are read-only.`;\n    const sourceSpan = this.resolver.toParseSourceSpan(templateId, assignment.sourceSpan);\n    if (sourceSpan === null) {\n      throw new Error(`Assertion failure: no SourceLocation found for property binding.`);\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMsg, [{\n      text: `The variable ${assignment.name} is declared here.`,\n      start: ((_a = target.valueSpan) == null ? void 0 : _a.start.offset) || target.sourceSpan.start.offset,\n      end: ((_b = target.valueSpan) == null ? void 0 : _b.end.offset) || target.sourceSpan.end.offset,\n      sourceFile: mapping.node.getSourceFile()\n    }]));\n  }\n  duplicateTemplateVar(templateId, variable, firstDecl) {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `Cannot redeclare variable '${variable.name}' as it was previously declared elsewhere for the same template.`;\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, variable.sourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, [{\n      text: `The variable '${firstDecl.name}' was first declared here.`,\n      start: firstDecl.sourceSpan.start.offset,\n      end: firstDecl.sourceSpan.end.offset,\n      sourceFile: mapping.node.getSourceFile()\n    }]));\n  }\n  requiresInlineTcb(templateId, node) {\n    this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TCB_REQUIRED, node.name, `This component requires inline template type-checking, which is not supported by the current environment.`));\n  }\n  requiresInlineTypeConstructors(templateId, node, directives) {\n    let message;\n    if (directives.length > 1) {\n      message = `This component uses directives which require inline type constructors, which are not supported by the current environment.`;\n    } else {\n      message = `This component uses a directive which requires an inline type constructor, which is not supported by the current environment.`;\n    }\n    this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message, directives.map((dir) => makeRelatedInformation(dir.name, `Requires an inline type constructor.`))));\n  }\n  suboptimalTypeInference(templateId, variables) {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    let diagnosticVar = null;\n    for (const variable of variables) {\n      if (diagnosticVar === null || (variable.value === \"\" || variable.value === \"$implicit\")) {\n        diagnosticVar = variable;\n      }\n    }\n    if (diagnosticVar === null) {\n      return;\n    }\n    let varIdentification = `'${diagnosticVar.name}'`;\n    if (variables.length === 2) {\n      varIdentification += ` (and 1 other)`;\n    } else if (variables.length > 2) {\n      varIdentification += ` (and ${variables.length - 1} others)`;\n    }\n    const message = `This structural directive supports advanced type inference, but the current compiler configuration prevents its usage. The variable ${varIdentification} will have type 'any' as a result.\n\nConsider enabling the 'strictTemplates' option in your tsconfig.json for better type inference within this template.`;\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, diagnosticVar.keySpan, ts19.DiagnosticCategory.Suggestion, ngErrorCode(ErrorCode.SUGGEST_SUBOPTIMAL_TYPE_INFERENCE), message));\n  }\n  splitTwoWayBinding(templateId, input, output, inputConsumer, outputConsumer) {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `The property and event halves of the two-way binding '${input.name}' are not bound to the same target.\n            Find more at https://angular.io/guide/two-way-binding#how-two-way-binding-works`;\n    const relatedMessages = [];\n    relatedMessages.push({\n      text: `The property half of the binding is to the '${inputConsumer.name.text}' component.`,\n      start: inputConsumer.name.getStart(),\n      end: inputConsumer.name.getEnd(),\n      sourceFile: inputConsumer.name.getSourceFile()\n    });\n    if (outputConsumer instanceof TmplAstElement2) {\n      let message = `The event half of the binding is to a native event called '${input.name}' on the <${outputConsumer.name}> DOM element.`;\n      if (!mapping.node.getSourceFile().isDeclarationFile) {\n        message += `\n \n Are you missing an output declaration called '${output.name}'?`;\n      }\n      relatedMessages.push({\n        text: message,\n        start: outputConsumer.sourceSpan.start.offset + 1,\n        end: outputConsumer.sourceSpan.start.offset + outputConsumer.name.length + 1,\n        sourceFile: mapping.node.getSourceFile()\n      });\n    } else {\n      relatedMessages.push({\n        text: `The event half of the binding is to the '${outputConsumer.name.text}' component.`,\n        start: outputConsumer.name.getStart(),\n        end: outputConsumer.name.getEnd(),\n        sourceFile: outputConsumer.name.getSourceFile()\n      });\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, input.keySpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SPLIT_TWO_WAY_BINDING), errorMsg, relatedMessages));\n  }\n  missingRequiredInputs(templateId, element, directiveName, isComponent, inputAliases) {\n    const message = `Required input${inputAliases.length === 1 ? \"\" : \"s\"} ${inputAliases.map((n) => `'${n}'`).join(\", \")} from ${isComponent ? \"component\" : \"directive\"} ${directiveName} must be specified.`;\n    this._diagnostics.push(makeTemplateDiagnostic(templateId, this.resolver.getSourceMapping(templateId), element.startSourceSpan, ts19.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_REQUIRED_INPUTS), message));\n  }\n};\nfunction makeInlineDiagnostic(templateId, code, node, messageText, relatedInformation) {\n  return {\n    ...makeDiagnostic(code, node, messageText, relatedInformation),\n    componentFile: node.getSourceFile(),\n    templateId\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/shim.mjs\nimport ts20 from \"typescript\";\nvar TypeCheckShimGenerator = class {\n  constructor() {\n    this.extensionPrefix = \"ngtypecheck\";\n    this.shouldEmit = false;\n  }\n  generateShimForFile(sf, genFilePath, priorShimSf) {\n    if (priorShimSf !== null) {\n      return priorShimSf;\n    }\n    return ts20.createSourceFile(genFilePath, \"export const USED_FOR_NG_TYPE_CHECKING = true;\", ts20.ScriptTarget.Latest, true, ts20.ScriptKind.TS);\n  }\n  static shimFor(fileName) {\n    return absoluteFrom(fileName.replace(/\\.tsx?$/, \".ngtypecheck.ts\"));\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.mjs\nimport { BindingPipe, Call as Call2, DYNAMIC_TYPE, ImplicitReceiver as ImplicitReceiver4, PropertyRead as PropertyRead4, PropertyWrite as PropertyWrite3, SafeCall, SafePropertyRead as SafePropertyRead3, ThisReceiver, TmplAstBoundAttribute, TmplAstBoundText, TmplAstElement as TmplAstElement3, TmplAstIcu, TmplAstReference as TmplAstReference3, TmplAstTemplate as TmplAstTemplate2, TmplAstTextAttribute as TmplAstTextAttribute2, TmplAstVariable as TmplAstVariable2, TransplantedType } from \"@angular/compiler\";\nimport ts23 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/diagnostics.mjs\nimport { AbsoluteSourceSpan as AbsoluteSourceSpan3 } from \"@angular/compiler\";\nimport ts21 from \"typescript\";\nfunction wrapForDiagnostics(expr) {\n  return ts21.factory.createParenthesizedExpression(expr);\n}\nfunction wrapForTypeChecker(expr) {\n  return ts21.factory.createParenthesizedExpression(expr);\n}\nfunction addParseSpanInfo(node, span) {\n  let commentText;\n  if (span instanceof AbsoluteSourceSpan3) {\n    commentText = `${span.start},${span.end}`;\n  } else {\n    commentText = `${span.start.offset},${span.end.offset}`;\n  }\n  ts21.addSyntheticTrailingComment(node, ts21.SyntaxKind.MultiLineCommentTrivia, commentText, false);\n}\nfunction addTemplateId(tcb, id) {\n  ts21.addSyntheticLeadingComment(tcb, ts21.SyntaxKind.MultiLineCommentTrivia, id, true);\n}\nfunction shouldReportDiagnostic(diagnostic) {\n  const { code } = diagnostic;\n  if (code === 6133) {\n    return false;\n  } else if (code === 6199) {\n    return false;\n  } else if (code === 2695) {\n    return false;\n  } else if (code === 7006) {\n    return false;\n  }\n  return true;\n}\nfunction translateDiagnostic(diagnostic, resolver) {\n  if (diagnostic.file === void 0 || diagnostic.start === void 0) {\n    return null;\n  }\n  const fullMapping = getTemplateMapping(diagnostic.file, diagnostic.start, resolver, true);\n  if (fullMapping === null) {\n    return null;\n  }\n  const { sourceLocation, templateSourceMapping, span } = fullMapping;\n  return makeTemplateDiagnostic(sourceLocation.id, templateSourceMapping, span, diagnostic.category, diagnostic.code, diagnostic.messageText);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/expression.mjs\nimport { ASTWithSource as ASTWithSource2, Call, EmptyExpr as EmptyExpr2, PropertyRead as PropertyRead3, SafeKeyedRead, SafePropertyRead as SafePropertyRead2 } from \"@angular/compiler\";\nimport ts22 from \"typescript\";\nvar NULL_AS_ANY = ts22.factory.createAsExpression(ts22.factory.createNull(), ts22.factory.createKeywordTypeNode(ts22.SyntaxKind.AnyKeyword));\nvar UNDEFINED = ts22.factory.createIdentifier(\"undefined\");\nvar UNARY_OPS = /* @__PURE__ */ new Map([\n  [\"+\", ts22.SyntaxKind.PlusToken],\n  [\"-\", ts22.SyntaxKind.MinusToken]\n]);\nvar BINARY_OPS = /* @__PURE__ */ new Map([\n  [\"+\", ts22.SyntaxKind.PlusToken],\n  [\"-\", ts22.SyntaxKind.MinusToken],\n  [\"<\", ts22.SyntaxKind.LessThanToken],\n  [\">\", ts22.SyntaxKind.GreaterThanToken],\n  [\"<=\", ts22.SyntaxKind.LessThanEqualsToken],\n  [\">=\", ts22.SyntaxKind.GreaterThanEqualsToken],\n  [\"==\", ts22.SyntaxKind.EqualsEqualsToken],\n  [\"===\", ts22.SyntaxKind.EqualsEqualsEqualsToken],\n  [\"*\", ts22.SyntaxKind.AsteriskToken],\n  [\"/\", ts22.SyntaxKind.SlashToken],\n  [\"%\", ts22.SyntaxKind.PercentToken],\n  [\"!=\", ts22.SyntaxKind.ExclamationEqualsToken],\n  [\"!==\", ts22.SyntaxKind.ExclamationEqualsEqualsToken],\n  [\"||\", ts22.SyntaxKind.BarBarToken],\n  [\"&&\", ts22.SyntaxKind.AmpersandAmpersandToken],\n  [\"&\", ts22.SyntaxKind.AmpersandToken],\n  [\"|\", ts22.SyntaxKind.BarToken],\n  [\"??\", ts22.SyntaxKind.QuestionQuestionToken]\n]);\nfunction astToTypescript(ast, maybeResolve, config) {\n  const translator = new AstTranslator(maybeResolve, config);\n  return translator.translate(ast);\n}\nvar AstTranslator = class {\n  constructor(maybeResolve, config) {\n    this.maybeResolve = maybeResolve;\n    this.config = config;\n  }\n  translate(ast) {\n    if (ast instanceof ASTWithSource2) {\n      ast = ast.ast;\n    }\n    if (ast instanceof EmptyExpr2) {\n      const res = ts22.factory.createIdentifier(\"undefined\");\n      addParseSpanInfo(res, ast.sourceSpan);\n      return res;\n    }\n    const resolved = this.maybeResolve(ast);\n    if (resolved !== null) {\n      return resolved;\n    }\n    return ast.visit(this);\n  }\n  visitUnary(ast) {\n    const expr = this.translate(ast.expr);\n    const op = UNARY_OPS.get(ast.operator);\n    if (op === void 0) {\n      throw new Error(`Unsupported Unary.operator: ${ast.operator}`);\n    }\n    const node = wrapForDiagnostics(ts22.factory.createPrefixUnaryExpression(op, expr));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitBinary(ast) {\n    const lhs = wrapForDiagnostics(this.translate(ast.left));\n    const rhs = wrapForDiagnostics(this.translate(ast.right));\n    const op = BINARY_OPS.get(ast.operation);\n    if (op === void 0) {\n      throw new Error(`Unsupported Binary.operation: ${ast.operation}`);\n    }\n    const node = ts22.factory.createBinaryExpression(lhs, op, rhs);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitChain(ast) {\n    const elements = ast.expressions.map((expr) => this.translate(expr));\n    const node = wrapForDiagnostics(ts22.factory.createCommaListExpression(elements));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitConditional(ast) {\n    const condExpr = this.translate(ast.condition);\n    const trueExpr = this.translate(ast.trueExp);\n    const falseExpr = wrapForTypeChecker(this.translate(ast.falseExp));\n    const node = ts22.factory.createParenthesizedExpression(ts22.factory.createConditionalExpression(condExpr, void 0, trueExpr, void 0, falseExpr));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitImplicitReceiver(ast) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitThisReceiver(ast) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitInterpolation(ast) {\n    return ast.expressions.reduce((lhs, ast2) => ts22.factory.createBinaryExpression(lhs, ts22.SyntaxKind.PlusToken, wrapForTypeChecker(this.translate(ast2))), ts22.factory.createStringLiteral(\"\"));\n  }\n  visitKeyedRead(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const key = this.translate(ast.key);\n    const node = ts22.factory.createElementAccessExpression(receiver, key);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitKeyedWrite(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const left = ts22.factory.createElementAccessExpression(receiver, this.translate(ast.key));\n    const right = wrapForTypeChecker(this.translate(ast.value));\n    const node = wrapForDiagnostics(ts22.factory.createBinaryExpression(left, ts22.SyntaxKind.EqualsToken, right));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitLiteralArray(ast) {\n    const elements = ast.expressions.map((expr) => this.translate(expr));\n    const literal = ts22.factory.createArrayLiteralExpression(elements);\n    const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitLiteralMap(ast) {\n    const properties = ast.keys.map(({ key }, idx) => {\n      const value = this.translate(ast.values[idx]);\n      return ts22.factory.createPropertyAssignment(ts22.factory.createStringLiteral(key), value);\n    });\n    const literal = ts22.factory.createObjectLiteralExpression(properties, true);\n    const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitLiteralPrimitive(ast) {\n    let node;\n    if (ast.value === void 0) {\n      node = ts22.factory.createIdentifier(\"undefined\");\n    } else if (ast.value === null) {\n      node = ts22.factory.createNull();\n    } else if (typeof ast.value === \"string\") {\n      node = ts22.factory.createStringLiteral(ast.value);\n    } else if (typeof ast.value === \"number\") {\n      node = ts22.factory.createNumericLiteral(ast.value);\n    } else if (typeof ast.value === \"boolean\") {\n      node = ast.value ? ts22.factory.createTrue() : ts22.factory.createFalse();\n    } else {\n      throw Error(`Unsupported AST value of type ${typeof ast.value}`);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitNonNullAssert(ast) {\n    const expr = wrapForDiagnostics(this.translate(ast.expression));\n    const node = ts22.factory.createNonNullExpression(expr);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitPipe(ast) {\n    throw new Error(\"Method not implemented.\");\n  }\n  visitPrefixNot(ast) {\n    const expression = wrapForDiagnostics(this.translate(ast.expression));\n    const node = ts22.factory.createLogicalNot(expression);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitPropertyRead(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const name = ts22.factory.createPropertyAccessExpression(receiver, ast.name);\n    addParseSpanInfo(name, ast.nameSpan);\n    const node = wrapForDiagnostics(name);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitPropertyWrite(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const left = ts22.factory.createPropertyAccessExpression(receiver, ast.name);\n    addParseSpanInfo(left, ast.nameSpan);\n    const leftWithPath = wrapForDiagnostics(left);\n    addParseSpanInfo(leftWithPath, ast.sourceSpan);\n    const right = wrapForTypeChecker(this.translate(ast.value));\n    const node = wrapForDiagnostics(ts22.factory.createBinaryExpression(leftWithPath, ts22.SyntaxKind.EqualsToken, right));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitSafePropertyRead(ast) {\n    let node;\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    if (this.config.strictSafeNavigationTypes) {\n      const expr = ts22.factory.createPropertyAccessExpression(ts22.factory.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(expr, ast.nameSpan);\n      node = ts22.factory.createParenthesizedExpression(ts22.factory.createConditionalExpression(NULL_AS_ANY, void 0, expr, void 0, UNDEFINED));\n    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      node = ts22.factory.createPropertyAccessExpression(tsCastToAny(receiver), ast.name);\n    } else {\n      const expr = ts22.factory.createPropertyAccessExpression(ts22.factory.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(expr, ast.nameSpan);\n      node = tsCastToAny(expr);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitSafeKeyedRead(ast) {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const key = this.translate(ast.key);\n    let node;\n    if (this.config.strictSafeNavigationTypes) {\n      const expr = ts22.factory.createElementAccessExpression(ts22.factory.createNonNullExpression(receiver), key);\n      addParseSpanInfo(expr, ast.sourceSpan);\n      node = ts22.factory.createParenthesizedExpression(ts22.factory.createConditionalExpression(NULL_AS_ANY, void 0, expr, void 0, UNDEFINED));\n    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      node = ts22.factory.createElementAccessExpression(tsCastToAny(receiver), key);\n    } else {\n      const expr = ts22.factory.createElementAccessExpression(ts22.factory.createNonNullExpression(receiver), key);\n      addParseSpanInfo(expr, ast.sourceSpan);\n      node = tsCastToAny(expr);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitCall(ast) {\n    const args = ast.args.map((expr2) => this.translate(expr2));\n    let expr;\n    const receiver = ast.receiver;\n    if (receiver instanceof PropertyRead3) {\n      const resolved = this.maybeResolve(receiver);\n      if (resolved !== null) {\n        expr = resolved;\n      } else {\n        const propertyReceiver = wrapForDiagnostics(this.translate(receiver.receiver));\n        expr = ts22.factory.createPropertyAccessExpression(propertyReceiver, receiver.name);\n        addParseSpanInfo(expr, receiver.nameSpan);\n      }\n    } else {\n      expr = this.translate(receiver);\n    }\n    let node;\n    if (ast.receiver instanceof SafePropertyRead2 || ast.receiver instanceof SafeKeyedRead) {\n      node = this.convertToSafeCall(ast, expr, args);\n    } else {\n      node = ts22.factory.createCallExpression(expr, void 0, args);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  visitSafeCall(ast) {\n    const args = ast.args.map((expr2) => this.translate(expr2));\n    const expr = wrapForDiagnostics(this.translate(ast.receiver));\n    const node = this.convertToSafeCall(ast, expr, args);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n  convertToSafeCall(ast, expr, args) {\n    if (this.config.strictSafeNavigationTypes) {\n      const call = ts22.factory.createCallExpression(ts22.factory.createNonNullExpression(expr), void 0, args);\n      return ts22.factory.createParenthesizedExpression(ts22.factory.createConditionalExpression(NULL_AS_ANY, void 0, call, void 0, UNDEFINED));\n    }\n    if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      return ts22.factory.createCallExpression(tsCastToAny(expr), void 0, args);\n    }\n    return tsCastToAny(ts22.factory.createCallExpression(ts22.factory.createNonNullExpression(expr), void 0, args));\n  }\n};\nvar _VeSafeLhsInferenceBugDetector = class {\n  static veWillInferAnyFor(ast) {\n    const visitor = _VeSafeLhsInferenceBugDetector.SINGLETON;\n    return ast instanceof Call ? ast.visit(visitor) : ast.receiver.visit(visitor);\n  }\n  visitUnary(ast) {\n    return ast.expr.visit(this);\n  }\n  visitBinary(ast) {\n    return ast.left.visit(this) || ast.right.visit(this);\n  }\n  visitChain(ast) {\n    return false;\n  }\n  visitConditional(ast) {\n    return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);\n  }\n  visitCall(ast) {\n    return true;\n  }\n  visitSafeCall(ast) {\n    return false;\n  }\n  visitImplicitReceiver(ast) {\n    return false;\n  }\n  visitThisReceiver(ast) {\n    return false;\n  }\n  visitInterpolation(ast) {\n    return ast.expressions.some((exp) => exp.visit(this));\n  }\n  visitKeyedRead(ast) {\n    return false;\n  }\n  visitKeyedWrite(ast) {\n    return false;\n  }\n  visitLiteralArray(ast) {\n    return true;\n  }\n  visitLiteralMap(ast) {\n    return true;\n  }\n  visitLiteralPrimitive(ast) {\n    return false;\n  }\n  visitPipe(ast) {\n    return true;\n  }\n  visitPrefixNot(ast) {\n    return ast.expression.visit(this);\n  }\n  visitNonNullAssert(ast) {\n    return ast.expression.visit(this);\n  }\n  visitPropertyRead(ast) {\n    return false;\n  }\n  visitPropertyWrite(ast) {\n    return false;\n  }\n  visitSafePropertyRead(ast) {\n    return false;\n  }\n  visitSafeKeyedRead(ast) {\n    return false;\n  }\n};\nvar VeSafeLhsInferenceBugDetector = _VeSafeLhsInferenceBugDetector;\n(() => {\n  _VeSafeLhsInferenceBugDetector.SINGLETON = new _VeSafeLhsInferenceBugDetector();\n})();\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/template_semantics.mjs\nimport { ImplicitReceiver as ImplicitReceiver3, RecursiveAstVisitor as RecursiveAstVisitor2, TmplAstVariable } from \"@angular/compiler\";\nvar ExpressionSemanticVisitor = class extends RecursiveAstVisitor2 {\n  constructor(templateId, boundTarget, oob) {\n    super();\n    this.templateId = templateId;\n    this.boundTarget = boundTarget;\n    this.oob = oob;\n  }\n  visitPropertyWrite(ast, context) {\n    super.visitPropertyWrite(ast, context);\n    if (!(ast.receiver instanceof ImplicitReceiver3)) {\n      return;\n    }\n    const target = this.boundTarget.getExpressionTarget(ast);\n    if (target instanceof TmplAstVariable) {\n      this.oob.illegalAssignmentToTemplateVar(this.templateId, ast, target);\n    }\n  }\n  static visit(ast, id, boundTarget, oob) {\n    ast.visit(new ExpressionSemanticVisitor(id, boundTarget, oob));\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.mjs\nvar TcbGenericContextBehavior;\n(function(TcbGenericContextBehavior2) {\n  TcbGenericContextBehavior2[TcbGenericContextBehavior2[\"UseEmitter\"] = 0] = \"UseEmitter\";\n  TcbGenericContextBehavior2[TcbGenericContextBehavior2[\"CopyClassNodes\"] = 1] = \"CopyClassNodes\";\n  TcbGenericContextBehavior2[TcbGenericContextBehavior2[\"FallbackToAny\"] = 2] = \"FallbackToAny\";\n})(TcbGenericContextBehavior || (TcbGenericContextBehavior = {}));\nfunction generateTypeCheckBlock(env, ref, name, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {\n  const tcb = new Context(env, domSchemaChecker, oobRecorder, meta.id, meta.boundTarget, meta.pipes, meta.schemas, meta.isStandalone);\n  const scope = Scope.forNodes(tcb, null, tcb.boundTarget.target.template, null);\n  const ctxRawType = env.referenceType(ref);\n  if (!ts23.isTypeReferenceNode(ctxRawType)) {\n    throw new Error(`Expected TypeReferenceNode when referencing the ctx param for ${ref.debugName}`);\n  }\n  let typeParameters = void 0;\n  let typeArguments = void 0;\n  if (ref.node.typeParameters !== void 0) {\n    if (!env.config.useContextGenericType) {\n      genericContextBehavior = TcbGenericContextBehavior.FallbackToAny;\n    }\n    switch (genericContextBehavior) {\n      case TcbGenericContextBehavior.UseEmitter:\n        typeParameters = new TypeParameterEmitter(ref.node.typeParameters, env.reflector).emit((typeRef) => env.referenceType(typeRef));\n        typeArguments = typeParameters.map((param) => ts23.factory.createTypeReferenceNode(param.name));\n        break;\n      case TcbGenericContextBehavior.CopyClassNodes:\n        typeParameters = [...ref.node.typeParameters];\n        typeArguments = typeParameters.map((param) => ts23.factory.createTypeReferenceNode(param.name));\n        break;\n      case TcbGenericContextBehavior.FallbackToAny:\n        typeArguments = ref.node.typeParameters.map(() => ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n        break;\n    }\n  }\n  const paramList = [tcbThisParam(ctxRawType.typeName, typeArguments)];\n  const scopeStatements = scope.render();\n  const innerBody = ts23.factory.createBlock([\n    ...env.getPreludeStatements(),\n    ...scopeStatements\n  ]);\n  const body = ts23.factory.createBlock([ts23.factory.createIfStatement(ts23.factory.createTrue(), innerBody, void 0)]);\n  const fnDecl = ts23.factory.createFunctionDeclaration(\n    void 0,\n    void 0,\n    name,\n    env.config.useContextGenericType ? typeParameters : void 0,\n    paramList,\n    void 0,\n    body\n  );\n  addTemplateId(fnDecl, meta.id);\n  return fnDecl;\n}\nvar TcbOp = class {\n  circularFallback() {\n    return INFER_TYPE_FOR_CIRCULAR_OP_EXPR;\n  }\n};\nvar TcbElementOp = class extends TcbOp {\n  constructor(tcb, scope, element) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.element = element;\n  }\n  get optional() {\n    return true;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    const initializer = tsCreateElement(this.element.name);\n    addParseSpanInfo(initializer, this.element.startSourceSpan || this.element.sourceSpan);\n    this.scope.addStatement(tsCreateVariable(id, initializer));\n    return id;\n  }\n};\nvar TcbVariableOp = class extends TcbOp {\n  constructor(tcb, scope, template, variable) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.template = template;\n    this.variable = variable;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    const ctx = this.scope.resolve(this.template);\n    const id = this.tcb.allocateId();\n    const initializer = ts23.factory.createPropertyAccessExpression(\n      ctx,\n      this.variable.value || \"$implicit\"\n    );\n    addParseSpanInfo(id, this.variable.keySpan);\n    let variable;\n    if (this.variable.valueSpan !== void 0) {\n      addParseSpanInfo(initializer, this.variable.valueSpan);\n      variable = tsCreateVariable(id, wrapForTypeChecker(initializer));\n    } else {\n      variable = tsCreateVariable(id, initializer);\n    }\n    addParseSpanInfo(variable.declarationList.declarations[0], this.variable.sourceSpan);\n    this.scope.addStatement(variable);\n    return id;\n  }\n};\nvar TcbTemplateContextOp = class extends TcbOp {\n  constructor(tcb, scope) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.optional = true;\n  }\n  execute() {\n    const ctx = this.tcb.allocateId();\n    const type = ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword);\n    this.scope.addStatement(tsDeclareVariable(ctx, type));\n    return ctx;\n  }\n};\nvar TcbTemplateBodyOp = class extends TcbOp {\n  constructor(tcb, scope, template) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.template = template;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    const directiveGuards = [];\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(this.template);\n    if (directives !== null) {\n      for (const dir of directives) {\n        const dirInstId = this.scope.resolve(this.template, dir);\n        const dirId = this.tcb.env.reference(dir.ref);\n        dir.ngTemplateGuards.forEach((guard2) => {\n          const boundInput = this.template.inputs.find((i) => i.name === guard2.inputName) || this.template.templateAttrs.find((i) => i instanceof TmplAstBoundAttribute && i.name === guard2.inputName);\n          if (boundInput !== void 0) {\n            const expr = tcbExpression(boundInput.value, this.tcb, this.scope);\n            markIgnoreDiagnostics(expr);\n            if (guard2.type === \"binding\") {\n              directiveGuards.push(expr);\n            } else {\n              const guardInvoke = tsCallMethod(dirId, `ngTemplateGuard_${guard2.inputName}`, [\n                dirInstId,\n                expr\n              ]);\n              addParseSpanInfo(guardInvoke, boundInput.value.sourceSpan);\n              directiveGuards.push(guardInvoke);\n            }\n          }\n        });\n        if (dir.hasNgTemplateContextGuard) {\n          if (this.tcb.env.config.applyTemplateContextGuards) {\n            const ctx = this.scope.resolve(this.template);\n            const guardInvoke = tsCallMethod(dirId, \"ngTemplateContextGuard\", [dirInstId, ctx]);\n            addParseSpanInfo(guardInvoke, this.template.sourceSpan);\n            directiveGuards.push(guardInvoke);\n          } else if (this.template.variables.length > 0 && this.tcb.env.config.suggestionsForSuboptimalTypeInference) {\n            this.tcb.oobRecorder.suboptimalTypeInference(this.tcb.id, this.template.variables);\n          }\n        }\n      }\n    }\n    let guard = null;\n    if (directiveGuards.length > 0) {\n      guard = directiveGuards.reduce((expr, dirGuard) => ts23.factory.createBinaryExpression(expr, ts23.SyntaxKind.AmpersandAmpersandToken, dirGuard), directiveGuards.pop());\n    }\n    const tmplScope = Scope.forNodes(this.tcb, this.scope, this.template, guard);\n    const statements = tmplScope.render();\n    if (statements.length === 0) {\n      return null;\n    }\n    let tmplBlock = ts23.factory.createBlock(statements);\n    if (guard !== null) {\n      tmplBlock = ts23.factory.createIfStatement(guard, tmplBlock);\n    }\n    this.scope.addStatement(tmplBlock);\n    return null;\n  }\n};\nvar TcbTextInterpolationOp = class extends TcbOp {\n  constructor(tcb, scope, binding) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.binding = binding;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    const expr = tcbExpression(this.binding.value, this.tcb, this.scope);\n    this.scope.addStatement(ts23.factory.createExpressionStatement(expr));\n    return null;\n  }\n};\nvar TcbDirectiveTypeOpBase = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return true;\n  }\n  execute() {\n    const dirRef = this.dir.ref;\n    const rawType = this.tcb.env.referenceType(this.dir.ref);\n    let type;\n    if (this.dir.isGeneric === false || dirRef.node.typeParameters === void 0) {\n      type = rawType;\n    } else {\n      if (!ts23.isTypeReferenceNode(rawType)) {\n        throw new Error(`Expected TypeReferenceNode when referencing the type for ${this.dir.ref.debugName}`);\n      }\n      const typeArguments = dirRef.node.typeParameters.map(() => ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n      type = ts23.factory.createTypeReferenceNode(rawType.typeName, typeArguments);\n    }\n    const id = this.tcb.allocateId();\n    addExpressionIdentifier(type, ExpressionIdentifier.DIRECTIVE);\n    addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);\n    this.scope.addStatement(tsDeclareVariable(id, type));\n    return id;\n  }\n};\nvar TcbNonGenericDirectiveTypeOp = class extends TcbDirectiveTypeOpBase {\n  execute() {\n    const dirRef = this.dir.ref;\n    if (this.dir.isGeneric) {\n      throw new Error(`Assertion Error: expected ${dirRef.debugName} not to be generic.`);\n    }\n    return super.execute();\n  }\n};\nvar TcbGenericDirectiveTypeWithAnyParamsOp = class extends TcbDirectiveTypeOpBase {\n  execute() {\n    const dirRef = this.dir.ref;\n    if (dirRef.node.typeParameters === void 0) {\n      throw new Error(`Assertion Error: expected typeParameters when creating a declaration for ${dirRef.debugName}`);\n    }\n    return super.execute();\n  }\n};\nvar TcbReferenceOp = class extends TcbOp {\n  constructor(tcb, scope, node, host, target) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.host = host;\n    this.target = target;\n    this.optional = true;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    let initializer = this.target instanceof TmplAstTemplate2 || this.target instanceof TmplAstElement3 ? this.scope.resolve(this.target) : this.scope.resolve(this.host, this.target);\n    if (this.target instanceof TmplAstElement3 && !this.tcb.env.config.checkTypeOfDomReferences || !this.tcb.env.config.checkTypeOfNonDomReferences) {\n      initializer = ts23.factory.createAsExpression(initializer, ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n    } else if (this.target instanceof TmplAstTemplate2) {\n      initializer = ts23.factory.createAsExpression(initializer, ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n      initializer = ts23.factory.createAsExpression(initializer, this.tcb.env.referenceExternalType(\"@angular/core\", \"TemplateRef\", [DYNAMIC_TYPE]));\n      initializer = ts23.factory.createParenthesizedExpression(initializer);\n    }\n    addParseSpanInfo(initializer, this.node.sourceSpan);\n    addParseSpanInfo(id, this.node.keySpan);\n    this.scope.addStatement(tsCreateVariable(id, initializer));\n    return id;\n  }\n};\nvar TcbInvalidReferenceOp = class extends TcbOp {\n  constructor(tcb, scope) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.optional = true;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    this.scope.addStatement(tsCreateVariable(id, NULL_AS_ANY));\n    return id;\n  }\n};\nvar TcbDirectiveCtorOp = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return true;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    addExpressionIdentifier(id, ExpressionIdentifier.DIRECTIVE);\n    addParseSpanInfo(id, this.node.startSourceSpan || this.node.sourceSpan);\n    const genericInputs = /* @__PURE__ */ new Map();\n    const boundAttrs = getBoundAttributes(this.dir, this.node);\n    for (const attr of boundAttrs) {\n      if (!this.tcb.env.config.checkTypeOfAttributes && attr.attribute instanceof TmplAstTextAttribute2) {\n        continue;\n      }\n      for (const { fieldName } of attr.inputs) {\n        if (genericInputs.has(fieldName)) {\n          continue;\n        }\n        const expression = translateInput(attr.attribute, this.tcb, this.scope);\n        genericInputs.set(fieldName, { type: \"binding\", field: fieldName, expression, sourceSpan: attr.attribute.sourceSpan });\n      }\n    }\n    for (const { classPropertyName } of this.dir.inputs) {\n      if (!genericInputs.has(classPropertyName)) {\n        genericInputs.set(classPropertyName, { type: \"unset\", field: classPropertyName });\n      }\n    }\n    const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, Array.from(genericInputs.values()));\n    markIgnoreDiagnostics(typeCtor);\n    this.scope.addStatement(tsCreateVariable(id, typeCtor));\n    return id;\n  }\n  circularFallback() {\n    return new TcbDirectiveCtorCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);\n  }\n};\nvar TcbDirectiveInputsOp = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    let dirId = null;\n    const boundAttrs = getBoundAttributes(this.dir, this.node);\n    const seenRequiredInputs = /* @__PURE__ */ new Set();\n    for (const attr of boundAttrs) {\n      const expr = widenBinding(translateInput(attr.attribute, this.tcb, this.scope), this.tcb);\n      let assignment = wrapForDiagnostics(expr);\n      for (const { fieldName, required, transformType } of attr.inputs) {\n        let target;\n        if (required) {\n          seenRequiredInputs.add(fieldName);\n        }\n        if (this.dir.coercedInputFields.has(fieldName)) {\n          let type;\n          if (transformType) {\n            type = this.tcb.env.referenceTransplantedType(new TransplantedType(transformType));\n          } else {\n            const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n            if (!ts23.isTypeReferenceNode(dirTypeRef)) {\n              throw new Error(`Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n            }\n            type = tsCreateTypeQueryForCoercedInput(dirTypeRef.typeName, fieldName);\n          }\n          const id = this.tcb.allocateId();\n          this.scope.addStatement(tsDeclareVariable(id, type));\n          target = id;\n        } else if (this.dir.undeclaredInputFields.has(fieldName)) {\n          continue;\n        } else if (!this.tcb.env.config.honorAccessModifiersForInputBindings && this.dir.restrictedInputFields.has(fieldName)) {\n          if (dirId === null) {\n            dirId = this.scope.resolve(this.node, this.dir);\n          }\n          const id = this.tcb.allocateId();\n          const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n          if (!ts23.isTypeReferenceNode(dirTypeRef)) {\n            throw new Error(`Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n          }\n          const type = ts23.factory.createIndexedAccessTypeNode(ts23.factory.createTypeQueryNode(dirId), ts23.factory.createLiteralTypeNode(ts23.factory.createStringLiteral(fieldName)));\n          const temp = tsDeclareVariable(id, type);\n          this.scope.addStatement(temp);\n          target = id;\n        } else {\n          if (dirId === null) {\n            dirId = this.scope.resolve(this.node, this.dir);\n          }\n          target = this.dir.stringLiteralInputFields.has(fieldName) ? ts23.factory.createElementAccessExpression(dirId, ts23.factory.createStringLiteral(fieldName)) : ts23.factory.createPropertyAccessExpression(dirId, ts23.factory.createIdentifier(fieldName));\n        }\n        if (attr.attribute.keySpan !== void 0) {\n          addParseSpanInfo(target, attr.attribute.keySpan);\n        }\n        assignment = ts23.factory.createBinaryExpression(target, ts23.SyntaxKind.EqualsToken, assignment);\n      }\n      addParseSpanInfo(assignment, attr.attribute.sourceSpan);\n      if (!this.tcb.env.config.checkTypeOfAttributes && attr.attribute instanceof TmplAstTextAttribute2) {\n        markIgnoreDiagnostics(assignment);\n      }\n      this.scope.addStatement(ts23.factory.createExpressionStatement(assignment));\n    }\n    this.checkRequiredInputs(seenRequiredInputs);\n    return null;\n  }\n  checkRequiredInputs(seenRequiredInputs) {\n    const missing = [];\n    for (const input of this.dir.inputs) {\n      if (input.required && !seenRequiredInputs.has(input.classPropertyName)) {\n        missing.push(input.bindingPropertyName);\n      }\n    }\n    if (missing.length > 0) {\n      this.tcb.oobRecorder.missingRequiredInputs(this.tcb.id, this.node, this.dir.name, this.dir.isComponent, missing);\n    }\n  }\n};\nvar TcbDirectiveCtorCircularFallbackOp = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    const id = this.tcb.allocateId();\n    const typeCtor = this.tcb.env.typeCtorFor(this.dir);\n    const circularPlaceholder = ts23.factory.createCallExpression(typeCtor, void 0, [ts23.factory.createNonNullExpression(ts23.factory.createNull())]);\n    this.scope.addStatement(tsCreateVariable(id, circularPlaceholder));\n    return id;\n  }\n};\nvar TcbDomSchemaCheckerOp = class extends TcbOp {\n  constructor(tcb, element, checkElement, claimedInputs) {\n    super();\n    this.tcb = tcb;\n    this.element = element;\n    this.checkElement = checkElement;\n    this.claimedInputs = claimedInputs;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    var _a;\n    if (this.checkElement) {\n      this.tcb.domSchemaChecker.checkElement(this.tcb.id, this.element, this.tcb.schemas, this.tcb.hostIsStandalone);\n    }\n    for (const binding of this.element.inputs) {\n      if (binding.type === 0 && this.claimedInputs.has(binding.name)) {\n        continue;\n      }\n      if (binding.type === 0) {\n        if (binding.name !== \"style\" && binding.name !== \"class\") {\n          const propertyName = (_a = ATTR_TO_PROP.get(binding.name)) != null ? _a : binding.name;\n          this.tcb.domSchemaChecker.checkProperty(this.tcb.id, this.element, propertyName, binding.sourceSpan, this.tcb.schemas, this.tcb.hostIsStandalone);\n        }\n      }\n    }\n    return null;\n  }\n};\nvar ATTR_TO_PROP = new Map(Object.entries({\n  \"class\": \"className\",\n  \"for\": \"htmlFor\",\n  \"formaction\": \"formAction\",\n  \"innerHtml\": \"innerHTML\",\n  \"readonly\": \"readOnly\",\n  \"tabindex\": \"tabIndex\"\n}));\nvar TcbUnclaimedInputsOp = class extends TcbOp {\n  constructor(tcb, scope, element, claimedInputs) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.element = element;\n    this.claimedInputs = claimedInputs;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    var _a;\n    let elId = null;\n    for (const binding of this.element.inputs) {\n      if (binding.type === 0 && this.claimedInputs.has(binding.name)) {\n        continue;\n      }\n      const expr = widenBinding(tcbExpression(binding.value, this.tcb, this.scope), this.tcb);\n      if (this.tcb.env.config.checkTypeOfDomBindings && binding.type === 0) {\n        if (binding.name !== \"style\" && binding.name !== \"class\") {\n          if (elId === null) {\n            elId = this.scope.resolve(this.element);\n          }\n          const propertyName = (_a = ATTR_TO_PROP.get(binding.name)) != null ? _a : binding.name;\n          const prop = ts23.factory.createElementAccessExpression(elId, ts23.factory.createStringLiteral(propertyName));\n          const stmt = ts23.factory.createBinaryExpression(prop, ts23.SyntaxKind.EqualsToken, wrapForDiagnostics(expr));\n          addParseSpanInfo(stmt, binding.sourceSpan);\n          this.scope.addStatement(ts23.factory.createExpressionStatement(stmt));\n        } else {\n          this.scope.addStatement(ts23.factory.createExpressionStatement(expr));\n        }\n      } else {\n        this.scope.addStatement(ts23.factory.createExpressionStatement(expr));\n      }\n    }\n    return null;\n  }\n};\nvar TcbDirectiveOutputsOp = class extends TcbOp {\n  constructor(tcb, scope, node, dir) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.node = node;\n    this.dir = dir;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    let dirId = null;\n    const outputs = this.dir.outputs;\n    for (const output of this.node.outputs) {\n      if (output.type !== 0 || !outputs.hasBindingPropertyName(output.name)) {\n        continue;\n      }\n      if (this.tcb.env.config.checkTypeOfOutputEvents && output.name.endsWith(\"Change\")) {\n        const inputName = output.name.slice(0, -6);\n        isSplitTwoWayBinding(inputName, output, this.node.inputs, this.tcb);\n      }\n      const field = outputs.getByBindingPropertyName(output.name)[0].classPropertyName;\n      if (dirId === null) {\n        dirId = this.scope.resolve(this.node, this.dir);\n      }\n      const outputField = ts23.factory.createElementAccessExpression(dirId, ts23.factory.createStringLiteral(field));\n      addParseSpanInfo(outputField, output.keySpan);\n      if (this.tcb.env.config.checkTypeOfOutputEvents) {\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0);\n        const subscribeFn = ts23.factory.createPropertyAccessExpression(outputField, \"subscribe\");\n        const call = ts23.factory.createCallExpression(subscribeFn, void 0, [handler]);\n        addParseSpanInfo(call, output.sourceSpan);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(call));\n      } else {\n        this.scope.addStatement(ts23.factory.createExpressionStatement(outputField));\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(handler));\n      }\n      ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n    }\n    return null;\n  }\n};\nvar TcbUnclaimedOutputsOp = class extends TcbOp {\n  constructor(tcb, scope, element, claimedOutputs) {\n    super();\n    this.tcb = tcb;\n    this.scope = scope;\n    this.element = element;\n    this.claimedOutputs = claimedOutputs;\n  }\n  get optional() {\n    return false;\n  }\n  execute() {\n    let elId = null;\n    for (const output of this.element.outputs) {\n      if (this.claimedOutputs.has(output.name)) {\n        continue;\n      }\n      if (this.tcb.env.config.checkTypeOfOutputEvents && output.name.endsWith(\"Change\")) {\n        const inputName = output.name.slice(0, -6);\n        if (isSplitTwoWayBinding(inputName, output, this.element.inputs, this.tcb)) {\n          continue;\n        }\n      }\n      if (output.type === 1) {\n        const eventType = this.tcb.env.config.checkTypeOfAnimationEvents ? this.tcb.env.referenceExternalType(\"@angular/animations\", \"AnimationEvent\") : 1;\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, eventType);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(handler));\n      } else if (this.tcb.env.config.checkTypeOfDomEvents) {\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0);\n        if (elId === null) {\n          elId = this.scope.resolve(this.element);\n        }\n        const propertyAccess = ts23.factory.createPropertyAccessExpression(elId, \"addEventListener\");\n        addParseSpanInfo(propertyAccess, output.keySpan);\n        const call = ts23.factory.createCallExpression(\n          propertyAccess,\n          void 0,\n          [ts23.factory.createStringLiteral(output.name), handler]\n        );\n        addParseSpanInfo(call, output.sourceSpan);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(call));\n      } else {\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1);\n        this.scope.addStatement(ts23.factory.createExpressionStatement(handler));\n      }\n      ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n    }\n    return null;\n  }\n};\nvar TcbComponentContextCompletionOp = class extends TcbOp {\n  constructor(scope) {\n    super();\n    this.scope = scope;\n    this.optional = false;\n  }\n  execute() {\n    const ctx = ts23.factory.createThis();\n    const ctxDot = ts23.factory.createPropertyAccessExpression(ctx, \"\");\n    markIgnoreDiagnostics(ctxDot);\n    addExpressionIdentifier(ctxDot, ExpressionIdentifier.COMPONENT_COMPLETION);\n    this.scope.addStatement(ts23.factory.createExpressionStatement(ctxDot));\n    return null;\n  }\n};\nvar INFER_TYPE_FOR_CIRCULAR_OP_EXPR = ts23.factory.createNonNullExpression(ts23.factory.createNull());\nvar Context = class {\n  constructor(env, domSchemaChecker, oobRecorder, id, boundTarget, pipes, schemas, hostIsStandalone) {\n    this.env = env;\n    this.domSchemaChecker = domSchemaChecker;\n    this.oobRecorder = oobRecorder;\n    this.id = id;\n    this.boundTarget = boundTarget;\n    this.pipes = pipes;\n    this.schemas = schemas;\n    this.hostIsStandalone = hostIsStandalone;\n    this.nextId = 1;\n  }\n  allocateId() {\n    return ts23.factory.createIdentifier(`_t${this.nextId++}`);\n  }\n  getPipeByName(name) {\n    if (!this.pipes.has(name)) {\n      return null;\n    }\n    return this.pipes.get(name);\n  }\n};\nvar Scope = class {\n  constructor(tcb, parent = null, guard = null) {\n    this.tcb = tcb;\n    this.parent = parent;\n    this.guard = guard;\n    this.opQueue = [];\n    this.elementOpMap = /* @__PURE__ */ new Map();\n    this.directiveOpMap = /* @__PURE__ */ new Map();\n    this.referenceOpMap = /* @__PURE__ */ new Map();\n    this.templateCtxOpMap = /* @__PURE__ */ new Map();\n    this.varMap = /* @__PURE__ */ new Map();\n    this.statements = [];\n  }\n  static forNodes(tcb, parent, templateOrNodes, guard) {\n    const scope = new Scope(tcb, parent, guard);\n    if (parent === null && tcb.env.config.enableTemplateTypeChecker) {\n      scope.opQueue.push(new TcbComponentContextCompletionOp(scope));\n    }\n    let children;\n    if (templateOrNodes instanceof TmplAstTemplate2) {\n      const varMap = /* @__PURE__ */ new Map();\n      for (const v of templateOrNodes.variables) {\n        if (!varMap.has(v.name)) {\n          varMap.set(v.name, v);\n        } else {\n          const firstDecl = varMap.get(v.name);\n          tcb.oobRecorder.duplicateTemplateVar(tcb.id, v, firstDecl);\n        }\n        const opIndex = scope.opQueue.push(new TcbVariableOp(tcb, scope, templateOrNodes, v)) - 1;\n        scope.varMap.set(v, opIndex);\n      }\n      children = templateOrNodes.children;\n    } else {\n      children = templateOrNodes;\n    }\n    for (const node of children) {\n      scope.appendNode(node);\n    }\n    return scope;\n  }\n  resolve(node, directive) {\n    const res = this.resolveLocal(node, directive);\n    if (res !== null) {\n      let clone;\n      if (ts23.isIdentifier(res)) {\n        clone = ts23.factory.createIdentifier(res.text);\n      } else if (ts23.isNonNullExpression(res)) {\n        clone = ts23.factory.createNonNullExpression(res.expression);\n      } else {\n        throw new Error(`Could not resolve ${node} to an Identifier or a NonNullExpression`);\n      }\n      ts23.setOriginalNode(clone, res);\n      clone.parent = clone.parent;\n      return ts23.setSyntheticTrailingComments(clone, []);\n    } else if (this.parent !== null) {\n      return this.parent.resolve(node, directive);\n    } else {\n      throw new Error(`Could not resolve ${node} / ${directive}`);\n    }\n  }\n  addStatement(stmt) {\n    this.statements.push(stmt);\n  }\n  render() {\n    for (let i = 0; i < this.opQueue.length; i++) {\n      const skipOptional = !this.tcb.env.config.enableTemplateTypeChecker;\n      this.executeOp(i, skipOptional);\n    }\n    return this.statements;\n  }\n  guards() {\n    let parentGuards = null;\n    if (this.parent !== null) {\n      parentGuards = this.parent.guards();\n    }\n    if (this.guard === null) {\n      return parentGuards;\n    } else if (parentGuards === null) {\n      return this.guard;\n    } else {\n      return ts23.factory.createBinaryExpression(parentGuards, ts23.SyntaxKind.AmpersandAmpersandToken, this.guard);\n    }\n  }\n  resolveLocal(ref, directive) {\n    if (ref instanceof TmplAstReference3 && this.referenceOpMap.has(ref)) {\n      return this.resolveOp(this.referenceOpMap.get(ref));\n    } else if (ref instanceof TmplAstVariable2 && this.varMap.has(ref)) {\n      return this.resolveOp(this.varMap.get(ref));\n    } else if (ref instanceof TmplAstTemplate2 && directive === void 0 && this.templateCtxOpMap.has(ref)) {\n      return this.resolveOp(this.templateCtxOpMap.get(ref));\n    } else if ((ref instanceof TmplAstElement3 || ref instanceof TmplAstTemplate2) && directive !== void 0 && this.directiveOpMap.has(ref)) {\n      const dirMap = this.directiveOpMap.get(ref);\n      if (dirMap.has(directive)) {\n        return this.resolveOp(dirMap.get(directive));\n      } else {\n        return null;\n      }\n    } else if (ref instanceof TmplAstElement3 && this.elementOpMap.has(ref)) {\n      return this.resolveOp(this.elementOpMap.get(ref));\n    } else {\n      return null;\n    }\n  }\n  resolveOp(opIndex) {\n    const res = this.executeOp(opIndex, false);\n    if (res === null) {\n      throw new Error(`Error resolving operation, got null`);\n    }\n    return res;\n  }\n  executeOp(opIndex, skipOptional) {\n    const op = this.opQueue[opIndex];\n    if (!(op instanceof TcbOp)) {\n      return op;\n    }\n    if (skipOptional && op.optional) {\n      return null;\n    }\n    this.opQueue[opIndex] = op.circularFallback();\n    const res = op.execute();\n    this.opQueue[opIndex] = res;\n    return res;\n  }\n  appendNode(node) {\n    if (node instanceof TmplAstElement3) {\n      const opIndex = this.opQueue.push(new TcbElementOp(this.tcb, this, node)) - 1;\n      this.elementOpMap.set(node, opIndex);\n      this.appendDirectivesAndInputsOfNode(node);\n      this.appendOutputsOfNode(node);\n      for (const child of node.children) {\n        this.appendNode(child);\n      }\n      this.checkAndAppendReferencesOfNode(node);\n    } else if (node instanceof TmplAstTemplate2) {\n      this.appendDirectivesAndInputsOfNode(node);\n      this.appendOutputsOfNode(node);\n      const ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;\n      this.templateCtxOpMap.set(node, ctxIndex);\n      if (this.tcb.env.config.checkTemplateBodies) {\n        this.opQueue.push(new TcbTemplateBodyOp(this.tcb, this, node));\n      } else if (this.tcb.env.config.alwaysCheckSchemaInTemplateBodies) {\n        this.appendDeepSchemaChecks(node.children);\n      }\n      this.checkAndAppendReferencesOfNode(node);\n    } else if (node instanceof TmplAstBoundText) {\n      this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, node));\n    } else if (node instanceof TmplAstIcu) {\n      this.appendIcuExpressions(node);\n    }\n  }\n  checkAndAppendReferencesOfNode(node) {\n    for (const ref of node.references) {\n      const target = this.tcb.boundTarget.getReferenceTarget(ref);\n      let ctxIndex;\n      if (target === null) {\n        this.tcb.oobRecorder.missingReferenceTarget(this.tcb.id, ref);\n        ctxIndex = this.opQueue.push(new TcbInvalidReferenceOp(this.tcb, this)) - 1;\n      } else if (target instanceof TmplAstTemplate2 || target instanceof TmplAstElement3) {\n        ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target)) - 1;\n      } else {\n        ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target.directive)) - 1;\n      }\n      this.referenceOpMap.set(ref, ctxIndex);\n    }\n  }\n  appendDirectivesAndInputsOfNode(node) {\n    const claimedInputs = /* @__PURE__ */ new Set();\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n    if (directives === null || directives.length === 0) {\n      if (node instanceof TmplAstElement3) {\n        this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));\n        this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, true, claimedInputs));\n      }\n      return;\n    }\n    const dirMap = /* @__PURE__ */ new Map();\n    for (const dir of directives) {\n      let directiveOp;\n      const host = this.tcb.env.reflector;\n      const dirRef = dir.ref;\n      if (!dir.isGeneric) {\n        directiveOp = new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);\n      } else if (!requiresInlineTypeCtor(dirRef.node, host, this.tcb.env) || this.tcb.env.config.useInlineTypeConstructors) {\n        directiveOp = new TcbDirectiveCtorOp(this.tcb, this, node, dir);\n      } else {\n        directiveOp = new TcbGenericDirectiveTypeWithAnyParamsOp(this.tcb, this, node, dir);\n      }\n      const dirIndex = this.opQueue.push(directiveOp) - 1;\n      dirMap.set(dir, dirIndex);\n      this.opQueue.push(new TcbDirectiveInputsOp(this.tcb, this, node, dir));\n    }\n    this.directiveOpMap.set(node, dirMap);\n    if (node instanceof TmplAstElement3) {\n      for (const dir of directives) {\n        for (const propertyName of dir.inputs.propertyNames) {\n          claimedInputs.add(propertyName);\n        }\n      }\n      this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));\n      const checkElement = directives.length === 0;\n      this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, checkElement, claimedInputs));\n    }\n  }\n  appendOutputsOfNode(node) {\n    const claimedOutputs = /* @__PURE__ */ new Set();\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n    if (directives === null || directives.length === 0) {\n      if (node instanceof TmplAstElement3) {\n        this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n      }\n      return;\n    }\n    for (const dir of directives) {\n      this.opQueue.push(new TcbDirectiveOutputsOp(this.tcb, this, node, dir));\n    }\n    if (node instanceof TmplAstElement3) {\n      for (const dir of directives) {\n        for (const outputProperty of dir.outputs.propertyNames) {\n          claimedOutputs.add(outputProperty);\n        }\n      }\n      this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n    }\n  }\n  appendDeepSchemaChecks(nodes) {\n    for (const node of nodes) {\n      if (!(node instanceof TmplAstElement3 || node instanceof TmplAstTemplate2)) {\n        continue;\n      }\n      if (node instanceof TmplAstElement3) {\n        const claimedInputs = /* @__PURE__ */ new Set();\n        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n        let hasDirectives;\n        if (directives === null || directives.length === 0) {\n          hasDirectives = false;\n        } else {\n          hasDirectives = true;\n          for (const dir of directives) {\n            for (const propertyName of dir.inputs.propertyNames) {\n              claimedInputs.add(propertyName);\n            }\n          }\n        }\n        this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, !hasDirectives, claimedInputs));\n      }\n      this.appendDeepSchemaChecks(node.children);\n    }\n  }\n  appendIcuExpressions(node) {\n    for (const variable of Object.values(node.vars)) {\n      this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, variable));\n    }\n    for (const placeholder of Object.values(node.placeholders)) {\n      if (placeholder instanceof TmplAstBoundText) {\n        this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, placeholder));\n      }\n    }\n  }\n};\nfunction tcbThisParam(name, typeArguments) {\n  return ts23.factory.createParameterDeclaration(\n    void 0,\n    void 0,\n    \"this\",\n    void 0,\n    ts23.factory.createTypeReferenceNode(name, typeArguments),\n    void 0\n  );\n}\nfunction tcbExpression(ast, tcb, scope) {\n  const translator = new TcbExpressionTranslator(tcb, scope);\n  return translator.translate(ast);\n}\nvar TcbExpressionTranslator = class {\n  constructor(tcb, scope) {\n    this.tcb = tcb;\n    this.scope = scope;\n  }\n  translate(ast) {\n    return astToTypescript(ast, (ast2) => this.resolve(ast2), this.tcb.env.config);\n  }\n  resolve(ast) {\n    if (ast instanceof PropertyRead4 && ast.receiver instanceof ImplicitReceiver4) {\n      return this.resolveTarget(ast);\n    } else if (ast instanceof PropertyWrite3 && ast.receiver instanceof ImplicitReceiver4) {\n      const target = this.resolveTarget(ast);\n      if (target === null) {\n        return null;\n      }\n      const expr = this.translate(ast.value);\n      const result = ts23.factory.createParenthesizedExpression(ts23.factory.createBinaryExpression(target, ts23.SyntaxKind.EqualsToken, expr));\n      addParseSpanInfo(result, ast.sourceSpan);\n      return result;\n    } else if (ast instanceof ImplicitReceiver4) {\n      return ts23.factory.createThis();\n    } else if (ast instanceof BindingPipe) {\n      const expr = this.translate(ast.exp);\n      const pipeRef = this.tcb.getPipeByName(ast.name);\n      let pipe;\n      if (pipeRef === null) {\n        this.tcb.oobRecorder.missingPipe(this.tcb.id, ast);\n        pipe = NULL_AS_ANY;\n      } else {\n        pipe = this.tcb.env.pipeInst(pipeRef);\n      }\n      const args = ast.args.map((arg) => this.translate(arg));\n      let methodAccess = ts23.factory.createPropertyAccessExpression(pipe, \"transform\");\n      addParseSpanInfo(methodAccess, ast.nameSpan);\n      if (!this.tcb.env.config.checkTypeOfPipes) {\n        methodAccess = ts23.factory.createAsExpression(methodAccess, ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n      }\n      const result = ts23.factory.createCallExpression(\n        methodAccess,\n        void 0,\n        [expr, ...args]\n      );\n      addParseSpanInfo(result, ast.sourceSpan);\n      return result;\n    } else if ((ast instanceof Call2 || ast instanceof SafeCall) && (ast.receiver instanceof PropertyRead4 || ast.receiver instanceof SafePropertyRead3)) {\n      if (ast.receiver.receiver instanceof ImplicitReceiver4 && !(ast.receiver.receiver instanceof ThisReceiver) && ast.receiver.name === \"$any\" && ast.args.length === 1) {\n        const expr = this.translate(ast.args[0]);\n        const exprAsAny = ts23.factory.createAsExpression(expr, ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword));\n        const result = ts23.factory.createParenthesizedExpression(exprAsAny);\n        addParseSpanInfo(result, ast.sourceSpan);\n        return result;\n      }\n      const receiver = this.resolveTarget(ast);\n      if (receiver === null) {\n        return null;\n      }\n      const method = wrapForDiagnostics(receiver);\n      addParseSpanInfo(method, ast.receiver.nameSpan);\n      const args = ast.args.map((arg) => this.translate(arg));\n      const node = ts23.factory.createCallExpression(method, void 0, args);\n      addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    } else {\n      return null;\n    }\n  }\n  resolveTarget(ast) {\n    const binding = this.tcb.boundTarget.getExpressionTarget(ast);\n    if (binding === null) {\n      return null;\n    }\n    const expr = this.scope.resolve(binding);\n    addParseSpanInfo(expr, ast.sourceSpan);\n    return expr;\n  }\n};\nfunction tcbCallTypeCtor(dir, tcb, inputs) {\n  const typeCtor = tcb.env.typeCtorFor(dir);\n  const members = inputs.map((input) => {\n    const propertyName = ts23.factory.createStringLiteral(input.field);\n    if (input.type === \"binding\") {\n      const expr = widenBinding(input.expression, tcb);\n      const assignment = ts23.factory.createPropertyAssignment(propertyName, wrapForDiagnostics(expr));\n      addParseSpanInfo(assignment, input.sourceSpan);\n      return assignment;\n    } else {\n      return ts23.factory.createPropertyAssignment(propertyName, NULL_AS_ANY);\n    }\n  });\n  return ts23.factory.createCallExpression(\n    typeCtor,\n    void 0,\n    [ts23.factory.createObjectLiteralExpression(members)]\n  );\n}\nfunction getBoundAttributes(directive, node) {\n  const boundInputs = [];\n  const processAttribute = (attr) => {\n    if (attr instanceof TmplAstBoundAttribute && attr.type !== 0) {\n      return;\n    }\n    const inputs = directive.inputs.getByBindingPropertyName(attr.name);\n    if (inputs !== null) {\n      boundInputs.push({\n        attribute: attr,\n        inputs: inputs.map((input) => {\n          var _a;\n          return {\n            fieldName: input.classPropertyName,\n            required: input.required,\n            transformType: ((_a = input.transform) == null ? void 0 : _a.type) || null\n          };\n        })\n      });\n    }\n  };\n  node.inputs.forEach(processAttribute);\n  node.attributes.forEach(processAttribute);\n  if (node instanceof TmplAstTemplate2) {\n    node.templateAttrs.forEach(processAttribute);\n  }\n  return boundInputs;\n}\nfunction translateInput(attr, tcb, scope) {\n  if (attr instanceof TmplAstBoundAttribute) {\n    return tcbExpression(attr.value, tcb, scope);\n  } else {\n    return ts23.factory.createStringLiteral(attr.value);\n  }\n}\nfunction widenBinding(expr, tcb) {\n  if (!tcb.env.config.checkTypeOfInputBindings) {\n    return tsCastToAny(expr);\n  } else if (!tcb.env.config.strictNullInputBindings) {\n    if (ts23.isObjectLiteralExpression(expr) || ts23.isArrayLiteralExpression(expr)) {\n      return expr;\n    } else {\n      return ts23.factory.createNonNullExpression(expr);\n    }\n  } else {\n    return expr;\n  }\n}\nvar EVENT_PARAMETER = \"$event\";\nfunction tcbCreateEventHandler(event, tcb, scope, eventType) {\n  const handler = tcbEventHandlerExpression(event.handler, tcb, scope);\n  let eventParamType;\n  if (eventType === 0) {\n    eventParamType = void 0;\n  } else if (eventType === 1) {\n    eventParamType = ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword);\n  } else {\n    eventParamType = eventType;\n  }\n  const guards = scope.guards();\n  let body = ts23.factory.createExpressionStatement(handler);\n  if (guards !== null) {\n    body = ts23.factory.createIfStatement(guards, body);\n  }\n  const eventParam = ts23.factory.createParameterDeclaration(\n    void 0,\n    void 0,\n    EVENT_PARAMETER,\n    void 0,\n    eventParamType\n  );\n  addExpressionIdentifier(eventParam, ExpressionIdentifier.EVENT_PARAMETER);\n  return ts23.factory.createArrowFunction(\n    void 0,\n    void 0,\n    [eventParam],\n    ts23.factory.createKeywordTypeNode(ts23.SyntaxKind.AnyKeyword),\n    void 0,\n    ts23.factory.createBlock([body])\n  );\n}\nfunction tcbEventHandlerExpression(ast, tcb, scope) {\n  const translator = new TcbEventHandlerTranslator(tcb, scope);\n  return translator.translate(ast);\n}\nfunction isSplitTwoWayBinding(inputName, output, inputs, tcb) {\n  const input = inputs.find((input2) => input2.name === inputName);\n  if (input === void 0 || input.sourceSpan !== output.sourceSpan) {\n    return false;\n  }\n  const inputConsumer = tcb.boundTarget.getConsumerOfBinding(input);\n  const outputConsumer = tcb.boundTarget.getConsumerOfBinding(output);\n  if (outputConsumer === null || inputConsumer.ref === void 0 || outputConsumer instanceof TmplAstTemplate2) {\n    return false;\n  }\n  if (outputConsumer instanceof TmplAstElement3) {\n    tcb.oobRecorder.splitTwoWayBinding(tcb.id, input, output, inputConsumer.ref.node, outputConsumer);\n    return true;\n  } else if (outputConsumer.ref !== inputConsumer.ref) {\n    tcb.oobRecorder.splitTwoWayBinding(tcb.id, input, output, inputConsumer.ref.node, outputConsumer.ref.node);\n    return true;\n  }\n  return false;\n}\nvar TcbEventHandlerTranslator = class extends TcbExpressionTranslator {\n  resolve(ast) {\n    if (ast instanceof PropertyRead4 && ast.receiver instanceof ImplicitReceiver4 && !(ast.receiver instanceof ThisReceiver) && ast.name === EVENT_PARAMETER) {\n      const event = ts23.factory.createIdentifier(EVENT_PARAMETER);\n      addParseSpanInfo(event, ast.nameSpan);\n      return event;\n    }\n    return super.resolve(ast);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/type_check_file.mjs\nimport ts24 from \"typescript\";\nvar TypeCheckFile = class extends Environment {\n  constructor(fileName, config, refEmitter, reflector, compilerHost) {\n    super(config, new ImportManager(new NoopImportRewriter(), \"i\"), refEmitter, reflector, ts24.createSourceFile(compilerHost.getCanonicalFileName(fileName), \"\", ts24.ScriptTarget.Latest, true));\n    this.fileName = fileName;\n    this.nextTcbId = 1;\n    this.tcbStatements = [];\n  }\n  addTypeCheckBlock(ref, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {\n    const fnId = ts24.factory.createIdentifier(`_tcb${this.nextTcbId++}`);\n    const fn = generateTypeCheckBlock(this, ref, fnId, meta, domSchemaChecker, oobRecorder, genericContextBehavior);\n    this.tcbStatements.push(fn);\n  }\n  render(removeComments) {\n    let source = this.importManager.getAllImports(this.contextFile.fileName).map((i) => `import * as ${i.qualifier.text} from '${i.specifier}';`).join(\"\\n\") + \"\\n\\n\";\n    const printer = ts24.createPrinter({ removeComments });\n    source += \"\\n\";\n    for (const stmt of this.pipeInstStatements) {\n      source += printer.printNode(ts24.EmitHint.Unspecified, stmt, this.contextFile) + \"\\n\";\n    }\n    for (const stmt of this.typeCtorStatements) {\n      source += printer.printNode(ts24.EmitHint.Unspecified, stmt, this.contextFile) + \"\\n\";\n    }\n    source += \"\\n\";\n    for (const stmt of this.tcbStatements) {\n      source += printer.printNode(ts24.EmitHint.Unspecified, stmt, this.contextFile) + \"\\n\";\n    }\n    source += \"\\nexport const IS_A_MODULE = true;\\n\";\n    return source;\n  }\n  getPreludeStatements() {\n    return [];\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/context.mjs\nvar InliningMode;\n(function(InliningMode2) {\n  InliningMode2[InliningMode2[\"InlineOps\"] = 0] = \"InlineOps\";\n  InliningMode2[InliningMode2[\"Error\"] = 1] = \"Error\";\n})(InliningMode || (InliningMode = {}));\nvar TypeCheckContextImpl = class {\n  constructor(config, compilerHost, refEmitter, reflector, host, inlining, perf) {\n    this.config = config;\n    this.compilerHost = compilerHost;\n    this.refEmitter = refEmitter;\n    this.reflector = reflector;\n    this.host = host;\n    this.inlining = inlining;\n    this.perf = perf;\n    this.fileMap = /* @__PURE__ */ new Map();\n    this.opMap = /* @__PURE__ */ new Map();\n    this.typeCtorPending = /* @__PURE__ */ new Set();\n    if (inlining === InliningMode.Error && config.useInlineTypeConstructors) {\n      throw new Error(`AssertionError: invalid inlining configuration.`);\n    }\n  }\n  addTemplate(ref, binder, template, pipes, schemas, sourceMapping, file, parseErrors, isStandalone) {\n    if (!this.host.shouldCheckComponent(ref.node)) {\n      return;\n    }\n    const fileData = this.dataForFile(ref.node.getSourceFile());\n    const shimData = this.pendingShimForComponent(ref.node);\n    const templateId = fileData.sourceManager.getTemplateId(ref.node);\n    const templateDiagnostics = [];\n    if (parseErrors !== null) {\n      templateDiagnostics.push(...this.getTemplateDiagnostics(parseErrors, templateId, sourceMapping));\n    }\n    const boundTarget = binder.bind({ template });\n    if (this.inlining === InliningMode.InlineOps) {\n      for (const dir of boundTarget.getUsedDirectives()) {\n        const dirRef = dir.ref;\n        const dirNode = dirRef.node;\n        if (!dir.isGeneric || !requiresInlineTypeCtor(dirNode, this.reflector, shimData.file)) {\n          continue;\n        }\n        this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {\n          fnName: \"ngTypeCtor\",\n          body: !dirNode.getSourceFile().isDeclarationFile,\n          fields: {\n            inputs: dir.inputs,\n            queries: dir.queries\n          },\n          coercedInputFields: dir.coercedInputFields\n        });\n      }\n    }\n    shimData.templates.set(templateId, {\n      template,\n      boundTarget,\n      templateDiagnostics\n    });\n    const usedPipes = [];\n    for (const name of boundTarget.getUsedPipes()) {\n      if (!pipes.has(name)) {\n        continue;\n      }\n      usedPipes.push(pipes.get(name));\n    }\n    const inliningRequirement = requiresInlineTypeCheckBlock(ref, shimData.file, usedPipes, this.reflector);\n    if (this.inlining === InliningMode.Error && inliningRequirement === TcbInliningRequirement.MustInline) {\n      shimData.oobRecorder.requiresInlineTcb(templateId, ref.node);\n      this.perf.eventCount(PerfEvent.SkipGenerateTcbNoInline);\n      return;\n    }\n    const meta = {\n      id: fileData.sourceManager.captureSource(ref.node, sourceMapping, file),\n      boundTarget,\n      pipes,\n      schemas,\n      isStandalone\n    };\n    this.perf.eventCount(PerfEvent.GenerateTcb);\n    if (inliningRequirement !== TcbInliningRequirement.None && this.inlining === InliningMode.InlineOps) {\n      this.addInlineTypeCheckBlock(fileData, shimData, ref, meta);\n    } else if (inliningRequirement === TcbInliningRequirement.ShouldInlineForGenericBounds && this.inlining === InliningMode.Error) {\n      shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, TcbGenericContextBehavior.FallbackToAny);\n    } else {\n      shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, TcbGenericContextBehavior.UseEmitter);\n    }\n  }\n  addInlineTypeCtor(fileData, sf, ref, ctorMeta) {\n    if (this.typeCtorPending.has(ref.node)) {\n      return;\n    }\n    this.typeCtorPending.add(ref.node);\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf);\n    ops.push(new TypeCtorOp(ref, ctorMeta));\n    fileData.hasInlines = true;\n  }\n  transform(sf) {\n    if (!this.opMap.has(sf)) {\n      return null;\n    }\n    const importManager = new ImportManager(new NoopImportRewriter(), \"_i\");\n    const ops = this.opMap.get(sf).sort(orderOps);\n    const textParts = splitStringAtPoints(sf.text, ops.map((op) => op.splitPoint));\n    const printer = ts25.createPrinter({ omitTrailingSemicolon: true });\n    let code = textParts[0];\n    ops.forEach((op, idx) => {\n      const text = op.execute(importManager, sf, this.refEmitter, printer);\n      code += \"\\n\\n\" + text + textParts[idx + 1];\n    });\n    let imports = importManager.getAllImports(sf.fileName).map((i) => `import * as ${i.qualifier.text} from '${i.specifier}';`).join(\"\\n\");\n    code = imports + \"\\n\" + code;\n    return code;\n  }\n  finalize() {\n    const updates = /* @__PURE__ */ new Map();\n    for (const originalSf of this.opMap.keys()) {\n      const newText = this.transform(originalSf);\n      if (newText !== null) {\n        updates.set(absoluteFromSourceFile(originalSf), {\n          newText,\n          originalFile: originalSf\n        });\n      }\n    }\n    for (const [sfPath, pendingFileData] of this.fileMap) {\n      for (const pendingShimData of pendingFileData.shimData.values()) {\n        this.host.recordShimData(sfPath, {\n          genesisDiagnostics: [\n            ...pendingShimData.domSchemaChecker.diagnostics,\n            ...pendingShimData.oobRecorder.diagnostics\n          ],\n          hasInlines: pendingFileData.hasInlines,\n          path: pendingShimData.file.fileName,\n          templates: pendingShimData.templates\n        });\n        const sfText = pendingShimData.file.render(false);\n        updates.set(pendingShimData.file.fileName, {\n          newText: sfText,\n          originalFile: null\n        });\n      }\n    }\n    return updates;\n  }\n  addInlineTypeCheckBlock(fileData, shimData, ref, tcbMeta) {\n    const sf = ref.node.getSourceFile();\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf);\n    ops.push(new InlineTcbOp(ref, tcbMeta, this.config, this.reflector, shimData.domSchemaChecker, shimData.oobRecorder));\n    fileData.hasInlines = true;\n  }\n  pendingShimForComponent(node) {\n    const fileData = this.dataForFile(node.getSourceFile());\n    const shimPath = TypeCheckShimGenerator.shimFor(absoluteFromSourceFile(node.getSourceFile()));\n    if (!fileData.shimData.has(shimPath)) {\n      fileData.shimData.set(shimPath, {\n        domSchemaChecker: new RegistryDomSchemaChecker(fileData.sourceManager),\n        oobRecorder: new OutOfBandDiagnosticRecorderImpl(fileData.sourceManager),\n        file: new TypeCheckFile(shimPath, this.config, this.refEmitter, this.reflector, this.compilerHost),\n        templates: /* @__PURE__ */ new Map()\n      });\n    }\n    return fileData.shimData.get(shimPath);\n  }\n  dataForFile(sf) {\n    const sfPath = absoluteFromSourceFile(sf);\n    if (!this.fileMap.has(sfPath)) {\n      const data = {\n        hasInlines: false,\n        sourceManager: this.host.getSourceManager(sfPath),\n        shimData: /* @__PURE__ */ new Map()\n      };\n      this.fileMap.set(sfPath, data);\n    }\n    return this.fileMap.get(sfPath);\n  }\n  getTemplateDiagnostics(parseErrors, templateId, sourceMapping) {\n    return parseErrors.map((error) => {\n      const span = error.span;\n      if (span.start.offset === span.end.offset) {\n        span.end.offset++;\n      }\n      return makeTemplateDiagnostic(templateId, sourceMapping, span, ts25.DiagnosticCategory.Error, ngErrorCode(ErrorCode.TEMPLATE_PARSE_ERROR), error.msg);\n    });\n  }\n};\nvar InlineTcbOp = class {\n  constructor(ref, meta, config, reflector, domSchemaChecker, oobRecorder) {\n    this.ref = ref;\n    this.meta = meta;\n    this.config = config;\n    this.reflector = reflector;\n    this.domSchemaChecker = domSchemaChecker;\n    this.oobRecorder = oobRecorder;\n  }\n  get splitPoint() {\n    return this.ref.node.end + 1;\n  }\n  execute(im, sf, refEmitter, printer) {\n    const env = new Environment(this.config, im, refEmitter, this.reflector, sf);\n    const fnName = ts25.factory.createIdentifier(`_tcb_${this.ref.node.pos}`);\n    const fn = generateTypeCheckBlock(env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder, TcbGenericContextBehavior.CopyClassNodes);\n    return printer.printNode(ts25.EmitHint.Unspecified, fn, sf);\n  }\n};\nvar TypeCtorOp = class {\n  constructor(ref, meta) {\n    this.ref = ref;\n    this.meta = meta;\n  }\n  get splitPoint() {\n    return this.ref.node.end - 1;\n  }\n  execute(im, sf, refEmitter, printer) {\n    const tcb = generateInlineTypeCtor(this.ref.node, this.meta);\n    return printer.printNode(ts25.EmitHint.Unspecified, tcb, sf);\n  }\n};\nfunction orderOps(op1, op2) {\n  return op1.splitPoint - op2.splitPoint;\n}\nfunction splitStringAtPoints(str, points) {\n  const splits = [];\n  let start = 0;\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    splits.push(str.substring(start, point));\n    start = point;\n  }\n  splits.push(str.substring(start));\n  return splits;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/source.mjs\nimport { ParseLocation, ParseSourceSpan } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/line_mappings.mjs\nvar LF_CHAR = 10;\nvar CR_CHAR = 13;\nvar LINE_SEP_CHAR = 8232;\nvar PARAGRAPH_CHAR = 8233;\nfunction getLineAndCharacterFromPosition(lineStartsMap, position) {\n  const lineIndex = findClosestLineStartPosition(lineStartsMap, position);\n  return { character: position - lineStartsMap[lineIndex], line: lineIndex };\n}\nfunction computeLineStartsMap(text) {\n  const result = [0];\n  let pos = 0;\n  while (pos < text.length) {\n    const char = text.charCodeAt(pos++);\n    if (char === CR_CHAR) {\n      if (text.charCodeAt(pos) === LF_CHAR) {\n        pos++;\n      }\n      result.push(pos);\n    } else if (char === LF_CHAR || char === LINE_SEP_CHAR || char === PARAGRAPH_CHAR) {\n      result.push(pos);\n    }\n  }\n  result.push(pos);\n  return result;\n}\nfunction findClosestLineStartPosition(linesMap, position, low = 0, high = linesMap.length - 1) {\n  while (low <= high) {\n    const pivotIdx = Math.floor((low + high) / 2);\n    const pivotEl = linesMap[pivotIdx];\n    if (pivotEl === position) {\n      return pivotIdx;\n    } else if (position > pivotEl) {\n      low = pivotIdx + 1;\n    } else {\n      high = pivotIdx - 1;\n    }\n  }\n  return low - 1;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/source.mjs\nvar TemplateSource = class {\n  constructor(mapping, file) {\n    this.mapping = mapping;\n    this.file = file;\n    this.lineStarts = null;\n  }\n  toParseSourceSpan(start, end) {\n    const startLoc = this.toParseLocation(start);\n    const endLoc = this.toParseLocation(end);\n    return new ParseSourceSpan(startLoc, endLoc);\n  }\n  toParseLocation(position) {\n    const lineStarts = this.acquireLineStarts();\n    const { line, character } = getLineAndCharacterFromPosition(lineStarts, position);\n    return new ParseLocation(this.file, position, line, character);\n  }\n  acquireLineStarts() {\n    if (this.lineStarts === null) {\n      this.lineStarts = computeLineStartsMap(this.file.content);\n    }\n    return this.lineStarts;\n  }\n};\nvar TemplateSourceManager = class {\n  constructor() {\n    this.templateSources = /* @__PURE__ */ new Map();\n  }\n  getTemplateId(node) {\n    return getTemplateId(node);\n  }\n  captureSource(node, mapping, file) {\n    const id = getTemplateId(node);\n    this.templateSources.set(id, new TemplateSource(mapping, file));\n    return id;\n  }\n  getSourceMapping(id) {\n    if (!this.templateSources.has(id)) {\n      throw new Error(`Unexpected unknown template ID: ${id}`);\n    }\n    return this.templateSources.get(id).mapping;\n  }\n  toParseSourceSpan(id, span) {\n    if (!this.templateSources.has(id)) {\n      return null;\n    }\n    const templateSource = this.templateSources.get(id);\n    return templateSource.toParseSourceSpan(span.start, span.end);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.mjs\nimport { AST, ASTWithSource as ASTWithSource3, BindingPipe as BindingPipe2, PropertyRead as PropertyRead5, PropertyWrite as PropertyWrite4, SafePropertyRead as SafePropertyRead4, TmplAstBoundAttribute as TmplAstBoundAttribute2, TmplAstBoundEvent, TmplAstElement as TmplAstElement4, TmplAstReference as TmplAstReference4, TmplAstTemplate as TmplAstTemplate3, TmplAstTextAttribute as TmplAstTextAttribute3, TmplAstVariable as TmplAstVariable3 } from \"@angular/compiler\";\nimport ts26 from \"typescript\";\nvar SymbolBuilder = class {\n  constructor(tcbPath, tcbIsShim, typeCheckBlock, templateData, componentScopeReader, getTypeChecker) {\n    this.tcbPath = tcbPath;\n    this.tcbIsShim = tcbIsShim;\n    this.typeCheckBlock = typeCheckBlock;\n    this.templateData = templateData;\n    this.componentScopeReader = componentScopeReader;\n    this.getTypeChecker = getTypeChecker;\n    this.symbolCache = /* @__PURE__ */ new Map();\n  }\n  getSymbol(node) {\n    if (this.symbolCache.has(node)) {\n      return this.symbolCache.get(node);\n    }\n    let symbol = null;\n    if (node instanceof TmplAstBoundAttribute2 || node instanceof TmplAstTextAttribute3) {\n      symbol = this.getSymbolOfInputBinding(node);\n    } else if (node instanceof TmplAstBoundEvent) {\n      symbol = this.getSymbolOfBoundEvent(node);\n    } else if (node instanceof TmplAstElement4) {\n      symbol = this.getSymbolOfElement(node);\n    } else if (node instanceof TmplAstTemplate3) {\n      symbol = this.getSymbolOfAstTemplate(node);\n    } else if (node instanceof TmplAstVariable3) {\n      symbol = this.getSymbolOfVariable(node);\n    } else if (node instanceof TmplAstReference4) {\n      symbol = this.getSymbolOfReference(node);\n    } else if (node instanceof BindingPipe2) {\n      symbol = this.getSymbolOfPipe(node);\n    } else if (node instanceof AST) {\n      symbol = this.getSymbolOfTemplateExpression(node);\n    } else {\n    }\n    this.symbolCache.set(node, symbol);\n    return symbol;\n  }\n  getSymbolOfAstTemplate(template) {\n    const directives = this.getDirectivesOfNode(template);\n    return { kind: SymbolKind.Template, directives, templateNode: template };\n  }\n  getSymbolOfElement(element) {\n    var _a;\n    const elementSourceSpan = (_a = element.startSourceSpan) != null ? _a : element.sourceSpan;\n    const node = findFirstMatchingNode(this.typeCheckBlock, { withSpan: elementSourceSpan, filter: ts26.isVariableDeclaration });\n    if (node === null) {\n      return null;\n    }\n    const symbolFromDeclaration = this.getSymbolOfTsNode(node);\n    if (symbolFromDeclaration === null || symbolFromDeclaration.tsSymbol === null) {\n      return null;\n    }\n    const directives = this.getDirectivesOfNode(element);\n    return {\n      ...symbolFromDeclaration,\n      kind: SymbolKind.Element,\n      directives,\n      templateNode: element\n    };\n  }\n  getDirectivesOfNode(element) {\n    var _a;\n    const elementSourceSpan = (_a = element.startSourceSpan) != null ? _a : element.sourceSpan;\n    const tcbSourceFile = this.typeCheckBlock.getSourceFile();\n    const isDirectiveDeclaration = (node) => (ts26.isTypeNode(node) || ts26.isIdentifier(node)) && ts26.isVariableDeclaration(node.parent) && hasExpressionIdentifier(tcbSourceFile, node, ExpressionIdentifier.DIRECTIVE);\n    const nodes = findAllMatchingNodes(this.typeCheckBlock, { withSpan: elementSourceSpan, filter: isDirectiveDeclaration });\n    const symbols = [];\n    for (const node of nodes) {\n      const symbol = this.getSymbolOfTsNode(node.parent);\n      if (symbol === null || !isSymbolWithValueDeclaration(symbol.tsSymbol) || !ts26.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n        continue;\n      }\n      const meta = this.getDirectiveMeta(element, symbol.tsSymbol.valueDeclaration);\n      if (meta !== null && meta.selector !== null) {\n        const ref = new Reference(symbol.tsSymbol.valueDeclaration);\n        if (meta.hostDirectives !== null) {\n          this.addHostDirectiveSymbols(element, meta.hostDirectives, symbols);\n        }\n        const directiveSymbol = {\n          ...symbol,\n          ref,\n          tsSymbol: symbol.tsSymbol,\n          selector: meta.selector,\n          isComponent: meta.isComponent,\n          ngModule: this.getDirectiveModule(symbol.tsSymbol.valueDeclaration),\n          kind: SymbolKind.Directive,\n          isStructural: meta.isStructural,\n          isInScope: true,\n          isHostDirective: false\n        };\n        symbols.push(directiveSymbol);\n      }\n    }\n    return symbols;\n  }\n  addHostDirectiveSymbols(host, hostDirectives, symbols) {\n    for (const current of hostDirectives) {\n      if (!ts26.isClassDeclaration(current.directive.node)) {\n        continue;\n      }\n      const symbol = this.getSymbolOfTsNode(current.directive.node);\n      const meta = this.getDirectiveMeta(host, current.directive.node);\n      if (meta !== null && symbol !== null && isSymbolWithValueDeclaration(symbol.tsSymbol)) {\n        if (meta.hostDirectives !== null) {\n          this.addHostDirectiveSymbols(host, meta.hostDirectives, symbols);\n        }\n        const directiveSymbol = {\n          ...symbol,\n          isHostDirective: true,\n          ref: current.directive,\n          tsSymbol: symbol.tsSymbol,\n          exposedInputs: current.inputs,\n          exposedOutputs: current.outputs,\n          selector: meta.selector,\n          isComponent: meta.isComponent,\n          ngModule: this.getDirectiveModule(current.directive.node),\n          kind: SymbolKind.Directive,\n          isStructural: meta.isStructural,\n          isInScope: true\n        };\n        symbols.push(directiveSymbol);\n      }\n    }\n  }\n  getDirectiveMeta(host, directiveDeclaration) {\n    var _a;\n    let directives = this.templateData.boundTarget.getDirectivesOfNode(host);\n    const firstChild = host.children[0];\n    if (firstChild instanceof TmplAstElement4) {\n      const isMicrosyntaxTemplate = host instanceof TmplAstTemplate3 && sourceSpanEqual(firstChild.sourceSpan, host.sourceSpan);\n      if (isMicrosyntaxTemplate) {\n        const firstChildDirectives = this.templateData.boundTarget.getDirectivesOfNode(firstChild);\n        if (firstChildDirectives !== null && directives !== null) {\n          directives = directives.concat(firstChildDirectives);\n        } else {\n          directives = directives != null ? directives : firstChildDirectives;\n        }\n      }\n    }\n    if (directives === null) {\n      return null;\n    }\n    return (_a = directives.find((m) => m.ref.node === directiveDeclaration)) != null ? _a : null;\n  }\n  getDirectiveModule(declaration) {\n    const scope = this.componentScopeReader.getScopeForComponent(declaration);\n    if (scope === null || scope.kind !== ComponentScopeKind.NgModule) {\n      return null;\n    }\n    return scope.ngModule;\n  }\n  getSymbolOfBoundEvent(eventBinding) {\n    const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n    if (consumer === null) {\n      return null;\n    }\n    let expectedAccess;\n    if (consumer instanceof TmplAstTemplate3 || consumer instanceof TmplAstElement4) {\n      expectedAccess = \"addEventListener\";\n    } else {\n      const bindingPropertyNames = consumer.outputs.getByBindingPropertyName(eventBinding.name);\n      if (bindingPropertyNames === null || bindingPropertyNames.length === 0) {\n        return null;\n      }\n      expectedAccess = bindingPropertyNames[0].classPropertyName;\n    }\n    function filter(n) {\n      if (!isAccessExpression(n)) {\n        return false;\n      }\n      if (ts26.isPropertyAccessExpression(n)) {\n        return n.name.getText() === expectedAccess;\n      } else {\n        return ts26.isStringLiteral(n.argumentExpression) && n.argumentExpression.text === expectedAccess;\n      }\n    }\n    const outputFieldAccesses = findAllMatchingNodes(this.typeCheckBlock, { withSpan: eventBinding.keySpan, filter });\n    const bindings = [];\n    for (const outputFieldAccess of outputFieldAccesses) {\n      if (consumer instanceof TmplAstTemplate3 || consumer instanceof TmplAstElement4) {\n        if (!ts26.isPropertyAccessExpression(outputFieldAccess)) {\n          continue;\n        }\n        const addEventListener = outputFieldAccess.name;\n        const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);\n        const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);\n        const positionInFile = this.getTcbPositionForNode(addEventListener);\n        const target = this.getSymbol(consumer);\n        if (target === null || tsSymbol === void 0) {\n          continue;\n        }\n        bindings.push({\n          kind: SymbolKind.Binding,\n          tsSymbol,\n          tsType,\n          target,\n          tcbLocation: {\n            tcbPath: this.tcbPath,\n            isShimFile: this.tcbIsShim,\n            positionInFile\n          }\n        });\n      } else {\n        if (!ts26.isElementAccessExpression(outputFieldAccess)) {\n          continue;\n        }\n        const tsSymbol = this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n        if (tsSymbol === void 0) {\n          continue;\n        }\n        const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n        if (target === null) {\n          continue;\n        }\n        const positionInFile = this.getTcbPositionForNode(outputFieldAccess);\n        const tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);\n        bindings.push({\n          kind: SymbolKind.Binding,\n          tsSymbol,\n          tsType,\n          target,\n          tcbLocation: {\n            tcbPath: this.tcbPath,\n            isShimFile: this.tcbIsShim,\n            positionInFile\n          }\n        });\n      }\n    }\n    if (bindings.length === 0) {\n      return null;\n    }\n    return { kind: SymbolKind.Output, bindings };\n  }\n  getSymbolOfInputBinding(binding) {\n    const consumer = this.templateData.boundTarget.getConsumerOfBinding(binding);\n    if (consumer === null) {\n      return null;\n    }\n    if (consumer instanceof TmplAstElement4 || consumer instanceof TmplAstTemplate3) {\n      const host = this.getSymbol(consumer);\n      return host !== null ? { kind: SymbolKind.DomBinding, host } : null;\n    }\n    const nodes = findAllMatchingNodes(this.typeCheckBlock, { withSpan: binding.sourceSpan, filter: isAssignment });\n    const bindings = [];\n    for (const node of nodes) {\n      if (!isAccessExpression(node.left)) {\n        continue;\n      }\n      const symbolInfo = this.getSymbolOfTsNode(node.left);\n      if (symbolInfo === null || symbolInfo.tsSymbol === null) {\n        continue;\n      }\n      const target = this.getDirectiveSymbolForAccessExpression(node.left, consumer);\n      if (target === null) {\n        continue;\n      }\n      bindings.push({\n        ...symbolInfo,\n        tsSymbol: symbolInfo.tsSymbol,\n        kind: SymbolKind.Binding,\n        target\n      });\n    }\n    if (bindings.length === 0) {\n      return null;\n    }\n    return { kind: SymbolKind.Input, bindings };\n  }\n  getDirectiveSymbolForAccessExpression(node, { isComponent, selector, isStructural }) {\n    var _a;\n    const tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.expression);\n    if ((tsSymbol == null ? void 0 : tsSymbol.declarations) === void 0 || tsSymbol.declarations.length === 0 || selector === null) {\n      return null;\n    }\n    const [declaration] = tsSymbol.declarations;\n    if (!ts26.isVariableDeclaration(declaration) || !hasExpressionIdentifier(\n      declaration.getSourceFile(),\n      (_a = declaration.type) != null ? _a : declaration.name,\n      ExpressionIdentifier.DIRECTIVE\n    )) {\n      return null;\n    }\n    const symbol = this.getSymbolOfTsNode(declaration);\n    if (symbol === null || !isSymbolWithValueDeclaration(symbol.tsSymbol) || !ts26.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n      return null;\n    }\n    const ref = new Reference(symbol.tsSymbol.valueDeclaration);\n    const ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);\n    return {\n      ref,\n      kind: SymbolKind.Directive,\n      tsSymbol: symbol.tsSymbol,\n      tsType: symbol.tsType,\n      tcbLocation: symbol.tcbLocation,\n      isComponent,\n      isStructural,\n      selector,\n      ngModule,\n      isHostDirective: false,\n      isInScope: true\n    };\n  }\n  getSymbolOfVariable(variable) {\n    const node = findFirstMatchingNode(this.typeCheckBlock, { withSpan: variable.sourceSpan, filter: ts26.isVariableDeclaration });\n    if (node === null || node.initializer === void 0) {\n      return null;\n    }\n    const expressionSymbol = this.getSymbolOfTsNode(node.initializer);\n    if (expressionSymbol === null) {\n      return null;\n    }\n    return {\n      tsType: expressionSymbol.tsType,\n      tsSymbol: expressionSymbol.tsSymbol,\n      initializerLocation: expressionSymbol.tcbLocation,\n      kind: SymbolKind.Variable,\n      declaration: variable,\n      localVarLocation: {\n        tcbPath: this.tcbPath,\n        isShimFile: this.tcbIsShim,\n        positionInFile: this.getTcbPositionForNode(node.name)\n      }\n    };\n  }\n  getSymbolOfReference(ref) {\n    const target = this.templateData.boundTarget.getReferenceTarget(ref);\n    let node = findFirstMatchingNode(this.typeCheckBlock, { withSpan: ref.sourceSpan, filter: ts26.isVariableDeclaration });\n    if (node === null || target === null || node.initializer === void 0) {\n      return null;\n    }\n    const originalDeclaration = ts26.isParenthesizedExpression(node.initializer) && ts26.isAsExpression(node.initializer.expression) ? this.getTypeChecker().getSymbolAtLocation(node.name) : this.getTypeChecker().getSymbolAtLocation(node.initializer);\n    if (originalDeclaration === void 0 || originalDeclaration.valueDeclaration === void 0) {\n      return null;\n    }\n    const symbol = this.getSymbolOfTsNode(originalDeclaration.valueDeclaration);\n    if (symbol === null || symbol.tsSymbol === null) {\n      return null;\n    }\n    const referenceVarTcbLocation = {\n      tcbPath: this.tcbPath,\n      isShimFile: this.tcbIsShim,\n      positionInFile: this.getTcbPositionForNode(node)\n    };\n    if (target instanceof TmplAstTemplate3 || target instanceof TmplAstElement4) {\n      return {\n        kind: SymbolKind.Reference,\n        tsSymbol: symbol.tsSymbol,\n        tsType: symbol.tsType,\n        target,\n        declaration: ref,\n        targetLocation: symbol.tcbLocation,\n        referenceVarLocation: referenceVarTcbLocation\n      };\n    } else {\n      if (!ts26.isClassDeclaration(target.directive.ref.node)) {\n        return null;\n      }\n      return {\n        kind: SymbolKind.Reference,\n        tsSymbol: symbol.tsSymbol,\n        tsType: symbol.tsType,\n        declaration: ref,\n        target: target.directive.ref.node,\n        targetLocation: symbol.tcbLocation,\n        referenceVarLocation: referenceVarTcbLocation\n      };\n    }\n  }\n  getSymbolOfPipe(expression) {\n    const methodAccess = findFirstMatchingNode(this.typeCheckBlock, { withSpan: expression.nameSpan, filter: ts26.isPropertyAccessExpression });\n    if (methodAccess === null) {\n      return null;\n    }\n    const pipeVariableNode = methodAccess.expression;\n    const pipeDeclaration = this.getTypeChecker().getSymbolAtLocation(pipeVariableNode);\n    if (pipeDeclaration === void 0 || pipeDeclaration.valueDeclaration === void 0) {\n      return null;\n    }\n    const pipeInstance = this.getSymbolOfTsNode(pipeDeclaration.valueDeclaration);\n    if (pipeInstance === null || !isSymbolWithValueDeclaration(pipeInstance.tsSymbol)) {\n      return null;\n    }\n    const symbolInfo = this.getSymbolOfTsNode(methodAccess);\n    if (symbolInfo === null) {\n      return null;\n    }\n    return {\n      kind: SymbolKind.Pipe,\n      ...symbolInfo,\n      classSymbol: {\n        ...pipeInstance,\n        tsSymbol: pipeInstance.tsSymbol\n      }\n    };\n  }\n  getSymbolOfTemplateExpression(expression) {\n    if (expression instanceof ASTWithSource3) {\n      expression = expression.ast;\n    }\n    const expressionTarget = this.templateData.boundTarget.getExpressionTarget(expression);\n    if (expressionTarget !== null) {\n      return this.getSymbol(expressionTarget);\n    }\n    let withSpan = expression.sourceSpan;\n    if (expression instanceof PropertyWrite4) {\n      withSpan = expression.nameSpan;\n    }\n    let node = null;\n    if (expression instanceof PropertyRead5) {\n      node = findFirstMatchingNode(this.typeCheckBlock, { withSpan, filter: ts26.isPropertyAccessExpression });\n    }\n    if (node === null) {\n      node = findFirstMatchingNode(this.typeCheckBlock, { withSpan, filter: anyNodeFilter });\n    }\n    if (node === null) {\n      return null;\n    }\n    while (ts26.isParenthesizedExpression(node)) {\n      node = node.expression;\n    }\n    if (expression instanceof SafePropertyRead4 && ts26.isConditionalExpression(node)) {\n      const whenTrueSymbol = this.getSymbolOfTsNode(node.whenTrue);\n      if (whenTrueSymbol === null) {\n        return null;\n      }\n      return {\n        ...whenTrueSymbol,\n        kind: SymbolKind.Expression,\n        tsType: this.getTypeChecker().getTypeAtLocation(node)\n      };\n    } else {\n      const symbolInfo = this.getSymbolOfTsNode(node);\n      return symbolInfo === null ? null : { ...symbolInfo, kind: SymbolKind.Expression };\n    }\n  }\n  getSymbolOfTsNode(node) {\n    var _a;\n    while (ts26.isParenthesizedExpression(node)) {\n      node = node.expression;\n    }\n    let tsSymbol;\n    if (ts26.isPropertyAccessExpression(node)) {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.name);\n    } else if (ts26.isElementAccessExpression(node)) {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.argumentExpression);\n    } else {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node);\n    }\n    const positionInFile = this.getTcbPositionForNode(node);\n    const type = this.getTypeChecker().getTypeAtLocation(node);\n    return {\n      tsSymbol: (_a = tsSymbol != null ? tsSymbol : type.symbol) != null ? _a : null,\n      tsType: type,\n      tcbLocation: {\n        tcbPath: this.tcbPath,\n        isShimFile: this.tcbIsShim,\n        positionInFile\n      }\n    };\n  }\n  getTcbPositionForNode(node) {\n    if (ts26.isTypeReferenceNode(node)) {\n      return this.getTcbPositionForNode(node.typeName);\n    } else if (ts26.isQualifiedName(node)) {\n      return node.right.getStart();\n    } else if (ts26.isPropertyAccessExpression(node)) {\n      return node.name.getStart();\n    } else if (ts26.isElementAccessExpression(node)) {\n      return node.argumentExpression.getStart();\n    } else {\n      return node.getStart();\n    }\n  }\n};\nfunction anyNodeFilter(n) {\n  return true;\n}\nfunction sourceSpanEqual(a, b) {\n  return a.start.offset === b.start.offset && a.end.offset === b.end.offset;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/src/checker.mjs\nvar REGISTRY2 = new DomElementSchemaRegistry2();\nvar TemplateTypeCheckerImpl = class {\n  constructor(originalProgram, programDriver, typeCheckAdapter, config, refEmitter, reflector, compilerHost, priorBuild, metaReader, localMetaReader, ngModuleIndex, componentScopeReader, typeCheckScopeRegistry, perf) {\n    this.originalProgram = originalProgram;\n    this.programDriver = programDriver;\n    this.typeCheckAdapter = typeCheckAdapter;\n    this.config = config;\n    this.refEmitter = refEmitter;\n    this.reflector = reflector;\n    this.compilerHost = compilerHost;\n    this.priorBuild = priorBuild;\n    this.metaReader = metaReader;\n    this.localMetaReader = localMetaReader;\n    this.ngModuleIndex = ngModuleIndex;\n    this.componentScopeReader = componentScopeReader;\n    this.typeCheckScopeRegistry = typeCheckScopeRegistry;\n    this.perf = perf;\n    this.state = /* @__PURE__ */ new Map();\n    this.completionCache = /* @__PURE__ */ new Map();\n    this.symbolBuilderCache = /* @__PURE__ */ new Map();\n    this.scopeCache = /* @__PURE__ */ new Map();\n    this.elementTagCache = /* @__PURE__ */ new Map();\n    this.isComplete = false;\n  }\n  getTemplate(component) {\n    const { data } = this.getLatestComponentState(component);\n    if (data === null) {\n      return null;\n    }\n    return data.template;\n  }\n  getUsedDirectives(component) {\n    var _a;\n    return ((_a = this.getLatestComponentState(component).data) == null ? void 0 : _a.boundTarget.getUsedDirectives()) || null;\n  }\n  getUsedPipes(component) {\n    var _a;\n    return ((_a = this.getLatestComponentState(component).data) == null ? void 0 : _a.boundTarget.getUsedPipes()) || null;\n  }\n  getLatestComponentState(component) {\n    this.ensureShimForComponent(component);\n    const sf = component.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    const fileRecord = this.getFileData(sfPath);\n    if (!fileRecord.shimData.has(shimPath)) {\n      return { data: null, tcb: null, tcbPath: shimPath, tcbIsShim: true };\n    }\n    const templateId = fileRecord.sourceManager.getTemplateId(component);\n    const shimRecord = fileRecord.shimData.get(shimPath);\n    const id = fileRecord.sourceManager.getTemplateId(component);\n    const program = this.programDriver.getProgram();\n    const shimSf = getSourceFileOrNull(program, shimPath);\n    if (shimSf === null || !fileRecord.shimData.has(shimPath)) {\n      throw new Error(`Error: no shim file in program: ${shimPath}`);\n    }\n    let tcb = findTypeCheckBlock(shimSf, id, false);\n    let tcbPath = shimPath;\n    if (tcb === null) {\n      const inlineSf = getSourceFileOrError(program, sfPath);\n      tcb = findTypeCheckBlock(inlineSf, id, false);\n      if (tcb !== null) {\n        tcbPath = sfPath;\n      }\n    }\n    let data = null;\n    if (shimRecord.templates.has(templateId)) {\n      data = shimRecord.templates.get(templateId);\n    }\n    return { data, tcb, tcbPath, tcbIsShim: tcbPath === shimPath };\n  }\n  isTrackedTypeCheckFile(filePath) {\n    return this.getFileAndShimRecordsForPath(filePath) !== null;\n  }\n  getFileRecordForTcbLocation({ tcbPath, isShimFile }) {\n    if (!isShimFile) {\n      if (this.state.has(tcbPath)) {\n        return this.state.get(tcbPath);\n      } else {\n        return null;\n      }\n    }\n    const records = this.getFileAndShimRecordsForPath(tcbPath);\n    if (records !== null) {\n      return records.fileRecord;\n    } else {\n      return null;\n    }\n  }\n  getFileAndShimRecordsForPath(shimPath) {\n    for (const fileRecord of this.state.values()) {\n      if (fileRecord.shimData.has(shimPath)) {\n        return { fileRecord, shimRecord: fileRecord.shimData.get(shimPath) };\n      }\n    }\n    return null;\n  }\n  getTemplateMappingAtTcbLocation(tcbLocation) {\n    const fileRecord = this.getFileRecordForTcbLocation(tcbLocation);\n    if (fileRecord === null) {\n      return null;\n    }\n    const shimSf = this.programDriver.getProgram().getSourceFile(tcbLocation.tcbPath);\n    if (shimSf === void 0) {\n      return null;\n    }\n    return getTemplateMapping(\n      shimSf,\n      tcbLocation.positionInFile,\n      fileRecord.sourceManager,\n      false\n    );\n  }\n  generateAllTypeCheckBlocks() {\n    this.ensureAllShimsForAllFiles();\n  }\n  getDiagnosticsForFile(sf, optimizeFor) {\n    switch (optimizeFor) {\n      case OptimizeFor.WholeProgram:\n        this.ensureAllShimsForAllFiles();\n        break;\n      case OptimizeFor.SingleFile:\n        this.ensureAllShimsForOneFile(sf);\n        break;\n    }\n    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n      const sfPath = absoluteFromSourceFile(sf);\n      const fileRecord = this.state.get(sfPath);\n      const typeCheckProgram = this.programDriver.getProgram();\n      const diagnostics = [];\n      if (fileRecord.hasInlines) {\n        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map((diag) => convertDiagnostic(diag, fileRecord.sourceManager)));\n      }\n      for (const [shimPath, shimRecord] of fileRecord.shimData) {\n        const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map((diag) => convertDiagnostic(diag, fileRecord.sourceManager)));\n        diagnostics.push(...shimRecord.genesisDiagnostics);\n        for (const templateData of shimRecord.templates.values()) {\n          diagnostics.push(...templateData.templateDiagnostics);\n        }\n      }\n      return diagnostics.filter((diag) => diag !== null);\n    });\n  }\n  getDiagnosticsForComponent(component) {\n    this.ensureShimForComponent(component);\n    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n      const sf = component.getSourceFile();\n      const sfPath = absoluteFromSourceFile(sf);\n      const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n      const fileRecord = this.getFileData(sfPath);\n      if (!fileRecord.shimData.has(shimPath)) {\n        return [];\n      }\n      const templateId = fileRecord.sourceManager.getTemplateId(component);\n      const shimRecord = fileRecord.shimData.get(shimPath);\n      const typeCheckProgram = this.programDriver.getProgram();\n      const diagnostics = [];\n      if (shimRecord.hasInlines) {\n        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map((diag) => convertDiagnostic(diag, fileRecord.sourceManager)));\n      }\n      const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n      diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map((diag) => convertDiagnostic(diag, fileRecord.sourceManager)));\n      diagnostics.push(...shimRecord.genesisDiagnostics);\n      for (const templateData of shimRecord.templates.values()) {\n        diagnostics.push(...templateData.templateDiagnostics);\n      }\n      return diagnostics.filter((diag) => diag !== null && diag.templateId === templateId);\n    });\n  }\n  getTypeCheckBlock(component) {\n    return this.getLatestComponentState(component).tcb;\n  }\n  getGlobalCompletions(context, component, node) {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getGlobalCompletions(context, node));\n  }\n  getExpressionCompletionLocation(ast, component) {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getExpressionCompletionLocation(ast));\n  }\n  getLiteralCompletionLocation(node, component) {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getLiteralCompletionLocation(node));\n  }\n  invalidateClass(clazz) {\n    this.completionCache.delete(clazz);\n    this.symbolBuilderCache.delete(clazz);\n    this.scopeCache.delete(clazz);\n    this.elementTagCache.delete(clazz);\n    const sf = clazz.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    const fileData = this.getFileData(sfPath);\n    const templateId = fileData.sourceManager.getTemplateId(clazz);\n    fileData.shimData.delete(shimPath);\n    fileData.isComplete = false;\n    this.isComplete = false;\n  }\n  makeTemplateDiagnostic(clazz, sourceSpan, category, errorCode, message, relatedInformation) {\n    const sfPath = absoluteFromSourceFile(clazz.getSourceFile());\n    const fileRecord = this.state.get(sfPath);\n    const templateId = fileRecord.sourceManager.getTemplateId(clazz);\n    const mapping = fileRecord.sourceManager.getSourceMapping(templateId);\n    return {\n      ...makeTemplateDiagnostic(templateId, mapping, sourceSpan, category, ngErrorCode(errorCode), message, relatedInformation),\n      __ngCode: errorCode\n    };\n  }\n  getOrCreateCompletionEngine(component) {\n    if (this.completionCache.has(component)) {\n      return this.completionCache.get(component);\n    }\n    const { tcb, data, tcbPath, tcbIsShim } = this.getLatestComponentState(component);\n    if (tcb === null || data === null) {\n      return null;\n    }\n    const engine = new CompletionEngine(tcb, data, tcbPath, tcbIsShim);\n    this.completionCache.set(component, engine);\n    return engine;\n  }\n  maybeAdoptPriorResultsForFile(sf) {\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.state.has(sfPath)) {\n      const existingResults = this.state.get(sfPath);\n      if (existingResults.isComplete) {\n        return;\n      }\n    }\n    const previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);\n    if (previousResults === null || !previousResults.isComplete) {\n      return;\n    }\n    this.perf.eventCount(PerfEvent.ReuseTypeCheckFile);\n    this.state.set(sfPath, previousResults);\n  }\n  ensureAllShimsForAllFiles() {\n    if (this.isComplete) {\n      return;\n    }\n    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n      const host = new WholeProgramTypeCheckingHost(this);\n      const ctx = this.newContext(host);\n      for (const sf of this.originalProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile || isShim(sf)) {\n          continue;\n        }\n        this.maybeAdoptPriorResultsForFile(sf);\n        const sfPath = absoluteFromSourceFile(sf);\n        const fileData = this.getFileData(sfPath);\n        if (fileData.isComplete) {\n          continue;\n        }\n        this.typeCheckAdapter.typeCheck(sf, ctx);\n        fileData.isComplete = true;\n      }\n      this.updateFromContext(ctx);\n      this.isComplete = true;\n    });\n  }\n  ensureAllShimsForOneFile(sf) {\n    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n      this.maybeAdoptPriorResultsForFile(sf);\n      const sfPath = absoluteFromSourceFile(sf);\n      const fileData = this.getFileData(sfPath);\n      if (fileData.isComplete) {\n        return;\n      }\n      const host = new SingleFileTypeCheckingHost(sfPath, fileData, this);\n      const ctx = this.newContext(host);\n      this.typeCheckAdapter.typeCheck(sf, ctx);\n      fileData.isComplete = true;\n      this.updateFromContext(ctx);\n    });\n  }\n  ensureShimForComponent(component) {\n    const sf = component.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    this.maybeAdoptPriorResultsForFile(sf);\n    const fileData = this.getFileData(sfPath);\n    if (fileData.shimData.has(shimPath)) {\n      return;\n    }\n    const host = new SingleShimTypeCheckingHost(sfPath, fileData, this, shimPath);\n    const ctx = this.newContext(host);\n    this.typeCheckAdapter.typeCheck(sf, ctx);\n    this.updateFromContext(ctx);\n  }\n  newContext(host) {\n    const inlining = this.programDriver.supportsInlineOperations ? InliningMode.InlineOps : InliningMode.Error;\n    return new TypeCheckContextImpl(this.config, this.compilerHost, this.refEmitter, this.reflector, host, inlining, this.perf);\n  }\n  clearAllShimDataUsingInlines() {\n    for (const fileData of this.state.values()) {\n      if (!fileData.hasInlines) {\n        continue;\n      }\n      for (const [shimFile, shimData] of fileData.shimData.entries()) {\n        if (shimData.hasInlines) {\n          fileData.shimData.delete(shimFile);\n        }\n      }\n      fileData.hasInlines = false;\n      fileData.isComplete = false;\n      this.isComplete = false;\n    }\n  }\n  updateFromContext(ctx) {\n    const updates = ctx.finalize();\n    return this.perf.inPhase(PerfPhase.TcbUpdateProgram, () => {\n      if (updates.size > 0) {\n        this.perf.eventCount(PerfEvent.UpdateTypeCheckProgram);\n      }\n      this.programDriver.updateFiles(updates, UpdateMode.Incremental);\n      this.priorBuild.recordSuccessfulTypeCheck(this.state);\n      this.perf.memory(PerfCheckpoint.TtcUpdateProgram);\n    });\n  }\n  getFileData(path2) {\n    if (!this.state.has(path2)) {\n      this.state.set(path2, {\n        hasInlines: false,\n        sourceManager: new TemplateSourceManager(),\n        isComplete: false,\n        shimData: /* @__PURE__ */ new Map()\n      });\n    }\n    return this.state.get(path2);\n  }\n  getSymbolOfNode(node, component) {\n    const builder = this.getOrCreateSymbolBuilder(component);\n    if (builder === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcSymbol, () => builder.getSymbol(node));\n  }\n  getOrCreateSymbolBuilder(component) {\n    if (this.symbolBuilderCache.has(component)) {\n      return this.symbolBuilderCache.get(component);\n    }\n    const { tcb, data, tcbPath, tcbIsShim } = this.getLatestComponentState(component);\n    if (tcb === null || data === null) {\n      return null;\n    }\n    const builder = new SymbolBuilder(tcbPath, tcbIsShim, tcb, data, this.componentScopeReader, () => this.programDriver.getProgram().getTypeChecker());\n    this.symbolBuilderCache.set(component, builder);\n    return builder;\n  }\n  getPotentialTemplateDirectives(component) {\n    var _a, _b;\n    const typeChecker = this.programDriver.getProgram().getTypeChecker();\n    const inScopeDirectives = (_b = (_a = this.getScopeData(component)) == null ? void 0 : _a.directives) != null ? _b : [];\n    const resultingDirectives = /* @__PURE__ */ new Map();\n    for (const d of inScopeDirectives) {\n      resultingDirectives.set(d.ref.node, d);\n    }\n    for (const directiveClass of this.localMetaReader.getKnown(MetaKind.Directive)) {\n      const directiveMeta = this.metaReader.getDirectiveMetadata(new Reference(directiveClass));\n      if (directiveMeta === null)\n        continue;\n      if (resultingDirectives.has(directiveClass))\n        continue;\n      const withScope = this.scopeDataOfDirectiveMeta(typeChecker, directiveMeta);\n      if (withScope === null)\n        continue;\n      resultingDirectives.set(directiveClass, { ...withScope, isInScope: false });\n    }\n    return Array.from(resultingDirectives.values());\n  }\n  getPotentialPipes(component) {\n    var _a, _b;\n    const typeChecker = this.programDriver.getProgram().getTypeChecker();\n    const inScopePipes = (_b = (_a = this.getScopeData(component)) == null ? void 0 : _a.pipes) != null ? _b : [];\n    const resultingPipes = /* @__PURE__ */ new Map();\n    for (const p of inScopePipes) {\n      resultingPipes.set(p.ref.node, p);\n    }\n    for (const pipeClass of this.localMetaReader.getKnown(MetaKind.Pipe)) {\n      const pipeMeta = this.metaReader.getPipeMetadata(new Reference(pipeClass));\n      if (pipeMeta === null)\n        continue;\n      if (resultingPipes.has(pipeClass))\n        continue;\n      const withScope = this.scopeDataOfPipeMeta(typeChecker, pipeMeta);\n      if (withScope === null)\n        continue;\n      resultingPipes.set(pipeClass, { ...withScope, isInScope: false });\n    }\n    return Array.from(resultingPipes.values());\n  }\n  getDirectiveMetadata(dir) {\n    if (!isNamedClassDeclaration(dir)) {\n      return null;\n    }\n    return this.typeCheckScopeRegistry.getTypeCheckDirectiveMetadata(new Reference(dir));\n  }\n  getNgModuleMetadata(module) {\n    if (!isNamedClassDeclaration(module)) {\n      return null;\n    }\n    return this.metaReader.getNgModuleMetadata(new Reference(module));\n  }\n  getPipeMetadata(pipe) {\n    if (!isNamedClassDeclaration(pipe)) {\n      return null;\n    }\n    return this.metaReader.getPipeMetadata(new Reference(pipe));\n  }\n  getPotentialElementTags(component) {\n    if (this.elementTagCache.has(component)) {\n      return this.elementTagCache.get(component);\n    }\n    const tagMap = /* @__PURE__ */ new Map();\n    for (const tag of REGISTRY2.allKnownElementNames()) {\n      tagMap.set(tag, null);\n    }\n    const scope = this.getScopeData(component);\n    if (scope !== null) {\n      for (const directive of scope.directives) {\n        if (directive.selector === null) {\n          continue;\n        }\n        for (const selector of CssSelector.parse(directive.selector)) {\n          if (selector.element === null || tagMap.has(selector.element)) {\n            continue;\n          }\n          tagMap.set(selector.element, directive);\n        }\n      }\n    }\n    this.elementTagCache.set(component, tagMap);\n    return tagMap;\n  }\n  getPotentialDomBindings(tagName) {\n    const attributes = REGISTRY2.allKnownAttributesOfElement(tagName);\n    return attributes.map((attribute) => ({\n      attribute,\n      property: REGISTRY2.getMappedPropName(attribute)\n    }));\n  }\n  getPotentialDomEvents(tagName) {\n    return REGISTRY2.allKnownEventsOfElement(tagName);\n  }\n  getPrimaryAngularDecorator(target) {\n    this.ensureAllShimsForOneFile(target.getSourceFile());\n    if (!isNamedClassDeclaration(target)) {\n      return null;\n    }\n    const ref = new Reference(target);\n    const dirMeta = this.metaReader.getDirectiveMetadata(ref);\n    if (dirMeta !== null) {\n      return dirMeta.decorator;\n    }\n    const pipeMeta = this.metaReader.getPipeMetadata(ref);\n    if (pipeMeta !== null) {\n      return pipeMeta.decorator;\n    }\n    const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);\n    if (ngModuleMeta !== null) {\n      return ngModuleMeta.decorator;\n    }\n    return null;\n  }\n  getOwningNgModule(component) {\n    if (!isNamedClassDeclaration(component)) {\n      return null;\n    }\n    const dirMeta = this.metaReader.getDirectiveMetadata(new Reference(component));\n    if (dirMeta !== null && dirMeta.isStandalone) {\n      return null;\n    }\n    const scope = this.componentScopeReader.getScopeForComponent(component);\n    if (scope === null || scope.kind !== ComponentScopeKind.NgModule || !isNamedClassDeclaration(scope.ngModule)) {\n      return null;\n    }\n    return scope.ngModule;\n  }\n  emit(kind, refTo, inContext) {\n    var _a, _b;\n    const emittedRef = this.refEmitter.emit(refTo, inContext.getSourceFile());\n    if (emittedRef.kind === 1) {\n      return null;\n    }\n    const emitted = emittedRef.expression;\n    if (emitted instanceof WrappedNodeExpr) {\n      if (refTo.node === inContext) {\n        return null;\n      }\n      let isForwardReference = false;\n      if (emitted.node.getStart() > inContext.getStart()) {\n        const declaration = (_b = (_a = this.programDriver.getProgram().getTypeChecker().getTypeAtLocation(emitted.node).getSymbol()) == null ? void 0 : _a.declarations) == null ? void 0 : _b[0];\n        if (declaration && declaration.getSourceFile() === inContext.getSourceFile()) {\n          isForwardReference = true;\n        }\n      }\n      return { kind, symbolName: emitted.node.text, isForwardReference };\n    } else if (emitted instanceof ExternalExpr2 && emitted.value.moduleName !== null && emitted.value.name !== null) {\n      return {\n        kind,\n        moduleSpecifier: emitted.value.moduleName,\n        symbolName: emitted.value.name,\n        isForwardReference: false\n      };\n    }\n    return null;\n  }\n  getPotentialImportsFor(toImport, inContext, importMode) {\n    var _a;\n    const imports = [];\n    const meta = (_a = this.metaReader.getDirectiveMetadata(toImport)) != null ? _a : this.metaReader.getPipeMetadata(toImport);\n    if (meta === null) {\n      return imports;\n    }\n    if (meta.isStandalone || importMode === PotentialImportMode.ForceDirect) {\n      const emitted = this.emit(PotentialImportKind.Standalone, toImport, inContext);\n      if (emitted !== null) {\n        imports.push(emitted);\n      }\n    }\n    const exportingNgModules = this.ngModuleIndex.getNgModulesExporting(meta.ref.node);\n    if (exportingNgModules !== null) {\n      for (const exporter of exportingNgModules) {\n        const emittedRef = this.emit(PotentialImportKind.NgModule, exporter, inContext);\n        if (emittedRef !== null) {\n          imports.push(emittedRef);\n        }\n      }\n    }\n    return imports;\n  }\n  getScopeData(component) {\n    if (this.scopeCache.has(component)) {\n      return this.scopeCache.get(component);\n    }\n    if (!isNamedClassDeclaration(component)) {\n      throw new Error(`AssertionError: components must have names`);\n    }\n    const scope = this.componentScopeReader.getScopeForComponent(component);\n    if (scope === null) {\n      return null;\n    }\n    const dependencies = scope.kind === ComponentScopeKind.NgModule ? scope.compilation.dependencies : scope.dependencies;\n    const data = {\n      directives: [],\n      pipes: [],\n      isPoisoned: scope.kind === ComponentScopeKind.NgModule ? scope.compilation.isPoisoned : scope.isPoisoned\n    };\n    const typeChecker = this.programDriver.getProgram().getTypeChecker();\n    for (const dep of dependencies) {\n      if (dep.kind === MetaKind.Directive) {\n        const dirScope = this.scopeDataOfDirectiveMeta(typeChecker, dep);\n        if (dirScope === null)\n          continue;\n        data.directives.push({ ...dirScope, isInScope: true });\n      } else if (dep.kind === MetaKind.Pipe) {\n        const pipeScope = this.scopeDataOfPipeMeta(typeChecker, dep);\n        if (pipeScope === null)\n          continue;\n        data.pipes.push({ ...pipeScope, isInScope: true });\n      }\n    }\n    this.scopeCache.set(component, data);\n    return data;\n  }\n  scopeDataOfDirectiveMeta(typeChecker, dep) {\n    if (dep.selector === null) {\n      return null;\n    }\n    const tsSymbol = typeChecker.getSymbolAtLocation(dep.ref.node.name);\n    if (!isSymbolWithValueDeclaration(tsSymbol)) {\n      return null;\n    }\n    let ngModule = null;\n    const moduleScopeOfDir = this.componentScopeReader.getScopeForComponent(dep.ref.node);\n    if (moduleScopeOfDir !== null && moduleScopeOfDir.kind === ComponentScopeKind.NgModule) {\n      ngModule = moduleScopeOfDir.ngModule;\n    }\n    return {\n      ref: dep.ref,\n      isComponent: dep.isComponent,\n      isStructural: dep.isStructural,\n      selector: dep.selector,\n      tsSymbol,\n      ngModule\n    };\n  }\n  scopeDataOfPipeMeta(typeChecker, dep) {\n    const tsSymbol = typeChecker.getSymbolAtLocation(dep.ref.node.name);\n    if (tsSymbol === void 0) {\n      return null;\n    }\n    return {\n      ref: dep.ref,\n      name: dep.name,\n      tsSymbol\n    };\n  }\n};\nfunction convertDiagnostic(diag, sourceResolver) {\n  if (!shouldReportDiagnostic(diag)) {\n    return null;\n  }\n  return translateDiagnostic(diag, sourceResolver);\n}\nvar WholeProgramTypeCheckingHost = class {\n  constructor(impl) {\n    this.impl = impl;\n  }\n  getSourceManager(sfPath) {\n    return this.impl.getFileData(sfPath).sourceManager;\n  }\n  shouldCheckComponent(node) {\n    const sfPath = absoluteFromSourceFile(node.getSourceFile());\n    const shimPath = TypeCheckShimGenerator.shimFor(sfPath);\n    const fileData = this.impl.getFileData(sfPath);\n    return !fileData.shimData.has(shimPath);\n  }\n  recordShimData(sfPath, data) {\n    const fileData = this.impl.getFileData(sfPath);\n    fileData.shimData.set(data.path, data);\n    if (data.hasInlines) {\n      fileData.hasInlines = true;\n    }\n  }\n  recordComplete(sfPath) {\n    this.impl.getFileData(sfPath).isComplete = true;\n  }\n};\nvar SingleFileTypeCheckingHost = class {\n  constructor(sfPath, fileData, impl) {\n    this.sfPath = sfPath;\n    this.fileData = fileData;\n    this.impl = impl;\n    this.seenInlines = false;\n  }\n  assertPath(sfPath) {\n    if (this.sfPath !== sfPath) {\n      throw new Error(`AssertionError: querying TypeCheckingHost outside of assigned file`);\n    }\n  }\n  getSourceManager(sfPath) {\n    this.assertPath(sfPath);\n    return this.fileData.sourceManager;\n  }\n  shouldCheckComponent(node) {\n    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n      return false;\n    }\n    const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);\n    return !this.fileData.shimData.has(shimPath);\n  }\n  recordShimData(sfPath, data) {\n    this.assertPath(sfPath);\n    if (data.hasInlines && !this.seenInlines) {\n      this.impl.clearAllShimDataUsingInlines();\n      this.seenInlines = true;\n    }\n    this.fileData.shimData.set(data.path, data);\n    if (data.hasInlines) {\n      this.fileData.hasInlines = true;\n    }\n  }\n  recordComplete(sfPath) {\n    this.assertPath(sfPath);\n    this.fileData.isComplete = true;\n  }\n};\nvar SingleShimTypeCheckingHost = class extends SingleFileTypeCheckingHost {\n  constructor(sfPath, fileData, impl, shimPath) {\n    super(sfPath, fileData, impl);\n    this.shimPath = shimPath;\n  }\n  shouldCheckNode(node) {\n    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n      return false;\n    }\n    const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);\n    if (shimPath !== this.shimPath) {\n      return false;\n    }\n    return !this.fileData.shimData.has(shimPath);\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/invalid_banana_in_box/index.mjs\nimport { TmplAstBoundEvent as TmplAstBoundEvent2 } from \"@angular/compiler\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/api/api.mjs\nimport { ASTWithSource as ASTWithSource4, RecursiveAstVisitor as RecursiveAstVisitor3 } from \"@angular/compiler\";\nvar TemplateCheckWithVisitor = class {\n  run(ctx, component, template) {\n    const visitor = new TemplateVisitor2(ctx, component, this);\n    return visitor.getDiagnostics(template);\n  }\n};\nvar TemplateVisitor2 = class extends RecursiveAstVisitor3 {\n  constructor(ctx, component, check) {\n    super();\n    this.ctx = ctx;\n    this.component = component;\n    this.check = check;\n    this.diagnostics = [];\n  }\n  visit(node, context) {\n    this.diagnostics.push(...this.check.visitNode(this.ctx, this.component, node));\n    node.visit(this);\n  }\n  visitAllNodes(nodes) {\n    for (const node of nodes) {\n      this.visit(node);\n    }\n  }\n  visitAst(ast) {\n    if (ast instanceof ASTWithSource4) {\n      ast = ast.ast;\n    }\n    this.visit(ast);\n  }\n  visitElement(element) {\n    this.visitAllNodes(element.attributes);\n    this.visitAllNodes(element.inputs);\n    this.visitAllNodes(element.outputs);\n    this.visitAllNodes(element.references);\n    this.visitAllNodes(element.children);\n  }\n  visitTemplate(template) {\n    this.visitAllNodes(template.attributes);\n    if (template.tagName === \"ng-template\") {\n      this.visitAllNodes(template.inputs);\n      this.visitAllNodes(template.outputs);\n      this.visitAllNodes(template.templateAttrs);\n    }\n    this.visitAllNodes(template.variables);\n    this.visitAllNodes(template.references);\n    this.visitAllNodes(template.children);\n  }\n  visitContent(content) {\n  }\n  visitVariable(variable) {\n  }\n  visitReference(reference) {\n  }\n  visitTextAttribute(attribute) {\n  }\n  visitBoundAttribute(attribute) {\n    this.visitAst(attribute.value);\n  }\n  visitBoundEvent(attribute) {\n    this.visitAst(attribute.handler);\n  }\n  visitText(text) {\n  }\n  visitBoundText(text) {\n    this.visitAst(text.value);\n  }\n  visitIcu(icu) {\n  }\n  getDiagnostics(template) {\n    this.diagnostics = [];\n    this.visitAllNodes(template);\n    return this.diagnostics;\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/invalid_banana_in_box/index.mjs\nvar InvalidBananaInBoxCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.INVALID_BANANA_IN_BOX;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof TmplAstBoundEvent2))\n      return [];\n    const name = node.name;\n    if (!name.startsWith(\"[\") || !name.endsWith(\"]\"))\n      return [];\n    const boundSyntax = node.sourceSpan.toString();\n    const expectedBoundSyntax = boundSyntax.replace(`(${name})`, `[(${name.slice(1, -1)})]`);\n    const diagnostic = ctx.makeTemplateDiagnostic(node.sourceSpan, `In the two-way binding syntax the parentheses should be inside the brackets, ex. '${expectedBoundSyntax}'.\n        Find more at https://angular.io/guide/two-way-binding`);\n    return [diagnostic];\n  }\n};\nvar factory = {\n  code: ErrorCode.INVALID_BANANA_IN_BOX,\n  name: ExtendedTemplateDiagnosticName.INVALID_BANANA_IN_BOX,\n  create: () => new InvalidBananaInBoxCheck()\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/missing_control_flow_directive/index.mjs\nimport { TmplAstTemplate as TmplAstTemplate4 } from \"@angular/compiler\";\nvar KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([\n  [\"ngIf\", \"NgIf\"],\n  [\"ngFor\", \"NgFor\"],\n  [\"ngSwitchCase\", \"NgSwitchCase\"],\n  [\"ngSwitchDefault\", \"NgSwitchDefault\"]\n]);\nvar MissingControlFlowDirectiveCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE;\n  }\n  run(ctx, component, template) {\n    const componentMetadata = ctx.templateTypeChecker.getDirectiveMetadata(component);\n    if (!componentMetadata || !componentMetadata.isStandalone) {\n      return [];\n    }\n    return super.run(ctx, component, template);\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof TmplAstTemplate4))\n      return [];\n    const controlFlowAttr = node.templateAttrs.find((attr) => KNOWN_CONTROL_FLOW_DIRECTIVES.has(attr.name));\n    if (!controlFlowAttr)\n      return [];\n    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);\n    if (symbol === null || symbol.directives.length > 0) {\n      return [];\n    }\n    const sourceSpan = controlFlowAttr.keySpan || controlFlowAttr.sourceSpan;\n    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(controlFlowAttr.name);\n    const errorMessage = `The \\`*${controlFlowAttr.name}\\` directive was used in the template, but neither the \\`${correspondingImport}\\` directive nor the \\`CommonModule\\` was imported. Please make sure that either the \\`${correspondingImport}\\` directive or the \\`CommonModule\\` is included in the \\`@Component.imports\\` array of this component.`;\n    const diagnostic = ctx.makeTemplateDiagnostic(sourceSpan, errorMessage);\n    return [diagnostic];\n  }\n};\nvar factory2 = {\n  code: ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE,\n  name: ExtendedTemplateDiagnosticName.MISSING_CONTROL_FLOW_DIRECTIVE,\n  create: (options) => {\n    return new MissingControlFlowDirectiveCheck();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/missing_ngforof_let/index.mjs\nimport { TmplAstTemplate as TmplAstTemplate5 } from \"@angular/compiler\";\nvar MissingNgForOfLetCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.MISSING_NGFOROF_LET;\n  }\n  visitNode(ctx, component, node) {\n    const isTemplate = node instanceof TmplAstTemplate5;\n    if (!(node instanceof TmplAstTemplate5)) {\n      return [];\n    }\n    if (node.templateAttrs.length === 0) {\n      return [];\n    }\n    const attr = node.templateAttrs.find((x) => x.name === \"ngFor\");\n    if (attr === void 0) {\n      return [];\n    }\n    if (node.variables.length > 0) {\n      return [];\n    }\n    const errorString = \"Your ngFor is missing a value. Did you forget to add the `let` keyword?\";\n    const diagnostic = ctx.makeTemplateDiagnostic(attr.sourceSpan, errorString);\n    return [diagnostic];\n  }\n};\nvar factory3 = {\n  code: ErrorCode.MISSING_NGFOROF_LET,\n  name: ExtendedTemplateDiagnosticName.MISSING_NGFOROF_LET,\n  create: () => new MissingNgForOfLetCheck()\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/nullish_coalescing_not_nullable/index.mjs\nimport { Binary } from \"@angular/compiler\";\nimport ts27 from \"typescript\";\nvar NullishCoalescingNotNullableCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.NULLISH_COALESCING_NOT_NULLABLE;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof Binary) || node.operation !== \"??\")\n      return [];\n    const symbolLeft = ctx.templateTypeChecker.getSymbolOfNode(node.left, component);\n    if (symbolLeft === null || symbolLeft.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const typeLeft = symbolLeft.tsType;\n    if (typeLeft.flags & (ts27.TypeFlags.Any | ts27.TypeFlags.Unknown)) {\n      return [];\n    }\n    if (typeLeft.getNonNullableType() !== typeLeft)\n      return [];\n    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);\n    if (symbol.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const templateMapping = ctx.templateTypeChecker.getTemplateMappingAtTcbLocation(symbol.tcbLocation);\n    if (templateMapping === null) {\n      return [];\n    }\n    const diagnostic = ctx.makeTemplateDiagnostic(templateMapping.span, `The left side of this nullish coalescing operation does not include 'null' or 'undefined' in its type, therefore the '??' operator can be safely removed.`);\n    return [diagnostic];\n  }\n};\nvar factory4 = {\n  code: ErrorCode.NULLISH_COALESCING_NOT_NULLABLE,\n  name: ExtendedTemplateDiagnosticName.NULLISH_COALESCING_NOT_NULLABLE,\n  create: (options) => {\n    const strictNullChecks = options.strictNullChecks === void 0 ? !!options.strict : !!options.strictNullChecks;\n    if (!strictNullChecks) {\n      return null;\n    }\n    return new NullishCoalescingNotNullableCheck();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/optional_chain_not_nullable/index.mjs\nimport { SafeCall as SafeCall2, SafeKeyedRead as SafeKeyedRead2, SafePropertyRead as SafePropertyRead5 } from \"@angular/compiler\";\nimport ts28 from \"typescript\";\nvar OptionalChainNotNullableCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof SafeCall2) && !(node instanceof SafePropertyRead5) && !(node instanceof SafeKeyedRead2))\n      return [];\n    const symbolLeft = ctx.templateTypeChecker.getSymbolOfNode(node.receiver, component);\n    if (symbolLeft === null || symbolLeft.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const typeLeft = symbolLeft.tsType;\n    if (typeLeft.flags & (ts28.TypeFlags.Any | ts28.TypeFlags.Unknown)) {\n      return [];\n    }\n    if (typeLeft.getNonNullableType() !== typeLeft)\n      return [];\n    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);\n    if (symbol.kind !== SymbolKind.Expression) {\n      return [];\n    }\n    const templateMapping = ctx.templateTypeChecker.getTemplateMappingAtTcbLocation(symbol.tcbLocation);\n    if (templateMapping === null) {\n      return [];\n    }\n    const advice = node instanceof SafePropertyRead5 ? `the '?.' operator can be replaced with the '.' operator` : `the '?.' operator can be safely removed`;\n    const diagnostic = ctx.makeTemplateDiagnostic(templateMapping.span, `The left side of this optional chain operation does not include 'null' or 'undefined' in its type, therefore ${advice}.`);\n    return [diagnostic];\n  }\n};\nvar factory5 = {\n  code: ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE,\n  name: ExtendedTemplateDiagnosticName.OPTIONAL_CHAIN_NOT_NULLABLE,\n  create: (options) => {\n    const strictNullChecks = options.strictNullChecks === void 0 ? !!options.strict : !!options.strictNullChecks;\n    if (!strictNullChecks) {\n      return null;\n    }\n    return new OptionalChainNotNullableCheck();\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/suffix_not_supported/index.mjs\nimport { TmplAstBoundAttribute as TmplAstBoundAttribute3 } from \"@angular/compiler\";\nvar STYLE_SUFFIXES = [\"px\", \"%\", \"em\"];\nvar SuffixNotSupportedCheck = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.SUFFIX_NOT_SUPPORTED;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof TmplAstBoundAttribute3))\n      return [];\n    if (!node.keySpan.toString().startsWith(\"attr.\") || !STYLE_SUFFIXES.some((suffix) => node.name.endsWith(`.${suffix}`))) {\n      return [];\n    }\n    const diagnostic = ctx.makeTemplateDiagnostic(node.keySpan, `The ${STYLE_SUFFIXES.map((suffix) => `'.${suffix}'`).join(\", \")} suffixes are only supported on style bindings.`);\n    return [diagnostic];\n  }\n};\nvar factory6 = {\n  code: ErrorCode.SUFFIX_NOT_SUPPORTED,\n  name: ExtendedTemplateDiagnosticName.SUFFIX_NOT_SUPPORTED,\n  create: () => new SuffixNotSupportedCheck()\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/text_attribute_not_binding/index.mjs\nimport { TmplAstTextAttribute as TmplAstTextAttribute4 } from \"@angular/compiler\";\nvar TextAttributeNotBindingSpec = class extends TemplateCheckWithVisitor {\n  constructor() {\n    super(...arguments);\n    this.code = ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING;\n  }\n  visitNode(ctx, component, node) {\n    if (!(node instanceof TmplAstTextAttribute4))\n      return [];\n    const name = node.name;\n    if (!name.startsWith(\"attr.\") && !name.startsWith(\"style.\") && !name.startsWith(\"class.\")) {\n      return [];\n    }\n    let errorString;\n    if (name.startsWith(\"attr.\")) {\n      const staticAttr = name.replace(\"attr.\", \"\");\n      errorString = `Static attributes should be written without the 'attr.' prefix.`;\n      if (node.value) {\n        errorString += ` For example, ${staticAttr}=\"${node.value}\".`;\n      }\n    } else {\n      const expectedKey = `[${name}]`;\n      const expectedValue = node.value === \"true\" || node.value === \"false\" ? node.value : `'${node.value}'`;\n      errorString = \"Attribute, style, and class bindings should be enclosed with square braces.\";\n      if (node.value) {\n        errorString += ` For example, '${expectedKey}=\"${expectedValue}\"'.`;\n      }\n    }\n    const diagnostic = ctx.makeTemplateDiagnostic(node.sourceSpan, errorString);\n    return [diagnostic];\n  }\n};\nvar factory7 = {\n  code: ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING,\n  name: ExtendedTemplateDiagnosticName.TEXT_ATTRIBUTE_NOT_BINDING,\n  create: () => new TextAttributeNotBindingSpec()\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/src/extended_template_checker.mjs\nimport ts29 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/core/api/src/public_options.mjs\nvar DiagnosticCategoryLabel;\n(function(DiagnosticCategoryLabel2) {\n  DiagnosticCategoryLabel2[\"Warning\"] = \"warning\";\n  DiagnosticCategoryLabel2[\"Error\"] = \"error\";\n  DiagnosticCategoryLabel2[\"Suppress\"] = \"suppress\";\n})(DiagnosticCategoryLabel || (DiagnosticCategoryLabel = {}));\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/src/extended_template_checker.mjs\nvar ExtendedTemplateCheckerImpl = class {\n  constructor(templateTypeChecker, typeChecker, templateCheckFactories, options) {\n    var _a, _b, _c, _d, _e;\n    this.partialCtx = { templateTypeChecker, typeChecker };\n    this.templateChecks = /* @__PURE__ */ new Map();\n    for (const factory8 of templateCheckFactories) {\n      const category = diagnosticLabelToCategory((_e = (_d = (_b = (_a = options == null ? void 0 : options.extendedDiagnostics) == null ? void 0 : _a.checks) == null ? void 0 : _b[factory8.name]) != null ? _d : (_c = options == null ? void 0 : options.extendedDiagnostics) == null ? void 0 : _c.defaultCategory) != null ? _e : DiagnosticCategoryLabel.Warning);\n      if (category === null) {\n        continue;\n      }\n      const check = factory8.create(options);\n      if (check === null) {\n        continue;\n      }\n      this.templateChecks.set(check, category);\n    }\n  }\n  getDiagnosticsForComponent(component) {\n    const template = this.partialCtx.templateTypeChecker.getTemplate(component);\n    if (template === null) {\n      return [];\n    }\n    const diagnostics = [];\n    for (const [check, category] of this.templateChecks.entries()) {\n      const ctx = {\n        ...this.partialCtx,\n        makeTemplateDiagnostic: (span, message, relatedInformation) => {\n          return this.partialCtx.templateTypeChecker.makeTemplateDiagnostic(component, span, category, check.code, message, relatedInformation);\n        }\n      };\n      diagnostics.push(...check.run(ctx, component, template));\n    }\n    return diagnostics;\n  }\n};\nfunction diagnosticLabelToCategory(label) {\n  switch (label) {\n    case DiagnosticCategoryLabel.Warning:\n      return ts29.DiagnosticCategory.Warning;\n    case DiagnosticCategoryLabel.Error:\n      return ts29.DiagnosticCategory.Error;\n    case DiagnosticCategoryLabel.Suppress:\n      return null;\n    default:\n      return assertNever(label);\n  }\n}\nfunction assertNever(value) {\n  throw new Error(`Unexpected call to 'assertNever()' with value:\n${value}`);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/typecheck/extended/index.mjs\nvar ALL_DIAGNOSTIC_FACTORIES = [\n  factory,\n  factory4,\n  factory5,\n  factory2,\n  factory7,\n  factory3,\n  factory6\n];\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/core/src/compiler.mjs\nvar CompilationTicketKind;\n(function(CompilationTicketKind2) {\n  CompilationTicketKind2[CompilationTicketKind2[\"Fresh\"] = 0] = \"Fresh\";\n  CompilationTicketKind2[CompilationTicketKind2[\"IncrementalTypeScript\"] = 1] = \"IncrementalTypeScript\";\n  CompilationTicketKind2[CompilationTicketKind2[\"IncrementalResource\"] = 2] = \"IncrementalResource\";\n})(CompilationTicketKind || (CompilationTicketKind = {}));\nfunction freshCompilationTicket(tsProgram, options, incrementalBuildStrategy, programDriver, perfRecorder, enableTemplateTypeChecker, usePoisonedData) {\n  return {\n    kind: CompilationTicketKind.Fresh,\n    tsProgram,\n    options,\n    incrementalBuildStrategy,\n    programDriver,\n    enableTemplateTypeChecker,\n    usePoisonedData,\n    perfRecorder: perfRecorder != null ? perfRecorder : ActivePerfRecorder.zeroedToNow()\n  };\n}\nfunction incrementalFromCompilerTicket(oldCompiler, newProgram, incrementalBuildStrategy, programDriver, modifiedResourceFiles, perfRecorder) {\n  const oldProgram = oldCompiler.getCurrentProgram();\n  const oldState = oldCompiler.incrementalStrategy.getIncrementalState(oldProgram);\n  if (oldState === null) {\n    return freshCompilationTicket(newProgram, oldCompiler.options, incrementalBuildStrategy, programDriver, perfRecorder, oldCompiler.enableTemplateTypeChecker, oldCompiler.usePoisonedData);\n  }\n  if (perfRecorder === null) {\n    perfRecorder = ActivePerfRecorder.zeroedToNow();\n  }\n  const incrementalCompilation = IncrementalCompilation.incremental(newProgram, versionMapFromProgram(newProgram, programDriver), oldProgram, oldState, modifiedResourceFiles, perfRecorder);\n  return {\n    kind: CompilationTicketKind.IncrementalTypeScript,\n    enableTemplateTypeChecker: oldCompiler.enableTemplateTypeChecker,\n    usePoisonedData: oldCompiler.usePoisonedData,\n    options: oldCompiler.options,\n    incrementalBuildStrategy,\n    incrementalCompilation,\n    programDriver,\n    newProgram,\n    perfRecorder\n  };\n}\nfunction incrementalFromStateTicket(oldProgram, oldState, newProgram, options, incrementalBuildStrategy, programDriver, modifiedResourceFiles, perfRecorder, enableTemplateTypeChecker, usePoisonedData) {\n  if (perfRecorder === null) {\n    perfRecorder = ActivePerfRecorder.zeroedToNow();\n  }\n  const incrementalCompilation = IncrementalCompilation.incremental(newProgram, versionMapFromProgram(newProgram, programDriver), oldProgram, oldState, modifiedResourceFiles, perfRecorder);\n  return {\n    kind: CompilationTicketKind.IncrementalTypeScript,\n    newProgram,\n    options,\n    incrementalBuildStrategy,\n    incrementalCompilation,\n    programDriver,\n    enableTemplateTypeChecker,\n    usePoisonedData,\n    perfRecorder\n  };\n}\nvar NgCompiler = class {\n  static fromTicket(ticket, adapter) {\n    switch (ticket.kind) {\n      case CompilationTicketKind.Fresh:\n        return new NgCompiler(adapter, ticket.options, ticket.tsProgram, ticket.programDriver, ticket.incrementalBuildStrategy, IncrementalCompilation.fresh(ticket.tsProgram, versionMapFromProgram(ticket.tsProgram, ticket.programDriver)), ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);\n      case CompilationTicketKind.IncrementalTypeScript:\n        return new NgCompiler(adapter, ticket.options, ticket.newProgram, ticket.programDriver, ticket.incrementalBuildStrategy, ticket.incrementalCompilation, ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);\n      case CompilationTicketKind.IncrementalResource:\n        const compiler = ticket.compiler;\n        compiler.updateWithChangedResources(ticket.modifiedResourceFiles, ticket.perfRecorder);\n        return compiler;\n    }\n  }\n  constructor(adapter, options, inputProgram, programDriver, incrementalStrategy, incrementalCompilation, enableTemplateTypeChecker, usePoisonedData, livePerfRecorder) {\n    var _a;\n    this.adapter = adapter;\n    this.options = options;\n    this.inputProgram = inputProgram;\n    this.programDriver = programDriver;\n    this.incrementalStrategy = incrementalStrategy;\n    this.incrementalCompilation = incrementalCompilation;\n    this.usePoisonedData = usePoisonedData;\n    this.livePerfRecorder = livePerfRecorder;\n    this.compilation = null;\n    this.constructionDiagnostics = [];\n    this.nonTemplateDiagnostics = null;\n    this.delegatingPerfRecorder = new DelegatingPerfRecorder(this.perfRecorder);\n    this.enableTemplateTypeChecker = enableTemplateTypeChecker || ((_a = options._enableTemplateTypeChecker) != null ? _a : false);\n    this.constructionDiagnostics.push(...this.adapter.constructionDiagnostics, ...verifyCompatibleTypeCheckOptions(this.options));\n    this.currentProgram = inputProgram;\n    this.closureCompilerEnabled = !!this.options.annotateForClosureCompiler;\n    this.entryPoint = adapter.entryPoint !== null ? getSourceFileOrNull(inputProgram, adapter.entryPoint) : null;\n    const moduleResolutionCache = ts30.createModuleResolutionCache(\n      this.adapter.getCurrentDirectory(),\n      this.adapter.getCanonicalFileName.bind(this.adapter)\n    );\n    this.moduleResolver = new ModuleResolver(inputProgram, this.options, this.adapter, moduleResolutionCache);\n    this.resourceManager = new AdapterResourceLoader(adapter, this.options);\n    this.cycleAnalyzer = new CycleAnalyzer(new ImportGraph(inputProgram.getTypeChecker(), this.delegatingPerfRecorder));\n    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, inputProgram);\n    this.ignoreForDiagnostics = new Set(inputProgram.getSourceFiles().filter((sf) => this.adapter.isShim(sf)));\n    this.ignoreForEmit = this.adapter.ignoreForEmit;\n    let dtsFileCount = 0;\n    let nonDtsFileCount = 0;\n    for (const sf of inputProgram.getSourceFiles()) {\n      if (sf.isDeclarationFile) {\n        dtsFileCount++;\n      } else {\n        nonDtsFileCount++;\n      }\n    }\n    livePerfRecorder.eventCount(PerfEvent.InputDtsFile, dtsFileCount);\n    livePerfRecorder.eventCount(PerfEvent.InputTsFile, nonDtsFileCount);\n  }\n  get perfRecorder() {\n    return this.livePerfRecorder;\n  }\n  updateWithChangedResources(changedResources, perfRecorder) {\n    this.livePerfRecorder = perfRecorder;\n    this.delegatingPerfRecorder.target = perfRecorder;\n    perfRecorder.inPhase(PerfPhase.ResourceUpdate, () => {\n      if (this.compilation === null) {\n        return;\n      }\n      this.resourceManager.invalidate();\n      const classesToUpdate = /* @__PURE__ */ new Set();\n      for (const resourceFile of changedResources) {\n        for (const templateClass of this.getComponentsWithTemplateFile(resourceFile)) {\n          classesToUpdate.add(templateClass);\n        }\n        for (const styleClass of this.getComponentsWithStyleFile(resourceFile)) {\n          classesToUpdate.add(styleClass);\n        }\n      }\n      for (const clazz of classesToUpdate) {\n        this.compilation.traitCompiler.updateResources(clazz);\n        if (!ts30.isClassDeclaration(clazz)) {\n          continue;\n        }\n        this.compilation.templateTypeChecker.invalidateClass(clazz);\n      }\n    });\n  }\n  getResourceDependencies(file) {\n    this.ensureAnalyzed();\n    return this.incrementalCompilation.depGraph.getResourceDependencies(file);\n  }\n  getDiagnostics() {\n    const diagnostics = [];\n    diagnostics.push(...this.getNonTemplateDiagnostics(), ...this.getTemplateDiagnostics());\n    if (this.options.strictTemplates) {\n      diagnostics.push(...this.getExtendedTemplateDiagnostics());\n    }\n    return this.addMessageTextDetails(diagnostics);\n  }\n  getDiagnosticsForFile(file, optimizeFor) {\n    const diagnostics = [];\n    diagnostics.push(...this.getNonTemplateDiagnostics().filter((diag) => diag.file === file), ...this.getTemplateDiagnosticsForFile(file, optimizeFor));\n    if (this.options.strictTemplates) {\n      diagnostics.push(...this.getExtendedTemplateDiagnostics(file));\n    }\n    return this.addMessageTextDetails(diagnostics);\n  }\n  getDiagnosticsForComponent(component) {\n    const compilation = this.ensureAnalyzed();\n    const ttc = compilation.templateTypeChecker;\n    const diagnostics = [];\n    try {\n      diagnostics.push(...ttc.getDiagnosticsForComponent(component));\n      const extendedTemplateChecker = compilation.extendedTemplateChecker;\n      if (this.options.strictTemplates && extendedTemplateChecker) {\n        diagnostics.push(...extendedTemplateChecker.getDiagnosticsForComponent(component));\n      }\n    } catch (err) {\n      if (!(err instanceof FatalDiagnosticError)) {\n        throw err;\n      }\n      diagnostics.push(err.toDiagnostic());\n    }\n    return this.addMessageTextDetails(diagnostics);\n  }\n  addMessageTextDetails(diagnostics) {\n    return diagnostics.map((diag) => {\n      if (diag.code && COMPILER_ERRORS_WITH_GUIDES.has(ngErrorCode(diag.code))) {\n        return {\n          ...diag,\n          messageText: diag.messageText + `. Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/NG${ngErrorCode(diag.code)}`\n        };\n      }\n      return diag;\n    });\n  }\n  getOptionDiagnostics() {\n    return this.constructionDiagnostics;\n  }\n  getCurrentProgram() {\n    return this.currentProgram;\n  }\n  getTemplateTypeChecker() {\n    if (!this.enableTemplateTypeChecker) {\n      throw new Error(\"The `TemplateTypeChecker` does not work without `enableTemplateTypeChecker`.\");\n    }\n    return this.ensureAnalyzed().templateTypeChecker;\n  }\n  getComponentsWithTemplateFile(templateFilePath) {\n    const { resourceRegistry } = this.ensureAnalyzed();\n    return resourceRegistry.getComponentsWithTemplate(resolve(templateFilePath));\n  }\n  getComponentsWithStyleFile(styleFilePath) {\n    const { resourceRegistry } = this.ensureAnalyzed();\n    return resourceRegistry.getComponentsWithStyle(resolve(styleFilePath));\n  }\n  getComponentResources(classDecl) {\n    if (!isNamedClassDeclaration(classDecl)) {\n      return null;\n    }\n    const { resourceRegistry } = this.ensureAnalyzed();\n    const styles = resourceRegistry.getStyles(classDecl);\n    const template = resourceRegistry.getTemplate(classDecl);\n    if (template === null) {\n      return null;\n    }\n    return { styles, template };\n  }\n  getMeta(classDecl) {\n    var _a;\n    if (!isNamedClassDeclaration(classDecl)) {\n      return null;\n    }\n    const ref = new Reference(classDecl);\n    const { metaReader } = this.ensureAnalyzed();\n    const meta = (_a = metaReader.getPipeMetadata(ref)) != null ? _a : metaReader.getDirectiveMetadata(ref);\n    if (meta === null) {\n      return null;\n    }\n    return meta;\n  }\n  async analyzeAsync() {\n    if (this.compilation !== null) {\n      return;\n    }\n    await this.perfRecorder.inPhase(PerfPhase.Analysis, async () => {\n      this.compilation = this.makeCompilation();\n      const promises = [];\n      for (const sf of this.inputProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile) {\n          continue;\n        }\n        let analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);\n        if (analysisPromise !== void 0) {\n          promises.push(analysisPromise);\n        }\n      }\n      await Promise.all(promises);\n      this.perfRecorder.memory(PerfCheckpoint.Analysis);\n      this.resolveCompilation(this.compilation.traitCompiler);\n    });\n  }\n  prepareEmit() {\n    const compilation = this.ensureAnalyzed();\n    const coreImportsFrom = compilation.isCore ? getR3SymbolsFile(this.inputProgram) : null;\n    let importRewriter;\n    if (coreImportsFrom !== null) {\n      importRewriter = new R3SymbolsImportRewriter(coreImportsFrom.fileName);\n    } else {\n      importRewriter = new NoopImportRewriter();\n    }\n    const defaultImportTracker = new DefaultImportTracker();\n    const before = [\n      ivyTransformFactory(compilation.traitCompiler, compilation.reflector, importRewriter, defaultImportTracker, this.delegatingPerfRecorder, compilation.isCore, this.closureCompilerEnabled),\n      aliasTransformFactory(compilation.traitCompiler.exportStatements),\n      defaultImportTracker.importPreservingTransformer()\n    ];\n    const afterDeclarations = [];\n    if (this.options.compilationMode !== \"experimental-local\" && compilation.dtsTransforms !== null) {\n      afterDeclarations.push(declarationTransformFactory(compilation.dtsTransforms, compilation.reflector, compilation.refEmitter, importRewriter));\n    }\n    if (compilation.aliasingHost !== null && compilation.aliasingHost.aliasExportsInDts) {\n      afterDeclarations.push(aliasTransformFactory(compilation.traitCompiler.exportStatements));\n    }\n    return { transformers: { before, afterDeclarations } };\n  }\n  getIndexedComponents() {\n    const compilation = this.ensureAnalyzed();\n    const context = new IndexingContext();\n    compilation.traitCompiler.index(context);\n    return generateAnalysis(context);\n  }\n  xi18n(ctx) {\n    const compilation = this.ensureAnalyzed();\n    compilation.traitCompiler.xi18n(ctx);\n  }\n  ensureAnalyzed() {\n    if (this.compilation === null) {\n      this.analyzeSync();\n    }\n    return this.compilation;\n  }\n  analyzeSync() {\n    this.perfRecorder.inPhase(PerfPhase.Analysis, () => {\n      this.compilation = this.makeCompilation();\n      for (const sf of this.inputProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile) {\n          continue;\n        }\n        this.compilation.traitCompiler.analyzeSync(sf);\n      }\n      this.perfRecorder.memory(PerfCheckpoint.Analysis);\n      this.resolveCompilation(this.compilation.traitCompiler);\n    });\n  }\n  resolveCompilation(traitCompiler) {\n    this.perfRecorder.inPhase(PerfPhase.Resolve, () => {\n      traitCompiler.resolve();\n      this.incrementalCompilation.recordSuccessfulAnalysis(traitCompiler);\n      this.perfRecorder.memory(PerfCheckpoint.Resolve);\n    });\n  }\n  get fullTemplateTypeCheck() {\n    const strictTemplates = !!this.options.strictTemplates;\n    return strictTemplates || !!this.options.fullTemplateTypeCheck;\n  }\n  getTypeCheckingConfig() {\n    const strictTemplates = !!this.options.strictTemplates;\n    const useInlineTypeConstructors = this.programDriver.supportsInlineOperations;\n    let typeCheckingConfig;\n    if (this.fullTemplateTypeCheck) {\n      typeCheckingConfig = {\n        applyTemplateContextGuards: strictTemplates,\n        checkQueries: false,\n        checkTemplateBodies: true,\n        alwaysCheckSchemaInTemplateBodies: true,\n        checkTypeOfInputBindings: strictTemplates,\n        honorAccessModifiersForInputBindings: false,\n        strictNullInputBindings: strictTemplates,\n        checkTypeOfAttributes: strictTemplates,\n        checkTypeOfDomBindings: false,\n        checkTypeOfOutputEvents: strictTemplates,\n        checkTypeOfAnimationEvents: strictTemplates,\n        checkTypeOfDomEvents: strictTemplates,\n        checkTypeOfDomReferences: strictTemplates,\n        checkTypeOfNonDomReferences: true,\n        checkTypeOfPipes: true,\n        strictSafeNavigationTypes: strictTemplates,\n        useContextGenericType: strictTemplates,\n        strictLiteralTypes: true,\n        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n        useInlineTypeConstructors,\n        suggestionsForSuboptimalTypeInference: this.enableTemplateTypeChecker && !strictTemplates\n      };\n    } else {\n      typeCheckingConfig = {\n        applyTemplateContextGuards: false,\n        checkQueries: false,\n        checkTemplateBodies: false,\n        alwaysCheckSchemaInTemplateBodies: this.closureCompilerEnabled,\n        checkTypeOfInputBindings: false,\n        strictNullInputBindings: false,\n        honorAccessModifiersForInputBindings: false,\n        checkTypeOfAttributes: false,\n        checkTypeOfDomBindings: false,\n        checkTypeOfOutputEvents: false,\n        checkTypeOfAnimationEvents: false,\n        checkTypeOfDomEvents: false,\n        checkTypeOfDomReferences: false,\n        checkTypeOfNonDomReferences: false,\n        checkTypeOfPipes: false,\n        strictSafeNavigationTypes: false,\n        useContextGenericType: false,\n        strictLiteralTypes: false,\n        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n        useInlineTypeConstructors,\n        suggestionsForSuboptimalTypeInference: false\n      };\n    }\n    if (this.options.strictInputTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfInputBindings = this.options.strictInputTypes;\n      typeCheckingConfig.applyTemplateContextGuards = this.options.strictInputTypes;\n    }\n    if (this.options.strictInputAccessModifiers !== void 0) {\n      typeCheckingConfig.honorAccessModifiersForInputBindings = this.options.strictInputAccessModifiers;\n    }\n    if (this.options.strictNullInputTypes !== void 0) {\n      typeCheckingConfig.strictNullInputBindings = this.options.strictNullInputTypes;\n    }\n    if (this.options.strictOutputEventTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfOutputEvents = this.options.strictOutputEventTypes;\n      typeCheckingConfig.checkTypeOfAnimationEvents = this.options.strictOutputEventTypes;\n    }\n    if (this.options.strictDomEventTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfDomEvents = this.options.strictDomEventTypes;\n    }\n    if (this.options.strictSafeNavigationTypes !== void 0) {\n      typeCheckingConfig.strictSafeNavigationTypes = this.options.strictSafeNavigationTypes;\n    }\n    if (this.options.strictDomLocalRefTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfDomReferences = this.options.strictDomLocalRefTypes;\n    }\n    if (this.options.strictAttributeTypes !== void 0) {\n      typeCheckingConfig.checkTypeOfAttributes = this.options.strictAttributeTypes;\n    }\n    if (this.options.strictContextGenerics !== void 0) {\n      typeCheckingConfig.useContextGenericType = this.options.strictContextGenerics;\n    }\n    if (this.options.strictLiteralTypes !== void 0) {\n      typeCheckingConfig.strictLiteralTypes = this.options.strictLiteralTypes;\n    }\n    return typeCheckingConfig;\n  }\n  getTemplateDiagnostics() {\n    const compilation = this.ensureAnalyzed();\n    const diagnostics = [];\n    for (const sf of this.inputProgram.getSourceFiles()) {\n      if (sf.isDeclarationFile || this.adapter.isShim(sf)) {\n        continue;\n      }\n      try {\n        diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram));\n      } catch (err) {\n        if (!(err instanceof FatalDiagnosticError)) {\n          throw err;\n        }\n        diagnostics.push(err.toDiagnostic());\n      }\n    }\n    const program = this.programDriver.getProgram();\n    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n    this.currentProgram = program;\n    return diagnostics;\n  }\n  getTemplateDiagnosticsForFile(sf, optimizeFor) {\n    const compilation = this.ensureAnalyzed();\n    const diagnostics = [];\n    if (!sf.isDeclarationFile && !this.adapter.isShim(sf)) {\n      try {\n        diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, optimizeFor));\n      } catch (err) {\n        if (!(err instanceof FatalDiagnosticError)) {\n          throw err;\n        }\n        diagnostics.push(err.toDiagnostic());\n      }\n    }\n    const program = this.programDriver.getProgram();\n    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n    this.currentProgram = program;\n    return diagnostics;\n  }\n  getNonTemplateDiagnostics() {\n    if (this.nonTemplateDiagnostics === null) {\n      const compilation = this.ensureAnalyzed();\n      this.nonTemplateDiagnostics = [...compilation.traitCompiler.diagnostics];\n      if (this.entryPoint !== null && compilation.exportReferenceGraph !== null) {\n        this.nonTemplateDiagnostics.push(...checkForPrivateExports(this.entryPoint, this.inputProgram.getTypeChecker(), compilation.exportReferenceGraph));\n      }\n    }\n    return this.nonTemplateDiagnostics;\n  }\n  getExtendedTemplateDiagnostics(sf) {\n    const diagnostics = [];\n    const compilation = this.ensureAnalyzed();\n    const extendedTemplateChecker = compilation.extendedTemplateChecker;\n    if (!extendedTemplateChecker) {\n      return [];\n    }\n    if (sf !== void 0) {\n      return compilation.traitCompiler.extendedTemplateCheck(sf, extendedTemplateChecker);\n    }\n    for (const sf2 of this.inputProgram.getSourceFiles()) {\n      diagnostics.push(...compilation.traitCompiler.extendedTemplateCheck(sf2, extendedTemplateChecker));\n    }\n    return diagnostics;\n  }\n  makeCompilation() {\n    var _a;\n    const checker = this.inputProgram.getTypeChecker();\n    const reflector = new TypeScriptReflectionHost(checker);\n    let refEmitter;\n    let aliasingHost = null;\n    if (this.adapter.unifiedModulesHost === null || !this.options._useHostForImportGeneration) {\n      let localImportStrategy;\n      if (this.options.rootDir !== void 0 || this.options.rootDirs !== void 0 && this.options.rootDirs.length > 0) {\n        localImportStrategy = new LogicalProjectStrategy(reflector, new LogicalFileSystem([...this.adapter.rootDirs], this.adapter));\n      } else {\n        localImportStrategy = new RelativePathStrategy(reflector);\n      }\n      refEmitter = new ReferenceEmitter([\n        new LocalIdentifierStrategy(),\n        new AbsoluteModuleStrategy(this.inputProgram, checker, this.moduleResolver, reflector),\n        localImportStrategy\n      ]);\n      if (this.entryPoint === null && this.options.generateDeepReexports === true) {\n        aliasingHost = new PrivateExportAliasingHost(reflector);\n      }\n    } else {\n      refEmitter = new ReferenceEmitter([\n        new LocalIdentifierStrategy(),\n        new AliasStrategy(),\n        new UnifiedModulesStrategy(reflector, this.adapter.unifiedModulesHost)\n      ]);\n      aliasingHost = new UnifiedModulesAliasingHost(this.adapter.unifiedModulesHost);\n    }\n    const isCore = isAngularCorePackage(this.inputProgram);\n    const evaluator = new PartialEvaluator(reflector, checker, this.incrementalCompilation.depGraph);\n    const dtsReader = new DtsMetadataReader(checker, reflector);\n    const localMetaRegistry = new LocalMetadataRegistry();\n    const localMetaReader = localMetaRegistry;\n    const depScopeReader = new MetadataDtsModuleScopeResolver(dtsReader, aliasingHost);\n    const metaReader = new CompoundMetadataReader([localMetaReader, dtsReader]);\n    const ngModuleIndex = new NgModuleIndexImpl(metaReader, localMetaReader);\n    const ngModuleScopeRegistry = new LocalModuleScopeRegistry(localMetaReader, metaReader, depScopeReader, refEmitter, aliasingHost);\n    const standaloneScopeReader = new StandaloneComponentScopeReader(metaReader, ngModuleScopeRegistry, depScopeReader);\n    const scopeReader = new CompoundComponentScopeReader([ngModuleScopeRegistry, standaloneScopeReader]);\n    const semanticDepGraphUpdater = this.incrementalCompilation.semanticDepGraphUpdater;\n    const metaRegistry = new CompoundMetadataRegistry([localMetaRegistry, ngModuleScopeRegistry]);\n    const injectableRegistry = new InjectableClassRegistry(reflector, isCore);\n    const hostDirectivesResolver = new HostDirectivesResolver(metaReader);\n    const exportedProviderStatusResolver = new ExportedProviderStatusResolver(metaReader);\n    const typeCheckScopeRegistry = new TypeCheckScopeRegistry(scopeReader, metaReader, hostDirectivesResolver);\n    let referencesRegistry;\n    let exportReferenceGraph = null;\n    if (this.entryPoint !== null) {\n      exportReferenceGraph = new ReferenceGraph();\n      referencesRegistry = new ReferenceGraphAdapter(exportReferenceGraph);\n    } else {\n      referencesRegistry = new NoopReferencesRegistry();\n    }\n    const dtsTransforms = new DtsTransformRegistry();\n    const resourceRegistry = new ResourceRegistry();\n    let compilationMode = CompilationMode.FULL;\n    if (!isCore) {\n      switch (this.options.compilationMode) {\n        case \"full\":\n          compilationMode = CompilationMode.FULL;\n          break;\n        case \"partial\":\n          compilationMode = CompilationMode.PARTIAL;\n          break;\n        case \"experimental-local\":\n          compilationMode = CompilationMode.LOCAL;\n          break;\n      }\n    }\n    const cycleHandlingStrategy = compilationMode === CompilationMode.FULL ? 0 : 1;\n    const strictCtorDeps = this.options.strictInjectionParameters || false;\n    const handlers = [\n      new ComponentDecoratorHandler(reflector, evaluator, metaRegistry, metaReader, scopeReader, depScopeReader, ngModuleScopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, strictCtorDeps, this.resourceManager, this.adapter.rootDirs, this.options.preserveWhitespaces || false, this.options.i18nUseExternalIds !== false, this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData, this.options.i18nNormalizeLineEndingsInICUs === true, this.moduleResolver, this.cycleAnalyzer, cycleHandlingStrategy, refEmitter, referencesRegistry, this.incrementalCompilation.depGraph, injectableRegistry, semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder, hostDirectivesResolver),\n      new DirectiveDecoratorHandler(reflector, evaluator, metaRegistry, ngModuleScopeRegistry, metaReader, injectableRegistry, refEmitter, referencesRegistry, isCore, strictCtorDeps, semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder),\n      new PipeDecoratorHandler(reflector, evaluator, metaRegistry, ngModuleScopeRegistry, injectableRegistry, isCore, this.delegatingPerfRecorder),\n      new InjectableDecoratorHandler(reflector, evaluator, isCore, strictCtorDeps, injectableRegistry, this.delegatingPerfRecorder),\n      new NgModuleDecoratorHandler(reflector, evaluator, metaReader, metaRegistry, ngModuleScopeRegistry, referencesRegistry, exportedProviderStatusResolver, semanticDepGraphUpdater, isCore, refEmitter, this.closureCompilerEnabled, (_a = this.options.onlyPublishPublicTypingsForNgModules) != null ? _a : false, injectableRegistry, this.delegatingPerfRecorder)\n    ];\n    const traitCompiler = new TraitCompiler(handlers, reflector, this.delegatingPerfRecorder, this.incrementalCompilation, this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms, semanticDepGraphUpdater, this.adapter);\n    const notifyingDriver = new NotifyingProgramDriverWrapper(this.programDriver, (program) => {\n      this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n      this.currentProgram = program;\n    });\n    const templateTypeChecker = new TemplateTypeCheckerImpl(this.inputProgram, notifyingDriver, traitCompiler, this.getTypeCheckingConfig(), refEmitter, reflector, this.adapter, this.incrementalCompilation, metaReader, localMetaReader, ngModuleIndex, scopeReader, typeCheckScopeRegistry, this.delegatingPerfRecorder);\n    const extendedTemplateChecker = this.constructionDiagnostics.length === 0 ? new ExtendedTemplateCheckerImpl(templateTypeChecker, checker, ALL_DIAGNOSTIC_FACTORIES, this.options) : null;\n    return {\n      isCore,\n      traitCompiler,\n      reflector,\n      scopeRegistry: ngModuleScopeRegistry,\n      dtsTransforms,\n      exportReferenceGraph,\n      metaReader,\n      typeCheckScopeRegistry,\n      aliasingHost,\n      refEmitter,\n      templateTypeChecker,\n      resourceRegistry,\n      extendedTemplateChecker\n    };\n  }\n};\nfunction isAngularCorePackage(program) {\n  const r3Symbols = getR3SymbolsFile(program);\n  if (r3Symbols === null) {\n    return false;\n  }\n  return r3Symbols.statements.some((stmt) => {\n    if (!ts30.isVariableStatement(stmt)) {\n      return false;\n    }\n    const modifiers = ts30.getModifiers(stmt);\n    if (modifiers === void 0 || !modifiers.some((mod) => mod.kind === ts30.SyntaxKind.ExportKeyword)) {\n      return false;\n    }\n    return stmt.declarationList.declarations.some((decl) => {\n      if (!ts30.isIdentifier(decl.name) || decl.name.text !== \"ITS_JUST_ANGULAR\") {\n        return false;\n      }\n      if (decl.initializer === void 0 || decl.initializer.kind !== ts30.SyntaxKind.TrueKeyword) {\n        return false;\n      }\n      return true;\n    });\n  });\n}\nfunction getR3SymbolsFile(program) {\n  return program.getSourceFiles().find((file) => file.fileName.indexOf(\"r3_symbols.ts\") >= 0) || null;\n}\nfunction* verifyCompatibleTypeCheckOptions(options) {\n  var _a, _b, _c;\n  if (options.fullTemplateTypeCheck === false && options.strictTemplates === true) {\n    yield makeConfigDiagnostic({\n      category: ts30.DiagnosticCategory.Error,\n      code: ErrorCode.CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK,\n      messageText: `\nAngular compiler option \"strictTemplates\" is enabled, however \"fullTemplateTypeCheck\" is disabled.\n\nHaving the \"strictTemplates\" flag enabled implies that \"fullTemplateTypeCheck\" is also enabled, so\nthe latter can not be explicitly disabled.\n\nOne of the following actions is required:\n1. Remove the \"fullTemplateTypeCheck\" option.\n2. Remove \"strictTemplates\" or set it to 'false'.\n\nMore information about the template type checking compiler options can be found in the documentation:\nhttps://angular.io/guide/template-typecheck\n      `.trim()\n    });\n  }\n  if (options.extendedDiagnostics && options.strictTemplates === false) {\n    yield makeConfigDiagnostic({\n      category: ts30.DiagnosticCategory.Error,\n      code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_IMPLIES_STRICT_TEMPLATES,\n      messageText: `\nAngular compiler option \"extendedDiagnostics\" is configured, however \"strictTemplates\" is disabled.\n\nUsing \"extendedDiagnostics\" requires that \"strictTemplates\" is also enabled.\n\nOne of the following actions is required:\n1. Remove \"strictTemplates: false\" to enable it.\n2. Remove \"extendedDiagnostics\" configuration to disable them.\n      `.trim()\n    });\n  }\n  const allowedCategoryLabels = Array.from(Object.values(DiagnosticCategoryLabel));\n  const defaultCategory = (_a = options.extendedDiagnostics) == null ? void 0 : _a.defaultCategory;\n  if (defaultCategory && !allowedCategoryLabels.includes(defaultCategory)) {\n    yield makeConfigDiagnostic({\n      category: ts30.DiagnosticCategory.Error,\n      code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL,\n      messageText: `\nAngular compiler option \"extendedDiagnostics.defaultCategory\" has an unknown diagnostic category: \"${defaultCategory}\".\n\nAllowed diagnostic categories are:\n${allowedCategoryLabels.join(\"\\n\")}\n      `.trim()\n    });\n  }\n  const allExtendedDiagnosticNames = ALL_DIAGNOSTIC_FACTORIES.map((factory8) => factory8.name);\n  for (const [checkName, category] of Object.entries((_c = (_b = options.extendedDiagnostics) == null ? void 0 : _b.checks) != null ? _c : {})) {\n    if (!allExtendedDiagnosticNames.includes(checkName)) {\n      yield makeConfigDiagnostic({\n        category: ts30.DiagnosticCategory.Error,\n        code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CHECK,\n        messageText: `\nAngular compiler option \"extendedDiagnostics.checks\" has an unknown check: \"${checkName}\".\n\nAllowed check names are:\n${allExtendedDiagnosticNames.join(\"\\n\")}\n        `.trim()\n      });\n    }\n    if (!allowedCategoryLabels.includes(category)) {\n      yield makeConfigDiagnostic({\n        category: ts30.DiagnosticCategory.Error,\n        code: ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL,\n        messageText: `\nAngular compiler option \"extendedDiagnostics.checks['${checkName}']\" has an unknown diagnostic category: \"${category}\".\n\nAllowed diagnostic categories are:\n${allowedCategoryLabels.join(\"\\n\")}\n        `.trim()\n      });\n    }\n  }\n}\nfunction makeConfigDiagnostic({ category, code, messageText }) {\n  return {\n    category,\n    code: ngErrorCode(code),\n    file: void 0,\n    start: void 0,\n    length: void 0,\n    messageText\n  };\n}\nvar ReferenceGraphAdapter = class {\n  constructor(graph) {\n    this.graph = graph;\n  }\n  add(source, ...references) {\n    for (const { node } of references) {\n      let sourceFile = node.getSourceFile();\n      if (sourceFile === void 0) {\n        sourceFile = ts30.getOriginalNode(node).getSourceFile();\n      }\n      if (sourceFile === void 0 || !isDtsPath(sourceFile.fileName)) {\n        this.graph.add(source, node);\n      }\n    }\n  }\n};\nvar NotifyingProgramDriverWrapper = class {\n  constructor(delegate, notifyNewProgram) {\n    var _a;\n    this.delegate = delegate;\n    this.notifyNewProgram = notifyNewProgram;\n    this.getSourceFileVersion = (_a = this.delegate.getSourceFileVersion) == null ? void 0 : _a.bind(this);\n  }\n  get supportsInlineOperations() {\n    return this.delegate.supportsInlineOperations;\n  }\n  getProgram() {\n    return this.delegate.getProgram();\n  }\n  updateFiles(contents, updateMode) {\n    this.delegate.updateFiles(contents, updateMode);\n    this.notifyNewProgram(this.delegate.getProgram());\n  }\n};\nfunction versionMapFromProgram(program, driver) {\n  if (driver.getSourceFileVersion === void 0) {\n    return null;\n  }\n  const versions = /* @__PURE__ */ new Map();\n  for (const possiblyRedirectedSourceFile of program.getSourceFiles()) {\n    const sf = toUnredirectedSourceFile(possiblyRedirectedSourceFile);\n    versions.set(absoluteFromSourceFile(sf), driver.getSourceFileVersion(sf));\n  }\n  return versions;\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/core/src/host.mjs\nimport ts31 from \"typescript\";\nvar DelegatingCompilerHost2 = class {\n  constructor(delegate) {\n    this.delegate = delegate;\n    this.createHash = this.delegateMethod(\"createHash\");\n    this.directoryExists = this.delegateMethod(\"directoryExists\");\n    this.fileNameToModuleName = this.delegateMethod(\"fileNameToModuleName\");\n    this.getCancellationToken = this.delegateMethod(\"getCancellationToken\");\n    this.getCanonicalFileName = this.delegateMethod(\"getCanonicalFileName\");\n    this.getCurrentDirectory = this.delegateMethod(\"getCurrentDirectory\");\n    this.getDefaultLibFileName = this.delegateMethod(\"getDefaultLibFileName\");\n    this.getDefaultLibLocation = this.delegateMethod(\"getDefaultLibLocation\");\n    this.getDirectories = this.delegateMethod(\"getDirectories\");\n    this.getEnvironmentVariable = this.delegateMethod(\"getEnvironmentVariable\");\n    this.getModifiedResourceFiles = this.delegateMethod(\"getModifiedResourceFiles\");\n    this.getNewLine = this.delegateMethod(\"getNewLine\");\n    this.getParsedCommandLine = this.delegateMethod(\"getParsedCommandLine\");\n    this.getSourceFileByPath = this.delegateMethod(\"getSourceFileByPath\");\n    this.readDirectory = this.delegateMethod(\"readDirectory\");\n    this.readFile = this.delegateMethod(\"readFile\");\n    this.readResource = this.delegateMethod(\"readResource\");\n    this.transformResource = this.delegateMethod(\"transformResource\");\n    this.realpath = this.delegateMethod(\"realpath\");\n    this.resolveModuleNames = this.delegateMethod(\"resolveModuleNames\");\n    this.resolveTypeReferenceDirectives = this.delegateMethod(\"resolveTypeReferenceDirectives\");\n    this.resourceNameToFileName = this.delegateMethod(\"resourceNameToFileName\");\n    this.trace = this.delegateMethod(\"trace\");\n    this.useCaseSensitiveFileNames = this.delegateMethod(\"useCaseSensitiveFileNames\");\n    this.writeFile = this.delegateMethod(\"writeFile\");\n    this.getModuleResolutionCache = this.delegateMethod(\"getModuleResolutionCache\");\n    this.hasInvalidatedResolutions = this.delegateMethod(\"hasInvalidatedResolutions\");\n    this.resolveModuleNameLiterals = this.delegateMethod(\"resolveModuleNameLiterals\");\n    this.resolveTypeReferenceDirectiveReferences = this.delegateMethod(\"resolveTypeReferenceDirectiveReferences\");\n  }\n  delegateMethod(name) {\n    return this.delegate[name] !== void 0 ? this.delegate[name].bind(this.delegate) : void 0;\n  }\n};\nvar NgCompilerHost = class extends DelegatingCompilerHost2 {\n  constructor(delegate, inputFiles, rootDirs, shimAdapter, shimTagger, entryPoint, diagnostics) {\n    super(delegate);\n    this.shimAdapter = shimAdapter;\n    this.shimTagger = shimTagger;\n    this.entryPoint = null;\n    this.entryPoint = entryPoint;\n    this.constructionDiagnostics = diagnostics;\n    this.inputFiles = [...inputFiles, ...shimAdapter.extraInputFiles];\n    this.rootDirs = rootDirs;\n    if (this.resolveModuleNames === void 0) {\n      this.resolveModuleNames = this.createCachedResolveModuleNamesFunction();\n    }\n  }\n  get ignoreForEmit() {\n    return this.shimAdapter.ignoreForEmit;\n  }\n  get shimExtensionPrefixes() {\n    return this.shimAdapter.extensionPrefixes;\n  }\n  postProgramCreationCleanup() {\n    this.shimTagger.finalize();\n  }\n  static wrap(delegate, inputFiles, options, oldProgram) {\n    const topLevelShimGenerators = [];\n    const perFileShimGenerators = [];\n    const rootDirs = getRootDirs(delegate, options);\n    perFileShimGenerators.push(new TypeCheckShimGenerator());\n    let diagnostics = [];\n    const normalizedTsInputFiles = [];\n    for (const inputFile of inputFiles) {\n      if (!isNonDeclarationTsPath(inputFile)) {\n        continue;\n      }\n      normalizedTsInputFiles.push(resolve(inputFile));\n    }\n    let entryPoint = null;\n    if (options.flatModuleOutFile != null && options.flatModuleOutFile !== \"\") {\n      entryPoint = findFlatIndexEntryPoint(normalizedTsInputFiles);\n      if (entryPoint === null) {\n        diagnostics.push({\n          category: ts31.DiagnosticCategory.Error,\n          code: ngErrorCode(ErrorCode.CONFIG_FLAT_MODULE_NO_INDEX),\n          file: void 0,\n          start: void 0,\n          length: void 0,\n          messageText: 'Angular compiler option \"flatModuleOutFile\" requires one and only one .ts file in the \"files\" field.'\n        });\n      } else {\n        const flatModuleId = options.flatModuleId || null;\n        const flatModuleOutFile = normalizeSeparators(options.flatModuleOutFile);\n        const flatIndexGenerator = new FlatIndexGenerator(entryPoint, flatModuleOutFile, flatModuleId);\n        topLevelShimGenerators.push(flatIndexGenerator);\n      }\n    }\n    const shimAdapter = new ShimAdapter(delegate, normalizedTsInputFiles, topLevelShimGenerators, perFileShimGenerators, oldProgram);\n    const shimTagger = new ShimReferenceTagger(perFileShimGenerators.map((gen) => gen.extensionPrefix));\n    return new NgCompilerHost(delegate, inputFiles, rootDirs, shimAdapter, shimTagger, entryPoint, diagnostics);\n  }\n  isShim(sf) {\n    return isShim(sf);\n  }\n  isResource(sf) {\n    return false;\n  }\n  getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile) {\n    const shimSf = this.shimAdapter.maybeGenerate(resolve(fileName));\n    if (shimSf !== null) {\n      return shimSf;\n    }\n    const sf = this.delegate.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);\n    if (sf === void 0) {\n      return void 0;\n    }\n    this.shimTagger.tag(sf);\n    return sf;\n  }\n  fileExists(fileName) {\n    return this.delegate.fileExists(fileName) || this.shimAdapter.maybeGenerate(resolve(fileName)) != null;\n  }\n  get unifiedModulesHost() {\n    return this.fileNameToModuleName !== void 0 ? this : null;\n  }\n  createCachedResolveModuleNamesFunction() {\n    const moduleResolutionCache = ts31.createModuleResolutionCache(this.getCurrentDirectory(), this.getCanonicalFileName.bind(this));\n    return (moduleNames, containingFile, reusedNames, redirectedReference, options) => {\n      return moduleNames.map((moduleName) => {\n        const module = ts31.resolveModuleName(moduleName, containingFile, options, this, moduleResolutionCache, redirectedReference);\n        return module.resolvedModule;\n      });\n    };\n  }\n};\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/ngtsc/program.mjs\nvar NgtscProgram = class {\n  constructor(rootNames, options, delegateHost, oldProgram) {\n    this.options = options;\n    const perfRecorder = ActivePerfRecorder.zeroedToNow();\n    perfRecorder.phase(PerfPhase.Setup);\n    if (!options.disableTypeScriptVersionCheck) {\n      verifySupportedTypeScriptVersion();\n    }\n    const reuseProgram = oldProgram == null ? void 0 : oldProgram.compiler.getCurrentProgram();\n    this.host = NgCompilerHost.wrap(delegateHost, rootNames, options, reuseProgram != null ? reuseProgram : null);\n    if (reuseProgram !== void 0) {\n      retagAllTsFiles(reuseProgram);\n    }\n    this.tsProgram = perfRecorder.inPhase(PerfPhase.TypeScriptProgramCreate, () => ts32.createProgram(this.host.inputFiles, options, this.host, reuseProgram));\n    perfRecorder.phase(PerfPhase.Unaccounted);\n    perfRecorder.memory(PerfCheckpoint.TypeScriptProgramCreate);\n    this.host.postProgramCreationCleanup();\n    untagAllTsFiles(this.tsProgram);\n    const programDriver = new TsCreateProgramDriver(this.tsProgram, this.host, this.options, this.host.shimExtensionPrefixes);\n    this.incrementalStrategy = oldProgram !== void 0 ? oldProgram.incrementalStrategy.toNextBuildStrategy() : new TrackedIncrementalBuildStrategy();\n    const modifiedResourceFiles = /* @__PURE__ */ new Set();\n    if (this.host.getModifiedResourceFiles !== void 0) {\n      const strings = this.host.getModifiedResourceFiles();\n      if (strings !== void 0) {\n        for (const fileString of strings) {\n          modifiedResourceFiles.add(absoluteFrom(fileString));\n        }\n      }\n    }\n    let ticket;\n    if (oldProgram === void 0) {\n      ticket = freshCompilationTicket(\n        this.tsProgram,\n        options,\n        this.incrementalStrategy,\n        programDriver,\n        perfRecorder,\n        false,\n        false\n      );\n    } else {\n      ticket = incrementalFromCompilerTicket(oldProgram.compiler, this.tsProgram, this.incrementalStrategy, programDriver, modifiedResourceFiles, perfRecorder);\n    }\n    this.compiler = NgCompiler.fromTicket(ticket, this.host);\n  }\n  getTsProgram() {\n    return this.tsProgram;\n  }\n  getReuseTsProgram() {\n    return this.compiler.getCurrentProgram();\n  }\n  getTsOptionDiagnostics(cancellationToken) {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => this.tsProgram.getOptionsDiagnostics(cancellationToken));\n  }\n  getTsSyntacticDiagnostics(sourceFile, cancellationToken) {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n      let res;\n      if (sourceFile !== void 0) {\n        if (ignoredFiles.has(sourceFile)) {\n          return [];\n        }\n        res = this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n      } else {\n        const diagnostics = [];\n        for (const sf of this.tsProgram.getSourceFiles()) {\n          if (!ignoredFiles.has(sf)) {\n            diagnostics.push(...this.tsProgram.getSyntacticDiagnostics(sf, cancellationToken));\n          }\n        }\n        res = diagnostics;\n      }\n      return res;\n    });\n  }\n  getTsSemanticDiagnostics(sourceFile, cancellationToken) {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n      let res;\n      if (sourceFile !== void 0) {\n        if (ignoredFiles.has(sourceFile)) {\n          return [];\n        }\n        res = this.tsProgram.getSemanticDiagnostics(sourceFile, cancellationToken);\n      } else {\n        const diagnostics = [];\n        for (const sf of this.tsProgram.getSourceFiles()) {\n          if (!ignoredFiles.has(sf)) {\n            diagnostics.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n          }\n        }\n        res = diagnostics;\n      }\n      return res;\n    });\n  }\n  getNgOptionDiagnostics(cancellationToken) {\n    return this.compiler.getOptionDiagnostics();\n  }\n  getNgStructuralDiagnostics(cancellationToken) {\n    return [];\n  }\n  getNgSemanticDiagnostics(fileName, cancellationToken) {\n    let sf = void 0;\n    if (fileName !== void 0) {\n      sf = this.tsProgram.getSourceFile(fileName);\n      if (sf === void 0) {\n        return [];\n      }\n    }\n    if (sf === void 0) {\n      return this.compiler.getDiagnostics();\n    } else {\n      return this.compiler.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n    }\n  }\n  loadNgStructureAsync() {\n    return this.compiler.analyzeAsync();\n  }\n  listLazyRoutes(entryRoute) {\n    return [];\n  }\n  emitXi18n() {\n    var _a, _b, _c;\n    const ctx = new MessageBundle(new HtmlParser(), [], {}, (_a = this.options.i18nOutLocale) != null ? _a : null);\n    this.compiler.xi18n(ctx);\n    i18nExtract((_b = this.options.i18nOutFormat) != null ? _b : null, (_c = this.options.i18nOutFile) != null ? _c : null, this.host, this.options, ctx, resolve);\n  }\n  emit(opts) {\n    var _a;\n    if (opts !== void 0 && opts.emitFlags !== void 0 && opts.emitFlags & EmitFlags.I18nBundle) {\n      this.emitXi18n();\n      if (!(opts.emitFlags & EmitFlags.JS)) {\n        return {\n          diagnostics: [],\n          emitSkipped: true,\n          emittedFiles: []\n        };\n      }\n    }\n    const forceEmit = (_a = opts == null ? void 0 : opts.forceEmit) != null ? _a : false;\n    this.compiler.perfRecorder.memory(PerfCheckpoint.PreEmit);\n    const res = this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptEmit, () => {\n      var _a2;\n      const { transformers } = this.compiler.prepareEmit();\n      const ignoreFiles = this.compiler.ignoreForEmit;\n      const emitCallback = (_a2 = opts == null ? void 0 : opts.emitCallback) != null ? _a2 : defaultEmitCallback;\n      const writeFile = (fileName, data, writeByteOrderMark, onError, sourceFiles) => {\n        if (sourceFiles !== void 0) {\n          for (const writtenSf of sourceFiles) {\n            if (writtenSf.isDeclarationFile) {\n              continue;\n            }\n            this.compiler.incrementalCompilation.recordSuccessfulEmit(writtenSf);\n          }\n        }\n        this.host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n      };\n      const customTransforms = opts && opts.customTransformers;\n      const beforeTransforms = transformers.before || [];\n      const afterDeclarationsTransforms = transformers.afterDeclarations;\n      if (customTransforms !== void 0 && customTransforms.beforeTs !== void 0) {\n        beforeTransforms.push(...customTransforms.beforeTs);\n      }\n      const emitResults = [];\n      for (const targetSourceFile of this.tsProgram.getSourceFiles()) {\n        if (targetSourceFile.isDeclarationFile || ignoreFiles.has(targetSourceFile)) {\n          continue;\n        }\n        if (!forceEmit && this.compiler.incrementalCompilation.safeToSkipEmit(targetSourceFile)) {\n          this.compiler.perfRecorder.eventCount(PerfEvent.EmitSkipSourceFile);\n          continue;\n        }\n        this.compiler.perfRecorder.eventCount(PerfEvent.EmitSourceFile);\n        emitResults.push(emitCallback({\n          targetSourceFile,\n          program: this.tsProgram,\n          host: this.host,\n          options: this.options,\n          emitOnlyDtsFiles: false,\n          writeFile,\n          customTransformers: {\n            before: beforeTransforms,\n            after: customTransforms && customTransforms.afterTs,\n            afterDeclarations: afterDeclarationsTransforms\n          }\n        }));\n      }\n      this.compiler.perfRecorder.memory(PerfCheckpoint.Emit);\n      return (opts && opts.mergeEmitResultsCallback || mergeEmitResults)(emitResults);\n    });\n    if (this.options.tracePerformance !== void 0) {\n      const perf = this.compiler.perfRecorder.finalize();\n      getFileSystem().writeFile(getFileSystem().resolve(this.options.tracePerformance), JSON.stringify(perf, null, 2));\n    }\n    return res;\n  }\n  getIndexedComponents() {\n    return this.compiler.getIndexedComponents();\n  }\n  getEmittedSourceFiles() {\n    throw new Error(\"Method not implemented.\");\n  }\n};\nvar defaultEmitCallback = ({ program, targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers }) => program.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\nfunction mergeEmitResults(emitResults) {\n  const diagnostics = [];\n  let emitSkipped = false;\n  const emittedFiles = [];\n  for (const er of emitResults) {\n    diagnostics.push(...er.diagnostics);\n    emitSkipped = emitSkipped || er.emitSkipped;\n    emittedFiles.push(...er.emittedFiles || []);\n  }\n  return { diagnostics, emitSkipped, emittedFiles };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/program.mjs\nfunction createProgram({ rootNames, options, host, oldProgram }) {\n  return new NgtscProgram(rootNames, options, host, oldProgram);\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/perform_compile.mjs\nimport ts34 from \"typescript\";\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/transformers/util.mjs\nimport ts33 from \"typescript\";\nfunction createMessageDiagnostic(messageText) {\n  return {\n    file: void 0,\n    start: void 0,\n    length: void 0,\n    category: ts33.DiagnosticCategory.Message,\n    messageText,\n    code: DEFAULT_ERROR_CODE,\n    source: SOURCE\n  };\n}\n\n// bazel-out/darwin_arm64-fastbuild/bin/packages/compiler-cli/src/perform_compile.mjs\nvar defaultFormatHost = {\n  getCurrentDirectory: () => ts34.sys.getCurrentDirectory(),\n  getCanonicalFileName: (fileName) => fileName,\n  getNewLine: () => ts34.sys.newLine\n};\nfunction formatDiagnostics(diags, host = defaultFormatHost) {\n  if (diags && diags.length) {\n    return diags.map((diagnostic) => replaceTsWithNgInErrors(ts34.formatDiagnosticsWithColorAndContext([diagnostic], host))).join(\"\");\n  } else {\n    return \"\";\n  }\n}\nfunction calcProjectFileAndBasePath(project, host = getFileSystem()) {\n  const absProject = host.resolve(project);\n  const projectIsDir = host.lstat(absProject).isDirectory();\n  const projectFile = projectIsDir ? host.join(absProject, \"tsconfig.json\") : absProject;\n  const projectDir = projectIsDir ? absProject : host.dirname(absProject);\n  const basePath = host.resolve(projectDir);\n  return { projectFile, basePath };\n}\nfunction readConfiguration(project, existingOptions, host = getFileSystem()) {\n  var _a;\n  try {\n    const fs = getFileSystem();\n    const readConfigFile = (configFile) => ts34.readConfigFile(configFile, (file) => host.readFile(host.resolve(file)));\n    const readAngularCompilerOptions = (configFile, parentOptions = {}) => {\n      const { config: config2, error: error2 } = readConfigFile(configFile);\n      if (error2) {\n        return parentOptions;\n      }\n      let existingNgCompilerOptions = { ...config2.angularCompilerOptions, ...parentOptions };\n      if (!config2.extends) {\n        return existingNgCompilerOptions;\n      }\n      const extendsPaths = typeof config2.extends === \"string\" ? [config2.extends] : config2.extends;\n      return [...extendsPaths].reverse().reduce((prevOptions, extendsPath) => {\n        const extendedConfigPath = getExtendedConfigPath(configFile, extendsPath, host, fs);\n        return extendedConfigPath === null ? prevOptions : readAngularCompilerOptions(extendedConfigPath, prevOptions);\n      }, existingNgCompilerOptions);\n    };\n    const { projectFile, basePath } = calcProjectFileAndBasePath(project, host);\n    const configFileName = host.resolve(host.pwd(), projectFile);\n    const { config, error } = readConfigFile(projectFile);\n    if (error) {\n      return {\n        project,\n        errors: [error],\n        rootNames: [],\n        options: {},\n        emitFlags: EmitFlags.Default\n      };\n    }\n    const existingCompilerOptions = {\n      genDir: basePath,\n      basePath,\n      ...readAngularCompilerOptions(configFileName),\n      ...existingOptions\n    };\n    const parseConfigHost = createParseConfigHost(host, fs);\n    const { options, errors, fileNames: rootNames, projectReferences } = ts34.parseJsonConfigFileContent(config, parseConfigHost, basePath, existingCompilerOptions, configFileName);\n    let emitFlags = EmitFlags.Default;\n    if (!(options.skipMetadataEmit || options.flatModuleOutFile)) {\n      emitFlags |= EmitFlags.Metadata;\n    }\n    if (options.skipTemplateCodegen) {\n      emitFlags = emitFlags & ~EmitFlags.Codegen;\n    }\n    return { project: projectFile, rootNames, projectReferences, options, errors, emitFlags };\n  } catch (e) {\n    const errors = [{\n      category: ts34.DiagnosticCategory.Error,\n      messageText: (_a = e.stack) != null ? _a : e.message,\n      file: void 0,\n      start: void 0,\n      length: void 0,\n      source: \"angular\",\n      code: UNKNOWN_ERROR_CODE\n    }];\n    return { project: \"\", errors, rootNames: [], options: {}, emitFlags: EmitFlags.Default };\n  }\n}\nfunction createParseConfigHost(host, fs = getFileSystem()) {\n  return {\n    fileExists: host.exists.bind(host),\n    readDirectory: ts34.sys.readDirectory,\n    readFile: host.readFile.bind(host),\n    useCaseSensitiveFileNames: fs.isCaseSensitive()\n  };\n}\nfunction getExtendedConfigPath(configFile, extendsValue, host, fs) {\n  const result = getExtendedConfigPathWorker(configFile, extendsValue, host, fs);\n  if (result !== null) {\n    return result;\n  }\n  return getExtendedConfigPathWorker(configFile, `${extendsValue}.json`, host, fs);\n}\nfunction getExtendedConfigPathWorker(configFile, extendsValue, host, fs) {\n  if (extendsValue.startsWith(\".\") || fs.isRooted(extendsValue)) {\n    const extendedConfigPath = host.resolve(host.dirname(configFile), extendsValue);\n    if (host.exists(extendedConfigPath)) {\n      return extendedConfigPath;\n    }\n  } else {\n    const parseConfigHost = createParseConfigHost(host, fs);\n    const { resolvedModule } = ts34.nodeModuleNameResolver(\n      extendsValue,\n      configFile,\n      { moduleResolution: 2, resolveJsonModule: true },\n      parseConfigHost\n    );\n    if (resolvedModule) {\n      return absoluteFrom(resolvedModule.resolvedFileName);\n    }\n  }\n  return null;\n}\nfunction exitCodeFromResult(diags) {\n  if (!diags)\n    return 0;\n  if (diags.every((diag) => diag.category !== ts34.DiagnosticCategory.Error)) {\n    return 0;\n  }\n  return diags.some((d) => d.source === \"angular\" && d.code === UNKNOWN_ERROR_CODE) ? 2 : 1;\n}\nfunction performCompilation({ rootNames, options, host, oldProgram, emitCallback, mergeEmitResultsCallback, gatherDiagnostics = defaultGatherDiagnostics, customTransformers, emitFlags = EmitFlags.Default, forceEmit = false, modifiedResourceFiles = null }) {\n  var _a;\n  let program;\n  let emitResult;\n  let allDiagnostics = [];\n  try {\n    if (!host) {\n      host = createCompilerHost({ options });\n    }\n    if (modifiedResourceFiles) {\n      host.getModifiedResourceFiles = () => modifiedResourceFiles;\n    }\n    program = createProgram({ rootNames, host, options, oldProgram });\n    const beforeDiags = Date.now();\n    allDiagnostics.push(...gatherDiagnostics(program));\n    if (options.diagnostics) {\n      const afterDiags = Date.now();\n      allDiagnostics.push(createMessageDiagnostic(`Time for diagnostics: ${afterDiags - beforeDiags}ms.`));\n    }\n    if (!hasErrors(allDiagnostics)) {\n      emitResult = program.emit({ emitCallback, mergeEmitResultsCallback, customTransformers, emitFlags, forceEmit });\n      allDiagnostics.push(...emitResult.diagnostics);\n      return { diagnostics: allDiagnostics, program, emitResult };\n    }\n    return { diagnostics: allDiagnostics, program };\n  } catch (e) {\n    program = void 0;\n    allDiagnostics.push({\n      category: ts34.DiagnosticCategory.Error,\n      messageText: (_a = e.stack) != null ? _a : e.message,\n      code: UNKNOWN_ERROR_CODE,\n      file: void 0,\n      start: void 0,\n      length: void 0\n    });\n    return { diagnostics: allDiagnostics, program };\n  }\n}\nfunction defaultGatherDiagnostics(program) {\n  const allDiagnostics = [];\n  function checkDiagnostics(diags) {\n    if (diags) {\n      allDiagnostics.push(...diags);\n      return !hasErrors(diags);\n    }\n    return true;\n  }\n  let checkOtherDiagnostics = true;\n  checkOtherDiagnostics = checkOtherDiagnostics && checkDiagnostics([...program.getTsOptionDiagnostics(), ...program.getNgOptionDiagnostics()]);\n  checkOtherDiagnostics = checkOtherDiagnostics && checkDiagnostics(program.getTsSyntacticDiagnostics());\n  checkOtherDiagnostics = checkOtherDiagnostics && checkDiagnostics([...program.getTsSemanticDiagnostics(), ...program.getNgStructuralDiagnostics()]);\n  checkOtherDiagnostics = checkOtherDiagnostics && checkDiagnostics(program.getNgSemanticDiagnostics());\n  return allDiagnostics;\n}\nfunction hasErrors(diags) {\n  return diags.some((d) => d.category === ts34.DiagnosticCategory.Error);\n}\n\nexport {\n  DEFAULT_ERROR_CODE,\n  UNKNOWN_ERROR_CODE,\n  SOURCE,\n  isTsDiagnostic,\n  EmitFlags,\n  createCompilerHost,\n  untagAllTsFiles,\n  TsCreateProgramDriver,\n  PatchedProgramIncrementalBuildStrategy,\n  freshCompilationTicket,\n  incrementalFromStateTicket,\n  NgCompiler,\n  NgCompilerHost,\n  NgtscProgram,\n  createProgram,\n  createMessageDiagnostic,\n  formatDiagnostics,\n  calcProjectFileAndBasePath,\n  readConfiguration,\n  exitCodeFromResult,\n  performCompilation,\n  defaultGatherDiagnostics\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}